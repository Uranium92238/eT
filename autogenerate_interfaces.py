#
#
#  eT - a coupled cluster program
#  Copyright (C) 2016-2020 the authors of eT
#
#  eT is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  eT is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program. If not, see <https://www.gnu.org/licenses/>.
#
#
from os import listdir, remove
from os.path import isfile, join
from re import search, findall
#
##
## Autogenerate interfaces
## Written by Alice Balbi and Andreas Skeidsvoll, Sep 2019
##
## This script reads relevant Fortran files in eT, and makes interfaces for
## them.
##
## Usage: call
##
## $ python3 autogenerate_interfaces.py
##
## in the main eT directory (where this file is found).
##
#
source_directory = 'src'
wavefunction_directory = join(source_directory, 'wavefunctions')
#
#  Dictionary with wavefunction directory as key and the corresponding class
#  file as value
#
wavefunction_classes = {
   'hf': ['hf_class.F90'],
   'uhf': ['uhf_class.F90'],
   'cc2': ['cc2_class.F90'],
   'cc3': ['cc3_class.F90'],
   'ccs': ['ccs_class.F90'],
   'ccsd': ['ccsd_class.F90'],
   'doubles': ['doubles_class.F90'],
   'hf': ['hf_class.F90'],
   'lowmem_cc2': ['lowmem_cc2_class.F90'],
   'mlcc2': ['mlcc2_class.F90'],
   'mp2': ['mp2_class.F90'],
}
#
#  Preparation section
#
#  Remove autogenerated files
#
for directory_name in wavefunction_classes:
   for file_name in listdir(join(wavefunction_directory, directory_name)):
      file_path = join(wavefunction_directory, directory_name, file_name)
#
      if (isfile(file_path) and ('_interface' in file_name)):
         remove(file_path)
#
#  List all submodules found in the wavefunction folders
#
wavefunction_all_submodules = {}
#
for directory_name in wavefunction_classes:
#
   file_names = []
#
   for file_name in listdir(join(wavefunction_directory, directory_name)):
#
      if (isfile(join(wavefunction_directory, directory_name, file_name))
          and (not (file_name in wavefunction_classes[directory_name]))):
         file_names.append(file_name)
#
   wavefunction_all_submodules[directory_name] = file_names
#
#  Interface generation section
#
for directory_name in wavefunction_all_submodules:
   for submodule_name in wavefunction_all_submodules[directory_name]:
#
      submodule_file = open(join(wavefunction_directory, directory_name,
                                 submodule_name),'r')
      interface_file = open(join(wavefunction_directory, directory_name,
                                 submodule_name
                                 .rstrip('.F90')+'_interface.F90'),'w')
#
      interface_file.write('!\n'
                           '!\n'
                           '!  eT - a coupled cluster program\n'
                           '!  Copyright (C) 2016-2020 the authors of eT\n'
                           '!\n'
                           '!  eT is free software: you can redistribute it '
                           'and/or modify\n'
                           '!  it under the terms of the GNU General Public '
                           'License as published by\n'
                           '!  the Free Software Foundation, either version 3 '
                           'of the License, or\n'
                           '!  (at your option) any later version.\n'
                           '!\n'
                           '!  eT is distributed in the hope that it will be '
                           'useful,\n'
                           '!  but WITHOUT ANY WARRANTY; without even the '
                           'implied warranty of\n'
                           '!  MERCHANTABILITY or FITNESS FOR A PARTICULAR '
                           'PURPOSE. See the\n'
                           '!  GNU General Public License for more details.\n'
                           '!\n'
                           '!  You should have received a copy of the GNU '
                           'General Public License\n'
                           '!  along with this program. If not, see '
                           '<https://www.gnu.org/licenses/>.\n')
#
#     Read until end of file
#
      with submodule_file as lines:
         while True:
#
            try:
               line = next(lines).rstrip(' \t\r')
#
            except StopIteration:
               break
#
            line_without_comments = line.partition('!')[0].strip()
#
#           Reached a subroutine or a function
#
            if (search(r'\b'+'module'+r'\b', line_without_comments) and
                (search(r'\b'+'subroutine'+r'\b', line_without_comments) 
                 or search(r'\b'+'function'+r'\b', line_without_comments))):
#
#              In case line contains an ampersand, read next line(s)
#
               while (line_without_comments[-1] == '&'):
#
                  try:
                     line_addition = next(lines).rstrip(' \t\r')
#
                  except StopIteration:
                     break
#
                  line = line + line_addition
                  line_without_comments = (
                     line_without_comments.strip('&').strip() 
                     + line_addition.partition('!')[0].strip())
#
               interface_file.write('!\n!\n'+line+'!!\n')
#
#              Make list of arguments in subroutine or function
#
               argument_list = []
#
#              Finds the text inside all brackets in the given line using
#              regex
#
               inside_all_brackets = findall('\((.*?)\)',
                                             line_without_comments)
#
               for inside_single_brackets in inside_all_brackets:
                  arguments_inside_single_brackets = (inside_single_brackets
                                                      .split(','))
#
                  for argument_name in arguments_inside_single_brackets:
                     if (argument_name.strip() != ''):
                        argument_list.append(argument_name.strip())
#
#              Loop until reaching end of subroutine or function
#
               line = next(lines)
#
               while True:
#
                  try:
                     line = next(lines).rstrip(' \t\r')
#
                  except StopIteration:
                     break
#
#                 Write header lines
#
                  if ((line[0] == '!') and (line[1] == '!')):
                     interface_file.write(line)
#
                  line_without_comments = line.partition('!')[0].strip()      
#
#                 Reached end of subroutine
#
                  if (search(r'\b'+'end'+r'\b', line_without_comments)
                      and search(r'\b'+'subroutine'+r'\b',
                                 line_without_comments)):
                     interface_file.write('!\n'+line)
                     break
#
#                 Reached end of function
#
                  if (search(r'\b'+'end'+r'\b', line_without_comments)
                      and search(r'\b'+'function'+r'\b',
                                 line_without_comments)):
                     interface_file.write('!\n'+line)
                     break
#
#                 Reached implicit none
#
                  if (search(r'\b'+'implicit none'+r'\b',
                             line_without_comments)):
                     interface_file.write(line+'!\n')
#
#                 Reached declaration of variable(s)
#
                  if (search('::', line_without_comments)):
                     after_dots = (line_without_comments.partition('::')[2]
                                   .strip())
                     variable_list = [variable_name.strip() 
                                      for variable_name
                                          in after_dots.split(',')]
#
#                    Look through all declared variables for the declaration
#                    of any subroutine or function arguments
#
                     found_argument = False
                     for variable_name in variable_list:
                        for argument_name in argument_list:
                           if (variable_name.lower()
                               == argument_name.lower()):
                              found_argument = True
#
                     if found_argument:
                        interface_file.write(line)
#
      submodule_file.close()
      interface_file.close()
#
#  End of script
#
