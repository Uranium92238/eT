#
#
#  eT - a coupled cluster program
#  Copyright (C) 2016-2020 the authors of eT
#
#  eT is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  eT is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program. If not, see <https://www.gnu.org/licenses/>.
#
#
from os import remove
from os.path import join
from re import search, findall
import glob


# Autogenerate interfaces
# Written by Alice Balbi and Andreas Skeidsvoll, Sep 2019
# Adapted by Sander Roet , Feb 2020

# This script reads relevant Fortran files in eT, and makes interfaces for
# them.

# Usage: call

# $ python3 autogenerate_interfaces.py

# in the main eT directory (where this file is found).


source_directory = 'src'
wavefunction_directory = join(source_directory, 'wavefunctions')


# Preparation section
# Remove autogenerated files

# Get all .F90 files in the directory
f90_files = set(glob.glob(wavefunction_directory+"/*/*.F90"))

# Make an empty set
removed_files = set()
# Remove all autogenerated files
for file_name in f90_files:
    if "_interface" in file_name:
        remove(file_name)
        # Add name to the set
        removed_files.add(file_name)

# Remove removed files from .F90 list
f90_files -= removed_files


#  List all submodules found in the wavefunction folders
# This should be defined as the first not-comment line of the F90 file
def is_submodule(file_name):
    with open(file_name, 'r') as f:
        for line in f.readlines():
            # Skip comment lines
            if line.startswith("!"):
                continue
            # First non-comment line start with submodule
            elif line.startswith("submodule"):
                return True
            # First non-comment line does not start with submodule
            else:
                return False


wave_function_all_submodules = {i for i in f90_files if is_submodule(i)}


def write_license(f):
    f.write('!\n'
            '!\n'
            '!  eT - a coupled cluster program\n'
            '!  Copyright (C) 2016-2020 the authors of eT\n'
            '!\n'
            '!  eT is free software: you can redistribute it and/or modify\n'
            '!  it under the terms of the GNU General Public '
            'License as published by\n'
            '!  the Free Software Foundation, either version 3 '
            'of the License, or\n'
            '!  (at your option) any later version.\n'
            '!\n'
            '!  eT is distributed in the hope that it will be '
            'useful,\n'
            '!  but WITHOUT ANY WARRANTY; without even the '
            'implied warranty of\n'
            '!  MERCHANTABILITY or FITNESS FOR A PARTICULAR '
            'PURPOSE. See the\n'
            '!  GNU General Public License for more details.\n'
            '!\n'
            '!  You should have received a copy of the GNU '
            'General Public License\n'
            '!  along with this program. If not, see '
            '<https://www.gnu.org/licenses/>.\n')


def fix_line_continuation(lines):
    lines_out = []
    lines_without_comments = []
    for line in lines:
        temp_line = line.rstrip(' \t\r')
        temp_line_without_comments = line.partition('!')[0].strip()

        while (temp_line_without_comments.endswith('&')):
            try:
                line_addition = next(lines).rstrip(' \t\r')
            except StopIteration:
                break
            temp_line = temp_line + line_addition
            temp_line_without_comments = (
                temp_line_without_comments.strip('&').strip() +
                line_addition.partition('!')[0].strip())
        lines_out.append(temp_line)
        lines_without_comments.append(temp_line_without_comments)

    return lines_out, lines_without_comments


def find_arguments(line):
    #  Make list of arguments in subroutine or function

    argument_list = []

    #  Finds the text inside all brackets in the given line using
    #  regex

    inside_all_brackets = findall(r'\((.*?)\)', line)

    for inside_single_brackets in inside_all_brackets:
        arguments_inside_single_brackets = (
            inside_single_brackets.split(','))
        for argument_name in arguments_inside_single_brackets:
            if (argument_name.strip() != ''):
                argument_list.append(argument_name.strip().lower())

    return argument_list


def write_function(iterator, arguments, outfile):
    for line, line_without_comments in iterator:
        # Write header lines
        if line[:2] == "!!":
            outfile.write(line)

        # Reached end of subroutine
        if (
            search(r'\b'+'end'+r'\b', line_without_comments) and
            search(r'\b'+'subroutine'+r'\b', line_without_comments)
           ):
            outfile.write('!\n'+line)
            break

        # Reached end of function

        if (
            search(r'\b'+'end'+r'\b', line_without_comments) and
            search(r'\b'+'function'+r'\b', line_without_comments)
           ):
            outfile.write('!\n'+line)
            break

        # Reached implicit none

        if (search(r'\b'+'implicit none'+r'\b',
                   line_without_comments)):
            outfile.write(line+'!\n')

        # Reached declaration of variable(s)

        if (search('::', line_without_comments)):
            after_dots = line_without_comments.partition('::')[2].strip()
            variable_list = [variable_name.strip()
                             for variable_name in after_dots.split(',')]
            # Look through all declared variables for the declaration
            # of any subroutine or function arguments

            found_argument = False
            for variable_name in variable_list:
                if (variable_name.lower() in arguments):
                    found_argument = True
                    break

            if found_argument:
                outfile.write(line)


# Interface generation section
for submodule_name in wave_function_all_submodules:
    with open(submodule_name, 'r') as f:
        # Make a generator
        lines = (i for i in f.readlines())
    lines, lines_without_comments = fix_line_continuation(lines)
    iterator = zip(lines, lines_without_comments)
    # Strip .F90 and add "_interface.F90"
    interface_name = submodule_name[:-4]+"_interface.F90"
    interface_file = open(interface_name, 'w')
    write_license(interface_file)

    for line, line_without_comments in iterator:
        if (search(r'\b'+'module'+r'\b', line_without_comments) and
            (search(r'\b'+'subroutine'+r'\b', line_without_comments) or
             search(r'\b'+'function'+r'\b', line_without_comments))):

            interface_file.write('!\n!\n'+line)

            argument_list = find_arguments(line_without_comments)


            # Loop until reaching end of subroutine or function
            write_function(iterator, argument_list, interface_file)

    interface_file.close()
