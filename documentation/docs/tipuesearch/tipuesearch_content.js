var tipuesearch = {"pages":[{"text":"The eT program Developer Info Eirik F. Kjønstad and Sarai D. Folkestad","tags":"","loc":"index.html","title":" The eT program "},{"text":"This File Depends On sourcefile~~et_program.f90~~EfferentGraph sourcefile~et_program.f90 eT_program.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~input_output.f90->sourcefile~et_program.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~cc2_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~mp2_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccsdpt_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~utils.f90 utils.F90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~et_program.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90->sourcefile~cc2_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90->sourcefile~cc3_class.f90 sourcefile~types.f90->sourcefile~mp2_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90->sourcefile~ccsdpt_class.f90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~cc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~cc3_class.f90 sourcefile~workspace.f90->sourcefile~mp2_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccsdpt_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~cc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~utils.f90->sourcefile~mp2_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccsdpt_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileet_programf90EfferentGraph = svgPanZoom('#sourcefileet_programf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs eT_program Source Code eT_program.F90 Source Code program eT_program ! !! !!                        eT - a coupled cluster program !!         Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! ! !  ::::::::::::::::::::::::::::::::::::: !  -::- Modules used by the program -::- !  ::::::::::::::::::::::::::::::::::::: ! use input_output ! IO module use input_reader ! Input reader routines ! !  Wavefunction classes ! use hf_class use mp2_class use ccs_class use cc2_class use ccsd_class use cc3_class use ccsdpt_class use mlcc2_class use mlccsd_class ! implicit none ! !  Method class allocatable objects ! type ( mp2 ), allocatable , target :: mp2_wf type ( ccs ), allocatable , target :: ccs_wf type ( cc2 ), allocatable , target :: cc2_wf type ( ccsd ), allocatable , target :: ccsd_wf type ( cc3 ), allocatable , target :: cc3_wf type ( ccsdpt ), allocatable , target :: ccsdpt_wf ! !  Multi-level methods ! type ( mlcc2 ), allocatable , target :: mlcc2_wf type ( mlccsd ), allocatable , target :: mlccsd_wf ! !  Wavefunction pointer ! class ( hf ), pointer :: wf => null () ! !  Method string ! character ( len = 40 ) :: method ! !  Unit identifier for input file eT.inp ! integer ( i15 ) :: unit_input = - 1 ! character ( len = 13 ) :: orbital_level ! !  :::::::::::::::::::::::::::::::::::::::::::::: !  -::-     Set up memory controller         -::- !  :::::::::::::::::::::::::::::::::::::::::::::: ! call work_init ! !  :::::::::::::::::::::::::::::::::::::::::::::: !  -::-  Create & open the main output file  -::- !  :::::::::::::::::::::::::::::::::::::::::::::: ! call generate_unit_identifier ( unit_output ) open ( unit = unit_output , file = 'eT.out' , status = 'unknown' , form = 'formatted' ) rewind ( unit_output ) ! !  :::::::::::::::::::::::::::::::::::::::::::::: !  -::-         Print program banner         -::- !  :::::::::::::::::::::::::::::::::::::::::::::: ! write ( unit_output , '(//t18,a)' ) 'eT - a coupled cluster program' write ( unit_output , '(t15,a//)' ) 'S. D. Folkestad, E. F. Kjønstad, 2017' ! !  Open input file ! call generate_unit_identifier ( unit_input ) open ( unit = unit_input , file = 'eT.inp' , status = 'old' , form = 'formatted' ) rewind ( unit_input ) ! !  :::::::::::::::::::::::::::::::::::::::::::::: !  -::- Reading method section of input file -::- !  :::::::::::::::::::::::::::::::::::::::::::::: ! !  Read the method from file, allocate the appropriate !  wavefunction object, and point to the main wavefunction !  wf to this object. ! call method_reader ( unit_input , method ) ! if ( trim ( method ) == 'MP2' ) then ! allocate ( mp2_wf ) wf => mp2_wf ! elseif ( trim ( method ) == 'CCS' ) then ! allocate ( ccs_wf ) wf => ccs_wf ! elseif ( trim ( method ) == 'CCSD' ) then ! allocate ( ccsd_wf ) wf => ccsd_wf ! elseif ( trim ( method ) == 'CC2' ) then ! allocate ( cc2_wf ) wf => cc2_wf ! elseif ( trim ( method ) == 'CC3' ) then ! allocate ( cc3_wf ) wf => cc3_wf ! elseif ( trim ( method ) == 'CCSD(T)' ) then ! allocate ( ccsdpt_wf ) wf => ccsdpt_wf ! elseif ( trim ( method ) == 'MLCC2' ) then ! allocate ( mlcc2_wf ) wf => mlcc2_wf ! elseif ( trim ( method ) == 'MLCCSD' ) then ! allocate ( mlccsd_wf ) wf => mlccsd_wf ! else write ( unit_output , * ) 'Method ' , trim ( method ), ' not recognized.' flush ( unit_output ) stop ! endif ! ! Close input file ! close ( unit_input ) ! ! ::::::::::::::::::::::::: ! -::- Run Calculation -::- ! ::::::::::::::::::::::::: ! call wf % init call wf % drv ! ! ::::::::::::::::::::::::::: ! -::- Close output file -::- ! ::::::::::::::::::::::::::: ! close ( unit_output ) ! end program eT_program","tags":"","loc":"sourcefile/et_program.f90.html","title":"eT_program.F90 – The eT program"},{"text":"This File Depends On sourcefile~~input_reader.f90~~EfferentGraph sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~input_reader.f90~~AfferentGraph sourcefile~input_reader.f90 input_reader.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~input_reader.f90->sourcefile~et_program.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 var pansourcefileinput_readerf90AfferentGraph = svgPanZoom('#sourcefileinput_readerf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules input_reader Source Code input_reader.F90 Source Code module input_reader ! !! !!    Input reader module !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! ! use types use workspace use input_output ! implicit none ! contains ! ! subroutine method_reader ( unit_input , method ) !! !!    Method Reader !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017 !! implicit none ! integer ( i15 ), intent ( in ) :: unit_input ! character ( len = 40 ) :: method ! character ( len = 40 ) :: line ! !     Start at the begining of eT.inp ! rewind ( unit_input ) ! do ! General do loop - ends when it reaches 'exit'. Either when method is specified or if no method is given. ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'CC' ) then ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! do ! General do loop - ends when it reaches 'exit'. Either when method is specified or if no method is given. ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'method:' ) then ! Set method ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! method = trim ( line ) ! exit ! elseif ( trim ( line ) == '}' ) then write ( unit_output , * ) 'Error: method was not specified in eT.inp.' stop endif ! enddo ! End general do loop ! else ! write ( unit_output , * ) 'Error: method was not specified in eT.inp.' stop ! endif ! ! exit ! elseif ( trim ( line ) == 'MLCC' ) then ! ! !           Determine what type of MLCC method ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! do ! General do loop - ends when it reaches 'exit'. Either when method is specified or if no method is given. read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'method:' ) then ! Set method ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! !                    Set method ! method = trim ( line ) ! exit ! elseif ( trim ( line ) == '}' ) then ! write ( unit_output , * ) 'Error: method was not specified in eT.inp.' stop ! endif ! enddo ! End general do loop ! else ! write ( unit_output , * ) 'Error: method was not specified in eT.inp.' stop ! endif exit ! elseif ( trim ( line ) == 'SCC' ) then ! !           Go to SCC specific reader ! write ( unit_output , '(t3,a)' ) 'Error: similarity constrained CC calculation requested, but it has not been implemented' stop ! elseif ( trim ( line ) == 'end of eT input' ) then ! write ( unit_output , * ) 'Error: method was not specified in eT.inp.' stop ! endif ! enddo ! End general do loop ! end subroutine method_reader ! ! function remove_preceding_blanks ( line ) !! !!    Remove Preceding Blanks. !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017 !! !!    Removes white spaces before text from line !! implicit none ! character ( len = 40 ) :: line ! character ( len = 40 ) :: remove_preceding_blanks ! integer ( i15 ) :: i = 0 , j = 0 , length = 0 ! do i = 1 , 40 if ( line ( i : i ) == ' ' ) then continue else length = 40 - ( i - 1 ) remove_preceding_blanks ( 1 : length ) = line ( i : 40 ) remove_preceding_blanks ( length + 1 : 40 ) = ' ' return endif enddo ! end function remove_preceding_blanks ! ! end module input_reader","tags":"","loc":"sourcefile/input_reader.f90.html","title":"input_reader.F90 – The eT program"},{"text":"This File Depends On sourcefile~~workspace.f90~~EfferentGraph sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~workspace.f90~~AfferentGraph sourcefile~workspace.f90 workspace.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~workspace.f90->sourcefile~cc2_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~workspace.f90->sourcefile~cc3_class.f90 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~workspace.f90->sourcefile~ccsdpt_class.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~workspace.f90->sourcefile~mp2_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90 sourcefile~input_reader.f90->sourcefile~et_program.f90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~cc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~utils.f90->sourcefile~ccsdpt_class.f90 sourcefile~utils.f90->sourcefile~mp2_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 var pansourcefileworkspacef90AfferentGraph = svgPanZoom('#sourcefileworkspacef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules workspace Source Code workspace.F90 Source Code module workspace ! !! !!    Workspace module !!    Written by Henrik Koch, Rolf H. Myhre, Eirik Kjønstad and Sarai Folkestad, Jan 2017 !! !!    NB! THIS IS BEING PHASED OUT & HAS BEEN REPLACED BY THE MEMORY MANAGER OBJECT. !!        THE MANY CALLS TO \"GET_AVAILABLE\" MEANS THAT WE CANNOT REMOVE IT JUST YET. !! !!    Manages program memory usage and contains: !! !!    work_init:       Initializes the memory management variables. !! !!    allocator:       Allocation of double precission array of two dimmensions (M,N). !!                     Updates memory management variables. !! !!    deallocator:     Deallocation of double precission array of two dimmensions (M,N). !!                     Updates memory management variables. !! !!    allocator_int:   Allocation of integer array of two dimmensions (M,N). !!                     Updates memory management variables. !! !!    deallocator_int: Deallocation of integer array of two dimmensions (M,N) !!                     Updates memory management variables. !! !!    get_available:   Returns available memory. !! ! use types use input_output ! implicit none ! integer , private :: work_length = 0 integer , private :: work_remains = 0 integer , private :: work_used = 0 ! integer ( i15 ) :: mem = 4000000000 ! ca. 30 gb ! ! contains ! ! subroutine work_init ! !     Work Initilization ! !     Initializes memory management variables ! implicit none ! work_length = mem work_remains = mem work_used = 0 ! end subroutine work_init ! ! subroutine allocator ( elm , M , N ) ! !     Allocator !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 ! !     Allocates array and updates memory variables ! implicit none ! integer , intent ( in ) :: M , N real ( dp ), dimension (:,:), allocatable :: elm integer :: size integer :: stat = 0 , error = 0 ! logical :: debug = . false . ! size = M * N ! allocate ( elm ( M , N ), stat = error ) ! if ( stat . ne . 0 ) then write ( unit_output , '(t3,a,i15)' ) 'Allocation error! Could not allocate array of size (M*N):' , size stop endif ! if ( debug ) write ( unit_output , * ) work_remains , 4 * size ! work_remains = work_remains - 4 * size work_used = work_used + 4 * size ! if ( work_remains . lt . 0 ) then write ( unit_output , '(t3,a)' ) \"Error: user-specified memory insufficient.\" stop endif ! end subroutine allocator ! ! subroutine deallocator ( elm , M , N ) ! !     Deallocator !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 ! !     Deallocation and update of memory information ! implicit none ! real ( dp ), dimension (:,:), allocatable :: elm integer :: stat = 0 , error = 0 integer , intent ( in ) :: M , N integer :: size ! size = M * N ! deallocate ( elm , stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Deallocation error! Could not deallocate array of size (M*N):' , size stop ! endif ! work_remains = work_remains + 4 * size work_used = work_used - 4 * size ! end subroutine deallocator ! ! subroutine allocator_int ( elm , M , N ) ! !     Allocator Integer Arrays !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 ! !     Allocates array and updates memory information ! implicit none ! integer , intent ( in ) :: M , N integer , dimension (:,:), allocatable :: elm integer :: size integer :: stat = 0 , error = 0 ! size = M * N ! allocate ( elm ( M , N ), stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Allocation error! Could not allocate array of size (M*N):' , size stop ! endif ! work_remains = work_remains - 2 * size work_used = work_used + 2 * size ! if ( work_remains . lt . 0 ) then ! write ( unit_output , '(t3,a)' ) \"Error: user-specified memory insufficient.\" stop ! endif ! end subroutine allocator_int ! ! subroutine deallocator_int ( elm , M , N ) ! !     Deallocator Integer Arrays !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 ! !     Deallocates array and updates memory information ! implicit none ! integer , dimension (:,:), allocatable :: elm integer :: stat = 0 , error = 0 integer , intent ( in ) :: M , N integer :: size ! size = M * N ! deallocate ( elm , stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Deallocation error! Could not deallocate array of size (M*N):' , size stop ! endif ! work_remains = work_remains + 2 * size work_used = work_used - 2 * size ! end subroutine deallocator_int ! ! integer function get_available () ! !     Get Available !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Mar 2017 ! !     Returns the available memory ! get_available = work_remains ! end function get_available ! ! end module workspace","tags":"","loc":"sourcefile/workspace.f90.html","title":"workspace.F90 – The eT program"},{"text":"This File Depends On sourcefile~~utils.f90~~EfferentGraph sourcefile~utils.f90 utils.F90 sourcefile~input_output.f90 input_output.F90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~types.f90->sourcefile~workspace.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~utils.f90~~AfferentGraph sourcefile~utils.f90 utils.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~utils.f90->sourcefile~cc2_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~utils.f90->sourcefile~mp2_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~utils.f90->sourcefile~ccsdpt_class.f90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefileutilsf90AfferentGraph = svgPanZoom('#sourcefileutilsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules utils Source Code utils.F90 Source Code module utils ! !! !!    Utilities module !!    Written by Sarai D. Folkstad and Eirik F. Kjønstad, 28 Feb 2017 !! !!    Contains: !! !!    Index functions: !!       index_packed: Calculates the packed index of symetric matrix !!       index_two:    Calculates the compound index of two indices !!       index_three   Calculates the compound index given by three indices !! !!    Matrix utilities: !!       packin:      packs in symetric matrix !!       packed_size: Returns size of packed matrix !!       squeareup:   squares up symmetric matrix !! !!    Batching subroutines: !!        num_batch:     Calculates the number of batches needed. !!        num_two_batch: Calculates the number of batches needed !!                       for to batching variables with equal number of batches. !!        batch_limits:  Returns batch start index and batch end index. !! ! use input_output use types ! contains ! !  ::::::::::::::::::::::::: !  -::- Index functions -::- !  ::::::::::::::::::::::::: ! integer ( i15 ) function index_packed ( i , j ) !! !!    Packed index !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Calculates the packed index of symetric matrix. !! implicit none ! integer ( i15 ), intent ( in ) :: i , j ! index_packed = ( max ( i , j ) * ( max ( i , j ) - 3 ) / 2 ) + i + j ! end function index_packed ! ! integer ( i15 ) function index_three ( p , q , r , dim_p , dim_q ) !! !!    Three index compound !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Returns the compound index (pqr) !! implicit none ! integer ( i15 ), intent ( in ) :: p , q , r , dim_p , dim_q ! index_three = dim_p * ( dim_q * ( r - 1 ) + q - 1 ) + p ! !     Debug sanity check ! !       if (p .eq. 0 .or. q .eq. 0 .or. r .eq. 0) write(unit_output,*) 'WARNING: one of the indices in index_three is zero!',p,q,r ! ! !       if (p .gt. dim_p) write(unit_output,*) 'WARNING: first index exceeds its dimension', p, dim_p !       if (q .gt. dim_q) write(unit_output,*) 'WARNING: first index exceeds its dimension', q, dim_q ! end function index_three ! ! integer ( i15 ) function index_two ( p , q , dim_p ) !! !!    Two index compound !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Returns the compound index (pq) !! implicit none ! integer ( i15 ), intent ( in ) :: p , q , dim_p ! index_two = dim_p * ( q - 1 ) + p ! ! !     Debug sanity check ! ! !       if (p .eq. 0 .or. q .eq. 0) write(unit_output,*) 'WARNING: one of the indices in index_two is zero!',p,q ! ! !       if (p .gt. dim_p) write(unit_output,*) 'WARNING: first index exceeds its dimension', p, dim_p ! end function index_two ! ! :::::::::::::::::::::::: ! -:- Matrix utilities -:- ! :::::::::::::::::::::::: ! integer ( i15 ) function packed_size ( N ) !! !!    Packed size !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Returns size of packed symmetric matrices !!    of dimension N x N (triangular elements) !! implicit none ! integer ( i15 ), intent ( in ) :: N ! packed_size = N * ( N + 1 ) / 2 ! end function packed_size ! ! subroutine squareup ( packed , unpacked , N ) !! !!    Square up packed symmetric matrix !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Squares up to full dimension (N x N) of packed matrices. !! implicit none ! integer ( i15 ), intent ( in ) :: N ! real ( dp ), dimension (:,:), intent ( in ) :: packed real ( dp ), dimension (:,:) :: unpacked ! integer ( i15 ) :: i = 0 , j = 0 ! do i = 1 , N do j = 1 , N unpacked ( i , j ) = packed ( index_packed ( i , j ), 1 ) enddo enddo ! end subroutine ! subroutine squareup_to_compound ( packed , unpacked , N , M ) !! !!    Square up packed symmetric matrix !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Squares up to full dimension ((N x N), M) of packed matrices. !! implicit none ! integer ( i15 ), intent ( in ) :: N , M ! real ( dp ), dimension ( N * ( N + 1 ) / 2 , M ), intent ( in ) :: packed real ( dp ), dimension ( N * N , M ) :: unpacked ! integer ( i15 ) :: i = 0 , j = 0 ! do i = 1 , N do j = 1 , N unpacked ( index_two ( i , j , N ), 1 : M ) = packed ( index_packed ( i , j ), 1 : M ) enddo enddo ! end subroutine ! ! subroutine packin ( packed , unpacked , N ) !! !!    Pack in symmetric matrix !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Pack down full square matrix of dimension N x N. !! implicit none ! integer ( i15 ), intent ( in ) :: N ! real ( dp ), dimension (:,:) :: packed real ( dp ), dimension (:,:), intent ( in ) :: unpacked ! integer ( i15 ) :: i = 0 , j = 0 ! do i = 1 , N do j = 1 , N ! ! if (abs(unpacked(i, j) - unpacked(j, i)) .gt. 10D-8) then !    write(unit_output,*) 'WARNING: Attempting to pack non-symmetric matrix' !    write(unit_output,*) 'Make sure code is bug-free. Information will be lost.' !    write(unit_output,*) unpacked(i, j), unpacked(j, i) ! endif ! packed ( index_packed ( i , j ), 1 ) = unpacked ( i , j ) ! enddo enddo ! end subroutine ! ! ::::::::::::::::::::::::::::::: !  -:- Batching functionality -:- ! ::::::::::::::::::::::::::::::: ! subroutine num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) !! !!    Number of batches !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Calculates number of batches !! !!    Batching structure will be: !!    With rest:     (n_batch-1)*(max_batch_length) + rest = required !!    Without rest:  (n_batch)*(max_batch_length) = required !! implicit none ! ! integer ( i15 ), intent ( in ) :: available , batch_dimension integer ( i15 ) :: max_batch_length , n_batch integer ( i15 ) :: required integer ( i15 ) :: buffer ! !     Adding buffer for required ! buffer = required / 10 ! required = required + buffer ! if ( required . lt . available ) then n_batch = 1 max_batch_length = batch_dimension return endif ! !     Max batch size ! max_batch_length = available / ( required / batch_dimension ) ! !     Number of full batches ! n_batch = batch_dimension / max_batch_length ! !     Test for rest ! if ( n_batch * max_batch_length . lt . batch_dimension ) then n_batch = n_batch + 1 endif ! end subroutine num_batch ! subroutine num_two_batch ( required , available , max_batch_length , n_batch , batch_dimension ) !! !!    Number of batches !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Calculates number of batches when two batching variables are needed !! !!    Batching structure will be: !!    With rest:     (n_batch-1)*(max_batch_length) + rest = required !!    Without rest:  (n_batch)*(max_batch_length) = required !! implicit none ! integer ( i15 ), intent ( in ) :: available , batch_dimension integer ( i15 ) :: max_batch_length , n_batch , i , buffer , required ! buffer = required / 10 ! required = required + buffer ! n_batch = 1 ! if ( required . lt . available ) then n_batch = 1 max_batch_length = batch_dimension return endif ! do i = 1 , batch_dimension if ( available . gt . required / i ** 2 ) then ! n_batch = i max_batch_length = batch_dimension / n_batch ! !           Test for rest ! if ( n_batch * max_batch_length . lt . batch_dimension ) then n_batch = n_batch + 1 endif ! return endif enddo ! end subroutine num_two_batch ! ! subroutine batch_limits ( first , last , batch_number , max_batch_length , batch_dimension ) !! !!     Batch limits !!     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!     Find batch limits (first and last) !! !!     batch_number: the current batch (1,2,...,n_batch) !!     max_batch_length: the length of each batch (except the last, which may be a rest, see n_one_batch routine) !!     batch_dimension: the dimensionality of the batching variable (e.g., n_vir for a virtual index) !! implicit none ! integer ( i15 ) :: first , last integer ( i15 ), intent ( in ) :: batch_number , max_batch_length , batch_dimension ! first = 1 + ( batch_number - 1 ) * max_batch_length last = min ( max_batch_length + ( batch_number - 1 ) * max_batch_length , batch_dimension ) ! end subroutine batch_limits ! subroutine get_n_lowest ( n , size , vec , sorted_short_vec , index_list ) !! !!    Get n lowest elements !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Finds the n lowest values of vec, !!    sorts them, and returns them in sorted_short_vec !!    together with an index list refering to the indices of the !!    lowest elements in the original vector. !! implicit none ! integer ( i15 ) :: n ! Number of elements wanted integer ( i15 ) :: size ! Size of original vector ! real ( dp ), dimension ( size , 1 ) :: vec real ( dp ), dimension ( n , 1 ) :: sorted_short_vec ! integer ( i15 ), dimension ( n , 1 ) :: index_list ! !     Variables for sorting ! real ( dp ) :: max integer ( i15 ) :: max_pos ! real ( dp ) :: swap = zero integer ( i15 ) :: swap_int = 0 ! integer ( i15 ) :: i = 0 , j = 0 ! !        Placing the n first elements of vec into sorted_short_vec ! sorted_short_vec ( 1 , 1 ) = vec ( 1 , 1 ) index_list ( 1 , 1 ) = 1 ! max = sorted_short_vec ( 1 , 1 ) max_pos = 1 ! do i = 2 , n ! sorted_short_vec ( i , 1 ) = vec ( i , 1 ) index_list ( i , 1 ) = i ! if ( sorted_short_vec ( i , 1 ) . ge . max ) then ! max = sorted_short_vec ( i , 1 ) max_pos = i ! endif enddo ! !        Looping through the rest of vec to find lowest values ! do i = n + 1 , size if ( vec ( i , 1 ) . lt . max ) then ! sorted_short_vec ( max_pos , 1 ) = vec ( i , 1 ) index_list ( max_pos , 1 ) = i max = vec ( i , 1 ) ! do j = 1 , n if ( sorted_short_vec ( j , 1 ) . gt . max ) then ! max = sorted_short_vec ( j , 1 ) max_pos = j ! endif enddo endif enddo ! !        Sorting sorted_short_vec ! do i = 1 , n do j = 1 , n - 1 if ( sorted_short_vec ( j , 1 ) . gt . sorted_short_vec ( j + 1 , 1 )) then ! swap = sorted_short_vec ( j , 1 ) sorted_short_vec ( j , 1 ) = sorted_short_vec ( j + 1 , 1 ) sorted_short_vec ( j + 1 , 1 ) = swap ! swap_int = index_list ( j , 1 ) index_list ( j , 1 ) = index_list ( j + 1 , 1 ) index_list ( j + 1 , 1 ) = swap_int ! endif enddo enddo ! end subroutine get_n_lowest ! function check_orthogonality ( A , M , N ) !! !!   Check orthogonality !!   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Check if columns of A are orthogonal. A is (M x N) matrix. !!    Returns logical. !! use workspace ! implicit none ! integer ( i15 ) :: M integer ( i15 ) :: N real ( dp ), dimension ( M , N ) :: A logical :: check_orthogonality ! integer ( i15 ) :: i = 0 , j = 0 real ( dp ), dimension (:,:), allocatable :: a_i , a_j real ( dp ) :: ddot ! check_orthogonality = . true . ! call allocator ( a_i , M , 1 ) call allocator ( a_j , M , 1 ) ! do i = 1 , N a_i (:, 1 ) = A (:, i ) do j = 1 , i - 1 a_j (:, 1 ) = A (:, j ) if ( abs ( ddot ( M , a_i , 1 , a_j , 1 )) . gt . 1.0d-07 ) then check_orthogonality = . false . return endif enddo enddo ! call deallocator ( a_i , M , 1 ) call deallocator ( a_j , M , 1 ) ! end function check_orthogonality ! end module utils","tags":"","loc":"sourcefile/utils.f90.html","title":"utils.F90 – The eT program"},{"text":"Files Dependent On This One sourcefile~~types.f90~~AfferentGraph sourcefile~types.f90 types.F90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~types.f90->sourcefile~cc2_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~types.f90->sourcefile~mp2_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~types.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~calc_procedures_class.f90 calc_procedures_class.F90 sourcefile~types.f90->sourcefile~calc_procedures_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~types.f90->sourcefile~cc3_class.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~et_program.f90 eT_program.F90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~workspace.f90->sourcefile~cc2_class.f90 sourcefile~workspace.f90->sourcefile~mp2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~ccsdpt_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~cc3_class.f90 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~utils.f90->sourcefile~cc2_class.f90 sourcefile~utils.f90->sourcefile~mp2_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccsdpt_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~cc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~mp2_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~ccsdpt_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~et_program.f90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 sourcefile~batching_index_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~input_reader.f90->sourcefile~et_program.f90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 var pansourcefiletypesf90AfferentGraph = svgPanZoom('#sourcefiletypesf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules types Source Code types.F90 Source Code module types ! !! !!  Types module !!  Written by Sarai D. Folkestad and Eirik F. Kjønstad, April 2017 !! !!  Defines the real and integer types used throughout the module !! ! implicit none ! !  Kind numbers for real and integers ! !  Usage:\treal(dp) \t :: foo !\t\t\t\tinteger(i15) :: foo_int ! integer , parameter :: sp = selected_real_kind ( 6 , 37 ) integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: qp = selected_real_kind ( 33 , 4931 ) integer , parameter :: i15 = selected_int_kind ( 15 ) ! !  Integers as reals ! real ( dp ), parameter :: zero = 0.0D0 , one = 1.0D0 , two = 2.0D0 , half = 0.5D0 real ( dp ), parameter :: three = 3.0D0 , four = 4.0D0 , five = 5.0D0 , six = 6.0D0 ! end module types","tags":"","loc":"sourcefile/types.f90.html","title":"types.F90 – The eT program"},{"text":"This File Depends On sourcefile~~memory_manager_class.f90~~EfferentGraph sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~memory_manager_class.f90~~AfferentGraph sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefilememory_manager_classf90AfferentGraph = svgPanZoom('#sourcefilememory_manager_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules memory_manager_class Source Code memory_manager_class.F90 Source Code module memory_manager_class ! !! !!                   Memory manager class module !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    The memory manager class handles the memory used by the model calculation, !!    and there is an object called 'mem' in the wavefunction object of this class. !! !!    Note: large arrays must always be allocated using the memory manager object. Small arrays, !!          integers, strings, etc., which use a negligible amount of memory, are not considered !!          by the memory manager. !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types use input_output ! !  Batching index class ! use batching_index_class ! !  :::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the memory_manager class -::- !  :::::::::::::::::::::::::::::::::::::::::::::::: ! type :: memory_manager ! !     The total amount of memory specified by user (standard: 30 GB) ! integer ( i15 ) :: total = 30000000000 ! !     The amount of memory currently available, based on the arrays currently allocated !     (memory used by objects and local variables are not included in this estimate) ! integer ( i15 ) :: available = 30000000000 ! !     Buffer for handling batches (standard: 10%). This means in practice that 'required !     memory' estimates are increased by 10% in case they miss they slightly underestimate !     the correct memory requirements ! integer ( i15 ) :: buffer = 10 ! 10% ! contains ! !     Initialization routine (used if user specifies a memory different from standard) ! procedure :: init => init_memory_manager ! !     Allocation and deallocation routines for double precision arrays ! procedure :: alloc => alloc_memory_manager procedure :: dealloc => dealloc_memory_manager ! !     Allocation and deallocation routines for integer arrays ! procedure :: alloc_int => alloc_int_memory_manager procedure :: dealloc_int => dealloc_int_memory_manager ! !     Routines for determining the number of batches ! procedure :: num_batch => num_batch_memory_manager ! For one-index batch procedure :: num_two_batch => num_two_batch_memory_manager ! For two-index batches ! end type memory_manager ! ! contains ! ! module subroutine init_memory_manager ( mem , total ) !! !!    Init (Memory Manager) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    Initializes the memory manager object by setting the !!    total and initial available memory !! !!    This is only called if the user specifies a total memory !!    different from the standard !! implicit none ! class ( memory_manager ) :: mem ! integer ( i15 ) :: total ! In GBs ! !     Set the specified total memory in bytes ! mem % total = total * 1.0D9 ! !     Update the initially available memory ! mem % available = mem % total ! end subroutine init_memory_manager ! ! module subroutine alloc_memory_manager ( mem , array , M , N ) !! !!    Alloc (Memory Manager) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    Allocates a double precision array and updates the available !!    memory accordingly. !! implicit none ! class ( memory_manager ) :: mem ! real ( dp ), dimension (:,:), allocatable :: array ! integer ( i15 ), intent ( in ) :: M , N ! First and second dimension of array that is being allocated ! integer ( i15 ) :: size ! Total size of array (M*N) integer ( i15 ) :: stat = 0 integer ( i15 ) :: error = 0 ! size = M * N ! !     Allocate array and check whether allocation was successful ! allocate ( array ( M , N ), stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Error: could not allocate array with #elements =' , size stop ! endif ! !     Update the available memory ! !     The 'double precision' type (see types.F90) is typically 8 bytes, !     though it might differ due to its definition in terms of precision. ! mem % available = mem % available - dp * size ! !     Check if there is no more memory (defined as being no more memory !     left of what was specified by user as available) ! if ( mem % available . lt . 0 ) then ! write ( unit_output , '(t3,a)' ) \"Error: user-specified memory insufficient.\" stop ! endif ! end subroutine alloc_memory_manager ! ! module subroutine dealloc_memory_manager ( mem , array , M , N ) !! !!    Dealloc (Memory Manager) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    Deallocates a double precision array and updates the available !!    memory accordingly. !! implicit none ! class ( memory_manager ) :: mem ! real ( dp ), dimension (:,:), allocatable :: array ! integer ( i15 ), intent ( in ) :: M , N ! First and second dimension of array that is being allocated ! integer ( i15 ) :: size ! Total size of array (M*N) integer ( i15 ) :: stat = 0 integer ( i15 ) :: error = 0 ! size = M * N ! !     Deallocate array and check whether deallocation was successful ! deallocate ( array , stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Error: could not deallocate array with #elements =' , size stop ! endif ! !     Update the available memory ! !     The 'double precision' type (see types.F90) is typically 8 bytes, !     though it might differ due to its definition in terms of precision. ! mem % available = mem % available + dp * size ! end subroutine dealloc_memory_manager ! ! module subroutine alloc_int_memory_manager ( mem , array , M , N ) !! !!    Alloc Int (Memory Manager) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    Allocates an integer array and updates the available !!    memory accordingly. !! implicit none ! class ( memory_manager ) :: mem ! integer ( i15 ), dimension (:,:), allocatable :: array ! integer ( i15 ), intent ( in ) :: M , N ! First and second dimension of array that is being allocated ! integer ( i15 ) :: size ! Total size of array (M*N) integer ( i15 ) :: stat = 0 integer ( i15 ) :: error = 0 ! size = M * N ! !     Allocate array and check whether allocation was successful ! allocate ( array ( M , N ), stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Error: could not allocate array with #elements =' , size stop ! endif ! !     Update the available memory ! !     The 'integer 15', or i15, type (see types.F90) is typically 4 bytes, !     though it might differ due to its definition in terms of precision. ! mem % available = mem % available - i15 * size ! !     Check if there is no more memory (defined as being no more memory !     left of what was specified by user as available) ! if ( mem % available . lt . 0 ) then ! write ( unit_output , '(t3,a)' ) \"Error: user-specified memory insufficient.\" stop ! endif ! end subroutine alloc_int_memory_manager ! ! module subroutine dealloc_int_memory_manager ( mem , array , M , N ) !! !!    Dealloc Int (Memory Manager) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    Deallocates an integer array and updates the available !!    memory accordingly. !! implicit none ! class ( memory_manager ) :: mem ! integer ( i15 ), dimension (:,:), allocatable :: array ! integer ( i15 ), intent ( in ) :: M , N ! First and second dimension of array that is being allocated ! integer ( i15 ) :: size ! Total size of array (M*N) integer ( i15 ) :: stat = 0 integer ( i15 ) :: error = 0 ! size = M * N ! !     Deallocate array and check whether deallocation was successful ! deallocate ( array , stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Error: could not deallocate array with #elements =' , size stop ! endif ! !     Update the available memory ! !     The 'integer 15', or i15, type (see types.F90) is typically 4 bytes, !     though it might differ due to its definition in terms of precision. ! mem % available = mem % available + i15 * size ! end subroutine dealloc_int_memory_manager ! ! subroutine num_batch_memory_manager ( mem , batch_p , required ) !! !!    Number of batches !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    Given the required memory, this routine determines, for a one-index batching, !!    the maximum batch length and the number of batches in total. !! implicit none ! class ( memory_manager ) :: mem ! class ( batching_index ) :: batch_p ! The index being batched over ! integer ( i15 ) :: required ! !     Add buffer to required estimate ! required = required + required / ( mem % buffer ) ! if ( required . lt . mem % available ) then ! !        No need to batch ! batch_p % num_batches = 1 batch_p % max_length = batch_p % index_dimension ! return ! endif ! !     We need to batch ! !     Determine maximum batch length ! batch_p % max_length = ( mem % available ) / ( required / ( batch_p % index_dimension )) ! !     Number of full batches ! batch_p % num_batches = ( batch_p % index_dimension ) / ( batch_p % max_length ) ! !     Test for rest not included in the preceding integer division ! if (( batch_p % num_batches ) * ( batch_p % max_length ) . lt . batch_p % index_dimension ) then ! batch_p % num_batches = batch_p % num_batches + 1 ! endif ! end subroutine num_batch_memory_manager ! ! subroutine num_two_batch_memory_manager ( mem , batch_p , batch_q , required ) !! !!    Number of two-batches !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    Given the required memory, this routine determines, for two-index batching, !!    the maximum batch length and the number of batches in total of both batching !!    indices. !! implicit none ! class ( memory_manager ) :: mem ! class ( batching_index ) :: batch_p class ( batching_index ) :: batch_q ! integer ( i15 ) :: required ! integer ( i15 ) :: i = 0 ! required = required + required / ( mem % buffer ) ! batch_p % num_batches = 1 batch_q % num_batches = 1 ! if ( required . lt . mem % available ) then ! !        No need to batch ! batch_p % num_batches = 1 batch_q % num_batches = 1 ! batch_p % max_length = batch_p % index_dimension batch_q % max_length = batch_q % index_dimension ! return ! endif ! !     We need to batch ! !     Test whether two different-length indices are requested, !     because this feature is not yet implemented ! if ( batch_p % index_dimension . ne . batch_q % index_dimension ) then ! write ( unit_output , '(t3,a)' ) 'Error: batching over indices of different lengths is not yet implemented' stop ! endif ! !     Determine number of batches ! do i = 1 , batch_p % index_dimension ! if ( mem % available . gt . required / i ** 2 ) then ! batch_p % num_batches = i batch_q % num_batches = i ! batch_p % max_length = ( batch_p % index_dimension ) / ( batch_p % num_batches ) batch_q % max_length = ( batch_q % index_dimension ) / ( batch_q % num_batches ) ! !           Test for rest ! if (( batch_p % num_batches ) * ( batch_p % max_length ) . lt . batch_p % index_dimension ) then ! batch_p % num_batches = batch_p % num_batches + 1 batch_p % num_batches = batch_p % num_batches + 1 ! endif ! return ! endif ! enddo ! end subroutine num_two_batch_memory_manager ! ! end module memory_manager_class","tags":"","loc":"sourcefile/memory_manager_class.f90.html","title":"memory_manager_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~batching_index_class.f90~~EfferentGraph sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~batching_index_class.f90~~AfferentGraph sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~batching_index_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~hf_class.f90 hf_class.F90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefilebatching_index_classf90AfferentGraph = svgPanZoom('#sourcefilebatching_index_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules batching_index_class Source Code batching_index_class.F90 Source Code module batching_index_class ! !! !!                    Batching index class module !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    The batching index class represents a single index (e.g. a in g_abcd) !!    that is being batched over. It contains information relevant to the !!    restriction of that index. !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types use input_output ! !  :::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the batching_index class -::- !  :::::::::::::::::::::::::::::::::::::::::::::::: ! type :: batching_index ! !     Values relating the limits and length of the current batch !     (set by determine_limits procedure for a given batch) ! integer ( i15 ) :: first = 0 ! Current first value of index integer ( i15 ) :: last = 0 ! Current last value of index integer ( i15 ) :: length = 0 ! Current length of batch (last - first + 1) ! !     Values relating the the size of the batch and the total number of batches !     (set by memory manager routines) ! integer ( i15 ) :: max_length = 0 ! Maximum length of batch (most batches will be of this size, but typically not all) integer ( i15 ) :: num_batches = 0 ! The number of batches in total for the index ! !     Value that must be initialized by user ! integer ( i15 ) :: index_dimension = 0 ! Full length of index (e.g., typically n_vir for virtual index) ! !     Logical for initialization (for sanity check) ! logical :: initialized = . false . ! contains ! !     Initialization routine (sets the index dimension) ! procedure :: init => init_batching_index ! !     Routine that sets the batch dependent variables, !     first, last and length, based on which batch it is ! procedure :: determine_limits => determine_limits_batching_index ! end type batching_index ! ! contains ! ! subroutine init_batching_index ( batch_p , dimension ) !! !!    Init (batching index) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! !!    Note: every batching index must be initialized! !!    The 'dimension' variable specifies the total length of the !!    batching index, e.g. the number of virtuals for a virtual index. !! implicit none ! class ( batching_index ) :: batch_p ! integer ( i15 ), intent ( in ) :: dimension ! batch_p % index_dimension = dimension batch_p % initialized = . true . ! end subroutine init_batching_index ! ! subroutine determine_limits_batching_index ( batch_p , batch_number ) !! !!    Determine limits !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 !! implicit none ! class ( batching_index ) :: batch_p ! p is general index (can be virtual or occupied or other) ! integer ( i15 ), intent ( in ) :: batch_number ! The current batch ! !     Sanity check ! if (. not . batch_p % initialized ) then ! write ( unit_output , '(t3,a)' ) 'Error: a non-initialized batching variable was used.' stop ! endif ! !     Determine limits of batch, q = first, first + 1, ..., last ! batch_p % first = 1 + ( batch_number - 1 ) * ( batch_p % max_length ) batch_p % last = min (( batch_p % max_length ) + ( batch_number - 1 ) * ( batch_p % max_length ), batch_p % index_dimension ) ! !     Calculate the length of the batch ! batch_p % length = batch_p % last - batch_p % first + 1 ! end subroutine determine_limits_batching_index ! ! end module batching_index_class","tags":"","loc":"sourcefile/batching_index_class.f90.html","title":"batching_index_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~input_output.f90~~EfferentGraph sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~input_output.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~input_output.f90~~AfferentGraph sourcefile~input_output.f90 input_output.F90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~input_output.f90->sourcefile~cc2_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~input_output.f90->sourcefile~ccsdpt_class.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~input_output.f90->sourcefile~mp2_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~input_output.f90->sourcefile~et_program.f90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~input_output.f90->sourcefile~cc3_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~cc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccsdpt_class.f90 sourcefile~workspace.f90->sourcefile~mp2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~cc3_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~cc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccsdpt_class.f90 sourcefile~utils.f90->sourcefile~mp2_class.f90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~et_program.f90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 sourcefile~batching_index_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 var pansourcefileinput_outputf90AfferentGraph = svgPanZoom('#sourcefileinput_outputf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules input_output Source Code input_output.F90 Source Code module input_output ! !! !!    Input_output module !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, April 2017 !! !!    Handles input and output and contains: !! !!    generate_unit_identifier: Returns a free unit_identifier which can be assigned to a file that is opened. !!    vec_print:                Prints vector in compound index order. !! ! use types ! implicit none ! integer ( i15 ) :: unit_output = 0 integer , private :: n_files = 0 ! contains ! ! subroutine generate_unit_identifier ( unit_identifier ) !! !!    Generate unit identifier !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, April 2017 !! !!    Returns a valid unit identifier for opening file. !! implicit none ! integer ( i15 ) :: unit_identifier ! n_files = n_files + 1 unit_identifier = n_files ! end subroutine generate_unit_identifier ! ! subroutine vec_print ( vec , dim_1 , dim_2 ) !! !!    Vector print !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, March 2017 !! !!    A vector is printed with a compound index (p q) of dimension (dim_1 x dim_2) !! implicit none ! integer ( i15 ) :: p = 0 , q = 0 , pq = 0 ! integer ( i15 ), intent ( in ) :: dim_1 , dim_2 real ( dp ), dimension ( dim_1 , dim_2 ), intent ( in ) :: vec ! do q = 1 , dim_2 do p = 1 , dim_1 ! write ( unit_output , * ) p , q , vec ( p , q ) ! enddo enddo ! end subroutine vec_print ! ! subroutine vec_print_nonzero_elm ( vec , dim_1 , dim_2 ) !! !!    Vector print !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, March 2017 !! !!    A vector is printed with a compound index (p q) of dimension (dim_1 x dim_2) !! implicit none ! integer ( i15 ) :: p = 0 , q = 0 , pq = 0 ! integer ( i15 ), intent ( in ) :: dim_1 , dim_2 real ( dp ), dimension ( dim_1 , dim_2 ), intent ( in ) :: vec ! do q = 1 , dim_2 do p = 1 , dim_1 ! if ( vec ( p , q ) . gt . 1.0D-03 ) then write ( unit_output , * ) p , q , vec ( p , q ) endif ! enddo enddo ! end subroutine vec_print_nonzero_elm end module input_output","tags":"","loc":"sourcefile/input_output.f90.html","title":"input_output.F90 – The eT program"},{"text":"This File Depends On sourcefile~~excited_state_specs_class.f90~~EfferentGraph sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~excited_state_specs_class.f90~~AfferentGraph sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefileexcited_state_specs_classf90AfferentGraph = svgPanZoom('#sourcefileexcited_state_specs_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules excited_state_specs_class Source Code excited_state_specs_class.F90 Source Code module excited_state_specs_class ! !! !!                       Excited State Specifictions class module !!            Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017 !! !!    The class contains specifications for the excited state calculation, and necesary variables provided by user. !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  ::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the excited_state_specs class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::: ! type :: excited_state_specs ! !     Settings for the excited state calculation ! real ( dp ) :: energy_threshold = 1.0D-06 ! Threshold for energies real ( dp ) :: residual_threshold = 1.0D-06 ! Threshold for equation residuals ! integer ( i15 ) :: max_iterations = 50 ! excited state maximum number of iterations ! logical :: restart = . false . ! logical :: user_specified_start_vector = . false . ! True if the user has provided startvectors integer ( i15 ), dimension (:,:), allocatable :: start_vectors ! !     Variables needed for excited state calculation ! integer ( i15 ) :: n_singlet_states = 0 integer ( i15 ) :: n_triplet_states = 0 ! !     Logicals to determine wether we have Jacobi of Jacobi transpose transformation ! logical :: right = . true . ! Default logical :: left = . false . ! !     Solution file name ! character ( len = 40 ) :: solution_file = 'right_valence' ! Should be 'right_valence', 'left_valence' !                                                            'right_core' or 'left_core'. ! end type excited_state_specs ! contains ! end module excited_state_specs_class","tags":"","loc":"sourcefile/excited_state_specs_class.f90.html","title":"excited_state_specs_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~mlcc_calculation_settings_class.f90~~EfferentGraph sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mlcc_calculation_settings_class.f90~~AfferentGraph sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 var pansourcefilemlcc_calculation_settings_classf90AfferentGraph = svgPanZoom('#sourcefilemlcc_calculation_settings_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mlcc_calculation_settings_class Source Code mlcc_calculation_settings_class.F90 Source Code module mlcc_calculation_settings_class ! !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the mlcc_calculation_settings class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ! type :: mlcc_calculation_settings ! !  Levels of the hierarchy ! logical :: CCS = . false . logical :: CC2 = . false . logical :: CCSD = . false . logical :: CC3 = . false . ! contains ! end type mlcc_calculation_settings ! contains ! ! end module mlcc_calculation_settings_class","tags":"","loc":"sourcefile/mlcc_calculation_settings_class.f90.html","title":"mlcc_calculation_settings_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~mlcc_orbitals_class.f90~~EfferentGraph sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mlcc_orbitals_class.f90~~AfferentGraph sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 var pansourcefilemlcc_orbitals_classf90AfferentGraph = svgPanZoom('#sourcefilemlcc_orbitals_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mlcc_orbitals_class Source Code mlcc_orbitals_class.F90 Source Code module mlcc_orbitals_class ! !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types use input_reader ! !  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the mlcc_orbitals class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ! type :: mlcc_orbitals ! !  Orbitals used ! logical :: cholesky = . false . logical :: cnto = . true . ! real ( dp ) :: delta_o = 1.0D-06 real ( dp ) :: delta_v = 1.0D-06 ! !  Cholesky specific variables ! integer ( i15 ) :: n_active_atoms integer ( i15 ), dimension (:,:), allocatable :: active_atoms ! contains ! !  -::- Procedure pointers -::- ! procedure :: orbital_reader => orbital_reader_mlcc_orb ! end type mlcc_orbitals ! contains ! !  -::- Procedure definitions -::- ! subroutine orbital_reader_mlcc_orb ( orbital_info , unit_input ) !! !! implicit none ! ! integer ( i15 ) :: unit_input ! class ( mlcc_orbitals ) :: orbital_info ! character ( len = 40 ) :: line ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! do ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'cnto' ) then ! CNTOs ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! do ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'delta_o:' ) then read ( unit_input , * ) orbital_info % delta_o cycle elseif ( trim ( line ) == 'delta_v:' ) then read ( unit_input , * ) orbital_info % delta_v cycle elseif ( trim ( line ) == '}' ) then return elseif ( trim ( line ) == 'end of eT input' ) then write ( unit_output , * ) 'Error: end of CNTO section of eT.inp was not found.' stop endif ! enddo ! endif ! Use defaults (cntos with both thresholds at 1.0D-6) return ! elseif ( trim ( line ) == 'cholesky' ) then ! cholesky orbitals ! orbital_info % cnto = . false . orbital_info % cholesky = . true . ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! do ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'n_active_atoms:' ) then ! read ( unit_input , * ) orbital_info % n_active_atoms cycle ! elseif ( trim ( line ) == 'active_atoms:' ) then ! if ( orbital_info % n_active_atoms == 0 ) then write ( unit_output , * )& 'Error: n_active_atoms must be specified in eT.inp before active atoms are selected' stop endif ! allocate ( orbital_info % active_atoms ( orbital_info % n_active_atoms , 1 )) read ( unit_input , * ) orbital_info % active_atoms cycle ! elseif ( trim ( line ) == '}' ) then ! !                       Sanity check for cholesky orbitals ! if ( orbital_info % n_active_atoms == 0 . or . . not . allocated ( orbital_info % active_atoms )) then write ( unit_output , * ) 'Error: information needed for Cholesky orbitals was not found in eT.inp' stop endif ! return elseif ( trim ( line ) == 'end of eT input' ) then write ( unit_output , * ) 'Error: end of cholesky section of eT.inp was not found.' stop endif enddo ! return else write ( unit_output , * ) 'Error: Cholesky orbitals requires specification of the active space!' stop endif elseif ( trim ( line ) == '}' ) then return elseif ( trim ( line ) == 'end of eT input.' ) then write ( unit_output , * ) 'Error: Could not find end of orbital section of eT.inp!' stop endif enddo ! else ! Use defaults (cntos with both thresholds at 1.0D-6) return endif ! end subroutine orbital_reader_mlcc_orb ! ! end module mlcc_orbitals_class","tags":"","loc":"sourcefile/mlcc_orbitals_class.f90.html","title":"mlcc_orbitals_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ground_state_specs_class.f90~~EfferentGraph sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~ground_state_specs_class.f90~~AfferentGraph sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefileground_state_specs_classf90AfferentGraph = svgPanZoom('#sourcefileground_state_specs_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules ground_state_specs_class Source Code ground_state_specs_class.F90 Source Code module ground_state_specs_class ! !! !!                       Ground State Specifictions class module !!            Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017 !! !!    The class contains specifications for the ground state calculation. !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  ::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the ground_state_specs class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::: ! type :: ground_state_specs ! !     Settings for the ground state calculation ! real ( dp ) :: energy_threshold = 1.0D-06 ! Threshold for energies real ( dp ) :: residual_threshold = 1.0D-06 ! Threshold for equation residuals ! integer ( i15 ) :: max_iterations = 50 ! Ground state maximum number of iterations ! logical :: restart = . false . ! end type ground_state_specs ! contains ! end module ground_state_specs_class","tags":"","loc":"sourcefile/ground_state_specs_class.f90.html","title":"ground_state_specs_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~calc_settings_class.f90~~EfferentGraph sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~calc_settings_class.f90~~AfferentGraph sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefilecalc_settings_classf90AfferentGraph = svgPanZoom('#sourcefilecalc_settings_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules calc_settings_class Source Code calc_settings_class.F90 Source Code module calc_settings_class ! !! !!                         Calculation settings class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  ::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the calc_settings class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::: ! type :: calc_settings ! real ( dp ) :: disk_space = 100 D0 ! 100 gigabytes; can be modified by user !   real(dp) :: memory     = 700000000  ! In words (= ca 5 gb) !! This should be hooked up to workspace!! ! character ( len = 40 ) :: print_level = 'developer' ! end type calc_settings ! contains ! !  No procedures yet. ! end module calc_settings_class","tags":"","loc":"sourcefile/calc_settings_class.f90.html","title":"calc_settings_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~calc_tasks_class.f90~~EfferentGraph sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~calc_tasks_class.f90~~AfferentGraph sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefilecalc_tasks_classf90AfferentGraph = svgPanZoom('#sourcefilecalc_tasks_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules calc_tasks_class Source Code calc_tasks_class.F90 Source Code module calc_tasks_class ! !! !!                       Calculation tasks class module !!            Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017 !! !!    The procedures class is used for two purposes. Wavefunctions possess !!    \"implemented\" and \"tasks\" objects, which are both instances of the class !!    calculation procedures. If one of the tasks requested is not implemented !!    for the wavefunction in question, the program stops, letting the user know !!    that the requested functionality is not a part of eT (yet). !! !!    Tasks are determined during the read of the input (see the main program). !!    Implemented are set by the wavefunction's initialization routine. !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  ::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the calc_tasks class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::: ! type :: calc_tasks ! logical :: ground_state = . false . logical :: excited_state = . false . logical :: core_excited_state = . false . logical :: ionized_state = . false . logical :: core_ionized_state = . false . logical :: multipliers = . false . ! character ( len = 40 ) :: current = 'ground_state' ! end type calc_tasks ! contains ! end module calc_tasks_class","tags":"","loc":"sourcefile/calc_tasks_class.f90.html","title":"calc_tasks_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~core_excited_state_specs_class.f90~~EfferentGraph sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~core_excited_state_specs_class.f90~~AfferentGraph sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefilecore_excited_state_specs_classf90AfferentGraph = svgPanZoom('#sourcefilecore_excited_state_specs_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules core_excited_state_specs_class Source Code core_excited_state_specs_class.F90 Source Code module core_excited_state_specs_class ! !! !!                  Core Excited State Specifictions class module !!            Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017 !! !!    The class contains specifications for the core excited state calculation, and necesary variables provided by user. !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  :::::::::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the core excited_state_specs class -::- !  :::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ! type :: core_excited_state_specs ! !     Variables necessary for core excitation calc ! integer ( i15 ) :: n_equivalent_cores ! Number of equivalent cores integer ( i15 ), dimension (:,:), allocatable :: cores ! Cores, given by order in MOLECULE.INP file integer ( i15 ), dimension (:,:), allocatable :: index_core_mo ! MO index/indices of core(s) ! end type core_excited_state_specs ! contains ! end module core_excited_state_specs_class","tags":"","loc":"sourcefile/core_excited_state_specs_class.f90.html","title":"core_excited_state_specs_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~calc_procedures_class.f90~~EfferentGraph sourcefile~calc_procedures_class.f90 calc_procedures_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~calc_procedures_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules calc_tasks_class Source Code calc_procedures_class.F90 Source Code module calc_tasks_class ! !! !!                       Calculation tasks class module !!            Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    The procedures class is used for two purposes. Wavefunctions possess !!    \"implemented\" and \"tasks\" objects, which are both instances of the class !!    calculation procedures. If one of the tasks requested is not implemented !!    for the wavefunction in question, the program stops, letting the user know !!    that the requested functionality is not a part of eT (yet). !! !!    Tasks are determined during the read of the input (see the main program). !!    Implemented are set by the wavefunction's initialization routine. !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  ::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the calc_procedures class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::: ! type :: calc_tasks ! logical :: ground_state = . false . logical :: excited_state = . false . logical :: core_excited_state = . false . logical :: ionized_state = . false . logical :: core_ionized_state = . false . logical :: properties = . false . ! character ( len = 40 ) :: current = 'ground_state' ! end type calc_tasks ! contains ! end module calc_tasks_class","tags":"","loc":"sourcefile/calc_procedures_class.f90.html","title":"calc_procedures_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~response_calc_specs_class.f90~~EfferentGraph sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~response_calc_specs_class.f90~~AfferentGraph sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefileresponse_calc_specs_classf90AfferentGraph = svgPanZoom('#sourcefileresponse_calc_specs_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules response_calc_specs_class Source Code response_calc_specs_class.F90 Source Code module response_calc_specs_class ! !! !!                   Response Calculation Specifictions class module !!            Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017 !! !!    The class contains specifications for the excited state calculation, and necesary variables provided by user. !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  ::::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the response_calc_specs class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::::::: ! type :: response_calc_specs ! !     Settings for the excited state calculation ! real ( dp ) :: energy_threshold = 1.0D-06 ! Threshold for energies real ( dp ) :: residual_threshold = 1.0D-06 ! Threshold for equation residuals ! integer ( i15 ) :: max_iterations = 50 ! excited state maximum number of iterations ! logical :: restart = . false . ! end type response_calc_specs ! contains ! end module response_calc_specs_class","tags":"","loc":"sourcefile/response_calc_specs_class.f90.html","title":"response_calc_specs_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~jacobian_submodule.f90~~EfferentGraph sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilejacobian_submodulef90EfferentGraph = svgPanZoom('#sourcefilejacobian_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules jacobian Source Code jacobian_submodule.F90 Source Code submodule ( mlcc2_class ) jacobian ! !! !!    Jacobian transformation submodule (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Contains the following family of procedures of the MLCC2 class: !! !!    jacobian_transformation: Directs the transformation by A. !! !!    MLCC2 contributions to jacobi transformation !! !!    jacobian_mlcc2_a1 !!    jacobian_mlcc2_b1 !!    jacobian_mlcc2_a2 !!    jacobian_mlcc2_b2 !! !!    Upper case indices are general indices, lower case indices are restricted !!    to the CC2 orbital space. !! ! implicit none ! logical :: debug = . false . logical :: timings = . false . ! character ( len = 40 ) :: integral_type ! contains ! module subroutine jacobian_mlcc2_transformation_mlcc2 ( wf , c_a_i , c_aibj ) !! !!    Jacobian transformation (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Directs the transformation by the CCSD Jacobi matrix, !! !!       A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >, !! !!    where the basis employed for the brackets is biorthonormal. !!    The transformation is rho = A c, i.e., !! !!       rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck !!                  + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl). !! !!    On exit, c is overwritten by rho. That is, c_a_i = rho_a_i, !!    and c_aibj = rho_aibj. !! implicit none ! class ( mlcc2 ) :: wf ! !     Incoming vector c ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_x2am , 1 ) :: c_aibj ! c_aibj ! !     Local unpacked and reordered vectors ! real ( dp ), dimension (:,:), allocatable :: rho_a_i ! rho_ai   = (A c)_ai real ( dp ), dimension (:,:), allocatable :: rho_ai_bj ! rho_ai   = (A c)_aibj real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_sym ! rho_ai   = (A c)_aibj real ( dp ), dimension (:,:), allocatable :: c_ai_bj ! rho_ai   = (A c)_aibj ! !     Indices ! integer ( i15 ) :: a = 0 , ab = 0 , ai = 0 , b = 0 integer ( i15 ) :: bj = 0 , i = 0 , ij = 0 , j = 0 , aibj = 0 ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 ! !     Allocate and zero the transformed vector (singles part) ! call wf % mem % alloc ( rho_a_i , wf % n_v , wf % n_o ) rho_a_i = zero ! !     :: CCS contributions to the singles c vector :: ! call wf % initialize_amplitudes call wf % read_amplitudes ! ! call wf % jacobian_ccs_a1 ( rho_a_i , c_a_i ) call wf % jacobian_ccs_b1 ( rho_a_i , c_a_i ) ! !     :: MLCC2 contributions to transformed vector :: ! call wf % jacobian_mlcc2_a1 ( rho_a_i , c_a_i ) ! !     Calculatenumber of active indices ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! !     Allocate the incoming unpacked doubles vector ! call wf % mem % alloc ( c_ai_bj , n_active_o * n_active_v , n_active_o * n_active_v ) c_ai_bj = zero ! call squareup ( c_aibj , c_ai_bj , n_active_o * n_active_v ) ! Pack out vector ! !     Scale the doubles vector by 1 + delta_ai,bj, i.e. !     redefine to c_ckdl = c_ckdl (1 + delta_ck,dl) ! do i = 1 , n_active_o * n_active_v ! c_ai_bj ( i , i ) = two * c_ai_bj ( i , i ) ! enddo ! !     - B1 term - ! call wf % jacobian_mlcc2_b1 ( rho_a_i , c_ai_bj ) ! ! !     Allocate unpacked transformed vector ! call wf % mem % alloc ( rho_ai_bj , n_active_o * n_active_v , n_active_o * n_active_v ) rho_ai_bj = zero ! !     - A2 term - ! call wf % jacobian_mlcc2_a2 ( rho_ai_bj , c_a_i ) ! !     Last term is already symmetric (B2). Perform the symmetrization !     rho_ai_bj = P_ij&#94;ab rho_ai_bj now, for convenience ! !     Allocate temporary symmetric transformed vector ! call wf % mem % alloc ( rho_ai_bj_sym , n_active_o * n_active_v , n_active_o * n_active_v ) rho_ai_bj_sym = zero ! do j = 1 , n_active_o do b = 1 , n_active_v ! bj = index_two ( b , j , n_active_v ) ! do i = 1 , n_active_o do a = 1 , n_active_v ! ai = index_two ( a , i , n_active_v ) ! rho_ai_bj_sym ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj ( bj , ai ) ! enddo enddo enddo enddo ! rho_ai_bj = rho_ai_bj_sym ! !     Done with temporary vector; deallocate ! call wf % mem % dealloc ( rho_ai_bj_sym , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     - B2 term - ! call wf % jacobian_mlcc2_b2 ( rho_ai_bj , c_ai_bj ) ! !     Divide rho_ai_bj by biorthonormal, and save to c_aibj ! do a = 1 , n_active_v do i = 1 , n_active_o ! ai = index_two ( a , i , n_active_v ) ! do b = 1 , n_active_v do j = 1 , n_active_o ! bj = index_two ( b , j , n_active_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai == bj ) rho_ai_bj ( ai , bj ) = half * rho_ai_bj ( ai , bj ) ! c_aibj ( aibj , 1 ) = rho_ai_bj ( ai , bj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj , n_active_o * n_active_v , n_active_o * n_active_v ) call wf % mem % dealloc ( c_ai_bj , n_active_o * n_active_v , n_active_o * n_active_v ) ! c_a_i = rho_a_i ! call wf % mem % dealloc ( rho_a_i , wf % n_v , wf % n_o ) ! end subroutine jacobian_mlcc2_transformation_mlcc2 ! ! module subroutine jacobian_mlcc2_a1_mlcc2 ( wf , rho_a_i , c_a_i ) !! !!    Jacobian tem A1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Calculates the A1 contribution to the jacobi transformation, !! !!       A1: 2*sum_BJck u_ik&#94;ac*g_kc,JB*c_BJ - sum_Bjck u_kj&#94;ca*g_kc,jB*c_BI !!            - sum_BJck u_ik&#94;ac*g_kB,Jc*c_BJ - sum_bJck u_ki&#94;cb*g_kc,Jb*c_AJ, !! !!     with, !! !!    u_ik&#94;ac = 2*s_ik&#94;ac - 2*s_ik&#94;ca, !! !!    which is constructed while batching over c !! implicit none ! class ( mlcc2 ) :: wf ! !     Incoming vectors c and rho ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: L_kc_J real ( dp ), dimension (:,:), allocatable :: L_BJ_J real ( dp ), dimension (:,:), allocatable :: L_jB_J real ( dp ), dimension (:,:), allocatable :: L_Jc_J real ( dp ), dimension (:,:), allocatable :: L_kB_J real ( dp ), dimension (:,:), allocatable :: u_ai_kc real ( dp ), dimension (:,:), allocatable :: g_ai_kc real ( dp ), dimension (:,:), allocatable :: u_bkc_i real ( dp ), dimension (:,:), allocatable :: g_kc_BJ real ( dp ), dimension (:,:), allocatable :: g_kc_JB real ( dp ), dimension (:,:), allocatable :: g_jkc_B real ( dp ), dimension (:,:), allocatable :: g_jB_kc real ( dp ), dimension (:,:), allocatable :: g_kB_Jc real ( dp ), dimension (:,:), allocatable :: c_JB real ( dp ), dimension (:,:), allocatable :: X_kc real ( dp ), dimension (:,:), allocatable :: X_a_B real ( dp ), dimension (:,:), allocatable :: X_J_i real ( dp ), dimension (:,:), allocatable :: rho_ai_active_space ! !     Indices ! integer ( i15 ) :: k = 0 , c = 0 , j = 0 , a = 0 , i = 0 , b = 0 integer ( i15 ) :: kc = 0 , ck = 0 , ai = 0 , ak = 0 , ic = 0 , jb = 0 , BJ = 0 , Jc = 0 integer ( i15 ) :: bi = 0 , kB = 0 , ci = 0 integer ( i15 ) :: jkc = 0 , bkc = 0 integer ( i15 ) :: akci = 0 , aick = 0 ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! call wf % read_amplitudes ! call wf % mem % alloc ( u_ai_kc , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * ( n_active_v )) ! do i = 1 , n_active_o do a = 1 , n_active_v ! ai = index_two ( a , i , n_active_v ) ! do c = 1 , n_active_v ! do k = 1 , n_active_o ! kc = index_two ( k , c , n_active_o ) ck = index_two ( c , k , n_active_v ) ak = index_two ( a , k , n_active_v ) ci = index_two ( c , i , n_active_v ) ! aick = index_packed ( ai , ck ) akci = index_packed ( ak , ci ) ! u_ai_kc ( ai , kc ) = two * wf % x2am ( aick , 1 ) - wf % x2am ( akci , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !     :: Term 1 :: !     2* sum_BJck u_ai_kc * g_kc_BJ * c_BJ ( = sum_BJck u_ik&#94;ac * g_kc,JB * c_BJ ) ! !     Construct g_kc,JB ordered as g_kc_BJ !     We will use read_cholesky_ai to get reordered cholesky vectors of ia-type. !     This is possible because L&#94;J_ia is unchanged on T1-transformation ! call wf % mem % alloc ( g_kc_JB , n_active_o * n_active_v , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_JB , & first_active_o , last_active_o , & first_active_v , last_active_v , & 1 , wf % n_o , & 1 , wf % n_v ) ! call wf % mem % alloc ( c_JB , ( wf % n_o ) * ( wf % n_v ), 1 ) do B = 1 , wf % n_v do J = 1 , wf % n_o ! JB = index_two ( J , B , wf % n_o ) ! c_JB ( JB , 1 ) = c_a_i ( B , J ) ! enddo enddo ! !      Add contribution to rho_a_i ! !      sum_BJ g_kc_BJ*c_BJ = X_kc ! call wf % mem % alloc ( X_kc , n_active_o * n_active_v , 1 ) call dgemm ( 'N' , 'T' , & ( n_active_o ) * n_active_v , & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & g_kc_JB , & ( n_active_o ) * n_active_v , & c_JB , & 1 , & zero , & X_kc , & ( n_active_o ) * n_active_v ) ! call wf % mem % dealloc ( g_kc_JB , n_active_o * n_active_v , ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( c_JB , ( wf % n_o ) * ( wf % n_v ), 1 ) ! call wf % mem % alloc ( rho_ai_active_space , n_active_v , n_active_o ) ! !      rho_a_i += 2 * sum_ck u_ai_kc * X_kc ! call dgemm ( 'N' , 'N' , & ( n_active_o ) * ( n_active_v ), & 1 , & n_active_o * n_active_v , & two , & u_ai_kc , & ( n_active_o ) * ( n_active_v ), & X_kc , & ( n_active_o ) * n_active_v , & zero , & rho_ai_active_space , & ( n_active_o ) * ( n_active_v )) ! call wf % mem % dealloc ( X_kc , n_active_o * n_active_v , 1 ) ! do i = 1 , n_active_o do a = 1 , n_active_v rho_a_i ( a + first_active_v - 1 , i + first_active_o - 1 ) = rho_a_i ( a + first_active_v - 1 , i + first_active_o - 1 )& + rho_ai_active_space ( a , i ) enddo enddo ! call wf % mem % dealloc ( rho_ai_active_space , n_active_v , n_active_o ) ! !       :: Term 2 :: !        - sum_Bjck u_a_jkc * g_jkc_B * c_BI (= - sum_Bjck u_kj&#94;ca * g_kc,jB * c_BI) ! !       Construct g_kc_jB ! call wf % mem % alloc ( g_kc_jB , n_active_o * n_active_v , n_active_o * wf % n_v ) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_jB , & first_active_o , last_active_o , & first_active_v , last_active_v , & first_active_o , last_active_o , & 1 , wf % n_v ) ! !       Reorder g_kc_jB to g_jkc_B ! call wf % mem % alloc ( g_jkc_B , n_active_v * n_active_o ** 2 , wf % n_v ) do c = 1 , n_active_v do k = 1 , n_active_o kc = index_two ( k , c , n_active_o ) do j = 1 , n_active_o jkc = index_three ( j , k , c , n_active_o , n_active_o ) do B = 1 , wf % n_v jB = index_two ( j , B , n_active_o ) g_jkc_B ( jkc , B ) = g_kc_jB ( kc , jB ) enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_jB , n_active_o * n_active_v , n_active_o * wf % n_v ) ! !       Add contribution to rho_a_i ! !       sum u_a_jkc*g_jkc_B = X_a_B ! call wf % mem % alloc ( X_a_B , n_active_v , wf % n_v ) call dgemm ( 'N' , 'N' , & ( n_active_v ), & wf % n_v , & n_active_o * n_active_v * n_active_o , & one , & u_ai_kc , & ( n_active_v ), & g_jkc_B , & n_active_o * n_active_v * n_active_o , & zero , & X_a_B , & ( n_active_v )) ! call wf % mem % dealloc ( g_jkc_B , n_active_v * n_active_o ** 2 , wf % n_v ) ! !       rho_a_i += - sum_ck  X_a_B*c_B_I ! call dgemm ( 'N' , 'N' , & ( n_active_v ), & wf % n_o , & wf % n_v , & - one , & X_a_B , & ( n_active_v ), & c_a_i , & wf % n_v , & one , & rho_a_i ( first_active_v , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( X_a_B , n_active_v , wf % n_v ) ! !        :: Term 3 :: !        - sum_BJck u_ai_kc * g_kc_BJ * c_BJ ( = - sum_BJck u_ik&#94;ac * g_kB,Jc * c_BJ ) ! !        construct g_kB_Jc ! call wf % mem % alloc ( g_kB_Jc , n_active_o * wf % n_v , n_active_v * wf % n_o ) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kB_Jc , & first_active_o , last_active_o , & 1 , wf % n_v , & 1 , wf % n_o , & first_active_v , last_active_v ) ! !        Reorder g_kB_Jc to g_kc_BJ ! call wf % mem % alloc ( g_kc_BJ , n_active_o * n_active_v , ( wf % n_o ) * ( wf % n_v )) g_kc_BJ = zero ! do c = 1 , n_active_v do k = 1 , n_active_o kc = index_two ( k , c , n_active_o ) do B = 1 , wf % n_v kB = index_two ( k , B , n_active_o ) do J = 1 , wf % n_o BJ = index_two ( B , J , wf % n_v ) Jc = index_two ( J , c , wf % n_o ) g_kc_BJ ( kc , BJ ) = g_kB_Jc ( kB , Jc ) enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kB_Jc , n_active_o * wf % n_v , n_active_v * wf % n_o ) ! !        Add term to rho_a_i ! !        sum_BJ g_kc_BJ*c_BJ = X_kc ! call wf % mem % alloc ( X_kc , n_active_o * n_active_v , 1 ) call dgemm ( 'N' , 'N' , & ( n_active_o ) * n_active_v , & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & g_kc_BJ , & ( n_active_o ) * n_active_v , & c_a_i , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_kc , & ( n_active_o ) * n_active_v ) ! call wf % mem % dealloc ( g_kc_BJ , n_active_o * n_active_v , ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % alloc ( rho_ai_active_space , n_active_v , n_active_o ) ! !        rho_a_i += 2 * sum_ck u_ai_kc * X_kc ! call dgemm ( 'N' , 'N' , & ( n_active_o ) * ( n_active_v ), & 1 , & n_active_o * n_active_v , & - one , & u_ai_kc , & ( n_active_o ) * ( n_active_v ), & X_kc , & ( n_active_o ) * n_active_v , & zero , & rho_ai_active_space , & ( n_active_o ) * ( n_active_v )) ! call wf % mem % dealloc ( X_kc , n_active_o * n_active_v , 1 ) ! do i = 1 , n_active_o do a = 1 , n_active_v rho_a_i ( a + first_active_v - 1 , i + first_active_o - 1 ) = rho_a_i ( a + first_active_v - 1 , i + first_active_o - 1 )& + rho_ai_active_space ( a , i ) enddo enddo ! call wf % mem % dealloc ( rho_ai_active_space , n_active_v , n_active_o ) ! !        :: Term 4 :: !        - sum_bJck c_A_J * g_J_bkc u_bkc_i*( =  - sum_bJck u_ki&#94;cb * g_Jb,kc * c_AJ) ! !        Reorder u_ai_kc(bi, kc) to u_bkc_i(bkc, i) ! call wf % mem % alloc ( u_bkc_i , n_active_o * n_active_v * n_active_v , n_active_o ) ! do i = 1 , n_active_o do b = 1 , n_active_v bi = index_two ( b , i , n_active_v ) do c = 1 , n_active_v do k = 1 , n_active_o kc = index_two ( k , c , n_active_o ) bkc = index_three ( b , k , c , n_active_v , n_active_o ) u_bkc_i ( bkc , i ) = u_ai_kc ( bi , kc ) enddo enddo enddo enddo ! call wf % mem % dealloc ( u_ai_kc , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * n_active_v ) ! !        Construct g_Jb_kc ! call wf % mem % alloc ( g_Jb_kc , n_active_v * wf % n_o , n_active_v * n_active_o ) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_Jb_kc , & 1 , wf % n_o , & first_active_v , last_active_v , & first_active_o , last_active_o , & first_active_v , last_active_v ) ! !        Add contribution to rho_a_i ! !        sum_bck g_Jb_kc*u_bkc_i = X_J_i ! call wf % mem % alloc ( X_J_i , wf % n_o , n_active_o ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & n_active_o , & ( n_active_v ** 2 ) * ( n_active_o ), & one , & g_Jb_kc , & wf % n_o , & u_bkc_i , & ( n_active_v ** 2 ) * ( n_active_o ), & zero , & X_J_i , & wf % n_o ) ! call wf % mem % dealloc ( g_Jb_kc , n_active_v * wf % n_o , n_active_v * n_active_o ) call wf % mem % dealloc ( u_bkc_i , n_active_o * n_active_v * n_active_v , n_active_o ) ! !        sum_J C_A_J * X_J_i ! call dgemm ( 'N' , 'N' , & wf % n_v , & n_active_o , & wf % n_o , & - one , & c_a_i , & wf % n_v , & X_J_i , & wf % n_o , & one , & rho_a_i ( 1 , first_active_o ), & wf % n_v ) ! call wf % mem % dealloc ( X_J_i , wf % n_o , n_active_o ) ! end subroutine jacobian_mlcc2_a1_mlcc2 ! ! module subroutine jacobian_mlcc2_b1_mlcc2 ( wf , rho_a_i , c_ai_bj ) !! !!    Jacobian tem B1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Calculates the B1 contribution to the jacobi transformation, !! !!       B1:   sum_ck F_kc*(2c_ai,ck - c_ak,ci) !!           - sum_ckj L_jIkc * c_aj,ck + sum_cbk L_Abkc * c_bi,ck !! !! !!    L_Abkc is constructed while batching over A. !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension (:,:) :: c_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , offset = 0 integer ( i15 ) :: A_n_batch = 0 , A_first = 0 , A_last = 0 , A_batch = 0 , A_length = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: c_ai_ck ! = c_ak,ci real ( dp ), dimension (:,:), allocatable :: c_bkc_i real ( dp ), dimension (:,:), allocatable :: rho_ai_active_space real ( dp ), dimension (:,:), allocatable :: fock_ck_active_space real ( dp ), dimension (:,:), allocatable :: L_jI_J real ( dp ), dimension (:,:), allocatable :: L_kc_J real ( dp ), dimension (:,:), allocatable :: L_Ab_J real ( dp ), dimension (:,:), allocatable :: g_jI_kc real ( dp ), dimension (:,:), allocatable :: g_Ab_kc real ( dp ), dimension (:,:), allocatable :: L_jck_I real ( dp ), dimension (:,:), allocatable :: L_Ab_kc ! integer ( i15 ) :: k = 0 , c = 0 , a = 0 , i = 0 , j = 0 , b = 0 integer ( i15 ) :: ak = 0 , ck = 0 , ai = 0 , ci = 0 , jI = 0 , kI = 0 , kc = 0 , jc = 0 , Ac = 0 , Ab = 0 , bi = 0 , kb = 0 integer ( i15 ) :: jck = 0 , bkc ! logical :: reorder ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! !     :: Term 1 :: !     sum_ck F_kc*(2c_ai,ck - c_ak,ci) ! !     Restrict Fock matrix ia-block to active space ordered as F_ck ! call wf % mem % alloc ( fock_ck_active_space , n_active_v , n_active_o ) ! do k = 1 , n_active_o do c = 1 , n_active_v ! fock_ck_active_space ( c , k ) = wf % fock_ia ( k + first_active_o - 1 , c + first_active_v - 1 ) ! enddo enddo ! call wf % mem % alloc ( c_ai_ck , n_active_o * n_active_v , n_active_o * n_active_v ) ! !     Construct 2c_ai,ck - c_ak,ci ! do i = 1 , n_active_o do a = 1 , n_active_v ! ai = index_two ( a , i , n_active_v ) ! do k = 1 , n_active_o ! ak = index_two ( a , k , n_active_v ) ! do c = 1 , n_active_v ! ck = index_two ( c , k , n_active_v ) ci = index_two ( c , i , n_active_v ) ! c_ai_ck ( ai , ck ) = two * c_ai_bj ( ai , ck ) - c_ai_bj ( ak , ci ) ! enddo enddo enddo enddo ! !     Adding term to rho ! call wf % mem % alloc ( rho_ai_active_space , n_active_v , n_active_o ) ! call dgemm ( 'N' , 'N' , & n_active_o * n_active_v , & 1 , & n_active_o * n_active_v , & one , & c_ai_ck , & n_active_o * n_active_v , & fock_ck_active_space , & n_active_o * n_active_v , & zero , & rho_ai_active_space , & n_active_o * n_active_v ) ! call wf % mem % dealloc ( c_ai_ck , n_active_o * n_active_v , n_active_o * n_active_v ) ! call wf % mem % dealloc ( fock_ck_active_space , n_active_o , n_active_v ) ! do a = 1 , n_active_v do i = 1 , n_active_o rho_a_i ( a + first_active_v - 1 , i + first_active_o - 1 ) = rho_a_i ( a + first_active_v - 1 , i + first_active_o - 1 ) & + rho_ai_active_space ( a , i ) enddo enddo ! call wf % mem % dealloc ( rho_ai_active_space , n_active_v , n_active_o ) ! !     :: Term 2 :: !     - sum_ckj L_jI,kc * c_aj,ck = - sum_ckj (2*g_jIkc - g_kIjc) * c_aj,ck (L_jI,kc ordered as L_jck_I) ! call wf % mem % alloc ( g_jI_kc , n_active_o * wf % n_o , n_active_v * n_active_o ) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_jI_kc , & first_active_o , last_active_o , & 1 , wf % n_o , & first_active_o , last_active_o , & first_active_v , last_active_v ) ! !     Construct L_jIkc ( = two*g_jI_kc - g_kI_jc ) ! call wf % mem % alloc ( L_jck_I , n_active_o * n_active_v * n_active_o , wf % n_o ) ! do j = 1 , n_active_o do i = 1 , wf % n_o do c = 1 , n_active_v do k = 1 , n_active_o kc = index_two ( k , c , n_active_o ) kI = index_two ( k , I , n_active_o ) jc = index_two ( j , c , n_active_o ) jI = index_two ( j , I , n_active_o ) jck = index_three ( j , c , k , n_active_o , n_active_v ) ! L_jck_I ( jck , I ) = two * g_jI_kc ( jI , kc ) - g_jI_kc ( kI , jc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_jI_kc , n_active_o * wf % n_o , n_active_v * n_active_o ) ! !     Add term to rho_a_i ! call dgemm ( 'N' , 'N' , & n_active_v , & wf % n_o , & n_active_v * n_active_o ** 2 , & - one , & c_ai_bj , & n_active_v , & L_jck_I , & n_active_v * n_active_o ** 2 , & one , & rho_a_i ( first_active_v , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( L_jck_I , n_active_o * n_active_v * n_active_o , wf % n_o ) ! !     :: Term 3 :: !     sum_cbk L_Abkc * c_bi,ck ! !     Prepare for batching over A ! required = max ( 2 * ( n_active_v ** 2 ) * ( wf % n_v ) * ( n_active_o ), & ( n_active_v ** 2 ) * ( wf % n_v ) * ( n_active_o ) + n_active_o * n_active_v * ( wf % n_J ) + ( wf % n_v ) * n_active_v * ( wf % n_J )) ! required = required * 4 ! Words available = get_available () max_length = 0 call num_batch ( required , available , max_length , A_n_batch , wf % n_v ) ! !     Initialize some variables for batching ! A_first = 0 A_last = 0 A_length = 0 ! !     Start looping over a-batches ! do A_batch = 1 , A_n_batch ! call batch_limits ( A_first , A_last , A_batch , max_length , wf % n_v ) ! A_length = A_last - A_first + 1 ! call wf % mem % alloc ( g_Ab_kc , n_active_v * A_length , n_active_o * n_active_v ) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , g_Ab_kc , & A_first , A_last , & first_active_v , last_active_v , & first_active_o , last_active_o , & first_active_v , last_active_v ) ! !        Construct L_Ab_kc = 2*g_Ab_kc - g_Ac_kb ! call wf % mem % alloc ( L_Ab_kc , n_active_v * A_length , n_active_o * n_active_v ) do A = 1 , A_length do b = 1 , n_active_v do c = 1 , n_active_v do k = 1 , n_active_o ! Ab = index_two ( A , b , A_length ) kc = index_two ( k , c , n_active_o ) kb = index_two ( k , b , n_active_o ) Ac = index_two ( A , c , A_length ) ! L_Ab_kc ( Ab , kc ) = two * g_Ab_kc ( Ab , kc ) - g_Ab_kc ( Ac , kb ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_Ab_kc , n_active_v * A_length , n_active_o * n_active_v ) ! !        Reorder c_bi_ck to c_bkc_i ! call wf % mem % alloc ( c_bkc_i , ( n_active_v ** 2 ) * n_active_o , n_active_o ) do i = 1 , n_active_o do b = 1 , n_active_v do c = 1 , n_active_v do k = 1 , n_active_o ! bi = index_two ( b , i , n_active_v ) ck = index_two ( c , k , n_active_v ) bkc = index_three ( b , k , c , n_active_v , n_active_o ) ! c_bkc_i ( bkc , i ) = c_ai_bj ( bi , ck ) ! enddo enddo enddo enddo ! !        Add contribution for current batch to rho ! call dgemm ( 'N' , 'N' , & A_length , & n_active_o , & ( n_active_v ** 2 ) * n_active_o , & one , & L_Ab_kc , & A_length , & c_bkc_i , & ( n_active_v ** 2 ) * n_active_o , & one , & rho_a_i ( A_first , first_active_o ), & wf % n_v ) ! call wf % mem % dealloc ( L_Ab_kc , n_active_v * A_length , n_active_o * n_active_v ) call wf % mem % dealloc ( c_bkc_i , ( n_active_v ** 2 ) * n_active_o , n_active_o ) ! enddo ! Batching over A ! ! end subroutine jacobian_mlcc2_b1_mlcc2 ! ! module subroutine jacobian_mlcc2_a2_mlcc2 ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian tem A2 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Calculates the A2 contribution to the jacobi transformation, !! !!       A2:   sum_C g_ai,bC * c_Cj - sum_K g_ai,Kj * C_bK. !! !!    g_ai,bC is constructed in batches of C. !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension (: , :) :: rho_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , batch_dimension = 0 , offset = 0 integer ( i15 ) :: c_n_batch = 0 , c_first = 0 , c_last = 0 , c_batch = 0 , c_length = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: g_ai_bC real ( dp ), dimension (:,:), allocatable :: g_ai_Kj real ( dp ), dimension (:,:), allocatable :: g_aij_K real ( dp ), dimension (:,:), allocatable :: rho_aij_b real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: L_bC_J real ( dp ), dimension (:,:), allocatable :: L_Kj_J real ( dp ), dimension (:,:), allocatable :: rho_aib_j ! !     Indices ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 , K = 0 integer ( i15 ) :: Kj = 0 , ai = 0 , aij = 0 , bj = 0 ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! !     :: Term 1 :: !     sum_C g_aib_C * c_C_j(= sum_C g_ai,bC * c_Cj) ! required = max ( 2 * n_active_v * ( wf % n_v ) * ( wf % n_J ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & n_active_v * ( wf % n_v ) * ( wf % n_J ) + ( n_active_v ** 2 ) * ( wf % n_v ) * n_active_o ) ! ! required = required * 4 ! Words available = get_available () max_length = 0 call num_batch ( required , available , max_length , C_n_batch , wf % n_v ) ! !     Initialize some variables for batching ! C_first = 0 C_last = 0 C_length = 0 ! !     Start looping over batches of c ! do C_batch = 1 , C_n_batch ! call batch_limits ( C_first , C_last , C_batch , max_length , wf % n_v ) ! !        Construct g_ai,bC ordered as g_ai_bC batching over C ! C_length = C_last - C_first + 1 ! call wf % mem % alloc ( g_ai_bC , n_active_v * n_active_o , n_active_v * C_length ) ! integral_type = 'electronic_repulsion' call wf % get_vo_vv ( integral_type , g_ai_bC , & first_active_v , last_active_v , & first_active_o , last_active_o , & first_active_v , last_active_v , & C_first , C_last ) ! !        Add contribution tho rho ! call dgemm ( 'N' , 'N' , & ( n_active_v ** 2 ) * n_active_o , & n_active_o , & C_length , & one , & g_ai_bC , & (( n_active_v ) ** 2 ) * n_active_o , & c_a_i ( c_first , first_active_o ), & wf % n_v , & one , & rho_ai_bj , & ( n_active_v ** 2 ) * n_active_o ) ! call wf % mem % dealloc ( g_ai_bC , n_active_v * n_active_o , n_active_v * C_length ) ! enddo ! batching over c ! !     :: Term 2 :: !     - sum_K g_aij_K * C_K_b(= - sum_K g_ai,Kj * C_bK) ! !     Construct g_ai,Kj ordered as g_aij_K ! call wf % mem % alloc ( g_ai_Kj , n_active_v * n_active_o , n_active_o * ( wf % n_o )) ! integral_type = 'electronic_repulsion' call wf % get_vo_oo ( integral_type , g_ai_Kj , & first_active_v , last_active_v , & first_active_o , last_active_o , & 1 , wf % n_o , & first_active_o , last_active_o ) ! !     Reorder g_ai_Kj to g_aij_K ! call wf % mem % alloc ( g_aij_K , n_active_v * n_active_o ** 2 , wf % n_o ) g_aij_K = zero do a = 1 , n_active_v do j = 1 , n_active_o do i = 1 , n_active_o aij = index_three ( a , i , j , n_active_v , n_active_o ) ai = index_two ( a , i , n_active_v ) do K = 1 , wf % n_o Kj = index_two ( K , j , wf % n_o ) g_aij_K ( aij , K ) = g_ai_Kj ( ai , Kj ) enddo enddo enddo enddo call wf % mem % dealloc ( g_ai_Kj , n_active_v * n_active_o , n_active_o * ( wf % n_o )) ! call wf % mem % alloc ( rho_aij_b , n_active_v * n_active_o ** 2 , n_active_v ) ! !      Add term to rho_ai_bj ! call dgemm ( 'N' , 'T' , & n_active_v * n_active_o ** 2 , & n_active_v , & wf % n_o , & - one , & g_aij_K , & n_active_v * n_active_o ** 2 , & c_a_i ( first_active_v , 1 ), & wf % n_v , & zero , & rho_aij_b , & n_active_v * n_active_o ** 2 ) ! call wf % mem % dealloc ( g_aij_K , n_active_v * n_active_o ** 2 , wf % n_o ) ! ! !     Reorder into rho_ai_bj ! do a = 1 , n_active_v do b = 1 , n_active_v do i = 1 , n_active_o do j = 1 , n_active_o ai = index_two ( a , i , n_active_v ) bj = index_two ( b , j , n_active_v ) aij = index_three ( a , i , j , n_active_v , n_active_o ) rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aij_b ( aij , b ) enddo enddo enddo enddo call wf % mem % dealloc ( rho_aij_b , n_active_v * n_active_o ** 2 , n_active_v ) ! end subroutine jacobian_mlcc2_a2_mlcc2 ! ! module subroutine jacobian_mlcc2_b2_mlcc2 ( wf , rho_ai_bj , c_ai_bj ) !! !!    Jacobian tem B2 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Calculates the B2 contribution to the jacobi transformation, !! !!       B2:   ε_ij&#94;ab*c_ai,bj. !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension (:,:) :: c_ai_bj real ( dp ), dimension (:,:) :: rho_ai_bj ! !     Local routine variables ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 integer ( i15 ) :: ai = 0 , bj = 0 ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! do i = 1 , n_active_o ! do a = 1 , n_active_v ! ai = index_two ( a , i , n_active_v ) ! do j = 1 , n_active_o ! do b = 1 , n_active_v ! bj = index_two ( b , j , n_active_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + c_ai_bj ( ai , bj ) * ( wf % fock_diagonal ( wf % n_o + a + first_active_v - 1 , 1 ) & - wf % fock_diagonal ( i + first_active_o - 1 , 1 ) & + wf % fock_diagonal ( wf % n_o + b + first_active_v - 1 , 1 ) & - wf % fock_diagonal ( j + first_active_o - 1 , 1 )) ! enddo enddo enddo enddo ! end subroutine jacobian_mlcc2_b2_mlcc2 ! ! module subroutine cvs_rho_aibj_projection_mlcc2 ( wf , vec_aibj ) !! !!    Rho projection for CVS (MLCC2), !!    Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( mlcc2 ) :: wf real ( dp ), dimension (:, :) :: vec_aibj ! integer ( i15 ) :: i = 0 , a = 0 , j = 0 , b = 0 , core = 0 , ai = 0 , bj = 0 , aibj = 0 ! logical :: core_orbital ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! do i = 1 , n_active_o do j = 1 , n_active_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if (( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) . or . & ( j . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 ))) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , n_active_v do b = 1 , n_active_v ai = index_two ( a , i , n_active_v ) bj = index_two ( b , j , n_active_v ) aibj = index_packed ( ai , bj ) vec_aibj ( ai , bj ) = zero enddo enddo endif enddo enddo ! end subroutine cvs_rho_aibj_projection_mlcc2 ! end submodule jacobian","tags":"","loc":"sourcefile/jacobian_submodule.f90.html","title":"jacobian_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~omega_submodule.f90~~EfferentGraph sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileomega_submodulef90EfferentGraph = svgPanZoom('#sourcefileomega_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules omega Source Code omega_submodule.F90 Source Code submodule ( mlcc2_class ) omega ! !! !!    Omega submodule (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Apr 2017 !! !!    Contains the following family of procedures of the MLCC2 class: !! !! !!    construct_omega: constructs the projection vector omega1 !!                     for the current amplitudes t1am for the !!                     wavefunction object wf. !!                     The routine assumes that the projection !!                     vector is allocated. !! !!    omega_a1:  adds A1 term to omega1 !!    omega_b1:  adds B1 term to omega1 !! !! !!    Upper case indices are general indices, lower case indices are restricted !!    to the CC2 orbital space. !! !! ! implicit none ! logical :: debug = . false . logical :: timings = . false . ! character ( len = 40 ) :: integral_type ! ! contains module subroutine construct_omega_mlcc2 ( wf ) !! !!    Construct Omega (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai Folkestad, Apr 2017 !! !!    Constructs the MlCC2 omega. !! !!    s2-amplitudes are constructed on the fly, according to the CC2 !!    expression for the doubles amplitudes. !! !!    Calculated by looping over active spaces, !!    Adding the omega contribution from each active space in turn. !! implicit none ! class ( mlcc2 ) :: wf ! !     Timing variables ! real ( dp ) :: omega_start = zero real ( dp ) :: omega_end = zero ! !     Start timing of omega ! call cpu_time ( omega_start ) ! !     Set the omega vector to zero ! wf % omega1 = zero ! !     :: Calculate CCS omega contributions :: ! call wf % omega_ccs_a1 ! !     :: Calculate CC2 omega contributions :: ! call wf % omega_mlcc2_a1 ! call wf % omega_mlcc2_b1 ! !     Timings ! call cpu_time ( omega_end ) if ( timings ) write ( unit_output , * ) 'Time in omega:' , omega_end - omega_start ! end subroutine construct_omega_mlcc2 ! module subroutine omega_mlcc2_a1_mlcc2 ( wf ) !! !!     Omega A1 !!     Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!     Calculates the A1 term of omega for the active space, !! !!     A1: sum_bcj g_Abjc * u_ij&#94;bc, !! !!     and adds it to the projection vector (omega1) of !!     the wavefunction object wf !! !!     u_ij&#94;bc = 2*s_ij&#94;bc - s_ij&#94;cb !! !!    Batching over A and c !! !! implicit none ! class ( mlcc2 ) :: wf ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , batch_dimension = 0 , offset = 0 integer ( i15 ) :: A_n_batch = 0 , A_first = 0 , A_last = 0 , A_batch = 0 , A_length = 0 integer ( i15 ) :: c_n_batch = 0 , c_first = 0 , c_last = 0 , c_batch = 0 , c_length = 0 ! !     Indices ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , c = 0 , b = 0 ! integer ( i15 ) :: ba = 0 , ab = 0 , bi = 0 integer ( i15 ) :: ci = 0 , bi = 0 , cj = 0 , bj = 0 integer ( i15 ) :: bjc = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: g_ib_jc real ( dp ), dimension (:,:), allocatable :: s_bi_cj real ( dp ), dimension (:,:), allocatable :: u_bjc_i real ( dp ), dimension (:,:), allocatable :: g_Ab_jc real ( dp ), dimension (:,:), allocatable :: L_Ab_J ! L_Ab&#94;J; A is batched over ! logical :: reorder ! To get L_ab_J reordered, for batching over a ! !     Active space variables ! integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index integer ( i15 ) :: n_active_o ! number of active occupied integer ( i15 ) :: n_active_v ! number of active virual ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_active_v , first_active_o ) ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! !     Prepare for batching ocer c and A ! required = n_active_v * ( wf % n_v ) * ( wf % n_J ) & + n_active_v * ( n_active_o ) * ( wf % n_J ) & + ( n_active_v ** 2 ) * ( wf % n_o ) * n_active_o & + (( n_active_o ) ** 2 ) * (( n_active_v ) ** 2 ) ! ! required = required * 4 ! Words available = get_available () max_length = 0 call num_two_batch ( required , available , max_length , c_n_batch , wf % n_v ) ! !     Initialize some variables for batching ! c_first = 0 c_last = 0 c_length = 0 ! !     Start looping over batches of c ! do c_batch = 1 , c_n_batch ! call batch_limits ( c_first , c_last , c_batch , max_length , n_active_v ) ! !        c is active index, and thus c_first and c_last must be displaced ! c_first = c_first + ( first_active_v - 1 ) c_last = c_last + ( first_active_v - 1 ) ! if ( c_last . gt . last_active_v ) c_last = last_active_v ! !        Length of batch ! c_length = c_last - c_first + 1 ! !      :: Construct u_ib_jc :: ! !        u_ij&#94;bc = 2*s_ij&#94;bc - s_ij&#94;cb =  (2*g_ij&#94;bc - g_ij&#94;cb)/ε_ij&#94;cb ! call wf % mem % alloc ( s_bi_cj , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * c_length ) call wf % get_s2am ( s_bi_cj , c_first , c_length ) ! call wf % mem % alloc ( u_bjc_i , n_active_v * n_active_o * c_length , n_active_o ) ! do b = 1 , n_active_v do i = 1 , n_active_o ! bi = index_two ( b , i , n_active_v ) ! do c = 1 , c_length do j = 1 , n_active_o ! cj = index_two ( c , j , c_length ) bj = index_two ( b , j , n_active_v ) ci = index_two ( c , i , c_length ) ! bjc = index_three ( b , j , c , n_active_v , n_active_o ) ! u_bjc_i ( bjc , i ) = ( two * s_bi_cj ( bi , cj ) - s_bi_cj ( bj , ci )) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( s_bi_cj , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * c_length ) ! !        Prepare for batching over A ! A_first = 0 A_last = 0 A_length = 0 A_n_batch = c_n_batch ! !        Start looping over a-batches ! do A_batch = 1 , A_n_batch ! call batch_limits ( A_first , A_last , A_batch , max_length , wf % n_v ) A_length = A_last - A_first + 1 ! !           :: Construct integral g_Ab,jc :: ! call wf % mem % alloc ( g_Ab_jc , n_active_v * a_length , n_active_o * c_length ) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , g_Ab_jc , & A_first , A_last , & first_active_v , last_active_v , & first_active_o , last_active_o , & first_active_v , last_active_v ) ! !           :: Add contributions to omega :: ! call dgemm ( 'N' , 'N' , & A_length , & n_active_o , & ( n_active_v ) * ( n_active_o ) * c_length , & one , & g_Ab_jc , & A_length , & u_bjc_i , & ( n_active_v ) * ( n_active_o ) * c_length , & one , & wf % omega1 ( A_first , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( g_Ab_jc , n_active_v * a_length , n_active_o * c_length ) ! enddo ! Batching over a ! call wf % mem % dealloc ( u_bjc_i , n_active_v * n_active_o * c_length , n_active_o ) ! if ( c_last . eq . last_active_v ) exit ! exit loop over c; This is necessary because n_active_v may be less than n_v ! enddo ! Batching over c ! end subroutine omega_mlcc2_a1_mlcc2 ! ! module subroutine omega_mlcc2_b1_mlcc2 ( wf ) !! !!    Omega B1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Calculates the B1 term of omega, !! !!    B1: - sum_bjk u_jk&#94;ab*g_kbjI + sum_bj u_ij&#94;ab F_jb, !! !!    with u_ij&#94;ab = 2*s_ij&#94;ab - s_ij&#94;ba. !! !!    Batching over b. !! implicit none ! class ( mlcc2 ) :: wf ! !     Batching ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , batch_dimension = 0 , offset = 0 integer ( i15 ) :: b_n_batch = 0 , b_first = 0 , b_last = 0 , b_batch = 0 , b_length = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: s_aj_bk real ( dp ), dimension (:,:), allocatable :: u_a_kbj real ( dp ), dimension (:,:), allocatable :: g_kb_ji ! !     looping indices ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 , a = 0 , b = 0 integer ( i15 ) :: I_full = 0 , J_full = 0 , A_full = 0 , B_full = 0 integer ( i15 ) :: aj = 0 , bk = 0 , ak = 0 , bj = 0 integer ( i15 ) :: kbj = 0 , jbi = 0 ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! !     Prepare for batching ! required = (( n_active_o ) ** 3 ) * ( n_active_v ) + (( n_active_o ) ** 2 ) * ( wf % n_J ) & + ( n_active_o ) * ( n_active_v ) * ( wf % n_J ) + (( n_active_o ) ** 2 ) * (( n_active_v ) ** 2 ) ! ! required = required * 4 ! Words available = get_available () max_length = 0 call num_batch ( required , available , max_length , b_n_batch , n_active_v ) ! !     Initialize some variables for batching ! b_first = 0 b_last = 0 b_length = 0 ! !     Start looping over a-batches ! do b_batch = 1 , b_n_batch ! call batch_limits ( b_first , b_last , b_batch , max_length , n_active_v ) ! !        b is active index, and thus b_first and b_last must be displaced ! b_first = b_first + ( first_active_v - 1 ) b_last = b_last + ( first_active_v - 1 ) ! b_length = b_last - b_first + 1 ! !        :: Construct u_jk&#94;ab :: ! !        u_jk&#94;ab = 2*s_jk&#94;ab - s_jk&#94;ba  (place in u_a_jkb) ! call wf % mem % alloc ( s_aj_bk , ( n_active_o ) * n_active_v , ( n_active_o ) * b_length ) call wf % get_s2am ( s_aj_bk , b_first , b_length ) ! call wf % mem % alloc ( u_a_kbj , n_active_v , ( n_active_o ** 2 ) * b_length ) do k = 1 , n_active_o do b = 1 , b_length ! bk = index_two ( b , k , b_length ) ! do j = 1 , n_active_o ! bj = index_two ( b , j , b_length ) kbj = index_three ( k , b , j , n_active_o , b_length ) ! do a = 1 , n_active_v ! aj = index_two ( a , j , n_active_v ) ak = index_two ( a , k , n_active_v ) ! u_a_kbj ( a , kbj ) = ( two * s_aj_bk ( aj , bk ) - s_aj_bk ( ak , bj )) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( s_aj_bk , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * ( b_length )) ! !        :: - sum_bjk u_ja_kb * g_kb_jI :: ! call wf % mem % alloc ( g_kb_jI , n_active_o * b_length , n_active_o * ( wf % n_o ) ) ! integral_type = 'electronic_repulsion' call wf % get_ov_oo ( integral_type , g_kb_jI , & first_active_o , last_active_o , & b_first , b_last , & first_active_o , last_active_o , & 1 , wf % n_o ) ! !        Add contributions to omega ! call dgemm ( 'N' , 'N' , & n_active_v , & ( wf % n_o ), & b_length * (( n_active_o ) ** 2 ), & - one , & u_a_kbj , & n_active_v , & g_kb_jI , & b_length * (( n_active_o ) ** 2 ), & one , & wf % omega1 ( first_active_v , 1 ), & ( wf % n_v )) ! call wf % mem % dealloc ( g_kb_jI , n_active_o * b_length , n_active_o * ( wf % n_o )) ! !        :: sum_jb F_jb u_ij&#94;ab :: ! do i = 1 , n_active_o ! I_full = i + first_active_o - 1 ! do a = 1 , n_active_v ! A_full = a + first_active_v - 1 ! do j = 1 , n_active_o ! J_full = j + first_active_o - 1 ! do b = 1 , b_length ! B_full = b + b_first - 1 ! jbi = index_three ( j , b , i , n_active_o , b_length ) wf % omega1 ( A_full , I_full ) = wf % omega1 ( A_full , I_full ) + u_a_kbj ( a , jbi ) * wf % fock_ia ( J_full , B_full ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( u_a_kbj , n_active_v , ( n_active_o ** 2 ) * b_length ) ! enddo ! end subroutine omega_mlcc2_b1_mlcc2 ! module subroutine get_s2am_mlcc2 ( wf , s_ai_bj , b_first , b_length ) !! !!    Get S_2 amplitudes, !!    Written by Sarai D. Folkestad, July 2017 !! !!    Construct !! !!       s_ai_bj = - 1/ε_ij&#94;ab * g_aibj, !! !!    while batching over b. !! implicit none ! class ( mlcc2 ) :: wf ! integer ( i15 ) :: b_first , b_length real ( dp ), dimension (( wf % n_CC2_v ) * ( wf % n_CC2_o ), b_length * ( wf % n_CC2_o )) :: s_ai_bj ! real ( dp ), dimension (:,:), allocatable :: g_ai_bj ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! integer ( i15 ) :: offset ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 , ia = 0 , jb = 0 , ai = 0 , bj = 0 ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! call wf % mem % alloc ( g_ai_bj , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * b_length ) ! integral_type = 'electronic_repulsion' call wf % get_vo_vo ( integral_type , g_ai_bj , & first_active_v , last_active_v , & first_active_o , last_active_o , & b_first , b_first + b_length - 1 , & first_active_o , last_active_o ) ! ! do a = 1 , n_active_v do i = 1 , n_active_o ! ai = index_two ( a , i , n_active_v ) ! do b = 1 , b_length do j = 1 , n_active_o ! bj = index_two ( b , j , b_length ) ! s_ai_bj ( ai , bj ) = g_ai_bj ( ai , bj ) / ( wf % fock_diagonal ( i + first_active_o - 1 , 1 )& + wf % fock_diagonal ( j + first_active_o - 1 , 1 ) & - wf % fock_diagonal ( wf % n_o + b + b_first - 1 , 1 ) & - wf % fock_diagonal ( wf % n_o + a + first_active_v - 1 , 1 )) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ai_bj , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * b_length ) ! end subroutine get_s2am_mlcc2 ! end submodule","tags":"","loc":"sourcefile/omega_submodule.f90.html","title":"omega_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~excited_state_submodule.f90~~EfferentGraph sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileexcited_state_submodulef90EfferentGraph = svgPanZoom('#sourcefileexcited_state_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules excited_state Source Code excited_state_submodule.F90 Source Code submodule ( mlcc2_class ) excited_state ! !! !!    Excited state submodule (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Contains the following family of procedures of the MLCC2 class: !! !!    inititialize_excited_states: Initializes number of s2 amplitudes (n_x2am), and adds it n_parameters !!    calculate_orbital_differences: Calculates the orbital differences, including the double excitation differences !!                                   in the active CC2 spaces !!    transform_trial_vectors: Transforms the new trial vectors. rho = Ac !! !!    Upper case indices are general indices, lower case indices are restricted !!    to the CC2 orbital space. !! ! implicit none ! logical :: debug = . false . logical :: timings = . false . ! ! contains ! ! module subroutine excited_state_preparations_mlcc2 ( wf ) !! !!    Excited State Preparations (MLCC2) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    A routine for preparation tasks (if any). Can be overwritten !!    in descendants if other preparations prove necessary. !! class ( mlcc2 ) :: wf ! !     Set current task to excited state calculation ! wf % tasks % current = 'excited_state' ! !     Set filename for solution vectors ! if ( wf % tasks % core_excited_state . or . wf % tasks % core_ionized_state ) then ! Core excitation ! if ( wf % excited_state_specifications % right ) then ! Right vectors wf % excited_state_specifications % solution_file = 'right_core' else ! Left vectors write ( unit_output , * ) 'Error: Jacobian transpose transformation not implemented for core excitations' ! S: should be able to get these with the same projections however so... stop endif ! else ! Valence excitation ! if ( wf % excited_state_specifications % left ) then ! Right vectors wf % excited_state_specifications % solution_file = 'left_valence' else ! Left vectors wf % excited_state_specifications % solution_file = 'right_valence' endif ! endif ! end subroutine excited_state_preparations_mlcc2 ! ! module subroutine initialize_excited_states_mlcc2 ( wf ) !! !!    Initialize excited states !!    Written by Sarai D. Folkestad, June 2017 !! !!    Calculates and sets n_s2am, and updates n_parameters !!    for excited state calculation !! implicit none ! class ( mlcc2 ) :: wf ! wf % n_x2am = (( wf % n_CC2_v ) * ( wf % n_CC2_o ))& * (( wf % n_CC2_v ) * ( wf % n_CC2_o ) + 1 ) / 2 ! wf % n_parameters = wf % n_parameters + wf % n_x2am ! end subroutine initialize_excited_states_mlcc2 ! ! module subroutine calculate_orbital_differences_mlcc2 ( wf , orbital_diff ) !! !!    Calculate Orbital Differences (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad May 2017 !! !!    Calculates orbital differences !! !!       1) ε_I&#94;A = ε_A - ε_I !!       2) ε_ij&#94;ab = ε_a + ε_b - ε_i - ε_j (for active spaces only) !! !!    and puts them in orbital_diff, which is a vector of length n_parameters. !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: orbital_diff ! !     Active space variables ! integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! last active occupied index integer ( i15 ) :: last_active_v ! last active virtual index integer ( i15 ) :: n_active_o integer ( i15 ) :: n_active_v ! integer ( i15 ) :: offset = 0 ! integer ( i15 ) :: A = 0 , I = 0 , b = 0 , j = 0 integer ( i15 ) :: AI = 0 , bj = 0 integer ( i15 ) :: aibj = 0 ! do I = 1 , wf % n_o do A = 1 , wf % n_v ! AI = index_two ( A , I , wf % n_v ) ! orbital_diff ( AI , 1 ) = wf % fock_diagonal ( A + wf % n_o , 1 ) - wf % fock_diagonal ( I , 1 ) ! enddo enddo ! !     Calculate active space indices ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! do i = 1 , n_active_o ! do a = 1 , n_active_v ! ai = index_two ( a , i , n_active_v ) ! do j = 1 , n_active_o ! do b = 1 , n_active_v ! bj = index_two ( b , j , n_active_v ) ! aibj = index_packed ( ai , bj ) ! orbital_diff (( wf % n_o ) * ( wf % n_v ) + aibj , 1 ) & = wf % fock_diagonal ( wf % n_o + a + first_active_v - 1 , 1 ) & - wf % fock_diagonal ( i + first_active_o - 1 , 1 ) & + wf % fock_diagonal ( wf % n_o + b + first_active_v - 1 , 1 ) & - wf % fock_diagonal ( j + first_active_o - 1 , 1 ) ! enddo enddo enddo enddo ! end subroutine calculate_orbital_differences_mlcc2 ! ! module subroutine transform_trial_vectors_mlcc2 ( wf , first_trial , last_trial ) !! !!    Transformation of Trial Vectors (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Each trial vector in first_trial to last_trial is read from file and !!    transformed before the transformed vector is written to file. !! !!    Singles and doubles part of the transformed vectors are written to !!    the same record in file transformed_vec, record length is n_parameters long. !! implicit none ! class ( mlcc2 ) :: wf ! integer ( i15 ), intent ( in ) :: first_trial , last_trial ! Which trial_vectors we are to transform ! real ( dp ), dimension (:,:), allocatable :: c_a_i real ( dp ), dimension (:,:), allocatable :: c_aibj ! integer ( i15 ) :: unit_trial_vecs = 0 , unit_rho = 0 , ioerror = 0 integer ( i15 ) :: trial = 0 ! ! !     Allocate c_a_i and c_aibj ! call wf % mem % alloc ( c_a_i , wf % n_v , wf % n_o ) c_a_i = zero ! call wf % mem % alloc ( c_aibj , wf % n_x2am , 1 ) c_aibj = zero ! !     Open trial vector- and transformed vector files ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * wf % n_parameters , iostat = ioerror ) ! call generate_unit_identifier ( unit_rho ) open ( unit = unit_rho , file = 'transformed_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * wf % n_parameters , iostat = ioerror ) ! !     For each trial vector: read, transform and write ! do trial = first_trial , last_trial ! read ( unit_trial_vecs , rec = trial , iostat = ioerror ) c_a_i , c_aibj if ( wf % excited_state_specifications % right ) then ! call wf % jacobian_mlcc2_transformation ( c_a_i , c_aibj ) ! elseif ( wf % excited_state_specifications % left ) then ! write ( unit_output , * ) 'Error: Jacobian transpose not implemented for mlcc2' stop ! else ! write ( unit_output , * ) 'Error: Excited state task not recognized' stop ! endif ! !        -::- Projections -::- ! !        Test for core calculation ! if ( wf % tasks % core_excited_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from valence contributions ! call wf % cvs_rho_a_i_projection ( c_a_i ) call wf % cvs_rho_aibj_projection ( c_aibj ) ! endif ! !        Test for ionization calculation ! if ( wf % tasks % ionized_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from regular excitations ! write ( unit_output , * ) 'Error: Ionized state not implemented for mlcc2' stop ! endif ! write ( unit_rho , rec = trial , iostat = ioerror ) c_a_i , c_aibj ! enddo ! !     Close files ! close ( unit_trial_vecs ) close ( unit_rho ) ! !     Deallocate c_a_i and c_aibj ! call wf % mem % dealloc ( c_a_i , wf % n_v , wf % n_o ) call wf % mem % dealloc ( c_aibj , wf % n_x2am , 1 ) ! end subroutine transform_trial_vectors_mlcc2 ! ! module subroutine cvs_residual_projection_mlcc2 ( wf , residual ) !! !!    Residual projection (MLCC2), !!    Written by Sarai D. Folkestad Aug. 2017 !! implicit none ! class ( mlcc2 ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! integer ( i15 ) :: i = 0 , a = 0 , j = 0 , b = 0 , core = 0 , ai = 0 , bj = 0 , aibj = 0 ! logical :: core_orbital ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 do i = 1 , wf % n_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if ( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) residual ( ai , 1 ) = zero enddo endif ! enddo ! do i = 1 , n_active_o do j = 1 , n_active_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if (( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) . or . & ( j . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 ))) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , n_active_v do b = 1 , n_active_v ai = index_two ( a , i , n_active_v ) bj = index_two ( b , j , n_active_v ) aibj = index_packed ( ai , bj ) residual ( wf % n_t1am + aibj , 1 ) = zero enddo enddo endif enddo enddo ! end subroutine cvs_residual_projection_mlcc2 ! ! module subroutine print_excitation_vector_mlcc2 ( wf , vec , unit_id ) !! !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: vec ! integer ( i15 ) :: unit_id ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 integer ( i15 ) :: n_active_o , n_active_v real ( dp ) :: a_active_i_active , a_active_i_inactive , a_inactive_i_active , a_inactive_i_inactive , total ! !        Print singles part ! write ( unit_id , '(2a6,a12)' ) 'a' , 'i' , 'coeff' write ( unit_id , '(t3,a)' ) '-------------------------' ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) if ( abs ( vec ( ai , 1 )) . gt . 1.0D-03 ) then write ( unit_id , '(2i6,f12.4)' ) a , i , vec ( ai , 1 ) endif ! enddo enddo flush ( unit_id ) ! !     Print doubles part ! write ( unit_id , '(/4a6, a11)' ) 'a' , 'i' , 'b' , 'j' , 'coeff' write ( unit_id , '(t3,a)' ) '---------------------------------' ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! do a = 1 , n_active_v do i = 1 , n_active_o do b = 1 , n_active_v do j = 1 , n_active_o ! ai = index_two ( a , i , n_active_v ) bj = index_two ( b , j , n_active_v ) aibj = index_packed ( ai , bj ) ! if ( abs ( vec (( wf % n_o ) * ( wf % n_v ) + aibj , 1 )) . gt . 1.0D-03 . and . ai . ge . bj ) then write ( unit_id , '(4i6,f12.4)' ) a , i , b , j , vec (( wf % n_o ) * ( wf % n_v ) + aibj , 1 ) endif ! enddo enddo enddo enddo ! ! ! a_active_i_active = 0 a_inactive_i_active = 0 a_active_i_inactive = 0 a_inactive_i_inactive = 0 ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) ! if ( a . le . n_active_v . and . i . le . n_active_o ) then ! a_active_i_active = a_active_i_active + ( vec ( ai , 1 )) ** 2 ! elseif ( a . le . n_active_v . and . i . gt . n_active_o ) then ! a_active_i_inactive = a_active_i_inactive + ( vec ( ai , 1 )) ** 2 ! elseif ( a . gt . n_active_v . and . i . le . n_active_o ) then ! a_inactive_i_active = a_inactive_i_active + ( vec ( ai , 1 )) ** 2 ! elseif ( a . gt . n_active_v . and . i . gt . n_active_o ) then ! a_inactive_i_inactive = a_inactive_i_inactive + ( vec ( ai , 1 )) ** 2 ! endif enddo enddo ! !     Print active space stats: ! total = ( a_active_i_active + a_active_i_inactive + a_inactive_i_active + a_inactive_i_inactive ) write ( unit_id , '(/a10, 3a12)' ) 'T->T:' , 'S->T:' , 'T->S:' , 'S->S:' write ( unit_id , '(a50)' ) '--------------------------------------------------' write ( unit_id , '(4f12.5)' ) a_active_i_active / total ,& a_active_i_inactive / total , & a_inactive_i_active / total ,& a_inactive_i_inactive / total write ( unit_id , '(/t3,a40,f12.5/)' ) 'Singles contribution to excitation is' , total end subroutine print_excitation_vector_mlcc2 ! module subroutine analyze_double_excitation_vector_mlcc2 ( wf , vec , n , sorted_short_vec , index_list ) !! !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension ( wf % n_x2am , 1 ) :: vec ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 , k = 0 ! integer ( i15 ) :: n ! Number of elements wanted ! real ( dp ), dimension ( n , 1 ) :: sorted_short_vec ! integer ( i15 ), dimension ( n , 4 ) :: index_list ! !     Variables for sorting ! real ( dp ) :: min integer ( i15 ) :: min_pos ! real ( dp ) :: swap = zero integer ( i15 ) :: swap_i = 0 , swap_a = 0 , swap_j = 0 , swap_b = 0 ! integer ( i15 ) :: n_active_o , n_active_v ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! !     Placing the n first elements of vec into sorted_short_vec ! index_list = 0 sorted_short_vec ( 1 , 1 ) = vec ( 1 , 1 ) index_list ( 1 , 1 ) = 1 index_list ( 1 , 2 ) = 1 index_list ( 1 , 3 ) = 1 index_list ( 1 , 4 ) = 1 ! min = abs ( sorted_short_vec ( 1 , 1 )) min_pos = 1 ! do i = 1 , n_active_o do a = 1 , n_active_v do j = 1 , n_active_o do b = 1 , n_active_v ! ai = index_two ( a , i , n_active_v ) bj = index_two ( b , j , n_active_v ) ! if ( ai . ge . bj ) then ! aibj = index_packed ( ai , bj ) ! if ( aibj . le . n ) then sorted_short_vec ( aibj , 1 ) = vec ( aibj , 1 ) index_list ( min_pos , 1 ) = a index_list ( min_pos , 2 ) = i index_list ( min_pos , 3 ) = b index_list ( min_pos , 4 ) = j ! if ( abs ( sorted_short_vec ( i , 1 )) . le . min ) then ! min = abs ( sorted_short_vec ( i , 1 )) min_pos = i ! endif else ! if ( abs ( vec ( aibj , 1 )) . ge . min ) then ! sorted_short_vec ( min_pos , 1 ) = vec ( aibj , 1 ) index_list ( min_pos , 1 ) = a index_list ( min_pos , 2 ) = i index_list ( min_pos , 3 ) = b index_list ( min_pos , 4 ) = j min = abs ( vec ( aibj , 1 )) ! endif endif ! do k = 1 , n if ( abs ( sorted_short_vec ( k , 1 )) . lt . min ) then ! min = abs ( sorted_short_vec ( k , 1 )) min_pos = k ! endif enddo endif ! enddo enddo enddo enddo ! !      Sorting sorted_short_vec ! do i = 1 , n do j = 1 , n - 1 if ( abs ( sorted_short_vec ( j , 1 )) . lt . abs ( sorted_short_vec ( j + 1 , 1 ))) then ! swap = sorted_short_vec ( j , 1 ) sorted_short_vec ( j , 1 ) = sorted_short_vec ( j + 1 , 1 ) sorted_short_vec ( j + 1 , 1 ) = swap ! swap_a = index_list ( j , 1 ) swap_i = index_list ( j , 2 ) swap_b = index_list ( j , 3 ) swap_j = index_list ( j , 4 ) ! index_list ( j , 1 ) = index_list ( j + 1 , 1 ) index_list ( j , 2 ) = index_list ( j + 1 , 2 ) index_list ( j , 3 ) = index_list ( j + 1 , 3 ) index_list ( j , 4 ) = index_list ( j + 1 , 4 ) index_list ( j + 1 , 1 ) = swap_a index_list ( j + 1 , 2 ) = swap_i index_list ( j + 1 , 3 ) = swap_b index_list ( j + 1 , 4 ) = swap_j ! endif enddo enddo ! ! end subroutine analyze_double_excitation_vector_mlcc2 ! ! module subroutine summary_excited_state_info_mlcc2 ( wf , energies ) !! !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! integer ( i15 ) :: unit_solution = - 1 , ioerror = 0 integer ( i15 ) :: state = 0 , i = 0 , a = 0 , ai = 0 ! real ( dp ), dimension (:,:), allocatable :: solution_ai , solution_aibj real ( dp ), dimension (:,:), allocatable :: sorted_max_vec_singles , sorted_max_vec_doubles ! integer ( i15 ), dimension (:,:), allocatable :: index_list_singles , index_list_doubles ! real ( dp ) :: norm , ddot real ( dp ) :: a_active_i_active , a_active_i_inactive , a_inactive_i_active , a_inactive_i_inactive , total ! integer ( i15 ) :: n_active_o , n_active_v ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! !     Open solution vector file ! call generate_unit_identifier ( unit_solution ) ! open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file ,& action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening solution file' ! !     Allocations ! call wf % mem % alloc ( solution_ai , wf % n_t1am , 1 ) call wf % mem % alloc ( solution_aibj , wf % n_x2am , 1 ) ! call wf % mem % alloc ( sorted_max_vec_singles , 20 , 1 ) call wf % mem % alloc ( sorted_max_vec_doubles , 20 , 1 ) ! call wf % mem % alloc_int ( index_list_singles , 20 , 2 ) call wf % mem % alloc_int ( index_list_doubles , 20 , 4 ) ! do state = 1 , wf % excited_state_specifications % n_singlet_states ! write ( unit_output , '(/t3,a30,i3,a1/)' ) 'Analysis of excitation vector ' , state , ':' write ( unit_output , '(t6, a, f14.8)' ) 'Excitation energy [a.u.]:   ' , energies ( state , 1 ) write ( unit_output , '(t6, a, f14.8)' ) 'Excited state energy [a.u.]:' , wf % energy + energies ( state , 1 ) ! !        Read the solution ! solution_ai = zero solution_aibj = zero read ( unit_solution , rec = state ) solution_ai , solution_aibj ! !        Calculate the contribution from single excitations ! norm = sqrt ( ddot ( wf % n_t1am , solution_ai , 1 , solution_ai , 1 )) write ( unit_output , '(/t6,a,f6.4)' ) 'Single excitation contribution to excitation vector: ' , norm ! !        Analysis of excitation vectors ! write ( unit_output , '(/t6,a)' ) 'Largest contributions to excitation vector:' ! write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' write ( unit_output , '(t6,a3, 8x, a3, 8x, a10)' ) 'a' , 'i' , 'amplitude' write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' ! !        Get 20 highest amplitudes ! call wf % analyze_single_excitation_vector ( solution_ai , 20 , sorted_max_vec_singles , index_list_singles ) call wf % analyze_double_excitation_vector ( solution_aibj , 20 , sorted_max_vec_doubles , index_list_doubles ) ! !        And print them ! do i = 1 , 20 ! if ( abs ( sorted_max_vec_singles ( i , 1 )) . lt . 1.0D-03 ) then ! exit ! else ! write ( unit_output , '(t6,i3, 8x,i3, 10x, f8.5)' ) & index_list_singles ( i , 1 ),& index_list_singles ( i , 2 ),& sorted_max_vec_singles ( i , 1 ) endif enddo ! write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' write ( unit_output , '(t6,a3, 8x, a3, 8x, a3, 8x, a3, 8x, a10)' ) 'a' , 'i' , 'b' , 'j' , 'amplitude' write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' ! do i = 1 , 20 ! if ( abs ( sorted_max_vec_doubles ( i , 1 )) . lt . 1.0D-03 ) then ! exit ! else ! write ( unit_output , '(t6,i3, 8x,i3, 8x,i3, 8x, i3, 10x, f8.5)' )& index_list_doubles ( i , 1 ),& index_list_doubles ( i , 2 ),& index_list_doubles ( i , 3 ),& index_list_doubles ( i , 4 ),& sorted_max_vec_doubles ( i , 1 ) endif enddo write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' ! !        MLCC Specific print ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) ! if ( a . le . n_active_v . and . i . le . n_active_o ) then ! a_active_i_active = a_active_i_active + ( solution_ai ( ai , 1 )) ** 2 ! elseif ( a . le . n_active_v . and . i . gt . n_active_o ) then ! a_active_i_inactive = a_active_i_inactive + ( solution_ai ( ai , 1 )) ** 2 ! elseif ( a . gt . n_active_v . and . i . le . n_active_o ) then ! a_inactive_i_active = a_inactive_i_active + ( solution_ai ( ai , 1 )) ** 2 ! elseif ( a . gt . n_active_v . and . i . gt . n_active_o ) then ! a_inactive_i_inactive = a_inactive_i_inactive + ( solution_ai ( ai , 1 )) ** 2 ! endif enddo enddo ! !     Print active space stats: ! total = ( a_active_i_active + a_active_i_inactive + a_inactive_i_active + a_inactive_i_inactive ) write ( unit_output , '(/t6, a10, 3a12)' ) 'T->T:' , 'S->T:' , 'T->S:' , 'S->S:' write ( unit_output , '(/t6, a50)' ) '--------------------------------------------------' write ( unit_output , '(/t6, 4f12.5)' ) a_active_i_active / total ,& a_active_i_inactive / total , & a_inactive_i_active / total ,& a_inactive_i_inactive / total enddo ! !     Deallocations ! call wf % mem % dealloc ( solution_ai , wf % n_t1am , 1 ) call wf % mem % dealloc ( solution_aibj , wf % n_x2am , 1 ) ! call wf % mem % dealloc ( sorted_max_vec_singles , 20 , 1 ) call wf % mem % dealloc ( sorted_max_vec_doubles , 20 , 1 ) ! call wf % mem % dealloc_int ( index_list_singles , 20 , 2 ) call wf % mem % dealloc_int ( index_list_doubles , 20 , 4 ) ! close ( unit_solution ) ! a_active_i_active = 0 a_inactive_i_active = 0 a_active_i_inactive = 0 a_inactive_i_inactive = 0 ! end subroutine summary_excited_state_info_mlcc2 end submodule","tags":"","loc":"sourcefile/excited_state_submodule.f90.html","title":"excited_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~input_reader_submodule.f90~~EfferentGraph sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileinput_reader_submodulef90EfferentGraph = svgPanZoom('#sourcefileinput_reader_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules input_reader Source Code input_reader_submodule.F90 Source Code submodule ( mlcc2_class ) input_reader ! !! !!    Input reader submodule (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017 !! !!    Contains the following family of procedures of the MLCC2 class: !! !! use input_reader ! contains ! ! subroutine mlcc_reader_mlcc2 ( wf , unit_input ) !! !! !! implicit none ! integer ( i15 ) :: unit_input ! class ( mlcc2 ) :: wf ! character ( len = 40 ) :: line ! !     Start at the begining of eT.inp ! rewind ( unit_input ) ! do ! General loop 1 ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'MLCC2' ) then ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! do ! General loop 2 ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'CC2' ) then ! wf % mlcc_settings % CC2 = . true . cycle ! elseif ( trim ( line ) == 'CCS' ) then ! wf % mlcc_settings % CCS = . true . cycle ! elseif ( trim ( line ) == '}' ) then ! exit ! Exit general loop 2 ! elseif ( trim ( line ) == 'end of eT input' ) then ! write ( unit_output , * ) 'Error: could not find end of MLCC2 section in eT.inp.' stop ! endif ! enddo ! exit ! Exit general loop 1 ! else write ( unit_output , * ) 'Error: missing \"{\" for MLCC2 section.' stop endif ! elseif ( trim ( line ) == 'end of eT input' ) then ! write ( unit_output , * ) 'Error: no MLCC2 input section found.' stop ! endif ! enddo ! end subroutine mlcc_reader_mlcc2 ! ! module subroutine read_orbital_info_mlcc2 ( wf , unit_input ) !! !! implicit none ! integer ( i15 ) :: unit_input ! class ( mlcc2 ) :: wf ! character ( len = 40 ) :: line ! !     Start at the begining of eT.inp ! rewind ( unit_input ) ! do ! General loop 1 ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'CC2 orbitals' ) then ! call wf % CC2_orbitals % orbital_reader ( unit_input ) exit ! elseif ( trim ( line ) == 'end of eT input' ) then ! backspace ( unit_input ) exit ! endif ! enddo ! end subroutine read_orbital_info_mlcc2 ! ! end submodule input_reader","tags":"","loc":"sourcefile/input_reader_submodule.f90.html","title":"input_reader_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~orbital_partitioning_submodule.f90~~EfferentGraph sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileorbital_partitioning_submodulef90EfferentGraph = svgPanZoom('#sourcefileorbital_partitioning_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules orbital_partitioning Source Code orbital_partitioning_submodule.F90 Source Code submodule ( mlcc2_class ) orbital_partitioning ! !! !!    Orbital partitioning submodule (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Apr 2017 !! !!    Contains the following family of procedures of the MLCC2 class: !! !!    orbital_partitioning:         Directs the orbital partitioning !!    cholesky_localization_drv:    Directs orbital localization by cholesky decomposition !!    cholesky_orbital_constructor: Directs construction of new orbitals !!    cholesky_decomposition:       Cholesky decomposes the density !!    cholesky_orbitals:            Constructs new orbitals (C matrix) from cholesky vectors !! !!    cnto_orbital_drv: !!    cc2_cnto: !! !!    Contains the following module subroutines and functions: These should eventually be moved to some !!                                                       utils ! !! !!    get_number_of_active_spaces:     Returns number of active spaces from cholesky.inp !!    get_number_of_active_atoms:      Returns number of active atoms from cholesky.inp !!    get_active_atoms:                Returns the indices of the active atoms from cholesky.inp !!    construct_active_ao_index_list:  Returns active_ao_index_list to be used as pivoting elements in cholesky decomposition !!    read_atom_info:                  Reads info from dalton, n_nuclei and n_ao !!    read_center_info:                Reads info from dalton, which aos belong to which nuclei !! !! ! implicit none ! logical :: debug = . false . logical :: timings = . true . ! integer ( i15 ) :: CCS_factor_n_singlet_states = 4 ! ! contains ! ! module subroutine orbital_partitioning_mlcc2 ( wf ) !! !!    Orbital partitioning, !!    Written by Sarai D. Folkestad, June 2017 !! !!    Directs the partitioning for mlcc calculations. !! !!    So far only Cholesky decomposition is available. !! implicit none ! class ( mlcc2 ) :: wf ! if ( wf % CC2_orbitals % cholesky ) then ! !        If cholesky - do Cholesky decomposition ! call wf % cholesky_localization_drv ! elseif ( wf % CC2_orbitals % cnto ) then ! call wf % cnto_orbital_drv ! endif ! end subroutine orbital_partitioning_mlcc2 ! ! module subroutine cholesky_localization_drv_mlcc2 ( wf ) !! !!    Cholesky orbital localization. driver, !!    Written by Sarai D. Folkestad, June 2017 !! !!    Driver for Cholesky density decomposition. !! !!    - Collects atom and ao-basis information. !!    - Constructs occupied and vacant densities. !!    - Constructs AO Fock matrix.  (This is currently an N&#94;5 operation, should be optimized/removed) !!    - By looping over active spaces, the occupied and virtual densities are Cholesky decomposed !!      and the cholesky vectors are used to generate new localized MO's. !!    - New orbitals are tested for orthonormality (Not implemented yet, only need overlap matrix from DALTON) !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension (:,:), allocatable :: orbitals real ( dp ), dimension (:,:), allocatable :: orbital_energies ! integer ( i15 ) :: n_nuclei integer ( i15 ) :: offset_o = 0 , offset_v = 0 integer ( i15 ) :: n_active_aos = 0 ! integer ( i15 ), dimension (:,:), allocatable :: ao_center_info , n_ao_on_center integer ( i15 ), dimension (:,:), allocatable :: active_ao_index_list integer ( i15 ) :: n_vectors_o = 0 , n_vectors_v = 0 ! !     Timing variables ! real ( dp ) :: start_chol_deco = 0 , end_chol_deco = 0 ! !     IO-variables ! logical :: file_exists integer ( i15 ) :: unit_cholesky_decomp = 0 , unit_overlap = 0 , ioerror = 0 ! !     Indices ! integer ( i15 ) :: i = 0 , j = 0 , ij = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: density_o , density_v real ( dp ), dimension (:,:), allocatable :: ao_fock real ( dp ), dimension (:,:), allocatable :: C real ( dp ), dimension (:,:), allocatable :: S_packed real ( dp ), dimension (:,:), allocatable :: S real ( dp ), dimension (:,:), allocatable :: Y_1 , Y_2 ! !     Start timings ! call cpu_time ( start_chol_deco ) ! !     Prepare for decomposition ! !     Prints ! write ( unit_output , '(//t3,a)' ) ':: Cholesky orbital construction' write ( unit_output , '(t3,a/)' ) ':: E. F. Kjønstad, S. D. Folkestad, Jun 2017' ! !     :: Get center info :: ! call read_atom_info ( n_nuclei , wf % n_ao ) ! call wf % mem % alloc_int ( n_ao_on_center , n_nuclei , 1 ) call wf % mem % alloc_int ( ao_center_info , wf % n_ao , 2 ) ! call read_center_info ( n_nuclei , wf % n_ao , n_ao_on_center , ao_center_info ) ! !     ::::::::::::::::::::::: !     -::- Occupied part -::- !     ::::::::::::::::::::::: ! !     :: Construct AO fock matrix :: ! call wf % mem % alloc ( ao_fock , wf % n_ao , wf % n_ao ) call wf % construct_ao_fock_new ( ao_fock ) ! call wf % mem % alloc ( density_o , wf % n_ao , wf % n_ao ) density_o = zero ! call wf % construct_density_matrix ( density_o , wf % mo_coef , wf % n_o , wf % n_v ) ! !     Prepare for loop over active spaces ! offset_o = 1 ! !     Variables for storing information on spaces !     Allocations for Cholesky localized orbitals ! call allocator ( orbitals , wf % n_ao , wf % n_mo ) call allocator ( orbital_energies , wf % n_mo , 1 ) ! !     Sanity check on active atoms ! if ( wf % CC2_orbitals % n_active_atoms . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atoms in cholesky section of eT.inp.' stop endif ! do i = 1 , wf % CC2_orbitals % n_active_atoms if ( wf % CC2_orbitals % active_atoms ( i , 1 ) . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atomss in cholesky section of eT.inp.' stop endif enddo ! !     :: Constructing active (CC2) localized Cholesky orbitals :: ! n_active_aos = 0 do i = 1 , wf % CC2_orbitals % n_active_atoms n_active_aos = n_active_aos + n_ao_on_center ( wf % CC2_orbitals % active_atoms ( i , 1 ), 1 ) enddo ! !     Construct active_ao_index_list ! call wf % mem % alloc_int ( active_ao_index_list , n_active_aos , 1 ) call construct_active_ao_index_list ( active_ao_index_list , n_active_aos , wf % CC2_orbitals % active_atoms , & wf % CC2_orbitals % n_active_atoms , ao_center_info , wf % n_ao ) ! call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . true ., n_active_aos , active_ao_index_list ) ! !     Save active space information ! wf % n_CC2_o = n_vectors_o ! wf % first_CC2_o = offset_o ! !     Calculate new offset ! offset_o = offset_o + n_vectors_o ! call wf % mem % dealloc_int ( active_ao_index_list , n_active_aos , 1 ) ! !     :: CCS  localized Cholesky orbitals  :: ! n_vectors_o = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . false ., n_active_aos ) wf % n_CCS_o = n_vectors_o ! wf % first_CCS_o = offset_o ! call wf % mem % dealloc ( density_o , wf % n_ao , wf % n_ao ) ! !     :::::::::::::::::::::: !     -::- Virtual part -::- !     :::::::::::::::::::::: ! !     Allocations for Cholesky localized orbitals ! call wf % mem % alloc ( density_v , wf % n_ao , wf % n_ao ) density_v = zero ! call wf % construct_density_matrix_v ( density_v , wf % mo_coef , wf % n_o , wf % n_v ) ! offset_v = 1 + wf % n_o ! !     Sanity check on active atoms ! if ( wf % CC2_orbitals % n_active_atoms . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atoms in cholesky.inp.' stop endif ! do i = 1 , wf % CC2_orbitals % n_active_atoms if ( wf % CC2_orbitals % active_atoms ( i , 1 ) . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atoms in cholesky.inp.' stop endif enddo ! !     :: Constructing active (CC2) localized Cholesky orbitals :: ! n_active_aos = 0 do i = 1 , wf % CC2_orbitals % n_active_atoms n_active_aos = n_active_aos + n_ao_on_center ( wf % CC2_orbitals % active_atoms ( i , 1 ), 1 ) enddo ! !     Construct active_ao_index_list ! call wf % mem % alloc_int ( active_ao_index_list , n_active_aos , 1 ) call construct_active_ao_index_list ( active_ao_index_list , n_active_aos , wf % CC2_orbitals % active_atoms , & wf % CC2_orbitals % n_active_atoms , ao_center_info , wf % n_ao ) ! call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v , & . true ., n_active_aos , active_ao_index_list ) ! !     Save active space information ! wf % n_CC2_v = n_vectors_v ! wf % first_CC2_v = offset_v - wf % n_o ! !     Calculate new offset ! offset_v = offset_v + n_vectors_v ! !call wf%mem%dealloc_int(active_atoms, n_CC2_atoms, 1) call wf % mem % dealloc_int ( active_ao_index_list , n_active_aos , 1 ) ! ! !     :: CCS :: ! n_vectors_v = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v ,& . false ., n_active_aos ) ! call wf % mem % dealloc ( density_v , wf % n_ao , wf % n_ao ) call wf % mem % dealloc ( ao_fock , wf % n_ao , wf % n_ao ) ! !     Save inactive space information ! wf % n_CCS_v = n_vectors_v ! wf % first_CCS_v = offset_v - wf % n_o ! wf % mo_coef = orbitals wf % fock_diagonal = orbital_energies ! call deallocator ( orbitals , wf % n_ao , wf % n_mo ) call deallocator ( orbital_energies , wf % n_mo , 1 ) ! !     :: Check orthogonality of new orbitals :: ! !     Read overlap matrix ! call generate_unit_identifier ( unit_overlap ) open ( unit = unit_overlap , file = 'MLCC_OVERLAP' , status = 'unknown' , form = 'formatted' , iostat = ioerror ) if ( ioerror . ne . 0 ) write ( unit_output , * ) 'WARNING: Error while opening MLCC_OVERLAP' rewind ( unit_overlap ) ! call wf % mem % alloc ( S_packed , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) read ( unit_overlap , * ) S_packed close ( unit_overlap ) ! call wf % mem % alloc ( S , wf % n_ao , wf % n_ao ) ! call squareup ( S_packed , S , wf % n_ao ) ! call wf % mem % dealloc ( S_packed , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) ! call wf % mem % alloc ( Y_1 , wf % n_mo , wf % n_ao ) call dgemm ( 'T' , 'N' , & wf % n_mo , & wf % n_ao , & wf % n_ao , & one , & wf % mo_coef , & wf % n_ao ,& S , & wf % n_ao , & zero , & Y_1 , & wf % n_mo ) ! call wf % mem % dealloc ( S , wf % n_ao , wf % n_ao ) call wf % mem % alloc ( Y_2 , wf % n_mo , wf % n_mo ) ! call dgemm ( 'N' , 'N' , & wf % n_mo , & wf % n_mo , & wf % n_ao , & one , & Y_1 , & wf % n_mo ,& wf % mo_coef , & wf % n_ao , & zero , & Y_2 , & wf % n_mo ) ! call wf % mem % dealloc ( Y_1 , wf % n_mo , wf % n_ao ) ! if (. not . ( check_orthogonality ( Y_2 , wf % n_mo , wf % n_mo ))) then write ( unit_output , * ) 'New orbitals not orthogonal' stop endif ! call wf % mem % dealloc ( Y_2 , wf % n_mo , wf % n_mo ) ! !     :: Save new orbitals and orbital energies :: ! ! call wf % mem % dealloc_int ( n_ao_on_center , n_nuclei , 2 ) call wf % mem % dealloc_int ( ao_center_info , wf % n_ao , 2 ) ! !     Close cholesky.inp ! close ( unit_cholesky_decomp ) ! !     Print summary ! write ( unit_output , '(t3,a,a,a/)' ) 'Summary of ' , trim ( wf % name ), ' Cholesky orbital construction:' ! !     Print timings ! call cpu_time ( end_chol_deco ) write ( unit_output , '(t6,a25,f14.8/)' ) 'Total CPU time (seconds):' ,& end_chol_deco - start_chol_deco ! call wf % print_orbital_info flush ( unit_output ) ! ! end subroutine cholesky_localization_drv_mlcc2 ! module subroutine cholesky_orbital_constructor_mlcc2 ( wf , orbitals , orbital_energies , offset , ao_fock , density , n_vectors ,& selection , n_active_aos , active_ao_index_list ) !! !!    Cholesky orbital constructor, !!    Written by Sarai Dery Folkestad, June 2017 !! !!    Constructs new localized orbitals (occupied/virtual) by !!    - Decomposing the density (occupied/virual) !!    - Transforming Fock matrix with Cholesky vectors, and diagonalizing it. !!      New orbitals are eigenvectors, orbital energies are eigenvectors. !! implicit none ! class ( mlcc2 ) :: wf real ( dp ), dimension ( wf % n_ao , wf % n_mo ) :: orbitals real ( dp ), dimension ( wf % n_mo , 1 ) :: orbital_energies real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: ao_fock integer ( i15 ) :: n_active_aos , offset integer ( i15 ) :: n_vectors real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: density logical :: selection integer ( i15 ), dimension ( n_active_aos , 1 ), optional :: active_ao_index_list ! real ( dp ), dimension (:,:), allocatable :: cholesky real ( dp ), dimension (:,:), allocatable :: orbitals_temp real ( dp ), dimension (:,:), allocatable :: orbital_energies_temp ! integer ( i15 ) :: i = 0 , j = 0 ! if ( selection . and . (. not . present ( active_ao_index_list )) ) then write ( unit_output , * ) 'WARNING: Illegal argument list for cholesky decomposition' stop endif ! call wf % mem % alloc ( cholesky , wf % n_ao , wf % n_ao ) cholesky = zero ! !     :: Construct cholesky vectors by decomposing density :: ! if ( selection ) then call wf % cholesky_decomposition ( density , cholesky , & n_vectors , . true ., n_active_aos , active_ao_index_list ) else call wf % cholesky_decomposition ( density , cholesky , & n_vectors , . false ., n_active_aos ) endif ! !     :: Construct cholesky orbitals :: ! call wf % mem % alloc ( orbitals_temp , wf % n_ao , n_vectors ) call wf % mem % alloc ( orbital_energies_temp , n_vectors , 1 ) orbitals_temp = zero orbital_energies_temp = zero ! call wf % cholesky_orbitals ( cholesky , n_vectors , orbitals_temp , orbital_energies_temp , ao_fock ) ! !     Place new orbitals and orbital energies in array ! do i = 1 , wf % n_ao do j = 1 , n_vectors orbitals ( i , j + offset - 1 ) = orbitals_temp ( i , j ) orbital_energies ( j + offset - 1 , 1 ) = orbital_energies_temp ( j , 1 ) enddo enddo ! !     Deallocations ! call wf % mem % dealloc ( cholesky , wf % n_ao , wf % n_ao ) call wf % mem % dealloc ( orbitals_temp , wf % n_ao , n_vectors ) call wf % mem % dealloc ( orbital_energies_temp , n_vectors , 1 ) ! end subroutine cholesky_orbital_constructor_mlcc2 ! ! module subroutine cholesky_decomposition_mlcc2 ( wf , density , cholesky_vectors ,& n_vectors , selection , n_active_aos , active_ao_index_list ) !! !!    Cholesky decomposition, !!    Written by Sarai dery Folkestad, June 2017. !! !!    Cholesky decomposes the density (occupied/virtual). !!    Pivoting elements are chosen according to the active ao-list if it is pressent. !!    If not, maximum diagonal elements are chosen as pivoting elements. !! !!    The Cholesky vectors are subtracted from the incoming density matrix, and the returned density can be furteh decomposed !!    for inactive region. !! implicit none ! class ( mlcc2 ) :: wf integer ( i15 ) :: n_active_aos integer ( i15 ) :: n_vectors real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: density real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: cholesky_vectors logical :: selection integer ( i15 ), dimension ( n_active_aos , 1 ), optional :: active_ao_index_list ! integer ( i15 ) :: index_max = 0 real ( dp ) :: max_diagonal ! real ( dp ), parameter :: threshold = 1.0d-02 real ( dp ), parameter :: tolerance = 1.0d-09 ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 ! if ( selection . and . (. not . present ( active_ao_index_list )) ) then write ( unit_output , * ) 'WARNING: Illegal argument list for cholesky decomposition' stop endif ! !     Looping over the number of cholesky vectors ! do i = 1 , wf % n_ao n_vectors = i ! !        Find the maximum diagonal ! index_max = 0 max_diagonal = - 1.0d10 ! Make this a really small number ! if ( selection ) then do j = 1 , n_active_aos ! if ( density ( active_ao_index_list ( j , 1 ), active_ao_index_list ( j , 1 )) . gt . max_diagonal ) then ! max_diagonal = density ( active_ao_index_list ( j , 1 ), active_ao_index_list ( j , 1 )) index_max = active_ao_index_list ( j , 1 ) ! endif ! enddo else do j = 1 , wf % n_ao ! if ( density ( j , j ) . gt . max_diagonal ) then ! max_diagonal = density ( j , j ) index_max = j ! endif ! enddo endif ! !        Check against threshold and whether diagonal is negative ! if ( max_diagonal . lt . 0.0d0 ) then if ( abs ( max_diagonal ) . gt . tolerance ) then ! write ( unit_output , * ) 'WARNING: Found negative diagonal in cholesky decomposition.' stop ! endif endif ! if ( abs ( max_diagonal ) . lt . threshold ) then n_vectors = n_vectors - 1 return endif ! !        Cholesky vectors ! do j = 1 , wf % n_ao ! cholesky_vectors ( j , i ) = density ( j , index_max ) / sqrt ( max_diagonal ) ! enddo ! !        Subtract from density ! do j = 1 , wf % n_ao do k = 1 , wf % n_ao ! density ( k , j ) = density ( k , j ) - cholesky_vectors ( k , i ) * cholesky_vectors ( j , i ) ! enddo enddo ! do j = 1 , wf % n_ao density ( j , index_max ) = 0.0D0 density ( index_max , j ) = 0.0D0 enddo ! enddo end subroutine cholesky_decomposition_mlcc2 ! ! module subroutine cholesky_orbitals_mlcc2 ( wf , cholesky_vectors , n_vectors , orbitals , orbital_energies , ao_fock ) !! !!    Cholesky orbitals, !!    Written by Sarai Dery Folkestad, June 2017 !! !!    Makes the new MO's fromthe Cholesky vectors !!    - Transforms the AO fock matrix by the Cholesky vectors !!    - Diagonalize the MO fock to get orbital energies and new orbitals. !! implicit none ! class ( mlcc2 ) :: wf real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: cholesky_vectors real ( dp ), dimension ( wf % n_ao , n_vectors ) :: orbitals real ( dp ), dimension ( n_vectors , 1 ) :: orbital_energies integer ( i15 ) :: n_vectors real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: ao_fock ! real ( dp ), dimension (:,:), allocatable :: mo_fock real ( dp ), dimension (:,:), allocatable :: X real ( dp ), dimension (:,:), allocatable :: work integer ( i15 ) :: lwork integer ( i15 ) :: info = 0 ! integer ( i15 ) :: a = 0 , b = 0 , i = 0 , j = 0 ! if ( n_vectors == 0 ) return ! call wf % mem % alloc ( X , n_vectors , wf % n_ao ) ! !     :: Transform AO Fock :: ! call dgemm ( 'T' , 'N' , & n_vectors , & wf % n_ao , & wf % n_ao , & one , & cholesky_vectors , & wf % n_ao , & ao_fock , & wf % n_ao , & zero , & X , & n_vectors ) ! call wf % mem % alloc ( mo_fock , n_vectors , n_vectors ) ! call dgemm ( 'N' , 'N' , & n_vectors , & n_vectors , & wf % n_ao , & one , & X , & n_vectors , & cholesky_vectors , & wf % n_ao , & zero , & mo_fock , & n_vectors ) ! call wf % mem % dealloc ( X , n_vectors , wf % n_ao ) ! !     :: Diagonalize MO fock :: ! call wf % mem % alloc ( work , 4 * n_vectors , 1 ) work = zero ! call dsyev ( 'V' , 'U' , & n_vectors , & mo_fock , & n_vectors , & orbital_energies , & work , & 4 * n_vectors , & info ) ! call wf % mem % dealloc ( work , 4 * n_vectors , 1 ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Diagonalization not successful.' stop endif ! !     Construct C-matrix (orbital coefficients) ! call dgemm ( 'N' , 'N' , & wf % n_ao , & n_vectors , & n_vectors , & one , & cholesky_vectors , & wf % n_ao , & mo_fock , & n_vectors , & zero , & orbitals , & wf % n_ao ) ! ! call wf % mem % dealloc ( mo_fock , n_vectors , n_vectors ) ! end subroutine cholesky_orbitals_mlcc2 ! ! module subroutine construct_active_ao_index_list ( active_ao_index_list , n_active_aos , active_atoms , & n_active_atoms , ao_center_info , n_ao ) !! !!    Construct active ao index list, !!    Written by Sarai Dery Folkestad, June 2017. !! !!    Constructs list of active ao's for cholesky decomposition. !! implicit none ! integer ( i15 ) :: n_active_aos integer ( i15 ) :: n_active_atoms integer ( i15 ) :: n_ao integer ( i15 ), dimension ( n_active_aos , 1 ) :: active_ao_index_list integer ( i15 ), dimension ( n_active_atoms , 1 ) :: active_atoms integer ( i15 ), dimension ( n_ao , 2 ) :: ao_center_info ! integer ( i15 ) :: i = 0 , j = 0 , counter = 0 ! counter = 0 do i = 1 , n_active_atoms do j = 1 , n_ao if ( ao_center_info ( j , 1 ) == active_atoms ( i , 1 )) then counter = counter + 1 active_ao_index_list ( counter , 1 ) = ao_center_info ( j , 2 ) endif enddo enddo ! end subroutine construct_active_ao_index_list ! ! !     ::::::::::::::::::::::: !     -::- CNTO Routines -::- !     ::::::::::::::::::::::: ! module subroutine cnto_orbital_drv_mlcc2 ( wf ) !! !!    CNTO orbital driver, !!    Written by Sarai D. Folkestad, June 2017. !! !!    Directs the construction of CNTOs and the selection of the active space. !! !!    A CCS calculation ground state and excited states is performed. !!    The M and N matrices are then constructed, !! !!       M_ij = 1/n sum_{k=1,n} (sum_a R&#94;k_ai*R1_aj) !!       N_ab = 1/n sum_{k=1,n} (sum_i R&#94;k_ai*R1_bi) !! !!    where n > 1. !! !!    Ri_ai is the i'th single excitation vector obtained from the CCS calculation. !!    The transformation matrices for the occupied and virtual part !!    are constructed by diagonalizing M and N. The number of active occupied !!    and virtual orbitals are determined from δ_o and δ_v !! !!       1 - sum_i λ&#94;o_i < δ_o !!       1 - sum_i λ&#94;v_i < δ_v !! !!    Where the orbitals of highest eigenvalues λ&#94;o/λ&#94;v are selected first. !! !!    Fock matrix is block diagonalized in active and inactive blocks in order to obtain !!    the orbitals and orbital energies used in the CC2 calculation. !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ) :: start_cnto = 0 , end_cnto = 0 ! !     Prints ! write ( unit_output , '(//t3,a)' ) ':: CNTO orbital partitioning for MLCC2 calculation ' write ( unit_output , '(t3,a/)' ) ':: E. F. Kjønstad, S. D. Folkestad, Jun 2017' write ( unit_output , '(/a35,e10.2)' ) 'Threshold for occupied orbitals:' , wf % CC2_orbitals % delta_o write ( unit_output , '(a35,e10.2/)' ) 'Threshold for virtual orbitals: ' , wf % CC2_orbitals % delta_v ! !     Timings ! call cpu_time ( start_cnto ) ! !     CNTO orbital selection for CCSD ! if ( wf % tasks % excited_state . or . wf % tasks % core_excited_state ) then ! call wf % cc2_cnto_lower_level_method ! else ! write ( unit_output , * ) 'WARNING: cntos without excited state calculation makes no sense.' endif ! !     Print info ! call wf % cc2_cnto_orbitals ! !     Print summary ! write ( unit_output , '(/t3,a,a,a/)' ) 'Summary of ' , trim ( wf % name ), ' CNTO orbital construction:' ! !     Print timings ! call cpu_time ( end_cnto ) ! if ( timings ) write ( unit_output , '(/t6,a26,f14.8/)' ) 'Total CPU time (seconds): ' , end_cnto - start_cnto flush ( unit_output ) ! call wf % print_orbital_info ! end subroutine cnto_orbital_drv_mlcc2 ! ! module subroutine cc2_cnto_lower_level_method_mlcc2 ( wf ) !! !!    CNTO lower level calculation (MLCC2), !!    Written by Sarai D. Folkestad, June 2017. !! !!    Runs lower level method for CNTOs !! implicit none ! class ( mlcc2 ) :: wf ! type ( ccs ), allocatable :: ccs_wf ! integer ( i15 ) :: lower_level_n_singlet_states integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ), dimension (:,:), allocatable :: index_list ! logical :: start_vec_exists ! !     :::::::::::::::::::::::::::::::::::::::::::::::: !     -::- Running lower level method calculation -::- !     :::::::::::::::::::::::::::::::::::::::::::::::: ! !     Allocate lower level method ! allocate ( ccs_wf ) ! !     :: Set calculation tasks :: ! ccs_wf % tasks = wf % tasks ! !     :: Set calculation settings :: ! ccs_wf % settings = wf % settings ccs_wf % core_excited_state_specifications = wf % core_excited_state_specifications ! !     :: Set number of excitations to use for cnto generation :: !        - Should be some function of wf%excited_state_specifications%n_singlet_states ! lower_level_n_singlet_states = CCS_factor_n_singlet_states * wf % excited_state_specifications % n_singlet_states ! ccs_wf % excited_state_specifications % n_singlet_states = lower_level_n_singlet_states ! !     :: Set convergence threshold for lower lying method :: ! ccs_wf % ground_state_specifications % energy_threshold = 1.0D-04 ccs_wf % ground_state_specifications % residual_threshold = 1.0D-04 ! ccs_wf % excited_state_specifications % energy_threshold = 1.0D-04 ccs_wf % excited_state_specifications % residual_threshold = 1.0D-04 ! !     :: User specified start vectors for excited state calculation :: ! !     Test for user specified start vector ! !     We must do some cumbersome tricks since n_singlet_states for ccs_wf is higher than for wf ! if ( wf % excited_state_specifications % user_specified_start_vector ) then ! !        Find indices lowest orbital differences (either core or valence) and place in index_list ! call wf % mem % alloc_int ( index_list , ccs_wf % excited_state_specifications % n_singlet_states , 1 ) ! if ( wf % tasks % excited_state ) then ! call ccs_wf % find_start_trial_indices ( index_list ) ! elseif ( wf % tasks % core_excited_state ) then ! call ccs_wf % find_start_trial_indices_core ( index_list ) ! endif ! !        Loop through user specified start vectors and ... ! do i = 1 , wf % excited_state_specifications % n_singlet_states start_vec_exists = . false . ! !           ... Check if it is contained in index list already ! do j = 1 , ccs_wf % excited_state_specifications % n_singlet_states if ( wf % excited_state_specifications % start_vectors ( i , 1 ) == index_list ( j , 1 )) & start_vec_exists = . true . enddo ! !           ... If not, exchange it with an element of index_list (starting at the end of index_list) ! if (. not . start_vec_exists ) then index_list ( ccs_wf % excited_state_specifications % n_singlet_states - i + 1 , 1 ) & = wf % excited_state_specifications % start_vectors ( i , 1 ) endif ! enddo ! !        Set user_specified_start_vector to true for lower level method ! !        OBS: It is crusial that tis is done AFTER the call to !             find_start_trial_indices/find_start_trial_indices_core ! ccs_wf % excited_state_specifications % user_specified_start_vector = . true . ! !        Let index_list be the user specified start vector. ! call wf % mem % alloc_int ( ccs_wf % excited_state_specifications % start_vectors , & ccs_wf % excited_state_specifications % n_singlet_states , 1 ) ! ccs_wf % excited_state_specifications % start_vectors = index_list ! call wf % mem % dealloc_int ( index_list , ccs_wf % excited_state_specifications % n_singlet_states , 1 ) ! !        Since orbitals will swap order, start vector in higher level method must be removed ! wf % excited_state_specifications % user_specified_start_vector = . false . call wf % mem % dealloc_int ( wf % excited_state_specifications % start_vectors , wf % excited_state_specifications % n_singlet_states , 1 ) ! endif ! !     :: Initialize lower level method :: ! ccs_wf % name = 'CCS' ! !     Set implemented generic methods ! ccs_wf % implemented % ground_state = . true . ccs_wf % implemented % excited_state = . true . ccs_wf % implemented % core_excited_state = . true . ! !     Read Hartree-Fock info from SIRIUS ! call ccs_wf % read_hf_info ! !     Read Cholesky AO integrals and transform to MO basis ! call ccs_wf % read_transform_cholesky ! !     Initialize amplitudes and associated attributes ! call ccs_wf % initialize_amplitudes ! !     Set the number of parameters in the wavefunction !     (that are solved for in the ground and excited state solvers) ! ccs_wf % n_parameters = ccs_wf % n_t1am ! !     Initialize the projection vector ! call ccs_wf % initialize_omega ! !     Allocate Fock matrix and set to zero ! call ccs_wf % initialize_fock_matrix ! !     :: Driver of lower level method :: ! call ccs_wf % drv ! !     Done with lower lying method ! deallocate ( ccs_wf ) ! end subroutine cc2_cnto_lower_level_method_mlcc2 ! ! module subroutine cc2_cnto_orbitals_mlcc2 ( wf ) !! !!    CNTO Oritals (MLCC2), !!    Written by Sarai D. Folkestad Aug. 2017 !! !!    Constructs the CNTO orbitals based on exitation vectors from lower level method !! implicit none ! class ( mlcc2 ) :: wf ! integer ( i15 ) :: unit_solution = - 1 integer ( i15 ) :: ioerror = 0 integer ( i15 ) :: state integer ( i15 ) :: lower_level_n_singlet_states ! real ( dp ), dimension (:,:), allocatable :: solution real ( dp ), dimension (:,:), allocatable :: R_a_i real ( dp ), dimension (:,:), allocatable :: R_a_i_sum real ( dp ), dimension (:,:), allocatable :: M_i_j real ( dp ), dimension (:,:), allocatable :: N_a_b real ( dp ), dimension (:,:), allocatable :: M real ( dp ), dimension (:,:), allocatable :: N real ( dp ), dimension (:,:), allocatable :: X real ( dp ), dimension (:,:), allocatable :: eigenvalues_o real ( dp ), dimension (:,:), allocatable :: eigenvalues_v real ( dp ), dimension (:,:), allocatable :: work real ( dp ), dimension (:,:), allocatable :: C_o real ( dp ), dimension (:,:), allocatable :: C_v real ( dp ), dimension (:,:), allocatable :: C_o_transformed real ( dp ), dimension (:,:), allocatable :: C_v_transformed real ( dp ), dimension (:,:), allocatable :: fock_o real ( dp ), dimension (:,:), allocatable :: fock_v real ( dp ), dimension (:,:), allocatable :: orbital_energies ! integer ( i15 ) :: info integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 , ai = 0 , ij = 0 ! real ( dp ) :: trace , ddot , sum_o , sum_v , norm ! !     :::::::::::::::::::::::::::::::::::::::::::::: !     -::- Construct CNTO transformation matrix -::- !     :::::::::::::::::::::::::::::::::::::::::::::: ! !     Open file of CCS solution vectors ! call generate_unit_identifier ( unit_solution ) ! !     Determine file name ! if ( wf % tasks % excited_state ) wf % excited_state_specifications % solution_file = 'right_valence' if ( wf % tasks % core_excited_state ) wf % excited_state_specifications % solution_file = 'right_core' ! open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file ,& action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * (( wf % n_o ) * ( wf % n_v )), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening solution file' , ioerror ! !     Allocations ! call wf % mem % alloc ( R_a_i , ( wf % n_o ) * ( wf % n_v ), 1 ) ! call wf % mem % alloc ( M_i_j , wf % n_o , wf % n_o ) M_i_j = zero ! call wf % mem % alloc ( N_a_b , wf % n_v , wf % n_v ) N_a_b = zero ! !     Construct M and N ! lower_level_n_singlet_states = CCS_factor_n_singlet_states * ( wf % excited_state_specifications % n_singlet_states ) ! do state = 1 , lower_level_n_singlet_states read ( unit = unit_solution , rec = state ) ( R_a_i ( i , 1 ), i = 1 , ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'T' , 'N' , & wf % n_o , & wf % n_o , & wf % n_v , & one , & R_a_i , & wf % n_v , & R_a_i , & wf % n_v , & one , & M_i_j , & wf % n_o ) ! call dgemm ( 'N' , 'T' , & wf % n_v , & wf % n_v , & wf % n_o , & one , & R_a_i , & wf % n_v , & R_a_i , & wf % n_v , & one , & N_a_b , & wf % n_v ) ! enddo ! call wf % mem % dealloc ( R_a_i ,( wf % n_o ) * ( wf % n_v ), 1 ) ! !     Done with file ! close ( unit_solution , status = 'delete' ) ! !     :: Normalize Tr(N) and Tr(M) :: ! trace = 0 ! do i = 1 , wf % n_o trace = trace + M_i_j ( i , i ) enddo ! call dscal (( wf % n_o ) * ( wf % n_o ), one / trace , M_i_j , 1 ) ! trace = 0 ! do i = 1 , wf % n_v trace = trace + N_a_b ( i , i ) enddo ! call dscal (( wf % n_v ) * ( wf % n_v ), one / trace , N_a_b , 1 ) ! !     :: Diagonalize M and N matrix :: ! call wf % mem % alloc ( eigenvalues_o , wf % n_o , 1 ) call wf % mem % alloc ( work , 4 * ( wf % n_o ), 1 ) work = zero ! call dsyev ( 'V' , 'U' , & wf % n_o , & M_i_j , & wf % n_o , & eigenvalues_o , & work , & 4 * ( wf % n_o ), & info ) ! call wf % mem % dealloc ( work , 4 * ( wf % n_o ), 1 ) ! call wf % mem % alloc ( eigenvalues_v , wf % n_v , 1 ) call wf % mem % alloc ( work , 4 * ( wf % n_v ), 1 ) work = zero ! call dsyev ( 'V' , 'U' , & wf % n_v , & N_a_b , & wf % n_v , & eigenvalues_v , & work , & 4 * ( wf % n_v ), & info ) ! call wf % mem % dealloc ( work , 4 * ( wf % n_v ), 1 ) ! !     :: Reorder M and N :: ! !     dsyev orderes eigenvalues and corresponding eigenvectors in ascending order. !     We wish to select active space according to highest eigenvalues, thus we must reorder ! call wf % mem % alloc ( M , wf % n_o , wf % n_o ) ! do i = 1 , wf % n_o ! j = i - 1 M (:, i ) = M_i_j (:, wf % n_o - j ) ! enddo ! call wf % mem % dealloc ( M_i_j , wf % n_o , wf % n_o ) ! call wf % mem % alloc ( N , wf % n_v , wf % n_v ) ! do a = 1 , wf % n_v ! b = a - 1 N (:, a ) = N_a_b (:, wf % n_v - b ) ! enddo ! call wf % mem % dealloc ( N_a_b , wf % n_v , wf % n_v ) ! !     Transform C to CNTO ! call wf % mem % alloc ( C_o , wf % n_ao , wf % n_o ) call wf % mem % alloc ( C_v , wf % n_ao , wf % n_v ) C_o = zero C_v = zero ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_o ij = index_two ( i , j , wf % n_ao ) C_o ( i , j ) = wf % mo_coef ( ij , 1 ) enddo ! do j = 1 , wf % n_v ij = index_two ( i , j + wf % n_o , wf % n_ao ) C_v ( i , j ) = wf % mo_coef ( ij , 1 ) enddo ! enddo ! call wf % mem % alloc ( C_o_transformed , wf % n_ao , wf % n_o ) call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_o , & wf % n_o , & one , & C_o , & wf % n_ao , & M , & wf % n_o , & zero , & C_o_transformed , & wf % n_ao ) ! call wf % mem % dealloc ( C_o , wf % n_ao , wf % n_o ) ! call wf % mem % alloc ( C_v_transformed , wf % n_ao , wf % n_v ) call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_v , & wf % n_v , & one , & C_v , & wf % n_ao , & N , & wf % n_v , & zero , & C_v_transformed , & wf % n_ao ) ! call wf % mem % dealloc ( C_v , wf % n_ao , wf % n_v ) ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_o ij = index_two ( i , j , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_o_transformed ( i , j ) enddo ! do j = 1 , wf % n_v ij = index_two ( i , j + wf % n_o , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_v_transformed ( i , j ) enddo ! enddo ! call wf % mem % dealloc ( C_o_transformed , wf % n_ao , wf % n_o ) call wf % mem % dealloc ( C_v_transformed , wf % n_ao , wf % n_v ) ! !     :: Determine number of active orbitals :: ! sum_o = 1 - eigenvalues_o ( wf % n_o , 1 ) wf % n_CC2_o = 1 ! do while (( sum_o . gt . wf % CC2_orbitals % delta_o ) . and . ( wf % n_CC2_o . le . wf % n_o )) ! sum_o = sum_o - eigenvalues_o ( wf % n_o - ( wf % n_CC2_o ), 1 ) wf % n_CC2_o = wf % n_CC2_o + 1 ! enddo ! sum_v = 1 - eigenvalues_v ( wf % n_v , 1 ) wf % n_CC2_v = 1 ! do while ( sum_v . gt . wf % CC2_orbitals % delta_v . and . ( wf % n_CC2_v . le . wf % n_v )) ! sum_v = sum_v - eigenvalues_v ( wf % n_v - ( wf % n_CC2_v ), 1 ) wf % n_CC2_v = wf % n_CC2_v + 1 ! enddo ! !     Save information to object ! wf % first_CC2_o = 1 wf % first_CC2_v = 1 ! wf % n_CCS_o = wf % n_o - wf % n_CC2_o wf % n_CCS_v = wf % n_v - wf % n_CC2_v ! wf % first_CCS_o = 1 + wf % n_CC2_o wf % first_CCS_v = 1 + wf % n_CC2_v ! call wf % mem % dealloc ( eigenvalues_o , wf % n_o , 1 ) call wf % mem % dealloc ( eigenvalues_v , wf % n_v , 1 ) ! !     :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: !     -::- Finding orbital energies and new block diagonal C matrix -::- !     :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ! !     Initialize amplitudes and associated attributes ! call wf % initialize_amplitudes call wf % initialize_omega ! !     Set the number of parameters in the wavefunction !     (that are solved for in the ground and excited state solvers) ! wf % n_parameters = wf % n_t1am ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize fock matrix ! call wf % initialize_fock_matrix ! !     :: Occupied Orbitals :: ! ! !     Diagonalize active-active block ! call wf % mem % alloc ( work , 4 * ( wf % n_CC2_o ), 1 ) call wf % mem % alloc ( orbital_energies , ( wf % n_CC2_o ), 1 ) work = zero ! call dsyev ( 'V' , 'U' , & ( wf % n_CC2_o ), & wf % fock_ij , & wf % n_o , & orbital_energies , & work , & 4 * ( wf % n_CC2_o ), & info ) ! call wf % mem % dealloc ( work , 4 * ( wf % n_CC2_o ), 1 ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Diagonalization of active virtual block not successful. ' stop endif ! !     Setting orbital energies ! do j = 1 , wf % n_CC2_o ! wf % fock_diagonal ( j , 1 ) = orbital_energies ( j , 1 ) ! enddo ! call wf % mem % dealloc ( orbital_energies , ( wf % n_CC2_o ), 1 ) ! !     Diagonalize inactive-inactive block ! call wf % mem % alloc ( work , 4 * wf % n_CCS_o , 1 ) call wf % mem % alloc ( orbital_energies , wf % n_CCS_o , 1 ) orbital_energies = zero work = zero ! call dsyev ( 'V' , 'U' , & wf % n_CCS_o , & wf % fock_ij ( wf % first_CCS_o , wf % first_CCS_o ), & wf % n_o , & orbital_energies , & work , & 4 * wf % n_CCS_o , & info ) ! call wf % mem % dealloc ( work , 4 * wf % n_CCS_o , 1 ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Diagonalization of inactive virtual block not successful.' stop endif ! !     Setting orbital energies ! do j = 1 , wf % n_CCS_o ! wf % fock_diagonal ( j + wf % first_CCS_o - 1 , 1 ) = orbital_energies ( j , 1 ) ! enddo call wf % mem % dealloc ( orbital_energies , wf % n_CCS_o , 1 ) ! !     Transform C-matrix (active occupied block) ! call wf % mem % alloc ( C_o , wf % n_ao , wf % n_o ) C_o = zero ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_o ij = index_two ( i , j , wf % n_ao ) C_o ( i , j ) = wf % mo_coef ( ij , 1 ) enddo ! enddo ! call wf % mem % alloc ( C_o_transformed , wf % n_ao , wf % n_CC2_o ) call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_CC2_o , & wf % n_CC2_o , & one , & C_o , & wf % n_ao , & wf % fock_ij , & wf % n_o , & zero , & C_o_transformed , & wf % n_ao ) ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_CC2_o ij = index_two ( i , j , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_o_transformed ( i , j ) enddo ! enddo ! call wf % mem % dealloc ( C_o_transformed , wf % n_ao , wf % n_CC2_o ) ! !     Transform C-matrix (inactive occupied block) ! call wf % mem % alloc ( C_o_transformed , wf % n_ao , wf % n_CCS_o ) call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_CCS_o , & wf % n_CCS_o , & one , & C_o ( 1 , wf % first_CCS_o ), & wf % n_ao , & wf % fock_ij ( wf % first_CCS_o , wf % first_CCS_o ), & wf % n_o , & zero , & C_o_transformed , & wf % n_ao ) ! call wf % mem % dealloc ( C_o , wf % n_ao , wf % n_o ) ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_CCS_o ij = index_two ( i , j + wf % first_CCS_o - 1 , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_o_transformed ( i , j ) enddo ! enddo ! call wf % mem % dealloc ( C_o_transformed , wf % n_ao , wf % n_CCS_o ) ! !     :: Vacant orbitals :: ! !     Diagonalize active-active block ! call wf % mem % alloc ( work , 4 * ( wf % n_CC2_v ), 1 ) call wf % mem % alloc ( orbital_energies , ( wf % n_CC2_v ), 1 ) work = zero ! call dsyev ( 'V' , 'U' , & ( wf % n_CC2_v ), & wf % fock_ab , & wf % n_v , & orbital_energies , & work , & 4 * ( wf % n_CC2_v ), & info ) ! call wf % mem % dealloc ( work , 4 * ( wf % n_CC2_v ), 1 ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Diagonalization of active virtual block not successful. ' , orbital_energies stop endif ! !     Setting orbital energies ! do j = 1 , wf % n_CC2_v ! wf % fock_diagonal ( j + wf % n_o , 1 ) = orbital_energies ( j , 1 ) ! enddo ! call wf % mem % dealloc ( orbital_energies , ( wf % n_CC2_v ), 1 ) ! !     Diagonalize inactive-inactive block ! call wf % mem % alloc ( work , 4 * wf % n_CCS_v , 1 ) call wf % mem % alloc ( orbital_energies , wf % n_CCS_v , 1 ) orbital_energies = zero work = zero ! call dsyev ( 'V' , 'U' , & wf % n_CCS_v , & wf % fock_ab ( wf % first_CCS_v , wf % first_CCS_v ), & wf % n_v , & orbital_energies , & work , & 4 * wf % n_CCS_v , & info ) ! call wf % mem % dealloc ( work , 4 * wf % n_CCS_v , 1 ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Diagonalization of inactive virtual block not successful.' stop endif ! !     Setting orbital energies ! do j = 1 , wf % n_CCS_v ! wf % fock_diagonal ( j + wf % n_o + wf % first_CCS_v - 1 , 1 ) = orbital_energies ( j , 1 ) ! enddo call wf % mem % dealloc ( orbital_energies , wf % n_CCS_v , 1 ) ! !     Transform C-matrix (active virtual block) ! call wf % mem % alloc ( C_v , wf % n_ao , wf % n_v ) C_v = zero ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_v ij = index_two ( i , j + wf % n_o , wf % n_ao ) C_v ( i , j ) = wf % mo_coef ( ij , 1 ) enddo ! enddo ! call wf % mem % alloc ( C_v_transformed , wf % n_ao , wf % n_CC2_v ) call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_CC2_v , & wf % n_CC2_v , & one , & C_v , & wf % n_ao , & wf % fock_ab , & wf % n_v , & zero , & C_v_transformed , & wf % n_ao ) ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_CC2_v ij = index_two ( i , j + wf % n_o , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_v_transformed ( i , j ) enddo ! enddo ! call wf % mem % dealloc ( C_v_transformed , wf % n_ao , wf % n_CC2_v ) ! !     Transform C-matrix (inactive virtual block) ! call wf % mem % alloc ( C_v_transformed , wf % n_ao , wf % n_CCS_v ) call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_CCS_v , & wf % n_CCS_v , & one , & C_v ( 1 , wf % first_CCS_v ), & wf % n_ao , & wf % fock_ab ( wf % first_CCS_v , wf % first_CCS_v ), & wf % n_v , & zero , & C_v_transformed , & wf % n_ao ) ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_CCS_v ij = index_two ( i , j + wf % n_o + wf % first_CCS_v - 1 , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_v_transformed ( i , j ) enddo ! enddo ! call wf % mem % dealloc ( C_v_transformed , wf % n_ao , wf % n_CCS_v ) call wf % mem % dealloc ( C_v , wf % n_ao , wf % n_v ) ! ! end subroutine cc2_cnto_orbitals_mlcc2 ! ! module subroutine print_orbital_info_mlcc2 ( wf ) !! !!    Print orbital info, !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Prints information on CNTO partitioning !! implicit none ! class ( mlcc2 ) :: wf ! write ( unit_output , '(t6,a10)' ) 'CC2 space:' write ( unit_output , '(t6,a30, i3)' ) 'Number of occupied orbitals:  ' , wf % n_CC2_o write ( unit_output , '(t6,a30, i3/)' ) 'Number of virtual orbitals:   ' , wf % n_CC2_v ! write ( unit_output , '(t6,a10)' ) 'CCS space:' write ( unit_output , '(t6,a30, i3)' ) 'Number of occupied orbitals:  ' , wf % n_CCS_o write ( unit_output , '(t6,a30, i3/)' ) 'Number of virtual orbitals:   ' , wf % n_CCS_v flush ( unit_output ) ! end subroutine print_orbital_info_mlcc2 end submodule orbital_partitioning","tags":"","loc":"sourcefile/orbital_partitioning_submodule.f90.html","title":"orbital_partitioning_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~jacobian_submodule.f90~2~~EfferentGraph sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilejacobian_submodulef902EfferentGraph = svgPanZoom('#sourcefilejacobian_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules jacobian Source Code jacobian_submodule.F90 Source Code submodule ( mlccsd_class ) jacobian ! !! !!    Jacobian transformation submodule (MLCCSD) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Aug 2017 !! ! implicit none ! logical :: debug = . false . logical :: timings = . false . ! character ( len = 40 ) :: integral_type ! contains ! module subroutine jacobian_mlccsd_transformation_mlccsd ( wf , c_a_i , c_aibj ) !! !!    Jacobian transformation (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Directs the transformation by the CCSD Jacobi matrix, !! !!       A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >, !! !!    where the basis employed for the brackets is biorthonormal. !!    The transformation is rho = A c, i.e., !! !!       rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck !!                  + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl). !! !!    On exit, c is overwritten by rho. That is, c_a_i = rho_a_i, !!    and c_aibj = rho_aibj. !! implicit none ! class ( mlccsd ) :: wf ! !      Incoming vector c ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_x2am , 1 ) :: c_aibj ! c_aibj ! !      Local unpacked and reordered vectors ! real ( dp ), dimension (:,:), allocatable :: rho_a_i ! rho_ai   = (A c)_ai real ( dp ), dimension (:,:), allocatable :: rho_ai_bj ! rho_ai   = (A c)_aibj real ( dp ), dimension (:,:), allocatable :: rho_ab_ij ! rho_ai   = (A c)_aibj real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_sym ! rho_ai   = (A c)_aibj real ( dp ), dimension (:,:), allocatable :: c_ai_bj ! rho_ai   = (A c)_aibj real ( dp ), dimension (:,:), allocatable :: c_ab_ij ! rho_ai   = (A c)_aibj real ( dp ), dimension (:,:), allocatable :: x_ia_jb ! rho_ai   = (A c)_aibj ! !      Indices ! integer ( i15 ) :: a = 0 , ab = 0 , ai = 0 , b = 0 integer ( i15 ) :: bj = 0 , i = 0 , ij = 0 , j = 0 , aibj = 0 ! integer ( i15 ) :: offset = 0 ! !    Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: active_space = 0 ! !    Allocate and zero the transformed vector (singles part) ! call wf % mem % alloc ( rho_a_i , wf % n_v , wf % n_o ) rho_a_i = zero ! !    :: CCS contributions to the singles c vector :: ! call initialize_amplitudes_ccs ( wf ) call wf % read_single_amplitudes ! call wf % jacobian_ccs_a1 ( rho_a_i , c_a_i ) call wf % jacobian_ccs_b1 ( rho_a_i , c_a_i ) ! !     :: MLCCSD contributions to transformed vector :: ! call wf % jacobian_mlcc2_a1 ( rho_a_i , c_a_i ) ! !     Calculate number of active indices ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! !     Allocate the incoming unpacked doubles vector ! call wf % mem % alloc ( c_ai_bj , n_active_o * n_active_v , n_active_o * n_active_v ) c_ai_bj = zero ! call squareup ( c_aibj , c_ai_bj , n_active_o * n_active_v ) ! Pack out vector ! !     Scale the doubles vector by 1 + delta_ai,bj, i.e. !     redefine to c_ckdl = c_ckdl (1 + delta_ck,dl) ! do i = 1 , n_active_o * n_active_v ! c_ai_bj ( i , i ) = two * c_ai_bj ( i , i ) ! enddo ! call wf % jacobian_mlcc2_b1 ( rho_a_i , c_ai_bj ) ! !     Allocate unpacked transformed vector ! call wf % mem % alloc ( rho_ai_bj , n_active_o * n_active_v , n_active_o * n_active_v ) rho_ai_bj = zero ! call wf % jacobian_mlcc2_a2 ( rho_ai_bj , c_a_i ) call wf % jacobian_mlccsd_b2 ( rho_ai_bj , c_a_i ) call wf % jacobian_mlccsd_c2 ( rho_ai_bj , c_a_i ) call wf % jacobian_mlccsd_d2 ( rho_ai_bj , c_a_i ) ! call wf % jacobian_mlccsd_e2 ( rho_ai_bj , c_ai_bj ) call wf % jacobian_mlccsd_f2 ( rho_ai_bj , c_ai_bj ) call wf % jacobian_mlccsd_g2 ( rho_ai_bj , c_ai_bj ) call wf % jacobian_mlccsd_h2 ( rho_ai_bj , c_ai_bj ) call wf % jacobian_mlccsd_i2 ( rho_ai_bj , c_ai_bj ) ! !     Allocate temporary symmetric transformed vector ! call wf % mem % alloc ( rho_ai_bj_sym , n_active_o * n_active_v , n_active_o * n_active_v ) rho_ai_bj_sym = zero !! do j = 1 , n_active_o do b = 1 , n_active_v !! bj = index_two ( b , j , n_active_v ) !! do i = 1 , n_active_o do a = 1 , n_active_v !! ai = index_two ( a , i , n_active_v ) !! rho_ai_bj_sym ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj ( bj , ai ) !! enddo enddo enddo enddo !! rho_ai_bj = rho_ai_bj_sym ! !     Done with temporary vector; deallocate ! call wf % mem % dealloc ( rho_ai_bj_sym , n_active_o * n_active_v , n_active_o * n_active_v ) ! !     In preparation for last two terms, reorder !     rho_ai_bj to rho_ab_ij, and c_ai_bj to c_ab_ij ! call wf % mem % alloc ( rho_ab_ij , ( n_active_v ) ** 2 , ( n_active_o ) ** 2 ) call wf % mem % alloc ( c_ab_ij , ( n_active_v ) ** 2 , ( n_active_o ) ** 2 ) ! rho_ab_ij = zero c_ab_ij = zero ! do j = 1 , n_active_o do i = 1 , n_active_o ! ij = index_two ( i , j , n_active_o ) ! do b = 1 , n_active_v ! bj = index_two ( b , j , n_active_v ) ! do a = 1 , n_active_v ! ai = index_two ( a , i , n_active_v ) ab = index_two ( a , b , n_active_v ) ! c_ab_ij ( ab , ij ) = c_ai_bj ( ai , bj ) rho_ab_ij ( ab , ij ) = rho_ai_bj ( ai , bj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( c_ai_bj , n_active_o * n_active_v , n_active_o * n_active_v ) call wf % mem % dealloc ( rho_ai_bj , n_active_o * n_active_v , n_active_o * n_active_v ) ! call wf % jacobian_mlccsd_j2 ( rho_ab_ij , c_ab_ij ) call wf % jacobian_mlccsd_k2 ( rho_ab_ij , c_ab_ij ) ! !     Done with reordered doubles c; deallocate ! call wf % mem % dealloc ( c_ab_ij , ( n_active_v ) ** 2 , ( n_active_o ) ** 2 ) ! !     Order rho_ab_ij back into rho_ai_bj & divide by !     the biorthonormal factor 1 + delta_ai,bj ! call wf % mem % alloc ( rho_ai_bj , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * ( n_active_v )) ! do j = 1 , n_active_o do b = 1 , n_active_v ! bj = index_two ( b , j , n_active_v ) ! do i = 1 , n_active_o ! ij = index_two ( i , j , n_active_o ) ! do a = 1 , n_active_v ! ab = index_two ( a , b , n_active_v ) ai = index_two ( a , i , n_active_v ) ! if (( a . eq . b ) . and . ( i . eq . j )) then ! rho_ai_bj ( ai , bj ) = half * rho_ab_ij ( ab , ij ) ! else ! rho_ai_bj ( ai , bj ) = rho_ab_ij ( ab , ij ) ! endif ! enddo enddo enddo enddo ! !     Done with reordered transformed vector; deallocate ! call wf % mem % dealloc ( rho_ab_ij , ( n_active_v ) ** 2 , ( n_active_o ) ** 2 ) ! !     c_a_i -> rho_a_i !     c_ai_bj -> rho_ai_bj ! c_a_i = rho_a_i ! c_aibj = zero call packin ( c_aibj , rho_ai_bj , n_active_o * n_active_v ) ! !     Deallocations ! call wf % mem % dealloc ( rho_a_i , wf % n_v , wf % n_o ) call wf % mem % dealloc ( rho_ai_bj , n_active_o * n_active_v , n_active_o * n_active_v ) ! end subroutine jacobian_mlccsd_transformation_mlccsd ! ! module subroutine jacobian_mlccsd_b2_mlccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD B2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    rho_ai_bj&#94;B2 = - sum_kc (F_kc t_ij&#94;ac c_bk + F_kc t_ik&#94;ab c_cj) !! !!    The term is added as rho_ai_bj(ai,bj) = rho_ai_bj(ai,bj) + rho_ai_bj&#94;B2, !!    where c_a_i(a,i) = c_ai above. !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (:,:) :: rho_ai_bj ! real ( dp ), dimension (:,:), allocatable :: x_c_aij ! t_ij&#94;ac real ( dp ), dimension (:,:), allocatable :: x_aib_k ! t_ik&#94;ab ! real ( dp ), dimension (:,:), allocatable :: I_k_aij ! An intermediate real ( dp ), dimension (:,:), allocatable :: I_k_j ! An intermediate ! real ( dp ), dimension (:,:), allocatable :: rho_b_aij ! rho_ai_bj, unordered, term 1 real ( dp ), dimension (:,:), allocatable :: rho_aib_j ! rho_ai_bj, unordered, term 2 ! integer ( i15 ) :: a = 0 , c = 0 , i = 0 , j = 0 , b = 0 , k = 0 integer ( i15 ) :: ai = 0 , cj = 0 , aicj = 0 , aij = 0 , bj = 0 integer ( i15 ) :: bk = 0 , aibk = 0 , aib = 0 ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: first_CCSD_o ! first active occupied index integer ( i15 ) :: first_CCSD_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! !     :: Term 1. - sum_kc F_kc t_ij&#94;ac c_bk :: ! !     k           - general index !     c           - CC2 index !     a, b, i, j  - CCSD indices ! !     Read the amplitudes from disk ! call wf % read_amplitudes ! !     Order the amplitudes as t_c_aij = t_ij&#94;ac ! call wf % mem % alloc ( x_c_aij , n_CC2_v , ( n_CCSD_v ) * ( n_CCSD_o ** 2 )) ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! aij = index_three ( a , i , j , n_CCSD_v , n_CCSD_o ) ! do c = 1 , n_CC2_v ! cj = index_two ( c , j , n_CC2_v ) ! aicj = index_packed ( ai , cj ) ! x_c_aij ( c , aij ) = wf % x2am ( aicj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !     Form the intermediate I_k_aij = sum_c F_k_c * x_c_aij ! call wf % mem % alloc ( I_K_aij , wf % n_o , ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 , & n_CC2_v , & one , & wf % fock_ia , & wf % n_o , & x_c_aij , & n_CC2_v , & zero , & I_k_aij , & wf % n_o ) ! call wf % mem % dealloc ( x_c_aij , n_CC2_v , ( n_CCSD_v ) * ( n_CCSD_o ** 2 )) ! !     Form rho_b_aij = sum_k c_b_k X_k_aij(k,aij) ! call wf % mem % alloc ( rho_b_aij , n_CCSD_v , ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & n_CCSD_v , & ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 , & wf % n_o , & - one , & c_a_i , & ! c_b_k wf % n_v , & I_k_aij , & wf % n_o , & zero , & rho_b_aij , & n_CCSD_v ) ! call wf % mem % dealloc ( I_k_aij , wf % n_o , ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 ) ! !     Add rho_b_aij to rho_ai_bj ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! aij = index_three ( a , i , j , n_CCSD_v , n_CCSD_o ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_b_aij ( b , aij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_b_aij , n_CCSD_v , ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 ) ! ! !     :: Term 2. - sum_kc F_kc t_ik&#94;ab c_cj :: ! !     c           - general index !     k           - CC2 index !     a, b, i, j  - CCSD indices ! !     Form I_k_j = sum_c F_kc c_cj = sum_c fock_ia(k,c) c_a_i(c,j) ! call wf % mem % alloc ( I_k_j , n_CC2_o , n_CCSD_o ) ! call dgemm ( 'N' , 'N' , & n_CC2_o , & n_CCSD_o , & wf % n_v , & one , & wf % fock_ia , & ! F_k_c wf % n_o , & c_a_i , & ! c_c_j wf % n_v , & zero , & I_k_j , & n_CC2_o ) ! !     Order the amplitudes as x_aib_k = t_ik&#94;ab ! call wf % read_amplitudes ! call wf % mem % alloc ( x_aib_k , (( n_CCSD_v ) ** 2 ) * ( n_CCSD_o ), n_CC2_o ) x_aib_k = zero ! do k = 1 , n_CC2_o do b = 1 , n_CCSD_v ! bk = index_two ( b , k , n_CC2_v ) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! aib = index_three ( a , i , b , n_CCSD_v , n_CCSD_o ) ! aibk = index_packed ( ai , bk ) ! x_aib_k ( aib , k ) = wf % x2am ( aibk , 1 ) ! enddo enddo enddo enddo ! !     Deallocate doubles amplitudes ! call wf % destruct_x2am ! !     Form rho_aib_j = - sum_k x_aib_k I_k_j ! call wf % mem % alloc ( rho_aib_j , ( n_CCSD_o ) * ( n_CCSD_v ) ** 2 , n_CCSD_o ) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ) ** 2 , & n_CCSD_o , & n_CC2_o , & - one , & x_aib_k , & ( n_CCSD_o ) * ( n_CCSD_v ) ** 2 , & I_k_j , & n_CC2_o , & zero , & rho_aib_j , & ( n_CCSD_o ) * ( n_CCSD_v ) ** 2 ) ! call wf % mem % dealloc ( I_k_j , n_CC2_o , n_CCSD_o ) call wf % mem % dealloc ( x_aib_k , ( n_CCSD_o ) * ( n_CCSD_v ) ** 2 , n_CC2_o ) ! do a = 1 , n_CCSD_v do i = 1 , n_CCSD_o ! ai = index_two ( a , i , n_CC2_v ) ! do b = 1 , n_CCSD_v ! aib = index_three ( a , i , b , n_CCSD_v , n_CCSD_o ) ! do j = 1 , n_CCSD_o ! bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aib_j ( aib , j ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aib_j , ( n_CCSD_o ) * ( n_CCSD_v ) ** 2 , n_CCSD_o ) ! end subroutine jacobian_mlccsd_b2_mlccsd ! ! module subroutine jacobian_mlccsd_c2_mlccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD C2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Aug 2017 !! !!    rho_ai_bj&#94;C2 = sum_kcl (g_ljkc * t_ki&#94;ac * c_bl) + (g_ljkc * t_li&#94;bc * c_ak) !!                         + (g_ljkc * t_lk&#94;ba * c_ci) !!                         - (L_ljkc * t_ik&#94;ac * c_bl)- (L_ljkc * t_il&#94;ab * c_ck) !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (:,:) :: rho_ai_bj ! real ( dp ), dimension (:,:), allocatable :: x_ai_kc real ( dp ), dimension (:,:), allocatable :: x_kc_ai real ( dp ), dimension (:,:), allocatable :: x_ab_kl real ( dp ), dimension (:,:), allocatable :: x_aib_l real ( dp ), dimension (:,:), allocatable :: c_kc real ( dp ), dimension (:,:), allocatable :: g_kc_lj real ( dp ), dimension (:,:), allocatable :: g_lj_kc real ( dp ), dimension (:,:), allocatable :: g_lc_jk real ( dp ), dimension (:,:), allocatable :: g_kj_lc real ( dp ), dimension (:,:), allocatable :: g_kl_jc real ( dp ), dimension (:,:), allocatable :: I_lj_ai real ( dp ), dimension (:,:), allocatable :: I_kl_ji real ( dp ), dimension (:,:), allocatable :: I_bi_jk real ( dp ), dimension (:,:), allocatable :: I_ab_jc real ( dp ), dimension (:,:), allocatable :: I_ljk_i real ( dp ), dimension (:,:), allocatable :: I_lj real ( dp ), dimension (:,:), allocatable :: rho_b_jai real ( dp ), dimension (:,:), allocatable :: rho_bij_a real ( dp ), dimension (:,:), allocatable :: rho_ab_ji real ( dp ), dimension (:,:), allocatable :: rho_aib_j ! integer ( i15 ) :: i = 0 , k = 0 , j = 0 , l = 0 integer ( i15 ) :: a = 0 , b = 0 , c = 0 ! integer ( i15 ) :: ab = 0 integer ( i15 ) :: ai = 0 , ak = 0 , ci = 0 , ck = 0 , bj = 0 , bl = 0 , ai_CC2 integer ( i15 ) :: kc = 0 , lc = 0 , jc = 0 integer ( i15 ) :: jl = 0 , lj = 0 , kl = 0 , ji = 0 , kj = 0 , jk = 0 integer ( i15 ) :: jai = 0 , bij = 0 , abj = 0 , ljk = 0 , aib = 0 integer ( i15 ) :: akci = 0 , akbl = 0 , aick = 0 , aibl = 0 ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: first_CCSD_o ! first active occupied index integer ( i15 ) :: first_CCSD_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index integer ( i15 ) :: last_CCSD_o ! first active occupied index integer ( i15 ) :: last_CCSD_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! !     Construct x_ai_kc (= t_ki&#94;ac) for term 1 !     Will also be used as t_li&#94;bc for term 2 ! call wf % read_amplitudes ! call wf % mem % alloc ( x_ai_kc , n_CCSD_v * n_CCSD_o , n_CC2_v * n_CC2_o ) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! do k = 1 , n_CC2_o ! ak = index_two ( a , k , n_CC2_v ) ! do c = 1 , n_CC2_v ! kc = index_two ( k , c , n_CC2_o ) ci = index_two ( c , i , n_CC2_v ) ! akci = index_packed ( ak , ci ) ! x_ai_kc ( ai , kc ) = wf % x2am ( akci , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !     :: Term 1 :: !     sum_kcl (g_ljkc * t_ki&#94;ac * c_bl) ! !     l           - general index !     k, c        - CC2 indices !     a, i, b, j  - CCSD indices ! !     Construct g_kc_lj (=g_lj,kc) ! call wf % mem % alloc ( g_lj_kc , ( wf % n_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_lj_kc , & 1 , wf % n_o , & first_CCSD_o , last_CCSD_o , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !     I_ai_lj = sum_(kc) x_ai_kc*g_kc_lj ! call wf % mem % alloc ( I_lj_ai , ( wf % n_o ) * ( n_CCSD_o ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( n_CCSD_o ), & ( n_CCSD_o ) * ( n_CCSD_v ), & n_CC2_o * n_CC2_v , & one , & g_lj_kc , & ( wf % n_o ) * ( n_CCSD_o ), & x_ai_kc , & ( n_CCSD_o ) * ( n_CCSD_v ), & zero , & I_lj_ai , & ( wf % n_o ) * ( n_CCSD_o )) ! call wf % mem % dealloc ( g_lj_kc , ( wf % n_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) ! !     rho_b_jai = sum_(l) I_lj_ai * c_bl ! call wf % mem % alloc ( rho_b_jai , n_CCSD_v , ( n_CCSD_o ** 2 ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'N' , & n_CCSD_v , & ( n_CCSD_o ** 2 ) * ( n_CCSD_v ), & wf % n_o , & one , & c_a_i , & ! c_b_l wf % n_v , & I_lj_ai , & ! I_l_jai wf % n_o , & zero , & rho_b_jai , & ( n_CCSD_v )) ! ! call wf % mem % dealloc ( I_lj_ai , ( wf % n_o ) * ( n_CCSD_o ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !     Add terms to rho_ai_bj ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! do j = 1 , n_CCSD_o ! jai = index_three ( j , a , i , n_CCSD_o , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_b_jai ( b , jai ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_b_jai , n_CCSD_v , ( n_CCSD_o ** 2 ) * ( n_CCSD_v )) ! !     :: Term 2 :: !     sum_kcl (g_ljkc * x_li&#94;bc * c_ak) ! !     k           - general index !     l, c        - CC2 index !     b, i, j, a  - CCSD index ! !     Construct g_kj_lc (= g_ljkc) ! call wf % mem % alloc ( g_kc_lj , ( wf % n_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CC2_o )) ! integral_type = 'electronic_repulsion' call wf % get_ov_oo ( integral_type , g_kc_lj , & 1 , wf % n_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o ) ! !     Reorder g_kc_lj to g_lc_jk ! call wf % mem % alloc ( g_lc_jk , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( wf % n_o )) ! do j = 1 , n_CCSD_o do l = 1 , n_CC2_o ! lj = index_two ( l , j , n_CC2_o ) ! do c = 1 , n_CC2_v ! lc = index_two ( l , c , n_CC2_o ) ! do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) jk = index_two ( j , k , n_CCSD_o ) ! g_lc_jk ( lc , jk ) = g_kc_lj ( kc , lj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_lj , ( wf % n_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CCSD_o )) ! !     I_bi_jk = sum_(kc) t_bi_lc*g_lc_jk ! call wf % mem % alloc ( I_bi_jk , ( n_CCSD_o ) * ( n_CCSD_v ), ( wf % n_o ) * ( n_CCSD_o )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( wf % n_o ) * ( n_CCSD_o ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & x_ai_kc , & ! x_bi_lc ( n_CCSD_o ) * ( n_CCSD_v ), & g_lc_jk , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & I_bi_jk , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( g_lc_jk , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( wf % n_o )) call wf % mem % dealloc ( x_ai_kc , n_CCSD_v * n_CCSD_o , n_CC2_v * n_CC2_o ) ! !     rho_bij_a = sum_(k) I_bi_jk * c_ak ! call wf % mem % alloc ( rho_bij_a , ( n_CCSD_o ** 2 ) * ( n_CCSD_v ), n_CCSD_v ) call dgemm ( 'N' , 'T' , & ( n_CCSD_o ** 2 ) * ( n_CCSD_v ), & n_CCSD_v , & wf % n_o , & one , & I_bi_jk , & !I_bij_k ( n_CCSD_o ** 2 ) * ( n_CCSD_v ), & c_a_i , & wf % n_v , & zero , & rho_bij_a , & ( n_CCSD_o ** 2 ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( I_bi_jk , ( n_CCSD_o ) * ( n_CCSD_v ), ( wf % n_o ) * ( n_CCSD_o )) ! !     Add terms to rho_ai_bj ! do i = 1 , n_CCSD_o do b = 1 , n_CCSD_v ! do j = 1 , n_CCSD_o ! bj = index_two ( b , j , n_CC2_v ) bij = index_three ( b , i , j , n_CCSD_v , n_CCSD_o ) ! do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_bij_a ( bij , a ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_bij_a , ( n_CCSD_o ** 2 ) * ( n_CCSD_v ), n_CCSD_v ) ! !     :: Term 3 :: !     sum_(kcl) g_ljkc * t_lk&#94;ba * c_ci ! !     c           - general index !     l, k        - CC2 indices !     i, j, a, b, - CCSD indices ! !     Construct and reorder t_kl&#94;ab to t_ab_kl ! call wf % read_amplitudes ! call wf % mem % alloc ( x_ab_kl , n_CCSD_v ** 2 , n_CC2_o ** 2 ) ! do b = 1 , n_CCSD_v do a = 1 , n_CCSD_v ! ab = index_two ( a , b , n_CCSD_v ) ! do k = 1 , n_CC2_o ! ak = index_two ( a , k , n_CC2_v ) ! do l = 1 , n_CC2_o ! kl = index_two ( k , l , n_CC2_o ) bl = index_two ( b , l , n_CC2_v ) akbl = index_packed ( ak , bl ) ! x_ab_kl ( ab , kl ) = wf % x2am ( akbl , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! call wf % mem % alloc ( g_lj_kc , ( n_CC2_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_lj_kc , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o , & first_CC2_o , last_CC2_o , & 1 , wf % n_v ) ! !     I_ljk_i = sum_(c) g_lj_kc * c_ci ! call wf % mem % alloc ( I_ljk_i , ( n_CC2_o ** 2 ) * ( n_CCSD_o ), ( n_CCSD_o )) ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ** 2 ) * ( n_CCSD_o ), & n_CCSD_o , & wf % n_v , & one , & g_lj_kc , & ! \"g_ljk_c\" ( n_CC2_o ** 2 ) * ( n_CCSD_o ), & c_a_i , & wf % n_v , & zero , & I_ljk_i , & ( n_CC2_o ** 2 ) * ( n_CCSD_o )) ! call wf % mem % dealloc ( g_lj_kc , ( n_CC2_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( wf % n_v )) ! !     Reorder I_kjl_i to I_kl_ji ! call wf % mem % alloc ( I_kl_ji , n_CC2_o ** 2 , n_CCSD_o ** 2 ) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o ! ji = index_two ( j , i , n_CCSD_o ) ! do k = 1 , n_CC2_o do l = 1 , n_CC2_o ! ljk = index_three ( l , j , k , n_CC2_o , n_CCSD_o ) ! kl = index_two ( k , l , n_CC2_o ) ! I_kl_ji ( kl , ji ) = I_ljk_i ( ljk , i ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( I_ljk_i , ( n_CC2_o ** 2 ) * ( n_CCSD_o ), ( n_CCSD_o )) ! !     rho_ab_ji = sum_(kl) t_ab_kl * I_kl_ji ! call wf % mem % alloc ( rho_ab_ji , n_CCSD_v ** 2 , n_CCSD_o ** 2 ) ! call dgemm ( 'N' , 'N' , & n_CCSD_v ** 2 , & n_CCSD_o ** 2 , & n_CC2_o ** 2 , & one , & x_ab_kl , & n_CCSD_v ** 2 , & I_kl_ji , & n_CC2_o ** 2 , & zero , & rho_ab_ji , & n_CCSD_v ** 2 ) ! call wf % mem % dealloc ( I_kl_ji , n_CC2_o ** 2 , n_CCSD_o ** 2 ) call wf % mem % dealloc ( x_ab_kl , n_CCSD_v ** 2 , n_CC2_o ** 2 ) ! !     Reorder into rho_ai_bj ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o ! ji = index_two ( j , i , n_CCSD_o ) ! do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! do b = 1 , n_CCSD_v ! ab = index_two ( a , b , n_CCSD_v ) bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ab_ji ( ab , ji ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ab_ji , n_CCSD_v ** 2 , n_CCSD_o ** 2 ) ! !     :: Term 4 :: !     - sum_(klc) L_ljkc * t_ik&#94;ac * c_bl !     = - 2 sum_(klc) g_ljkc * t_ik&#94;ac * c_bl !         + sum_(klc) g_kjlc * t_ik&#94;ac * c_bl !     = (4a) + (4b) ! !     Construct t_ik&#94;ac ordered as t_kc_ai ! call wf % read_amplitudes ! call wf % mem % alloc ( x_kc_ai , n_CC2_o * n_CC2_v , n_CCSD_o * n_CCSD_v ) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ai_CC2 = index_two ( a , i , n_CC2_v ) ! do k = 1 , n_CC2_o do c = 1 , n_CC2_v ! kc = index_two ( k , c , n_CC2_o ) ck = index_two ( c , k , n_CC2_v ) aick = index_packed ( ai_CC2 , ck ) ! x_kc_ai ( kc , ai ) = wf % x2am ( aick , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !     :: 4a :: !     - 2 sum_(klc) g_ljkc * t_ik&#94;ac * c_bl ! !     l           - general index !     k, c        - CC2 indices !     a, i, b, j  - CCSD indices ! !     Construct g_ljkc ! call wf % mem % alloc ( g_lj_kc , ( wf % n_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_lj_kc , & 1 , wf % n_o , & first_CCSD_o , last_CCSD_o , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !     I_lj_ai = - 2sum_(ck) g_lj_kc *t_kc_ai ! call wf % mem % alloc ( I_lj_ai ,( wf % n_o ) * ( n_CCSD_o ), ( n_CCSD_v ) * ( n_CCSD_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( n_CCSD_o ), & ( n_CCSD_v ) * ( n_CCSD_o ), & ( n_CC2_v ) * ( n_CC2_o ), & - two , & g_lj_kc , & ( wf % n_o ) * ( n_CCSD_o ), & x_kc_ai , & ( n_CC2_v ) * ( n_CC2_o ), & zero , & I_lj_ai , & ( wf % n_o ) * ( n_CCSD_o )) ! call wf % mem % dealloc ( g_lj_kc , ( wf % n_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) ! !     :: 4b :: !     sum_(klc) g_kjlc * t_ik&#94;ac * c_bl !     l           - general index !     k, c        - CC2 indices !     a, i, j, b  - CCSD indices ! !     Construct g_kjlc ! call wf % mem % alloc ( g_kj_lc , ( n_CC2_o ) * ( n_CCSD_o ), ( wf % n_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_kj_lc , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o , & 1 , wf % n_o , & first_CC2_v , last_CC2_v ) ! !     Reorder g_kj_lc to g_lj_kc ! call wf % mem % alloc ( g_lj_kc , ( wf % n_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) ! do j = 1 , n_CCSD_o do c = 1 , n_CC2_v do l = 1 , wf % n_o ! lj = index_two ( l , j , wf % n_o ) ! do k = 1 , n_CC2_o ! kj = index_two ( k , j , n_CC2_o ) ! kc = index_two ( k , c , n_CC2_o ) lc = index_two ( l , c , wf % n_o ) ! g_lj_kc ( lj , kc ) = g_kj_lc ( kj , lc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kj_lc , ( n_CC2_o ) * ( n_CCSD_o ), ( wf % n_o ) * ( n_CC2_v )) ! !     I_lj_ai += sum_(kc) g_lj_kc * x_kc_ai ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( n_CCSD_o ), & ( n_CCSD_v ) * ( n_CCSD_o ), & ( n_CC2_v ) * ( n_CC2_o ), & one , & g_lj_kc , & ( wf % n_o ) * ( n_CCSD_o ), & x_kc_ai , & ( n_CC2_v ) * ( n_CC2_o ), & one , & I_lj_ai , & ( wf % n_o ) * ( n_CCSD_o )) ! call wf % mem % dealloc ( g_lj_kc , ( wf % n_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) call wf % mem % dealloc ( x_kc_ai , n_CC2_o * n_CC2_v , n_CCSD_o * n_CCSD_v ) ! !     rho_b_jai = sum_(l) c_bl *I_lj_ai ! call wf % mem % alloc ( rho_b_jai , n_CCSD_v , ( n_CCSD_v ) * ( n_CCSD_o ** 2 )) ! call dgemm ( 'N' , 'N' , & n_CCSD_v , & ( n_CCSD_v ) * ( n_CCSD_o ** 2 ), & wf % n_o , & one , & c_a_i , & ! c_bl wf % n_v , & I_lj_ai , & ! I_l_jai wf % n_o , & zero , & rho_b_jai , & ( n_CCSD_v )) ! call wf % mem % dealloc ( I_lj_ai ,( wf % n_o ) * ( n_CCSD_o ), ( n_CCSD_v ) * ( n_CCSD_o )) ! !     Add terms to rho_ai_bj ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! do j = 1 , n_CCSD_o ! jai = index_three ( j , a , i , n_CCSD_o , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_b_jai ( b , jai ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_b_jai , n_CCSD_v , ( n_CCSD_o ) * ( n_CCSD_v ) * n_CCSD_o ) !     :: Term 5 :: !     - sum_(klc) L_ljkc * t_il&#94;ab * c_ck !     = - 2 sum_(klc) g_ljkc * t_il&#94;ab * c_ck !         + sum_(klc) g_kjlc * t_il&#94;ab * c_ck !     = (5a) + (5b) ! call wf % read_amplitudes ! call wf % mem % alloc ( x_aib_l , ( n_CCSD_o ) * ( n_CCSD_v ** 2 ), n_CC2_o ) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! do l = 1 , n_CC2_o do b = 1 , n_CCSD_v ! bl = index_two ( b , l , n_CC2_v ) ! aib = index_three ( a , i , b , n_CCSD_v , n_CCSD_o ) ! aibl = index_packed ( ai , bl ) ! x_aib_l ( aib , l ) = wf % x2am ( aibl , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !     :: 5a :: !     - 2 sum_(klc) g_ljkc * t_il&#94;ab * c_ck ! !     k, c        - general index !     l           - CC2 index !     a, i, b, j  - CCSD index ! !     Construct g_ljkc ! call wf % mem % alloc ( g_lj_kc , ( n_CC2_o ) * ( n_CCSD_o ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_lj_kc , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o , & 1 , wf % n_o , & 1 , wf % n_v ) ! call wf % mem % alloc ( c_kc , ( wf % n_o ) * ( wf % n_v ), 1 ) ! do c = 1 , wf % n_v do k = 1 , wf % n_o kc = index_two ( k , c , wf % n_o ) c_kc ( kc , 1 ) = c_a_i ( c , k ) enddo enddo ! call wf % mem % alloc ( I_lj , ( n_CC2_o ) * ( n_CCSD_o ), 1 ) ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) * ( n_CCSD_o ), & 1 , & ( wf % n_o ) * ( wf % n_v ), & - two , & g_lj_kc , & ( n_CC2_o ) * ( n_CCSD_o ), & c_kc , & ( wf % n_o ) * ( wf % n_v ), & zero , & I_lj , & ( n_CC2_o ) * ( n_CCSD_o )) ! call wf % mem % dealloc ( g_lj_kc , ( n_CC2_o ) * ( n_CCSD_o ), ( wf % n_o ) * ( wf % n_v )) ! !     :: 5a :: !     sum_(klc) g_kjlc * t_il&#94;ab * c_ck ! !     k, c        - general index !     l           - CC2 index !     a, i, b, j  - CCSD index ! !     Construct g_ljkc call wf % mem % alloc ( g_kj_lc , ( wf % n_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_kj_lc , & 1 , wf % n_o , & first_CCSD_o , last_CCSD_o , & first_CC2_o , last_CC2_o , & 1 , wf % n_v ) ! !     Reorder g_kj_lc to g_lj_kc ! call wf % mem % alloc ( g_lj_kc , ( n_CC2_o ) * ( n_CCSD_o ), ( wf % n_o ) * ( wf % n_v )) ! do j = 1 , n_CCSD_o do c = 1 , wf % n_v do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) kj = index_two ( k , j , wf % n_o ) ! do l = 1 , n_CC2_o ! lj = index_two ( l , j , n_CC2_o ) lc = index_two ( l , c , n_CC2_o ) ! g_lj_kc ( lj , kc ) = g_kj_lc ( kj , lc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kj_lc , ( wf % n_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) * ( n_CCSD_o ), & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & g_lj_kc , & ( n_CC2_o ) * ( n_CCSD_o ), & c_kc , & ( wf % n_o ) * ( wf % n_v ), & one , & I_lj , & ( n_CC2_o ) * ( n_CCSD_o )) ! call wf % mem % dealloc ( g_lj_kc , ( n_CC2_o ) * ( n_CCSD_o ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( c_kc , ( wf % n_o ) * ( wf % n_v ), 1 ) ! call wf % mem % alloc ( rho_aib_j ,( n_CCSD_o ) * ( n_CCSD_v ** 2 ), n_CCSD_o ) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ** 2 ), & n_CCSD_o , & n_CC2_o , & one , & x_aib_l , & ( n_CCSD_o ) * ( n_CCSD_v ** 2 ), & I_lj , & n_CC2_o , & zero , & rho_aib_j , & ( n_CCSD_o ) * ( n_CCSD_v ** 2 )) ! call wf % mem % dealloc ( I_lj , ( n_CC2_o ) * ( n_CCSD_o ), 1 ) call wf % mem % dealloc ( x_aib_l , ( n_CCSD_o ) * ( n_CCSD_v ** 2 ), n_CC2_o ) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! do j = 1 , n_CCSD_o do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) aib = index_three ( a , i , b , n_CCSD_v , n_CCSD_o ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aib_j ( aib , j ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aib_j ,( n_CCSD_o ) * ( n_CCSD_v ** 2 ), n_CCSD_o ) ! end subroutine jacobian_mlccsd_c2_mlccsd ! ! module subroutine jacobian_mlccsd_d2_mlccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD D2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    rho_ai_bj&#94;D2 = - sum_kcd g_kcbd (x_ij&#94;cd c_ak + x_kj&#94;ad c_ci + x_ik&#94;ca c_dj) !!                       + sum_kcd L_kcbd (x_ik&#94;ac c_dj + x_ij&#94;ad c_ck) !! !!    Note: the code is structured so that we batch over the index b, !!          where the integrals are made as g_kc_db = g_kcbd and held !!          in some ordering or other throughout a given batch (i.e., !!          all five terms are constructed gradually in the batches). !! !!    The term is added as rho_ai_bj(ai,bj) = rho_ai_bj(ai,bj) + rho_ai_bj&#94;D2, !!    where c_a_i(a,i) = c_ai above. !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (:,:) :: rho_ai_bj ! real ( dp ), dimension (:,:), allocatable :: L_kc_J real ( dp ), dimension (:,:), allocatable :: L_bd_J ! real ( dp ), dimension (:,:), allocatable :: g_kc_bd real ( dp ), dimension (:,:), allocatable :: g_kc_bd_CC2 real ( dp ), dimension (:,:), allocatable :: g_kd_bc real ( dp ), dimension (:,:), allocatable :: g_kb_cd ! real ( dp ), dimension (:,:), allocatable :: L_kc_bd real ( dp ), dimension (:,:), allocatable :: L_kcb_d real ( dp ), dimension (:,:), allocatable :: L_ck_bd ! real ( dp ), dimension (:,:), allocatable :: x_cd_ij real ( dp ), dimension (:,:), allocatable :: x_aj_kd real ( dp ), dimension (:,:), allocatable :: x_ai_kc real ( dp ), dimension (:,:), allocatable :: x_d_aij ! real ( dp ), dimension (:,:), allocatable :: I_bd real ( dp ), dimension (:,:), allocatable :: I_kb_ij real ( dp ), dimension (:,:), allocatable :: I_kcb_j real ( dp ), dimension (:,:), allocatable :: I_kdb_i ! real ( dp ), dimension (:,:), allocatable :: c_ck ! real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_CCSD real ( dp ), dimension (:,:), allocatable :: rho_b_aij real ( dp ), dimension (:,:), allocatable :: rho_a_bij real ( dp ), dimension (:,:), allocatable :: rho_aj_bi ! ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_b_length = 0 , batch_dimension = 0 integer ( i15 ) :: n_batch = 0 , b_first = 0 , b_last = 0 , b_batch = 0 , b_length = 0 ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 ! integer ( i15 ) :: ai = 0 , aj = 0 , ak = 0 , ai_CCSD = 0 , ai_CC2 = 0 integer ( i15 ) :: bi = 0 , bj = 0 , bd = 0 , bc = 0 , bj_CCSD = 0 integer ( i15 ) :: cd = 0 , ci = 0 , ck = 0 integer ( i15 ) :: dj = 0 integer ( i15 ) :: ij = 0 integer ( i15 ) :: kc = 0 , kb = 0 , kd = 0 , kc_CC2 ! integer ( i15 ) :: aij = 0 , bij = 0 , kcb = 0 ! integer ( i15 ) :: akdj = 0 , aidj = 0 , akci = 0 , cidj = 0 , aick = 0 ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: first_CCSD_o ! first active occupied index integer ( i15 ) :: first_CCSD_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index integer ( i15 ) :: last_CCSD_o ! first active occupied index integer ( i15 ) :: last_CCSD_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! !     Determine batch size, etc. !     (Redo estimate once loop is done) ! required = max ( 2 * ( n_CCSD_v ) * ( wf % n_o ) * ( wf % n_J ) + & 2 * ( wf % n_J ) * ( wf % n_v ) * ( n_CCSD_v ) + & ( n_CC2_o ** 2 ) * ( n_CC2_v ** 2 ), & ! Construction of L_bc&#94;J ( wf % n_J ) * ( wf % n_v ) * ( n_CCSD_v ) + & ( wf % n_o ) * (( wf % n_v ) ** 2 ) * ( n_CCSD_v ) + & ( n_CC2_o ** 2 ) * ( n_CC2_v ** 2 )) ! Holding L_bc&#94;J and g_aibc ! required = 4 * required ! Words available = get_available () ! batch_dimension = n_CCSD_v ! Batch over the virtual index b max_b_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_b_length , n_batch , batch_dimension ) ! do b_batch = 1 , n_batch ! !        Get batching limits ! call batch_limits ( b_first , b_last , b_batch , max_b_length , batch_dimension ) b_length = b_last - b_first + 1 ! !        Construct g_kcbd for the batch ! call wf % mem % alloc ( g_kc_bd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * b_length ) ! integral_type = 'electronic_repulsion' call wf % get_ov_vv ( integral_type , g_kc_bd , & 1 , wf % n_o , & 1 , wf % n_v , & b_first , b_last , & 1 , wf % n_v ) ! !        :: Term 1 :: !        - sum_kcd g_kcbd x_ij&#94;cd c_ak ! !        k           - general index !        c, d        - CC2 indices !        a, b, i, j  - CCSD indices ! !        Construct and order x_ij&#94;cd as x_cd_ij ! call wf % read_amplitudes ! call wf % mem % alloc ( x_cd_ij , n_CC2_v ** 2 , n_CCSD_o ** 2 ) ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o ! ij = index_two ( i , j , n_CCSD_o ) ! do d = 1 , n_CC2_v ! dj = index_two ( d , j , n_CC2_v ) ! do c = 1 , n_CC2_v ! ci = index_two ( c , i , n_CC2_v ) cd = index_two ( c , d , n_CC2_v ) cidj = index_packed ( ci , dj ) ! x_cd_ij ( cd , ij ) = wf % x2am ( cidj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !        Reorder g_kc_bd to g_kb_cd with c and d restricted to the CC2 space ! call wf % mem % alloc ( g_kb_cd , ( wf % n_o ) * b_length , n_CC2_v ** 2 ) ! do c = 1 , n_CC2_v do d = 1 , n_CC2_v ! cd = index_two ( c , d , n_CC2_v ) ! do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) ! do b = 1 , b_length ! bd = index_two ( b , d , b_length ) kb = index_two ( k , b , wf % n_o ) ! g_kb_cd ( kb , cd ) = g_kc_bd ( kc , bd ) ! enddo enddo enddo enddo ! !        I_kb_ij = sum(cd) g_kb_cd * x_cd_ij ! call wf % mem % alloc ( I_kb_ij , ( wf % n_o ) * b_length , n_CCSD_o ** 2 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( b_length ), & n_CCSD_o ** 2 , & n_CC2_v ** 2 , & one , & g_kb_cd , & ( wf % n_o ) * ( b_length ), & x_cd_ij , & n_CC2_v ** 2 , & zero , & I_kb_ij , & ( wf % n_o ) * ( b_length )) ! call wf % mem % dealloc ( g_kb_cd , ( wf % n_o ) * b_length , n_CC2_v ** 2 ) call wf % mem % dealloc ( x_cd_ij , n_CC2_v ** 2 , n_CCSD_o ** 2 ) ! !        rho_a_bij = - sum_k c_a_k* I_kb_ij ! call wf % mem % alloc ( rho_a_bij , n_CCSD_v , b_length * ( n_CCSD_o ** 2 )) ! call dgemm ( 'N' , 'N' , & n_CCSD_v , & b_length * ( n_CCSD_o ** 2 ), & wf % n_o , & - one , & c_a_i , & ! c_a_k wf % n_v , & I_kb_ij , & ! I_k_bij wf % n_o , & zero , & rho_a_bij , & n_CCSD_v ) call wf % mem % dealloc ( I_kb_ij , ( wf % n_o ) * b_length , n_CCSD_o ** 2 ) ! !        Add to rho_ai_bj ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! do b = 1 , b_length ! bj = index_two ( b + b_first - 1 , j , n_CC2_v ) ! bij = index_three ( b , i , j , b_length , n_CCSD_o ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_a_bij ( a , bij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_a_bij , n_CCSD_v , b_length * ( n_CCSD_o ** 2 )) ! !        :: Term 2 :: !        - sum_kcd g_kcbd x_kj&#94;ad c_ci ! !        c           - general index !        k, d        - CC2 indices !        a, b, i, j  - CCSD indices ! !        Reorder g_kc_bd to g_kd_bc and constrain k and d to CC2 space ! call wf % mem % alloc ( g_kd_bc , ( n_CC2_o ) * ( n_CC2_v ), b_length * ( wf % n_v )) ! do k = 1 , n_CC2_o do d = 1 , n_CC2_v ! kd = index_two ( k , d , n_CC2_o ) ! do b = 1 , b_length ! bd = index_two ( b , d , b_length ) ! do c = 1 , wf % n_v ! bc = index_two ( b , c , b_length ) kc = index_two ( k , c , wf % n_o ) ! g_kd_bc ( kd , bc ) = g_kc_bd ( kc , bd ) ! enddo enddo enddo enddo ! !        I_kdb_i = sum_c g_kd_bc *c_ci ! call wf % mem % alloc ( I_kdb_i , ( b_length ) * ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o )) ! call dgemm ( 'N' , 'N' , & ( b_length ) * ( n_CC2_o ) * ( n_CC2_v ), & ( n_CCSD_o ), & wf % n_v , & one , & g_kd_bc , & ! g_kdb_c ( b_length ) * ( n_CC2_o ) * ( n_CC2_v ), & c_a_i , & ! c_c_i wf % n_v , & zero , & I_kdb_i , & ( b_length ) * ( n_CC2_o ) * ( n_CC2_v )) ! call wf % mem % dealloc ( g_kd_bc , ( n_CC2_o ) * ( n_CC2_v ), b_length * ( wf % n_v )) ! !        Construct and order  x_kj&#94;ad to x_aj_kd ! call wf % read_amplitudes ! call wf % mem % alloc ( x_aj_kd , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_v ) * ( n_CC2_o )) ! do j = 1 , n_CCSD_o do k = 1 , n_CC2_o do d = 1 , n_CC2_v ! dj = index_two ( d , j , n_CC2_v ) kd = index_two ( k , d , n_CC2_o ) ! do a = 1 , n_CCSD_v ! aj = index_two ( a , j , n_CCSD_v ) ak = index_two ( a , k , n_CC2_v ) akdj = index_packed ( ak , dj ) ! x_aj_kd ( aj , kd ) = wf % x2am ( akdj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !        rho_aj_bi = -sum_(kd) I_kdb_i * x_aj_kd ! call wf % mem % alloc ( rho_aj_bi , ( n_CCSD_o ) * ( n_CCSD_v ), b_length * n_CCSD_o ) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & b_length * n_CCSD_o , & ( n_CC2_v ) * ( n_CC2_o ), & - one , & x_aj_kd , & ( n_CCSD_o ) * ( n_CCSD_v ), & I_kdb_i , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_aj_bi , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( I_kdb_i , ( b_length ) * ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o )) ! call wf % mem % dealloc ( x_aj_kd , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_v ) * ( n_CC2_o )) ! !        Add to rho_ai_bj ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) aj = index_two ( a , j , n_CCSD_v ) ! do b = 1 , b_length ! bi = index_two ( b , i , b_length ) bj = index_two ( b + b_first - 1 , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aj_bi ( aj , bi ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aj_bi , ( n_CCSD_o ) * ( n_CCSD_v ), b_length * n_CCSD_o ) ! !        :: Term 3 :: !        - sum_kcd g_kcbd x_ik&#94;ca c_dj ! !        d           - general index !        k, c        - CC2 indices !        a, b, i, j  - CCSD indices ! !        Constrain k, c to CC2 space for g_kc_bd ! call wf % mem % alloc ( g_kc_bd_CC2 , ( n_CC2_o ) * ( n_CC2_v ), ( b_length ) * ( wf % n_v )) ! do k = 1 , n_CC2_o do c = 1 , n_CC2_v ! kc = index_two ( k , c , wf % n_o ) kc_CC2 = index_two ( k , c , n_CC2_o ) ! g_kc_bd_CC2 ( kc_CC2 , :) = g_kc_bd ( kc , :) ! enddo enddo ! !        I_kcb_j = sum_(d) g_kc_bd_CC2 * c_d_j ! call wf % mem % alloc ( I_kcb_j , ( n_CC2_o ) * ( n_CC2_v ) * b_length , n_CCSD_o ) ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) * ( n_CC2_v ) * b_length , & n_CCSD_o , & wf % n_v , & one , & g_kc_bd_CC2 , & ! g_kcb_d ( n_CC2_o ) * ( n_CC2_v ) * b_length , & c_a_i , & wf % n_v , & zero , & I_kcb_j , & ( n_CC2_o ) * ( n_CC2_v ) * b_length ) ! call wf % mem % dealloc ( g_kc_bd_CC2 , ( n_CC2_o ) * ( n_CC2_v ), ( b_length ) * ( wf % n_v )) ! !        Construct and order x_ik&#94;ca as x_ai_kc ! call wf % read_amplitudes ! call wf % mem % alloc ( x_ai_kc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_v ) * ( n_CC2_o )) ! do i = 1 , n_CCSD_o do k = 1 , n_CC2_o do c = 1 , n_CC2_v ! ci = index_two ( c , i , n_CC2_v ) kc = index_two ( k , c , n_CC2_o ) ! do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ak = index_two ( a , k , n_CC2_v ) akci = index_packed ( ak , ci ) ! x_ai_kc ( ai , kc ) = wf % x2am ( akci , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !        rho_ai_bj_CCSD = -sum_(kc) x_ai_kc * I_kcb_j ! call wf % mem % alloc ( rho_ai_bj_CCSD , n_CCSD_o * n_CCSD_v , ( b_length ) * ( n_CCSD_o )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( b_length ) * ( n_CCSD_o ), & ( n_CC2_o ) * ( n_CC2_v ), & - one , & x_ai_kc , & ( n_CCSD_o ) * ( n_CCSD_v ), & I_kcb_j , & ! I_kc_bj ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_ai_bj_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( x_ai_kc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_v ) * ( n_CC2_o )) call wf % mem % dealloc ( I_kcb_j , ( n_CC2_o ) * ( n_CC2_v ) * b_length , n_CCSD_o ) ! !        Add to rho_ai_bj ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , b_length ! bj_CCSD = index_two ( b , j , b_length ) bj = index_two ( b + b_first - 1 , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), b_length * n_CCSD_o ) ! !        Construct L_kcbd for the batch (constrain k to CC2 space) ! call wf % mem % alloc ( L_kc_bd , ( n_CC2_o ) * ( wf % n_v ), ( wf % n_v ) * b_length ) ! do c = 1 , wf % n_v do k = 1 , n_CC2_o ! kc = index_two ( k , c , wf % n_o ) kc_CC2 = index_two ( k , c , n_CC2_o ) ! do d = 1 , wf % n_v ! kd = index_two ( k , d , wf % n_o ) ! do b = 1 , b_length ! bd = index_two ( b , d , b_length ) bc = index_two ( b , c , b_length ) ! L_kc_bd ( kc_CC2 , bd ) = two * g_kc_bd ( kc , bd ) - g_kc_bd ( kd , bc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_bd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * b_length ) ! !       :: Term 4 :: !       sum_(kcd) L_kcbd x_ik&#94;ac c_dj ! !       d           - general index !       k, c        - CC2 indices !       a, b, i, j  - CCSD indices ! call wf % mem % alloc ( L_kcb_d , n_CC2_o * n_CC2_v * b_length , wf % n_v ) ! do c = 1 , n_CC2_v do k = 1 , n_CC2_o ! kc = index_two ( k , c , n_CC2_o ) ! do d = 1 , wf % n_v ! do b = 1 , b_length ! bd = index_two ( b , d , b_length ) kcb = index_three ( k , c , b , n_CC2_o , n_CC2_v ) ! L_kcb_d ( kcb , d ) = L_kc_bd ( kc , bd ) ! enddo enddo enddo enddo ! !        I_kc_bj = sum_(d) L_kc_bd *c_dj ! call wf % mem % alloc ( I_kcb_j , ( n_CC2_o ) * ( n_CC2_v ) * ( b_length ), ( n_CCSD_o )) ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) * ( n_CC2_v ) * ( b_length ), & ( n_CCSD_o ), & wf % n_v , & one , & L_kcb_d , & ! L_kcb_d ( n_CC2_o ) * ( n_CC2_v ) * ( b_length ), & c_a_i , & wf % n_v , & zero , & I_kcb_j , & ( n_CC2_o ) * ( n_CC2_v ) * ( b_length )) ! call wf % mem % dealloc ( L_kcb_d , n_CC2_o * n_CC2_v * b_length , wf % n_v ) ! !        Construct x_ik&#94;ac ordered as x_ai_kc with ! call wf % read_amplitudes ! call wf % mem % alloc ( x_ai_kc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_v ) * ( n_CC2_o )) ! do i = 1 , n_CCSD_o do k = 1 , n_CC2_o do c = 1 , n_CC2_v ! ck = index_two ( c , k , n_CC2_v ) kc = index_two ( k , c , n_CC2_o ) ! do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ai_CC2 = index_two ( a , i , n_CC2_v ) ! aick = index_packed ( ai_CC2 , ck ) ! x_ai_kc ( ai , kc ) = wf % x2am ( aick , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !        rho_ai_bj_CCSD = x_ai_kc * I_kcb_j ! call wf % mem % alloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( b_length ) * ( n_CCSD_o )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( b_length ) * ( n_CCSD_o ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & x_ai_kc , & ( n_CCSD_o ) * ( n_CCSD_v ), & I_kcb_j , & ! I_kc_bj ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_ai_bj_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( I_kcb_j , ( n_CC2_o ) * ( n_CC2_v ) * ( b_length ), ( n_CCSD_o )) call wf % mem % dealloc ( x_ai_kc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_v ) * ( n_CC2_o )) ! !        Add to rho_ai_bj ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , b_length ! bj_CCSD = index_two ( b , j , b_length ) bj = index_two ( b + b_first - 1 , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), b_length * n_CCSD_o ) ! !        :: Term 5 :: !        sum_kcd L_kcbd t_ij&#94;ad c_ck ! !        c           - general index !        k, d        - CC2 indices !        a, b, i, j  - CCSD indices ! ! !        Reorder L_kc_bd to L_ck_bd and constrain d to CC2 space ! call wf % mem % alloc ( L_ck_bd , ( wf % n_v ) * ( n_CC2_o ), ( n_CC2_v ) * ( b_length )) ! do k = 1 , n_CC2_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) kc = index_two ( k , c , n_CC2_o ) ! do d = 1 , n_CC2_v do b = 1 , b_length ! bd = index_two ( b , d , b_length ) ! L_ck_bd ( ck , bd ) = L_kc_bd ( kc , bd ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( L_kc_bd , ( n_CC2_o ) * ( wf % n_v ), ( wf % n_v ) * b_length ) ! !        I_bd = sum_(ck) L_ck_bd * c_ck ! call wf % mem % alloc ( I_bd , 1 , b_length * n_CC2_v ) ! call dgemm ( 'N' , 'N' , & 1 , & b_length * n_CC2_v , & ( n_CC2_o ) * ( wf % n_v ), & one , & c_a_i , & 1 , & L_ck_bd , & ( n_CC2_o ) * ( wf % n_v ), & zero , & I_bd , & 1 ) ! call wf % mem % dealloc ( L_ck_bd , ( wf % n_v ) * ( n_CC2_o ), ( n_CC2_v ) * ( b_length )) ! !        Construct x_ij&#94;ad ordered as x_d_aij ! call wf % read_amplitudes ! call wf % mem % alloc ( x_d_aij , ( n_CC2_v ), ( n_CCSD_o ** 2 ) * ( n_CCSD_v )) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do d = 1 , n_CC2_v ! dj = index_two ( d , j , n_CC2_v ) ! do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) aij = index_three ( a , i , j , n_CCSD_v , n_CCSD_o ) ! aidj = index_packed ( ai , dj ) ! x_d_aij ( d , aij ) = wf % x2am ( aidj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !        rho_b_aij = sum(d) I_bd * x_d_aij ! call wf % mem % alloc ( rho_b_aij , b_length , ( n_CCSD_v ) * ( n_CCSD_o ** 2 )) ! call dgemm ( 'N' , 'N' , & b_length , & ( n_CCSD_v ) * ( n_CCSD_o ** 2 ), & n_CC2_v , & one , & I_bd , & ! I_b_d b_length , & x_d_aij , & n_CC2_v , & zero , & rho_b_aij , & b_length ) ! call wf % mem % dealloc ( I_bd , 1 , b_length * n_CC2_v ) call wf % mem % dealloc ( x_d_aij , ( n_CC2_v ), ( n_CCSD_o ** 2 ) * ( n_CCSD_v )) ! !        Add to rho_ai_bj ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) aij = index_three ( a , i , j , n_CCSD_v , n_CCSD_o ) ! do b = 1 , b_length ! bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_b_aij ( b , aij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_b_aij , b_length , ( n_CCSD_v ) * ( n_CCSD_o ** 2 )) ! enddo ! End of batches over b ! ! end subroutine jacobian_mlccsd_d2_mlccsd ! ! module subroutine jacobian_mlccsd_e2_mlccsd ( wf , rho_ai_bj , c_ai_ck ) !! !!    Jacobian MLCCSD E2 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    rho_ai_bj&#94;E2 = 2 sum_dlck x_bj,DL * L_KC,LD * c_ai,CK !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_ck ! real ( dp ), dimension (:,:), allocatable :: x_dl_bj real ( dp ), dimension (:,:), allocatable :: g_kc_ld real ( dp ), dimension (:,:), allocatable :: L_ck_dl real ( dp ), dimension (:,:), allocatable :: I_ck_bj real ( dp ), dimension (:,:), allocatable :: c_ai_ck_CCSD real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_CCSD ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 , i = 0 , j = 0 , k = 0 , l = 0 integer ( i15 ) :: ck = 0 , dl = 0 , kc = 0 , kd = 0 , lc = 0 , ld = 0 integer ( i15 ) :: ai = 0 , bj = 0 , ai_CCSD = 0 , bj_CCSD = 0 integer ( i15 ) :: dlbj = 0 ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: first_CCSD_o ! first active occupied index integer ( i15 ) :: first_CCSD_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index integer ( i15 ) :: last_CCSD_o ! first active occupied index integer ( i15 ) :: last_CCSD_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! !     Read X2 amplitudes from disk ! call wf % read_amplitudes ! call wf % mem % alloc ( x_dl_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! do l = 1 , n_CC2_o do d = 1 , n_CC2_v ! dl = index_two ( d , l , n_CC2_v ) ! do j = 1 , n_CCSD_o do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bj_CCSD = index_two ( b , j , n_CCSD_v ) dlbj = index_packed ( dl , bj ) ! x_dl_bj ( dl , bj_CCSD ) = wf % x2am ( dlbj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! call wf % mem % alloc ( g_kc_ld , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !     Construct L_kc,ld ordered as L_ck_dl ! call wf % mem % alloc ( L_ck_dl , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) L_ck_dl = zero ! do l = 1 , n_CC2_o do d = 1 , n_CC2_v ! dl = index_two ( d , l , n_CC2_v ) ld = index_two ( l , d , n_CC2_o ) ! do k = 1 , n_CC2_o ! kd = index_two ( k , d , n_CC2_o ) ! do c = 1 , n_CC2_v ! ck = index_two ( c , k , n_CC2_v ) kc = index_two ( k , c , n_CC2_o ) lc = index_two ( l , c , n_CC2_o ) ! L_ck_dl ( ck , dl ) = two * g_kc_ld ( kc , ld ) - g_kc_ld ( kd , lc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_ld , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     Intermediate I_ck_bj = sum_dl L_ck_dl * x_dl_bj ! call wf % mem % alloc ( I_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) * ( n_CC2_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & L_ck_dl , & ( n_CC2_o ) * ( n_CC2_v ), & x_dl_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & I_ck_bj , & ( n_CC2_o ) * ( n_CC2_v )) ! call wf % mem % dealloc ( x_dl_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( L_ck_dl , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     rho_ai_bj = 2 * sum_ck c_ai_CK * I_CK_bj ! call wf % mem % alloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % alloc ( c_ai_ck_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do a = 1 , n_CCSD_v do i = 1 , n_CCSD_o ai_CCSD = index_two ( a , i , n_CCSD_v ) ai = index_two ( a , i , n_CC2_v ) c_ai_ck_CCSD ( ai_CCSD , :) = c_ai_ck ( ai , :) enddo enddo ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & two , & c_ai_ck_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v ), & I_ck_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_ai_bj_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( I_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( c_ai_ck_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bj_CCSD = index_two ( b , j , n_CCSD_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! end subroutine jacobian_mlccsd_e2_mlccsd ! ! module subroutine jacobian_mlccsd_f2_mlccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian MLCCSD F2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;F2 =   - sum_(CKDL) x_ai,CK * L_KC,LD * c_bL,Dj !!                        - sum_(CKDL) x_ai,Dj * L_KC,LD * c_bL,CK !!                        - sum_(CKDL) x_ai_bL * L_KC,LD * c_CK,Dj !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_bj ! real ( dp ), dimension (:,:), allocatable :: L_KC_J real ( dp ), dimension (:,:), allocatable :: g_KC_LD ! real ( dp ), dimension (:,:), allocatable :: L_CK_DL real ( dp ), dimension (:,:), allocatable :: L_D_LCK real ( dp ), dimension (:,:), allocatable :: L_L_CKD ! real ( dp ), dimension (:,:), allocatable :: c_DL_bj ! real ( dp ), dimension (:,:), allocatable :: x_ai_CK real ( dp ), dimension (:,:), allocatable :: x_aij_D real ( dp ), dimension (:,:), allocatable :: x_aib_L ! real ( dp ), dimension (:,:), allocatable :: I_D_b real ( dp ), dimension (:,:), allocatable :: I_L_j real ( dp ), dimension (:,:), allocatable :: I_CK_bj ! real ( dp ), dimension (:,:), allocatable :: rho_aij_b real ( dp ), dimension (:,:), allocatable :: rho_aib_j real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_CCSD ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ai = 0 , bj = 0 , bk = 0 , bl = 0 , ck = 0 , cl = 0 , dj = 0 , dl = 0 integer ( i15 ) :: ai_CC2 = 0 , ai_CCSD = 0 , bj_CCSD = 0 integer ( i15 ) :: kc = 0 , kd = 0 , ld = 0 , lc = 0 ! integer ( i15 ) :: aij = 0 , aib = 0 , lck = 0 , ckd = 0 ! integer ( i15 ) :: bldj = 0 , aidj = 0 , bkcl = 0 , aibl = 0 , aick = 0 ! !        Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index ! !        Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! !        :: Construct L_kc,ld :: ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! call wf % mem % alloc ( L_CK_DL , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) L_CK_DL = zero ! !        Construct L_KC,LD ordered as L_CK_DL ! do C = 1 , n_CC2_v do K = 1 , n_CC2_o ! KC = index_two ( k , c , n_CC2_o ) CK = index_two ( c , k , n_CC2_v ) ! do D = 1 , n_CC2_v do L = 1 , n_CC2_o ! LC = index_two ( L , C , n_CC2_o ) LD = index_two ( L , D , n_CC2_o ) DL = index_two ( D , L , n_CC2_v ) KD = index_two ( K , D , n_CC2_o ) ! L_CK_DL ( CK , DL ) = two * g_KC_LD ( KC , LD ) - g_KC_LD ( KD , LC ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        :: Term 1: - sum_CKLD t_ai,CK * L_KC,LD * c_bL,Dj :: ! !        Reorder c_bL_Dj as c_DL_bj, ! call wf % mem % alloc ( c_DL_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) c_DL_bj = zero ! do L = 1 , n_CC2_o do j = 1 , n_CCSD_o do D = 1 , n_CC2_v ! dj = index_two ( d , j , n_CC2_v ) dl = index_two ( d , l , n_CC2_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) bl = index_two ( b , l , n_CC2_v ) ! c_dl_bj ( dl , bj ) = c_ai_bj ( bl , dj ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( I_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !        I_ck_bj = sum_dl L_CK_DL*c_DL_bj = sum_DL L_KC,LD*c_bL,Dj ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) * ( n_CC2_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & L_ck_dl , & ( n_CC2_o ) * ( n_CC2_v ), & c_dl_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & I_ck_bj , & ( n_CC2_o ) * ( n_CC2_v )) ! call wf % mem % dealloc ( c_DL_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( L_CK_DL , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! call wf % read_amplitudes ! call wf % mem % alloc ( x_ai_ck , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! AI_CC2 = index_two ( a , i , n_CC2_v ) ai = index_two ( a , i , n_CCSD_v ) ! do K = 1 , n_CC2_o do C = 1 , n_CC2_v ! CK = index_two ( C , K , n_CC2_v ) AICK = index_packed ( AI_CC2 , CK ) ! x_ai_ck ( ai , ck ) = wf % x2am ( AICK , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !        rho_ai_bj = sum_ck t_ai_ck*I_ck_bj ! call wf % mem % alloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & - one , & x_ai_ck , & ( n_CCSD_o ) * ( n_CCSD_v ), & I_ck_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_ai_bj_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( I_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( x_ai_ck , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Add to rho_ai_bj ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bj_CCSD = index_two ( b , j , n_CCSD_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !        :: Term 2: - sum_ckdl x_ai,dj * L_kc,ld * c_bl,ck ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !        Construct L_ck,dl reordered as L_d_clk ! call wf % mem % alloc ( L_D_LCK , n_CC2_v , ( n_CC2_v ) * (( n_CC2_o ) ** 2 )) ! do K = 1 , n_CC2_o do L = 1 , n_CC2_o do C = 1 , n_CC2_v ! LCK = index_three ( L , C , K , n_CC2_o , n_CC2_v ) ! KC = index_two ( K , C , n_CC2_o ) LC = index_two ( L , C , n_CC2_o ) ! do D = 1 , n_CC2_v ! LD = index_two ( L , D , n_CC2_o ) KD = index_two ( K , D , n_CC2_o ) ! L_D_LCK ( D , LCK ) = two * g_KC_LD ( KC , LD ) - g_KC_LD ( KD , LC ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        I_d_b = sum_clk L_d_LCK * c_b_LCK !        Here dgemm is tricked to believe that c_bL_CK is c_b_LCK ! call wf % mem % alloc ( I_D_b , n_CC2_v , n_CCSD_v ) ! call dgemm ( 'N' , 'T' , & n_CC2_v , & n_CCSD_v , & (( n_CC2_o ) ** 2 ) * ( n_CC2_v ), & one , & L_d_lck , & n_CC2_v , & c_ai_bj , & ! c_b_lck n_CC2_v , & zero , & I_d_b , & n_CC2_v ) ! call wf % mem % dealloc ( L_D_LCK , n_CC2_v , ( n_CC2_v ) * (( n_CC2_o ) ** 2 )) ! call wf % read_amplitudes ! call wf % mem % alloc ( x_aij_d , ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), n_CC2_v ) ! !        Reorder X2 amplitudes ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o do D = 1 , n_CC2_v ! dj = index_two ( d , j , n_CC2_v ) ! do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! aij = index_three ( a , i , j , n_CCSD_v , n_CCSD_o ) ! aidj = index_packed ( ai , dj ) ! x_aij_D ( aij , D ) = wf % x2am ( aidj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! call wf % mem % alloc ( rho_aij_b , ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), n_CCSD_v ) ! !        rho_aij_b = sum_d t_aij_d*Y_d_b ! call dgemm ( 'N' , 'N' , & ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), & n_CCSD_v , & n_CC2_v , & - one , & x_aij_d , & ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), & I_d_b , & n_CC2_v , & zero , & rho_aij_b , & ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 )) ! call wf % mem % dealloc ( x_aij_d , ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), n_CC2_v ) call wf % mem % dealloc ( I_D_b , n_CC2_v , n_CCSD_v ) ! !        Adding term 2 to rho_ai_bj ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! aij = index_three ( a , i , j , n_CCSD_v , n_CCSD_o ) ! ai = index_two ( a , i , n_CC2_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aij_b ( aij , b ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aij_b , ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), n_CCSD_v ) ! !        :: Term 3: - sum_(CKDL) x_ai,bL * L_KC,LD * c_CK,Dj :: ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! call wf % mem % alloc ( L_L_CKD , ( n_CC2_o ), ( n_CC2_o ) * (( n_CC2_v ) ** 2 )) ! !        Construct L_kc,dl ordered as L_l_ckd ! do C = 1 , n_CC2_v do K = 1 , n_CC2_o ! KC = index_two ( K , C , n_CC2_o ) ! do D = 1 , n_CC2_v ! CKD = index_three ( C , K , D , n_CC2_v , n_CC2_o ) ! do L = 1 , n_CC2_o ! LC = index_two ( L , C , n_CC2_o ) LD = index_two ( L , D , n_CC2_o ) KD = index_two ( K , D , n_CC2_o ) ! L_L_CKD ( L , CKD ) = two * g_KC_LD ( KC , LD ) - g_KC_LD ( KD , LC ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! call wf % mem % alloc ( I_L_j , n_CC2_o , n_CCSD_o ) ! !        I_L_j = sum_(CKD) L_L_CKD * c_CKD_j ! call dgemm ( 'N' , 'N' , & n_CC2_o , & n_CCSD_o , & (( n_CC2_v ) ** 2 ) * ( n_CC2_o ), & one , & L_L_CKD , & n_CC2_o , & c_ai_bj , & ! c_ai_bj(ck,dl)= c_ckd_l (( n_CC2_v ) ** 2 ) * ( n_CC2_o ), & zero , & I_L_j , & n_CC2_o ) ! call wf % mem % dealloc ( L_L_CKD , ( n_CC2_o ), ( n_CC2_o ) * (( n_CC2_v ) ** 2 )) ! call wf % read_amplitudes ! call wf % mem % alloc ( x_aib_L , ( n_CCSD_o ) * (( n_CCSD_v ) ** 2 ), n_CC2_o ) ! do L = 1 , n_CC2_o do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! do b = 1 , n_CCSD_v ! bl = index_two ( b , l , n_CC2_v ) ! aib = index_three ( a , i , b , n_CCSD_v , n_CCSD_o ) ! aibl = index_packed ( ai , bl ) ! x_aib_L ( aib , L ) = wf % x2am ( aibl , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !        rho_ai_bj_CCSD = sum_L x_aib_L * I_L_j ! call wf % mem % alloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ** 2 ), & n_CCSD_o , & n_CC2_o , & - one , & x_aib_L , & ( n_CCSD_o ) * ( n_CCSD_v ** 2 ), & I_l_j , & n_CC2_o , & zero , & rho_ai_bj_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v ** 2 )) ! call wf % mem % dealloc ( x_aib_L , ( n_CCSD_o ) * (( n_CCSD_v ) ** 2 ), n_CC2_o ) call wf % mem % dealloc ( I_L_j , n_CC2_o , n_CCSD_o ) ! !        Add to rho_ai_bj ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bj_CCSD = index_two ( b , j , n_CCSD_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! end subroutine jacobian_mlccsd_f2_mlccsd ! ! module subroutine jacobian_mlccsd_g2_mlccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian MLCCSD G2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;G2 =  - sum_ckdl x_bL,Dj * L_KC,LD * c_ai,CK !!                       - sum_ckdl x_CK_bL * L_KC,LD * c_ai,Dj !!                       - sum_ckld x_CK,Dj * L_KC,LD * c_ai,bL !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_bj ! real ( dp ), dimension (:,:), allocatable :: g_KC_LD ! real ( dp ), dimension (:,:), allocatable :: L_CK_DL real ( dp ), dimension (:,:), allocatable :: L_D_CLK real ( dp ), dimension (:,:), allocatable :: L_L_CKD ! real ( dp ), dimension (:,:), allocatable :: c_ai_ck real ( dp ), dimension (:,:), allocatable :: c_aib_l real ( dp ), dimension (:,:), allocatable :: c_aij_d ! real ( dp ), dimension (:,:), allocatable :: x_dl_bj real ( dp ), dimension (:,:), allocatable :: x_clk_b real ( dp ), dimension (:,:), allocatable :: x_ckd_j ! real ( dp ), dimension (:,:), allocatable :: I_ck_bj real ( dp ), dimension (:,:), allocatable :: I_d_b real ( dp ), dimension (:,:), allocatable :: I_l_j ! real ( dp ), dimension (:,:), allocatable :: rho_aij_b real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_CCSD ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ai = 0 , bj = 0 , bk = 0 , bl = 0 , ck = 0 , cl = 0 , dj = 0 , dl = 0 integer ( i15 ) :: kc = 0 , lc = 0 , kd = 0 , ld = 0 integer ( i15 ) :: ai_CCSD = 0 , ai_CC2 = 0 , bj_CCSD = 0 ! integer ( i15 ) :: aib = 0 , aij = 0 , ckd = 0 , clk = 0 ! integer ( i15 ) :: ckbl = 0 , ckdj = 0 , bldj = 0 ! !        Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index ! !        Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! !        :: Term 1: - sum_ckdl t_bl,dj * L_kc,ld * c_ai,ck  :: ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! call wf % mem % alloc ( L_CK_DL , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Construct L_kc_ld ordered as L_ck_dl ! do C = 1 , n_CC2_v do K = 1 , n_CC2_o ! KC = index_two ( K , C , n_CC2_o ) CK = index_two ( C , K , n_CC2_v ) ! do D = 1 , n_CC2_v do L = 1 , n_CC2_o ! LC = index_two ( L , C , n_CC2_o ) LD = index_two ( L , D , n_CC2_o ) DL = index_two ( D , L , n_CC2_v ) KD = index_two ( K , D , n_CC2_o ) ! L_CK_DL ( CK , DL ) = two * g_KC_LD ( KC , LD ) - g_KC_LD ( KD , LC ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Reorder t_bl_dj as t_dl_bj ! call wf % read_amplitudes ! call wf % mem % alloc ( x_DL_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! do L = 1 , n_CC2_o do j = 1 , n_CCSD_o do D = 1 , n_CC2_v ! dj = index_two ( d , j , n_CC2_v ) dl = index_two ( d , l , n_CC2_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) bl = index_two ( b , l , n_CC2_v ) ! bldj = index_packed ( bl , dj ) ! x_dl_bj ( dl , bj ) = wf % x2am ( bldj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! call wf % mem % alloc ( I_CK_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !        I_CK_bj = sum_dl x_bL,Dj * L_KC,LD = sum_dl L_CK_DL t_DL_bj ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) * ( n_CC2_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & L_CK_DL , & ( n_CC2_o ) * ( n_CC2_v ), & x_DL_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & I_CK_bj , & ( n_CC2_o ) * ( n_CC2_v )) ! call wf % mem % dealloc ( x_DL_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( L_CK_DL , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        rho_ai_bj =+ - sum_CK c_ai,CK X_CK_bj ! call wf % mem % alloc ( c_ai_CK , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do a = 1 , n_CCSD_v do i = 1 , n_CCSD_o ! ai = index_two ( a , i , n_CCSD_v ) ai_CC2 = index_two ( a , i , n_CC2_v ) ! c_ai_CK ( ai ,:) = c_ai_bj ( ai_CC2 , :) ! enddo enddo ! call wf % mem % alloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & - one , & c_ai_ck , & ( n_CCSD_o ) * ( n_CCSD_v ), & I_ck_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_ai_bj_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( c_ai_CK , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) call wf % mem % dealloc ( I_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !        Add to rho_ai_bj ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bj_CCSD = index_two ( b , j , n_CCSD_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !        :: Term 2: - sum_ckdl t_ck_bl * L_kc,ld * c_ai,dj ! ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !        Reorder L_ck_dl to L_d_clk ! call wf % mem % alloc ( L_D_CLK , n_CC2_v , ( n_CC2_v ) * (( n_CC2_o ) ** 2 )) ! do K = 1 , n_CC2_o do L = 1 , n_CC2_o do C = 1 , n_CC2_v ! CLK = index_three ( C , L , K , n_CC2_v , n_CC2_o ) ! KC = index_two ( K , C , n_CC2_o ) LC = index_two ( L , C , n_CC2_o ) ! do D = 1 , n_CC2_v ! LD = index_two ( L , D , n_CC2_o ) KD = index_two ( K , D , n_CC2_o ) ! L_D_CLK ( D , CLK ) = two * g_KC_LD ( KC , LD ) - g_KC_LD ( KD , LC ) ! enddo enddo enddo enddo call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Reorder x_ck,bl as x_clk_b ! call wf % read_amplitudes ! call wf % mem % alloc ( x_CLK_b , ( n_CC2_v ) * (( n_CC2_o ) ** 2 ), n_CCSD_v ) ! do K = 1 , n_CC2_o do L = 1 , n_CC2_o do C = 1 , n_CC2_v ! CK = index_two ( C , K , n_CC2_v ) ! CLK = index_three ( C , L , K , n_CC2_v , n_CC2_o ) ! do b = 1 , n_CCSD_v ! BL = index_two ( b , l , n_CC2_v ) ! CKBL = index_packed ( CK , BL ) ! x_CLK_b ( CLK , b ) = wf % x2am ( ckbl , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! !        I_D_b = sum_CLK L_D_CLK * c_CLK_b ! call wf % mem % alloc ( I_D_b , n_CC2_v , n_CCSD_v ) ! call dgemm ( 'N' , 'N' , & n_CC2_v , & n_CCSD_v , & (( n_CC2_o ) ** 2 ) * n_CC2_v , & one , & L_D_CLK , & n_CC2_v , & x_CLK_b , & (( n_CC2_o ) ** 2 ) * n_CC2_v , & zero , & I_D_b , & n_CC2_v ) ! call wf % mem % dealloc ( x_CLK_b , ( n_CC2_v ) * (( n_CC2_o ) ** 2 ), n_CCSD_v ) call wf % mem % dealloc ( L_D_CLK , n_CC2_v , ( n_CC2_v ) * (( n_CC2_o ) ** 2 )) ! call wf % mem % alloc ( c_aij_D , ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), n_CC2_v ) ! !        Reorder c_ai_dj to c_aij_d ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o do d = 1 , n_CC2_v ! dj = index_two ( d , j , n_CC2_v ) ! do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! aij = index_three ( a , i , j , n_CCSD_v , n_CCSD_o ) ! c_aij_d ( aij , d ) = c_ai_bj ( ai , dj ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( rho_aij_b , ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), n_CCSD_v ) ! !        rho_aij_b = sum_d c_aij_d * I_d_b ! call dgemm ( 'N' , 'N' , & ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), & n_CCSD_v , & n_CC2_v , & - one , & c_aij_D , & ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), & I_d_b , & n_CC2_v , & zero , & rho_aij_b , & ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 )) ! call wf % mem % dealloc ( c_aij_D , ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), n_CC2_v ) call wf % mem % dealloc ( I_D_b , n_CC2_v , n_CCSD_v ) ! !        Adding term 2 to rho_ai_bj ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! aij = index_three ( a , i , j , n_CCSD_v , n_CCSD_o ) ! ai = index_two ( a , i , n_CC2_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aij_b ( aij , b ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aij_b , ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), n_CCSD_v ) ! !        :: Term 3: - sum_ckld x_ck,dj * L_kc,ld * c_ai,bl :: ! ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! call wf % mem % alloc ( L_L_CKD , n_CC2_o , ( n_CC2_o ) * (( n_CC2_v ) ** 2 )) ! !        Construct L_kc_ld ordered as  L_l_ckd ! do C = 1 , n_CC2_v do K = 1 , n_CC2_o ! KC = index_two ( K , C , n_CC2_o ) ! do D = 1 , n_CC2_v ! CKD = index_three ( C , K , D , n_CC2_v , n_CC2_o ) ! do L = 1 , n_CC2_o ! LC = index_two ( L , C , n_CC2_o ) LD = index_two ( L , D , n_CC2_o ) KD = index_two ( K , D , n_CC2_o ) ! L_L_CKD ( L , CKD ) = two * g_KC_LD ( KC , LD ) - g_KC_LD ( KD , LC ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Reorder x_ck,dj to x_ckd_j ! call wf % read_amplitudes ! call wf % mem % alloc ( x_ckd_j , ( n_CC2_v ** 2 ) * ( n_CC2_o ), n_CCSD_o ) ! do K = 1 , n_CC2_o do C = 1 , n_CC2_v ! CK = index_two ( C , K , n_CC2_v ) ! do D = 1 , n_CC2_v ! CKD = index_three ( C , K , D , n_CC2_v , n_CC2_o ) ! do j = 1 , n_CCSD_o ! DJ = index_two ( D , j , n_CC2_v ) ! CKDJ = index_packed ( CK , DJ ) ! x_CKD_j ( CKD , j ) = wf % x2am ( CKDJ , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! call wf % mem % alloc ( I_L_j , n_CC2_o , n_CCSD_o ) ! !        I_L_j = sum_ckd L_L_CKD*x_CKD_j ! call dgemm ( 'N' , 'N' , & n_CC2_o , & n_CCSD_o , & (( n_CC2_v ) ** 2 ) * n_CC2_o , & one , & L_l_ckd , & n_CC2_o , & x_ckd_j , & (( n_CC2_v ) ** 2 ) * n_CC2_o , & zero , & I_l_j , & n_CC2_o ) ! call wf % mem % dealloc ( L_L_CKD , n_CC2_o , ( n_CC2_o ) * (( n_CC2_v ) ** 2 )) call wf % mem % dealloc ( x_ckd_j , ( n_CC2_v ** 2 ) * ( n_CC2_o ), n_CCSD_o ) ! !        rho_aib_j = sum_L c_aib_L*I_L_j ! call wf % mem % alloc ( c_aib_L , n_CCSD_o * ( n_CCSD_v ** 2 ), n_CC2_o ) ! do L = 1 , n_CC2_o do b = 1 , n_CCSD_v ! BL = index_two ( B , L , n_CC2_v ) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! AI = index_two ( A , I , n_CC2_v ) ! aib = index_three ( a , i , b , n_CCSD_v , n_CCSD_o ) ! c_aib_L ( aib , L ) = c_ai_bj ( AI , BL ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'N' , & n_CCSD_o * ( n_CCSD_v ** 2 ), & n_CCSD_o , & n_CC2_o , & - one , & c_aib_L , & n_CCSD_o * ( n_CCSD_v ** 2 ), & I_L_j , & n_CC2_o , & zero , & rho_ai_bj_CCSD , & n_CCSD_o * ( n_CCSD_v ** 2 )) ! call wf % mem % dealloc ( c_aib_L , n_CCSD_o * ( n_CCSD_v ** 2 ), n_CC2_o ) call wf % mem % dealloc ( I_L_j , wf % n_o , wf % n_o ) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bj_CCSD = index_two ( b , j , n_CCSD_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! end subroutine jacobian_mlccsd_g2_mlccsd ! ! module subroutine jacobian_mlccsd_h2_mlccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian MLCCSD H2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;H2 =  sum_CKDL x_Ci,aK * g_KC,LD * c_bL,Dj !!                     + sum_CKDL x_Cj,aL * g_KC,LD * c_bK,Di !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_bj ! real ( dp ), dimension (:,:), allocatable :: g_kc_ld real ( dp ), dimension (:,:), allocatable :: g_lc_kd ! real ( dp ), dimension (:,:), allocatable :: x_ai_kc real ( dp ), dimension (:,:), allocatable :: x_aj_lc ! real ( dp ), dimension (:,:), allocatable :: c_ld_bj real ( dp ), dimension (:,:), allocatable :: c_kd_bi ! real ( dp ), dimension (:,:), allocatable :: I_ai_ld real ( dp ), dimension (:,:), allocatable :: I_aj_kd ! real ( dp ), dimension (:,:), allocatable :: rho_aj_bi real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_CCSD ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ak = 0 , ai = 0 , aj = 0 , al = 0 , bi = 0 , bj = 0 , bk = 0 , bl = 0 , ci = 0 , cj = 0 , di = 0 , dj = 0 integer ( i15 ) :: kc = 0 , kd = 0 , ld = 0 , lc = 0 integer ( i15 ) :: ai_CCSD = 0 , bj_CCSD = 0 integer ( i15 ) :: akci = 0 , alcj = 0 ! !        Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index ! !        Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! !        :: Term 1: sum_ckld t_ci,ak * g_kc,ld * c_bl,dj :: ! !        Construct g_kc_ld ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !        x_ak,ci ordered as x_ai_kc ! call wf % read_amplitudes ! call wf % mem % alloc ( x_ai_kc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! do c = 1 , n_CC2_v do k = 1 , n_CC2_o ! CI = index_two ( c , i , n_CC2_v ) AK = index_two ( a , k , n_CC2_v ) KC = index_two ( k , c , n_CC2_o ) ! AKCI = index_packed ( AK , CI ) ! x_ai_KC ( ai , KC ) = wf % x2am ( AKCI , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! call wf % mem % alloc ( I_ai_ld , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        I_ai_ld = sum_ck t_ai_kc*g_kc_ld ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & x_ai_KC , & ( n_CCSD_o ) * ( n_CCSD_v ), & g_kc_LD , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & I_ai_LD , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( x_ai_KC , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! call wf % mem % alloc ( c_LD_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !        Reorder c_bl,dj as c_ld_bj ! do L = 1 , n_CC2_o do b = 1 , n_CCSD_v ! BL = index_two ( b , l , n_CC2_v ) ! do j = 1 , n_CCSD_o ! bj = index_two ( b , j , n_CCSD_v ) ! do D = 1 , n_CC2_v ! DJ = index_two ( D , J , n_CC2_v ) LD = index_two ( l , d , n_CC2_o ) ! c_LD_bj ( LD , bj ) = c_ai_bj ( BL , DJ ) ! enddo enddo enddo enddo ! !        rho_ai_bj += sum_ld X_ai_ld*c_ld_bj ! call wf % mem % alloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & I_ai_ld , & ( n_CCSD_o ) * ( n_CCSD_v ), & c_ld_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_ai_bj_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( c_LD_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( I_ai_ld , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bj_CCSD = index_two ( b , j , n_CCSD_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !        :: Term 2: sum_ckdl t_cj,al * g_kc,ld * c_bk,di ! !        Construct g_kc_ld ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !        Reorder g_kc_ld to g_lc_kd ! call wf % mem % alloc ( g_LC_KD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do C = 1 , n_CC2_v do D = 1 , n_CC2_v do K = 1 , n_CC2_o ! KC = index_two ( k , c , n_CC2_o ) KD = index_two ( k , d , n_CC2_o ) ! do L = 1 , n_CC2_o ! LC = index_two ( L , C , n_CC2_o ) LD = index_two ( L , D , n_CC2_o ) ! g_LC_KD ( LC , KD ) = g_KC_LD ( KC , LD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !       x_al,cj ordered as x_aj_lc ! call wf % read_amplitudes ! call wf % mem % alloc ( x_aj_lc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! aj = index_two ( a , j , n_CCSD_v ) ! do C = 1 , n_CC2_v ! CJ = index_two ( C , J , n_CC2_v ) ! do L = 1 , n_CC2_o ! AL = index_two ( A , L , n_CC2_v ) LC = index_two ( L , C , n_CC2_o ) ! ALCJ = index_packed ( AL , CJ ) ! x_aj_LC ( aj , LC ) = wf % x2am ( ALCJ , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_x2am ! call wf % mem % alloc ( I_aj_kd , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        I_aj_kd = sum_lc x_aj_lc * g_lc_kd ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & x_aj_lc , & ( n_CCSD_o ) * ( n_CCSD_v ), & g_lc_kd , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & I_aj_kd , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( g_LC_KD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) call wf % mem % dealloc ( x_aj_lc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Reorder c_bk,di as c_kd_bi ! call wf % mem % alloc ( c_kd_bi , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! do i = 1 , n_CCSD_o do k = 1 , n_CC2_o do d = 1 , n_CC2_v ! kd = index_two ( k , d , n_CC2_o ) di = index_two ( d , i , n_CC2_v ) ! do b = 1 , n_CCSD_v ! bk = index_two ( b , k , n_CC2_v ) bi = index_two ( b , i , n_CCSD_v ) ! c_kd_bi ( kd , bi ) = c_ai_bj ( bk , di ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( rho_aj_bi , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !        rho_aj_bi = sum_kd  Y_aj_kd * c_kd_bi ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & I_aj_kd , & ( n_CCSD_o ) * ( n_CCSD_v ), & c_kd_bi , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_aj_bi , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( c_kd_bi , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( I_aj_kd , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Reorder into rho_ai_bj ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! do j = 1 , n_CCSD_o ! aj = index_two ( a , j , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bi = index_two ( b , i , n_CCSD_v ) bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aj_bi ( aj , bi ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aj_bi , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! end subroutine jacobian_mlccsd_h2_mlccsd ! ! module subroutine jacobian_mlccsd_i2_mlccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian MLCCSD I2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;I2 =  sum_C F_bC * c_ai,Cj - sum_K F_jK * c_ai,bK !!                     + sum_ck L_bj,KC * c_ai,CK !!                     - sum_ck ( g_KC,bj * c_aK,Ci + g_Ki,bC * c_aK,Cj ) !! !!       Batch over c to construct  g_ki_bC !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_bj ! real ( dp ), dimension (:,:), allocatable :: c_aij_c real ( dp ), dimension (:,:), allocatable :: c_aib_k real ( dp ), dimension (:,:), allocatable :: c_ai_ck real ( dp ), dimension (:,:), allocatable :: c_aj_ck ! real ( dp ), dimension (:,:), allocatable :: rho_aij_b real ( dp ), dimension (:,:), allocatable :: rho_aib_j real ( dp ), dimension (:,:), allocatable :: rho_aj_bi real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_CCSD ! real ( dp ), dimension (:,:), allocatable :: g_bj_kc real ( dp ), dimension (:,:), allocatable :: g_bc_kj real ( dp ), dimension (:,:), allocatable :: g_ck_bj ! reordering of g_bj_kc and g_bc_kj ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 ! integer ( i15 ) :: ai = 0 , aj = 0 , ak = 0 , bi = 0 , bj = 0 , bk = 0 , ci = 0 , cj = 0 , ck = 0 integer ( i15 ) :: bc = 0 integer ( i15 ) :: kc = 0 integer ( i15 ) :: kj = 0 integer ( i15 ) :: ai_CCSD = 0 , ai_CC2 = 0 , bj_CCSD = 0 ! integer ( i15 ) :: aij = 0 , aib = 0 ! integer ( i15 ) :: offset = 0 ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , n_batch = 0 , batch_dimension = 0 integer ( i15 ) :: c_batch = 0 , c_first = 0 , c_last = 0 , c_length = 0 ! !        Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: first_CCSD_o ! first active occupied index integer ( i15 ) :: first_CCSD_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index integer ( i15 ) :: last_CCSD_o ! first active occupied index integer ( i15 ) :: last_CCSD_v ! first active virtual index ! !        Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! !        :: sum_c F_bC * c_ai,Cj :: ! !        Reorder c_ai,cj to c_aij_c ! call wf % mem % alloc ( c_aij_c , ( n_CC2_v ) * (( n_CC2_o ) ** 2 ), n_CC2_v ) ! do j = 1 , n_CC2_o do i = 1 , n_CC2_o do a = 1 , n_CC2_v ! ai = index_two ( a , i , n_CC2_v ) ! aij = index_three ( a , i , j , n_CC2_v , n_CC2_o ) ! do c = 1 , n_CC2_v ! cj = index_two ( c , j , n_CC2_v ) ! c_aij_c ( aij , c ) = c_ai_bj ( ai , cj ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( rho_aij_b , ( n_CC2_v ) * (( n_CC2_o ) ** 2 ), n_CC2_v ) ! !        rho_ai_bj += sum_c F_bc * c_ai,cj = sum_c c_aij_c(aij,c) F_ab(b,c) = sum_c c_aij_c(aij,c) F_ab&#94;T(c,b) ! call dgemm ( 'N' , 'T' , & ( n_CC2_v ) * (( n_CC2_o ) ** 2 ), & n_CC2_v , & n_CC2_v , & one , & c_aij_c , & ( n_CC2_v ) * (( n_CC2_o ) ** 2 ), & wf % fock_ab , & wf % n_v , & zero , & rho_aij_b , & ( n_CC2_v ) * (( n_CC2_o ) ** 2 )) ! call wf % mem % dealloc ( c_aij_c , ( n_CC2_v ) * (( n_CC2_o ) ** 2 ), n_CC2_v ) ! !        Reorder rho_aij_b into rho_ai_bj ! do i = 1 , n_CC2_o do j = 1 , n_CC2_o do a = 1 , n_CC2_v ! ai = index_two ( a , i , n_CC2_v ) ! aij = index_three ( a , i , j , n_CC2_v , n_CC2_o ) ! do b = 1 , n_CC2_v ! bj = index_two ( b , j , n_CC2_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aij_b ( aij , b ) ! enddo enddo enddo enddo ! ! call wf % mem % dealloc ( rho_aij_b , ( n_CCSD_v ) * (( n_CCSD_o ) ** 2 ), n_CCSD_v ) ! !       ::  - sum_k F_jk * c_ai,bk  :: ! !        rho_ai_bj += - sum_k F_jk * c_ai,bk = - sum_k c_aib_k(aib,k) F_ij(k,j)&#94;T ! call wf % mem % alloc ( c_aib_k , ( n_CC2_o ) * (( n_CC2_v ) ** 2 ), n_CC2_o ) ! do b = 1 , n_CC2_v do i = 1 , n_CC2_o do a = 1 , n_CC2_v ! ai = index_two ( a , i , n_CC2_v ) ! aib = index_three ( a , i , b , n_CC2_v , n_CC2_o ) ! do k = 1 , n_CC2_o ! bk = index_two ( b , k , n_CC2_v ) ! c_aib_k ( aib , k ) = c_ai_bj ( ai , bk ) ! enddo enddo enddo enddo ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) * (( n_CC2_v ) ** 2 ), & n_CC2_o , & n_CC2_o , & - one , & c_aib_k , & ( n_CC2_o ) * (( n_CC2_v ) ** 2 ), & wf % fock_ij , & wf % n_o , & one , & rho_ai_bj , & ( n_CC2_o ) * (( n_CC2_v ) ** 2 )) ! call wf % mem % dealloc ( c_aib_k , ( n_CC2_o ) * (( n_CC2_v ) ** 2 ), n_CC2_o ) ! !        ::   sum_ck L_bj,kc*c_ai,ck - sum_ck ( g_kc,bj*c_ak,ci + g_ki,bc*c_ak,cj ) :: ! !         sum_ck ( g_bj,kc*(2*c_ai,ck - c_ak,ci) - g_bc,kj*c_ai,ck - g_ki,bc*c_ak,cj ) ! !        Construct g_bj,kc ! call wf % mem % alloc ( g_bj_kc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_vo_ov ( integral_type , g_bj_kc , & first_CCSD_v , last_CCSD_v , & first_CCSD_o , last_CCSD_o , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !        Reordering g_bj_kc to g_ck_bj ! call wf % mem % alloc ( g_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! do j = 1 , n_CCSD_o do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) ! do k = 1 , n_CC2_o do c = 1 , n_CC2_v ! ck = index_two ( c , k , n_CC2_v ) kc = index_two ( k , c , n_CC2_o ) ! g_ck_bj ( ck , bj ) = g_bj_kc ( bj , kc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_bj_kc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !       rho_ai_bj += sum_ck 2*c_ai_ck * g_ck_bj ! call wf % mem % alloc ( c_ai_ck , ( n_CCSD_v ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) ! do a = 1 , n_CCSD_v do i = 1 , n_CCSD_o ! ai = index_two ( a , i , n_CCSD_v ) ai_CC2 = index_two ( a , i , n_CC2_v ) ! c_ai_ck ( ai , :) = c_ai_bj ( ai_CC2 , :) ! enddo enddo ! call wf % mem % alloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & two , & c_ai_ck , & ( n_CCSD_o ) * ( n_CCSD_v ), & g_ck_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_ai_bj_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( c_ai_ck , ( n_CCSD_v ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Reorder c_ak,ci to c_ai_ck ! call wf % mem % alloc ( c_ai_ck , ( n_CCSD_v ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) ! do i = 1 , n_CCSD_o do k = 1 , n_CC2_o do a = 1 , n_CCSD_v ! ak = index_two ( a , k , n_CC2_v ) ai = index_two ( a , i , n_CCSD_v ) ! do c = 1 , n_CC2_v ! ck = index_two ( c , k , n_CC2_v ) ci = index_two ( c , i , n_CC2_v ) ! c_ai_ck ( ai , ck ) = c_ai_bj ( ak , ci ) ! enddo enddo enddo enddo ! !        rho_ai_bj_CCSD += - sum_ck g_ck_bj*c_ai_ck ! call dgemm ( 'N' , 'N' , & ( n_CCSD_v ) * ( n_CCSD_o ), & ( n_CCSD_v ) * ( n_CCSD_o ), & ( n_CC2_o ) * ( n_CC2_v ), & - one , & c_ai_ck , & ( n_CCSD_v ) * ( n_CCSD_o ), & g_ck_bj , & ( n_CC2_o ) * ( n_CC2_v ), & one , & rho_ai_bj_CCSD , & ( n_CCSD_v ) * ( n_CCSD_o )) ! call wf % mem % dealloc ( c_ai_ck , ( n_CCSD_v ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CC2_v )) call wf % mem % dealloc ( g_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !        Add to rho ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bj_CCSD = index_two ( b , j , n_CCSD_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % alloc ( g_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !       Start batching over c ! MUST BE FIXED ! required = 2 * ( wf % n_J ) * (( wf % n_v ) ** 2 ) & + 4 * ( wf % n_J ) * ( wf % n_v ) * ( wf % n_o ) & + 2 * ( wf % n_J ) * (( wf % n_o ) ** 2 ) ! required = 4 * required ! In words available = get_available () ! batch_dimension = n_CC2_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !       Loop over the number of a batches ! do c_batch = 1 , n_batch ! !          For each batch, get the limits for the a index ! call batch_limits ( c_first , c_last , c_batch , max_batch_length , batch_dimension ) c_length = c_last - c_first + 1 ! !           Construct g_bc_kj ! call wf % mem % alloc ( g_bc_kj , c_length * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CCSD_o )) ! integral_type = 'electronic_repulsion' call wf % get_vv_oo ( integral_type , g_bc_kj , & first_CCSD_v , last_CCSD_v , & c_first , c_last , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o ) ! ! !           Reorder g_bc_kj ! do c = 1 , c_length do b = 1 , n_CCSD_v ! bc = index_two ( b , c , n_CCSD_v ) ! do j = 1 , n_CCSD_o ! bj = index_two ( b , j , n_CCSD_v ) ! do k = 1 , n_CC2_o ! kj = index_two ( k , j , n_CC2_o ) ck = index_two ( c + c_first - 1 , k , n_CC2_v ) ! g_ck_bj ( ck , bj ) = g_bc_kj ( bc , kj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_bc_kj , c_length * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CCSD_o )) enddo ! !        rho_ai_bj += - sum_ck c_ai_ck * g_ck_bj ! call wf % mem % alloc ( c_ai_ck , n_CCSD_o * n_CCSD_v , n_CC2_o * n_CC2_v ) ! do a = 1 , n_CCSD_v do i = 1 , n_CCSD_o ai = index_two ( a , i , n_CCSD_v ) ai_CC2 = index_two ( a , i , n_CC2_v ) c_ai_ck ( ai ,:) = c_ai_bj ( ai_CC2 , :) enddo enddo ! call wf % mem % alloc ( rho_ai_bj_CCSD , n_CCSD_o * n_CCSD_v , n_CCSD_o * n_CCSD_v ) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & - one , & c_ai_ck , & ( n_CCSD_o ) * ( n_CCSD_v ), & g_ck_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_ai_bj_CCSD , & ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( c_ai_ck , n_CCSD_o * n_CCSD_v , n_CC2_o * n_CC2_v ) ! !        Add to rho ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ai_CCSD = index_two ( a , i , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bj_CCSD = index_two ( b , j , n_CCSD_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj_CCSD ( ai_CCSD , bj_CCSD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj_CCSD , ( n_CCSD_v ) * ( n_CCSD_o ), ( n_CCSD_v ) * ( n_CCSD_o )) ! ! !        Reorder  c_ak,cj to c_aj_ck ! call wf % mem % alloc ( c_aj_ck , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do j = 1 , n_CCSD_o do k = 1 , n_CC2_o do a = 1 , n_CCSD_v ! ak = index_two ( a , k , n_CC2_v ) aj = index_two ( a , j , n_CCSD_v ) ! do c = 1 , n_CC2_v ! ck = index_two ( c , k , n_CC2_v ) cj = index_two ( c , j , n_CC2_v ) ! c_aj_ck ( aj , ck ) = c_ai_bj ( ak , cj ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( rho_aj_bi , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & - one , & c_aj_ck , & ( n_CCSD_o ) * ( n_CCSD_v ), & g_ck_bj , & !g_ck_bi(ck,bi) = g_bc,ki ( n_CC2_o ) * ( n_CC2_v ), & zero , & rho_aj_bi , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( g_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( c_aj_ck , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Reorder rho_aj_bi into rho_ai_bj ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CC2_v ) ! do j = 1 , n_CCSD_o ! aj = index_two ( a , j , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CC2_v ) bi = index_two ( b , i , n_CCSD_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aj_bi ( aj , bi ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aj_bi , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! ! end subroutine jacobian_mlccsd_i2_mlccsd ! ! module subroutine jacobian_mlccsd_j2_mlccsd ( wf , rho_ab_ij , c_ab_ij ) !! !!       Jacobian CCSD J2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ab_ij&#94;J2 =    sum_ckld t_ci,dj * g_kc,ld * c_ak,bl !!                       + sum_ckdl t_ak,bl * g_kc,ld * c_ci,dj !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ab_ij real ( dp ), dimension (:,:) :: c_ab_ij ! real ( dp ), dimension (:,:), allocatable :: g_kc_ld real ( dp ), dimension (:,:), allocatable :: g_kl_cd ! real ( dp ), dimension (:,:), allocatable :: x_cd_ij real ( dp ), dimension (:,:), allocatable :: x_ab_kl ! real ( dp ), dimension (:,:), allocatable :: c_ab_kl real ( dp ), dimension (:,:), allocatable :: c_cd_ij ! real ( dp ), dimension (:,:), allocatable :: I_kl_ij ! real ( dp ), dimension (:,:), allocatable :: rho_ab_ij_CCSD ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ab = 0 , cd = 0 integer ( i15 ) :: ai = 0 , bj = 0 , bl = 0 , ak = 0 , ci = 0 , dj = 0 integer ( i15 ) :: kl = 0 , ij = 0 integer ( i15 ) :: kc = 0 , ld = 0 integer ( i15 ) :: ab_CC2 = 0 , ij_CC2 = 0 ! integer ( i15 ) :: aibj = 0 , akbl = 0 , cidj = 0 ! !        Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: first_CCSD_o ! first active occupied index integer ( i15 ) :: first_CCSD_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index integer ( i15 ) :: last_CCSD_o ! first active occupied index integer ( i15 ) :: last_CCSD_v ! first active virtual index ! !        Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! !        Constructing g_kc_ld ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! call wf % mem % alloc ( g_KL_CD , ( n_CC2_o ) ** 2 , ( n_CC2_v ) ** 2 ) ! !        Reorder g_kc_ld to g_kl_cd ! do C = 1 , n_CC2_v do D = 1 , n_CC2_v ! CD = index_two ( C , D , n_CC2_v ) ! do K = 1 , n_CC2_o ! KC = index_two ( K , C , n_CC2_o ) ! do L = 1 , n_CC2_o ! KL = index_two ( K , L , n_CC2_o ) LD = index_two ( L , D , n_CC2_o ) ! g_KL_CD ( KL , CD ) = g_KC_LD ( KC , LD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Reordered X2 amplitudes ! call wf % read_amplitudes ! call wf % mem % alloc ( x_cd_ij , ( n_CC2_v ) ** 2 , ( n_CCSD_o ) ** 2 ) ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o ! ij = index_two ( i , j , n_CCSD_o ) ! do c = 1 , n_CC2_v ! ci = index_two ( c , i , n_CC2_v ) ! do d = 1 , n_CC2_v ! dj = index_two ( d , j , n_CC2_v ) cd = index_two ( c , d , n_CC2_v ) ! cidj = index_packed ( ci , dj ) ! x_cd_ij ( cd , ij ) = wf % x2am ( cidj , 1 ) ! enddo enddo enddo enddo call wf % destruct_x2am ! !        I_kl_ij = g_kl_cd * t_cd_ij ! call wf % mem % alloc ( I_kl_ij , ( n_CC2_o ) ** 2 , ( n_CCSD_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) ** 2 , & ( n_CCSD_o ) ** 2 , & ( n_CC2_v ) ** 2 , & one , & g_kl_cd , & ( n_CC2_o ) ** 2 , & x_cd_ij , & ( n_CC2_v ) ** 2 , & zero , & I_kl_ij , & ( n_CC2_o ) ** 2 ) ! call wf % mem % dealloc ( x_cd_ij , ( n_CC2_v ) ** 2 , ( n_CCSD_o ) ** 2 ) call wf % mem % alloc ( c_ab_kl , n_CCSD_v ** 2 , n_CC2_o ** 2 ) ! do a = 1 , n_CCSD_v do b = 1 , n_CCSD_v ! ab = index_two ( a , b , n_CCSD_v ) ab_CC2 = index_two ( a , b , n_CC2_v ) ! c_ab_kl ( ab , :) = c_ab_ij ( ab_CC2 , :) ! enddo enddo ! !        rho_ab_ij += c_ab_kl * X_kl_ij ! call wf % mem % alloc ( rho_ab_ij_CCSD , n_CCSD_v ** 2 , n_CCSD_o ** 2 ) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_v ) ** 2 , & ( n_CCSD_o ) ** 2 , & ( n_CC2_o ) ** 2 , & one , & c_ab_kl , & ( n_CCSD_v ) ** 2 , & I_kl_ij , & ( n_CC2_o ) ** 2 , & zero , & rho_ab_ij_CCSD ,& ( n_CCSD_v ) ** 2 ) ! call wf % mem % dealloc ( c_ab_kl , n_CCSD_v ** 2 , n_CC2_o ** 2 ) call wf % mem % dealloc ( I_kl_ij , ( n_CC2_o ) ** 2 , ( n_CCSD_o ) ** 2 ) ! !        I_kl_ij = g_kl_cd * c_cd_ij ! call wf % mem % alloc ( c_cd_ij , n_CC2_v ** 2 , n_CCSD_o ** 2 ) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o ! ij = index_two ( i , j , n_CCSD_o ) ij_CC2 = index_two ( i , j , n_CC2_o ) ! c_cd_ij (:, ij ) = c_ab_ij (:, ij_CC2 ) ! enddo enddo ! call wf % mem % alloc ( I_kl_ij , ( n_CC2_o ) ** 2 , ( n_CCSD_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) ** 2 , & ( n_CCSD_o ) ** 2 , & ( n_CC2_v ) ** 2 , & one , & g_kl_cd , & ( n_CC2_o ) ** 2 , & c_cd_ij , & ( n_CC2_v ) ** 2 , & zero , & I_kl_ij , & ( n_CC2_o ) ** 2 ) ! call wf % mem % dealloc ( c_cd_ij , n_CC2_v ** 2 , n_CCSD_o ** 2 ) call wf % mem % dealloc ( g_kl_cd , ( n_CC2_o ) ** 2 , ( n_CC2_v ) ** 2 ) ! !        Reordered X2 amplitudes ! call wf % read_amplitudes ! call wf % mem % alloc ( x_ab_kl , ( n_CCSD_v ) ** 2 , ( n_CC2_o ) ** 2 ) ! do k = 1 , n_CC2_o do l = 1 , n_CC2_o ! kl = index_two ( k , l , n_CC2_o ) ! do a = 1 , n_CCSD_v ! ak = index_two ( a , k , n_CC2_v ) ! do b = 1 , n_CCSD_v ! bl = index_two ( b , l , n_CC2_v ) ab = index_two ( a , b , n_CCSD_v ) ! akbl = index_packed ( ak , bl ) ! x_ab_kl ( ab , kl ) = wf % x2am ( akbl , 1 ) ! enddo enddo enddo enddo call wf % destruct_x2am ! !        rho_ab_ij += t_ab_kl * X_kl_ij ! call dgemm ( 'N' , 'N' , & ( n_CCSD_v ) ** 2 , & ( n_CCSD_o ) ** 2 , & ( n_CC2_o ) ** 2 , & one , & x_ab_kl , & ( n_CCSD_v ) ** 2 , & I_kl_ij , & ( n_CC2_o ) ** 2 , & one , & rho_ab_ij_CCSD ,& ( n_CCSD_v ) ** 2 ) ! call wf % mem % dealloc ( I_kl_ij , ( n_CC2_o ) ** 2 , ( n_CCSD_o ) ** 2 ) call wf % mem % dealloc ( x_ab_kl , ( n_CCSD_v ) ** 2 , ( n_CC2_o ) ** 2 ) ! do a = 1 , n_CCSD_v do b = 1 , n_CCSD_v ! ab = index_two ( a , b , n_CCSD_v ) ab_CC2 = index_two ( a , b , n_CC2_v ) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o ! ij = index_two ( i , j , n_CCSD_o ) ij_CC2 = index_two ( i , j , n_CC2_o ) ! rho_ab_ij ( ab_CC2 , ij_CC2 ) = rho_ab_ij ( ab_CC2 , ij_CC2 ) + rho_ab_ij_CCSD ( ab , ij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ab_ij_CCSD , n_CCSD_v ** 2 , n_CCSD_o ** 2 ) ! end subroutine jacobian_mlccsd_j2_mlccsd ! ! module subroutine jacobian_mlccsd_k2_mlccsd ( wf , rho_ab_ij , c_ab_ij ) !! !!       Jacobian MLCCSD K2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ab_ij&#94;K2 =    sum_kl g_Ki,Lj * c_aK,bL !!                       + sum_cd g_aC,bD * c_Ci,Dj !! !!       For the last term we batch over a and b and !!       add each batch to rho_ai_bj !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ab_ij real ( dp ), dimension (:,:) :: c_ab_ij ! real ( dp ), dimension (:,:), allocatable :: L_Ki_J real ( dp ), dimension (:,:), allocatable :: L_ca_J real ( dp ), dimension (:,:), allocatable :: L_ac_J real ( dp ), dimension (:,:), allocatable :: L_db_J real ( dp ), dimension (:,:), allocatable :: L_bd_J ! real ( dp ), dimension (:,:), allocatable :: g_ki_lj real ( dp ), dimension (:,:), allocatable :: g_kl_ij real ( dp ), dimension (:,:), allocatable :: g_ac_bd real ( dp ), dimension (:,:), allocatable :: g_ab_cd ! real ( dp ), dimension (:,:), allocatable :: c_ab_kl real ( dp ), dimension (:,:), allocatable :: c_cd_ij ! real ( dp ), dimension (:,:), allocatable :: rho_batch_ab_ij real ( dp ), dimension (:,:), allocatable :: rho_ab_ij_CCSD ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 ! integer ( i15 ) :: ab = 0 , db = 0 , ca = 0 , cd = 0 , full_ab = 0 , ac = 0 , bd = 0 integer ( i15 ) :: ij = 0 , ki = 0 , kl = 0 , lj = 0 , full_ij = 0 integer ( i15 ) :: ab_CC2 = 0 , ij_CC2 = 0 ! !        Batching and memory handling variables ! integer ( i15 ) :: a_n_batch = 0 , a_first = 0 , a_last = 0 , a_length = 0 , a_max_length = 0 , a_batch = 0 integer ( i15 ) :: b_n_batch = 0 , b_first = 0 , b_last = 0 , b_length = 0 , b_max_length = 0 , b_batch = 0 ! integer ( i15 ) :: required = 0 , available = 0 ! !        Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: first_CCSD_o ! first active occupied index integer ( i15 ) :: first_CCSD_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index integer ( i15 ) :: last_CCSD_o ! first active occupied index integer ( i15 ) :: last_CCSD_v ! first active virtual index ! !        Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! call wf % mem % alloc ( g_Ki_Lj , ( n_CCSD_o ) * ( n_CC2_o ), ( n_CCSD_o ) * ( n_CC2_o )) ! integral_type = 'electronic_repulsion' call wf % get_oo_oo ( integral_type , g_Ki_Lj , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o ) ! ! !        Reorder g_ki_lj to g_kl_ij ! call wf % mem % alloc ( g_kl_ij , ( n_CC2_o ) ** 2 , ( n_CCSD_o ) ** 2 ) ! do j = 1 , n_CCSD_o do i = 1 , n_CCSD_o ! ij = index_two ( i , j , n_CCSD_o ) ! do k = 1 , n_CC2_o ! ki = index_two ( k , i , n_CC2_o ) ! do l = 1 , n_CC2_o ! kl = index_two ( k , l , n_CC2_o ) lj = index_two ( l , j , n_CC2_o ) ! g_KL_ij ( kl , ij ) = g_Ki_Lj ( ki , lj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_Ki_Lj , ( n_CCSD_o ) * ( n_CC2_o ), ( n_CCSD_o ) * ( n_CC2_o )) ! !        rho_ab_ij += sum_kl g_ki,lj * c_ak,bl = sum_kl c_ab_ij(ab,kl) g_kl_ij(kl,ij) ! call wf % mem % alloc ( c_ab_kl , n_CCSD_v ** 2 , n_CC2_o ** 2 ) ! do a = 1 , n_CCSD_v do b = 1 , n_CCSD_v ! ab = index_two ( a , b , n_CCSD_v ) ab_CC2 = index_two ( a , b , n_CC2_v ) ! c_ab_kl ( ab , :) = c_ab_ij ( ab_CC2 , :) ! enddo enddo ! call wf % mem % alloc ( rho_ab_ij_CCSD , n_CCSD_v ** 2 , n_CCSD_o ** 2 ) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_v ) ** 2 , & ( n_CCSD_o ) ** 2 , & ( n_CC2_o ) ** 2 , & one , & c_ab_kl , & ( n_CCSD_v ) ** 2 , & g_kl_ij , & ( n_CC2_o ) ** 2 , & zero , & rho_ab_ij_CCSD , & ( n_CCSD_v ) ** 2 ) ! call wf % mem % dealloc ( g_kl_ij , ( n_CC2_o ) ** 2 , ( n_CCSD_o ) ** 2 ) call wf % mem % dealloc ( c_ab_kl , n_CCSD_v ** 2 , n_CC2_o ** 2 ) ! do a = 1 , n_CCSD_v do b = 1 , n_CCSD_v ! ab = index_two ( a , b , n_CCSD_v ) ab_CC2 = index_two ( a , b , n_CC2_v ) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o ! ij = index_two ( i , j , n_CCSD_o ) ij_CC2 = index_two ( i , j , n_CC2_o ) ! rho_ab_ij ( ab_CC2 , ij_CC2 ) = rho_ab_ij ( ab_CC2 , ij_CC2 ) + rho_ab_ij_CCSD ( ab , ij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ab_ij_CCSD , n_CCSD_v ** 2 , n_CCSD_o ** 2 ) ! !        Prepare for batching over a and b ! !        ::  sum_cd g_aC,bD * c_Ci,Dj :: ! required = max ( 3 * ( wf % n_v ) ** 2 * ( wf % n_J ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & ! Needed to get L_db_J ( wf % n_v ) ** 4 + 2 * ( wf % n_v ) ** 2 * ( wf % n_J )) ! Needed to get g_ac_bd ! required = required * 4 ! Words available = get_available () ! a_max_length = 0 call num_two_batch ( required , available , a_max_length , a_n_batch , n_CCSD_v ) ! !        Initialize some variables for batching ! a_first = 0 a_last = 0 a_length = 0 ! !        Start looping over a-batches ! do a_batch = 1 , a_n_batch ! call batch_limits ( a_first , a_last , a_batch , a_max_length , n_CCSD_v ) a_length = a_last - a_first + 1 ! !           Start looping over batches of b ! b_first = 0 b_last = 0 b_length = 0 ! b_max_length = a_max_length ! do b_batch = 1 , a_n_batch ! call batch_limits ( b_first , b_last , b_batch , b_max_length , n_CCSD_v ) b_length = b_last - b_first + 1 ! !              Allocate g_ac_bd = g_acbd ! call wf % mem % alloc ( g_ac_bd , ( n_CC2_v ) * a_length , ( n_CC2_v ) * b_length ) ! integral_type = 'electronic_repulsion' call wf % get_vv_vv ( integral_type , g_ac_bd , & a_first , a_last , & first_CC2_v , last_CC2_v ,& b_first , b_last , & first_CC2_v , last_CC2_v ) ! !              sum_cd g_ac,bd * c_ci,dj = sum_cd g_ac,bd c_cd,ij = sum_cd g_ab_cd c_cd_ij ! !              Reorder g_ca_db into g_ab_cd !              (Here, g_ab_cd = g_acbd = g_ca_db.) ! call wf % mem % alloc ( g_ab_cd , a_length * b_length , ( n_CC2_v ) ** 2 ) ! do b = 1 , b_length do a = 1 , a_length ! ab = index_two ( a , b , a_length ) ! do d = 1 , n_CC2_v ! bd = index_two ( b , d , b_length ) ! do c = 1 , n_CC2_v ! ac = index_two ( a , c , a_length ) cd = index_two ( c , d , n_CC2_v ) ! g_ab_cd ( ab , cd ) = g_ac_bd ( ac , bd ) ! = g_acbd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ac_bd , ( n_CC2_v ) * a_length , ( n_CC2_v ) * b_length ) ! call wf % mem % alloc ( rho_batch_ab_ij , a_length * b_length , ( n_CC2_o ) ** 2 ) ! !              rho_ab_ij += sum_cd g_ac,bd * c_ci,dj = sum_cd g_ab_cd(ab, cd) c_ab_ij(cd, ij) ! call wf % mem % alloc ( c_cd_ij , n_CC2_v ** 2 , n_CCSD_o ** 2 ) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o ! ij = index_two ( i , j , n_CCSD_o ) ij_CC2 = index_two ( i , j , n_CC2_o ) ! c_cd_ij (:, ij ) = c_ab_ij (:, ij_CC2 ) ! enddo enddo ! call dgemm ( 'N' , 'N' , & a_length * b_length , & ( n_CCSD_o ) ** 2 , & ( n_CC2_v ) ** 2 , & one , & g_ab_cd , & a_length * b_length , & c_cd_ij , & ( n_CC2_v ) ** 2 , & zero , & rho_batch_ab_ij , & a_length * b_length ) ! call wf % mem % dealloc ( g_ab_cd , a_length * b_length , ( n_CC2_v ) ** 2 ) call wf % mem % dealloc ( c_cd_ij , n_CC2_v ** 2 , n_CCSD_o ** 2 ) ! !              Reorder into rho_ab_ij ! do b = 1 , b_length do a = 1 , a_length ! ab = index_two ( a , b , a_length ) ! full_ab = index_two ( a + a_first - 1 , b + b_first - 1 , n_CC2_v ) ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o ! ij = index_two ( i , j , n_CCSD_o ) full_ij = index_two ( i , j , n_CC2_o ) ! rho_ab_ij ( full_ab , full_ij ) = rho_ab_ij ( full_ab , full_ij ) + rho_batch_ab_ij ( ab , ij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_batch_ab_ij , a_length * b_length , ( n_CCSD_o ) ** 2 ) ! enddo ! End batches of b enddo ! End batches of a ! end subroutine jacobian_mlccsd_k2_mlccsd ! ! end submodule jacobian","tags":"","loc":"sourcefile/jacobian_submodule.f90~2.html","title":"jacobian_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~omega_submodule.f90~2~~EfferentGraph sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileomega_submodulef902EfferentGraph = svgPanZoom('#sourcefileomega_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules omega Source Code omega_submodule.F90 Source Code submodule ( mlccsd_class ) omega ! implicit none ! logical :: debug = . false . logical :: timings = . false . ! character ( len = 40 ) :: integral_type ! contains ! module subroutine initialize_omega_mlccsd ( wf ) ! !      Initialize Omega (MLCCSD) !      Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !      Allocates the projection vector (omega1, omega2) and sets it !      to zero. ! implicit none ! class ( mlccsd ) :: wf ! call wf % mem % alloc ( wf % omega1 , wf % n_v , wf % n_o ) wf % omega1 = zero ! call wf % mem % alloc ( wf % omega2 , wf % n_t2am , 1 ) wf % omega2 = zero ! end subroutine initialize_omega_mlccsd ! module subroutine construct_omega_mlccsd ( wf ) !! !!    Construct Omega (MLCCSD) !!    Written by Eirik F. Kjønstad and Sarai Folkestad, Apr 2017 !! !!    Constructs the MlCC2 omega. !! !!    s2-amplitudes are constructed on the fly, according to the CC2 !!    expression for the doubles amplitudes. !! !!    Calculated by looping over active spaces, !!    Adding the omega contribution from each active space in turn. !! implicit none ! class ( mlccsd ) :: wf ! !     Looping variables ! integer ( i15 ) :: active_space ! !     Timing variables ! real ( dp ) :: omega_start = zero real ( dp ) :: omega_end = zero ! real ( dp ), dimension (:,:), allocatable :: x_IA_JB ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 ! !     Start timing of omega ! call cpu_time ( omega_start ) ! !     Set the omega vector to zero ! wf % omega1 = zero wf % omega2 = zero ! !     :: Calculate CCS omega contributions :: ! call wf % omega_ccs_a1 ! !     OBS! T2 could be deleted here to be allocated and read from file !           at the end of this routine for memory savings. ! !     :: Calculate CCSD omega contributions :: ! !     Construct x2 amplitude: x&#94;AB_IJ = s&#94;AB_IJ + t&#94;AB_IJ !     s amplitudes are CC2 amplitudes, t amplitudes are CCSD corrections. !     x is given in entire CC2 space (upper case letters), however !     t is zero for external/semi-external and s is zero for internal. ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) ! call wf % mem % alloc ( x_IA_JB , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) call wf % get_mlccsd_x2am ( x_IA_JB ) ! !     Omega 1 contributions ! call wf % omega_mlccsd_a1 ( x_IA_JB ) call wf % omega_mlccsd_b1 ( x_IA_JB ) ! !     Omega 2 contributions ! call wf % omega_mlccsd_a2 ( x_IA_JB ) call wf % omega_mlccsd_b2 ( x_IA_JB ) call wf % omega_mlccsd_c2 ( x_IA_JB ) call wf % omega_mlccsd_d2 ( x_IA_JB ) call wf % omega_mlccsd_e2 ( x_IA_JB ) ! call wf % mem % dealloc ( x_IA_JB , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! call cpu_time ( omega_end ) if ( timings ) write ( unit_output , * ) 'Time in omega:' , omega_end - omega_start ! end subroutine construct_omega_mlccsd ! ! module subroutine get_mlccsd_x2am_mlccsd ( wf , x_ia_jb ) !! !!    Constructs x_ia_jb amplitudes for current active space !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: x_ia_jb ! real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: g_ai_bj real ( dp ), dimension (:,:), allocatable :: s_ai_bj_CC2 real ( dp ), dimension (:,:), allocatable :: I1_a_IBJ ! Intermediato of transformation real ( dp ), dimension (:,:), allocatable :: I2_aIB_j ! Intermediato of transformation real ( dp ), dimension (:,:), allocatable :: I3_Ia_jB ! Intermediato of transformation real ( dp ), dimension (:,:), allocatable :: I4_i_ajB ! Intermediato of transformation ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 , ia = 0 , bj = 0 , ai = 0 , aIB = 0 , jB = 0 , aibj = 0 ! ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: first_CCSD_o ! first active occupied index integer ( i15 ) :: first_CCSD_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! if ( wf % mlcc_settings % CC2 ) then ! !        Construct s2-amplitudes in CC2/CCS block diagonal basis ! call wf % mem % alloc ( L_ai_J , n_CC2_o * n_CC2_v , wf % n_J ) L_ai_J = zero ! call wf % get_cholesky_ai_for_cc2_amplitudes ( L_ai_J , first_CC2_v , last_CC2_v , first_CC2_o , last_CC2_o ) ! call wf % mem % alloc ( g_ai_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        g_ib_jc = g_bi,cj = sum_J L_bj&#94;J*L_ci&#94;J ! call dgemm ( 'N' , 'T' , & ( n_CC2_o ) * ( n_CC2_v ), & ( n_CC2_o ) * ( n_CC2_v ), & ( wf % n_J ), & one , & L_ai_J , & ( n_CC2_o ) * ( n_CC2_v ), & L_ai_J , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & g_ai_bj , & ( n_CC2_o ) * ( n_CC2_v )) ! call wf % mem % dealloc ( L_ai_J , n_CC2_o * n_CC2_v , wf % n_J ) ! call wf % mem % alloc ( s_AI_BJ_CC2 , n_CC2_o * n_CC2_v , n_CC2_o * n_CC2_v ) ! do A = 1 , n_CC2_v do I = 1 , n_CC2_o ! AI = index_two ( A , I , n_CC2_v ) ! do B = 1 , n_CC2_v do J = 1 , n_CC2_o ! BJ = index_two ( B , J , n_CC2_v ) ! s_AI_BJ_CC2 ( AI , BJ ) = g_ai_bj ( AI , BJ ) / ( wf % fock_diagonal_cc2_ccs ( I + first_CC2_o - 1 , 1 )& + wf % fock_diagonal_cc2_ccs ( J + first_CC2_o - 1 , 1 ) & - wf % fock_diagonal_cc2_ccs ( wf % n_o + B + first_CC2_v - 1 , 1 ) & - wf % fock_diagonal_cc2_ccs ( wf % n_o + A + first_CC2_v - 1 , 1 )) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ai_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !        Transform to CCSD/CC2/CCS block diagonal basis (Cholesky or cnto) ! !        Transform index A : X1_a_IBJ = sum_A T_aA*s_A_IBJ_CC2 ! call wf % mem % alloc ( I1_a_IBJ , n_CC2_v , ( n_CC2_o ** 2 ) * n_CC2_v ) ! call dgemm ( 'N' , 'N' , & n_CC2_v ,& ( n_CC2_o ** 2 ) * n_CC2_v , & n_CC2_v , & one , & wf % T_v ( first_CC2_v , first_CC2_v ), & wf % n_v , & s_AI_BJ_CC2 , & n_CC2_v , & zero , & I1_a_IBJ , & n_CC2_v ) ! call wf % mem % dealloc ( s_AI_BJ_CC2 , n_CC2_o * n_CC2_v , n_CC2_o * n_CC2_v ) ! !        Transform index J : X2_aIB_j = sum_J X1_aIB_J*T_jJ ! call wf % mem % alloc ( I2_aIB_j , ( n_CC2_v ** 2 ) * n_CC2_o , n_CC2_o ) ! call dgemm ( 'N' , 'T' , & ( n_CC2_v ** 2 ) * n_CC2_o , & n_CC2_o , & n_CC2_o , & one , & I1_a_IBJ , & ( n_CC2_v ** 2 ) * n_CC2_o , & wf % T_o ( first_CC2_o , first_CC2_o ), & wf % n_o , & zero , & I2_aIB_j , & ( n_CC2_v ** 2 ) * n_CC2_o ) ! call wf % mem % dealloc ( I1_A_IBJ , n_CC2_v , ( n_CC2_o ** 2 ) * n_CC2_v ) ! !        Reorder X2_aIB_j to X3_Ia_jB ! call wf % mem % alloc ( I3_Ia_jB , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_v ) * ( n_CC2_o )) I3_Ia_jB = zero ! do a = 1 , n_CC2_v do j = 1 , n_CC2_o do B = 1 , n_CC2_v ! jB = index_two ( j , B , n_CC2_o ) ! do I = 1 , n_CC2_o ! aIB = index_three ( a , I , B , n_CC2_v , n_CC2_o ) Ia = index_two ( I , a , n_CC2_o ) ! I3_Ia_jB ( Ia , jB ) = I2_aIB_j ( aIB , j ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( I2_aIB_j , ( n_CC2_v ** 2 ) * ( n_CC2_o ), n_CC2_o ) ! !        Transform index I : I4_i_ajB = sum_I T_iI*I3_Ia_jB ! call wf % mem % alloc ( I4_i_ajB , ( n_CC2_o ), ( n_CC2_o ) * ( n_CC2_v ) ** 2 ) ! call dgemm ( 'N' , 'N' , & n_CC2_o , & ( n_CC2_o ) * ( n_CC2_v ** 2 ), & n_CC2_o , & one , & wf % T_o ( first_CC2_o , first_CC2_o ), & wf % n_o , & I3_Ia_jB , & n_CC2_o , & zero , & I4_i_ajB , & n_CC2_o ) ! call wf % mem % dealloc ( I3_Ia_jB , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_v ) * ( n_CC2_o )) ! !        Transform index B : s_ia_jb = sum_B I4_i_ajB*T_bB ! call dgemm ( 'N' , 'T' , & ( n_CC2_o ** 2 ) * ( n_CC2_v ), & n_CC2_v , & n_CC2_v , & one , & I4_i_ajB , & ( n_CC2_o ** 2 ) * ( n_CC2_v ), & wf % T_v ( first_CC2_v , first_CC2_v ), & wf % n_v , & zero , & x_ia_jb , & ( n_CC2_o ** 2 ) * ( n_CC2_v )) ! call wf % mem % dealloc ( I4_i_ajB , n_CC2_o , ( n_CC2_o ) * ( n_CC2_v ** 2 )) ! !        Replace internals with CCSD amplitudes ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v do b = 1 , n_CCSD_v ! ia = index_two ( i , a , n_CC2_o ) jb = index_two ( j , b , n_CC2_o ) ai = index_two ( a , i , n_CCSD_v ) bj = index_two ( b , j , n_CCSD_v ) ! aibj = index_packed ( ai , bj ) ! x_ia_jb ( ia , jb ) = wf % t2am ( aibj , 1 ) ! enddo enddo enddo enddo ! else ! No CC2 amplitudes ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o do a = 1 , n_CCSD_v do b = 1 , n_CCSD_v ! ia = index_two ( i , a , n_CC2_o ) jb = index_two ( j , b , n_CC2_o ) ai = index_two ( a , i , n_CCSD_v ) bj = index_two ( b , j , n_CCSD_v ) ! aibj = index_packed ( ai , bj ) ! x_ia_jb ( ia , jb ) = wf % t2am ( aibj , 1 ) ! enddo enddo enddo enddo endif ! end subroutine get_mlccsd_x2am_mlccsd ! ! module subroutine omega_mlccsd_a1_mlccsd ( wf , x_ib_jc ) !! !!    Omega A1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Calculates the A1 term of omega for the active space, !! !!    A1: sum_bcj g_Abjc * u_ij&#94;bc, !! !!    where upper case letters indicate CCS space, and !!    lower case letters are the combined CC2/CCSD spaces. !! !!    A1 is added to the projection vector (omega1) of !!    the wavefunction object wf. !! !!    u_ij&#94;bc = 2*x_ij&#94;bc - x_ij&#94;cb !! !!    Batching over A. !! !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_ib_jc ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , batch_dimension = 0 , offset = 0 integer ( i15 ) :: A_n_batch = 0 , A_first = 0 , A_last = 0 , A_batch = 0 , A_length = 0 ! !     Indices ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , c = 0 , b = 0 integer ( i15 ) :: ib = 0 , ic = 0 , jb = 0 , jc = 0 integer ( i15 ) :: bjc = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: u_bjc_i real ( dp ), dimension (:,:), allocatable :: g_Ab_jc real ( dp ), dimension (:,:), allocatable :: L_Ab_J real ( dp ), dimension (:,:), allocatable :: L_jc_J ! logical :: reorder ! To get L_ab_J reordered, for batching over a ! !     Active space variables ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: last_CC2_o ! last active occupied index integer ( i15 ) :: last_CC2_v ! last active virtual index integer ( i15 ) :: n_CC2_o ! number of active occupied index integer ( i15 ) :: n_CC2_v ! number of active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! !     :: Construct u_ib_jc :: ! !     u_ij&#94;bc = 2*s_ij&#94;bc - s_ij&#94;cb =  (2*g_ij&#94;bc - g_ij&#94;cb)/ε_ij&#94;cb ! ! call wf % mem % alloc ( u_bjc_i , ( n_CC2_v ** 2 ) * ( n_CC2_o ), ( n_CC2_o )) ! do b = 1 , n_CC2_v do i = 1 , n_CC2_o ! ib = index_two ( i , b , n_CC2_o ) ! do c = 1 , n_CC2_v do j = 1 , n_CC2_o ! jc = index_two ( j , c , n_CC2_o ) jb = index_two ( j , b , n_CC2_o ) ic = index_two ( i , c , n_CC2_o ) ! bjc = index_three ( b , j , c , n_CC2_v , n_CC2_o ) ! u_bjc_i ( bjc , i ) = ( two * x_ib_jc ( ib , jc ) - x_ib_jc ( ic , jb )) ! enddo enddo enddo enddo ! !     Prepare for batching over A ! required = ( n_CC2_v ) * ( wf % n_v ) * ( wf % n_J ) & + ( n_CC2_v ) * ( n_CC2_o ) * ( wf % n_J ) & + (( n_CC2_v ) ** 2 ) * ( wf % n_o ) * ( n_CC2_o ) & + (( n_CC2_o ) ** 2 ) * (( n_CC2_v ) ** 2 ) ! ! required = required * 4 ! Words available = get_available () max_length = 0 call num_batch ( required , available , max_length , A_n_batch , wf % n_v ) ! A_first = 0 A_last = 0 A_length = 0 ! !     Start looping over a-batches ! do A_batch = 1 , A_n_batch ! call batch_limits ( A_first , A_last , A_batch , max_length , wf % n_v ) A_length = A_last - A_first + 1 ! !        :: Construct integral g_Ab,jc :: ! call wf % mem % alloc ( g_Ab_jc , ( n_CC2_v ) * A_length , ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , g_Ab_jc , & A_first , A_last , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !        :: Add contributions to omega :: ! call dgemm ( 'N' , 'N' , & A_length , & n_CC2_o , & ( n_CC2_o ) * ( n_CC2_v ** 2 ), & one , & g_Ab_jc , & A_length , & u_bjc_i , & ( n_CC2_o ) * ( n_CC2_v ** 2 ), & one , & wf % omega1 ( A_first , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( g_Ab_jc , ( n_CC2_v ) * a_length , ( n_CC2_o ) * ( n_CC2_v )) ! enddo ! Batching over a ! call wf % mem % dealloc ( u_bjc_i , ( n_CC2_v ** 2 ) * ( n_CC2_o ), ( n_CC2_o )) ! end subroutine omega_mlccsd_a1_mlccsd ! ! module subroutine omega_mlccsd_b1_mlccsd ( wf , x_ja_kb ) !! !!    Omega B1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Calculates the B1 term of omega, !! !!    B1: - sum_bjk u_jk&#94;ab*g_kbjI + sum_bj u_ij&#94;ab F_jb, !! !!    with u_ij&#94;ab = 2*x_ij&#94;ab - x_ij&#94;ba. !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_ja_kb ! !     Batching ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , batch_dimension = 0 , offset = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: u_a_kbj real ( dp ), dimension (:,:), allocatable :: g_kb_jI real ( dp ), dimension (:,:), allocatable :: L_kb_J real ( dp ), dimension (:,:), allocatable :: L_jI_J ! !     looping indices ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 , a = 0 , b = 0 integer ( i15 ) :: I_full = 0 , J_full = 0 , A_full = 0 , B_full = 0 integer ( i15 ) :: ja = 0 , kb = 0 , ka = 0 , jb = 0 , aj = 0 integer ( i15 ) :: kbj = 0 , jbi = 0 ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! !     :: Construct u_jk&#94;ab :: ! !     u_jk&#94;ab = 2*s_jk&#94;ab - s_jk&#94;ba  (place in u_a_jkb) ! ! call wf % mem % alloc ( u_a_kbj , n_CC2_v , ( n_CC2_o ** 2 ) * n_CC2_v ) do k = 1 , n_CC2_o do b = 1 , n_CC2_v ! kb = index_two ( k , b , n_CC2_o ) ! do j = 1 , n_CC2_o ! jb = index_two ( j , b , n_CC2_o ) kbj = index_three ( k , b , j , n_CC2_o , n_CC2_v ) ! do a = 1 , n_CC2_v ! ja = index_two ( j , a , n_CC2_o ) ka = index_two ( k , a , n_CC2_o ) ! u_a_kbj ( a , kbj ) = ( two * x_ja_kb ( ja , kb ) - x_ja_kb ( jb , ka )) ! enddo enddo enddo enddo ! !     :: - sum_bjk u_ja_kb * g_kb_jI :: ! call wf % mem % alloc ( g_kb_jI , n_CC2_o * n_CC2_v , n_CC2_o * ( wf % n_o ) ) ! integral_type = 'electronic_repulsion' call wf % get_ov_oo ( integral_type , g_kb_jI , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & 1 , wf % n_o ) ! !     Add contributions to omega ! call dgemm ( 'N' , 'N' , & n_CC2_v , & ( wf % n_o ), & n_CC2_v * (( n_CC2_o ) ** 2 ), & - one , & u_a_kbj , & n_CC2_v , & g_kb_jI , & n_CC2_v * (( n_CC2_o ) ** 2 ), & one , & wf % omega1 ( first_CC2_v , 1 ), & ( wf % n_v )) ! call wf % mem % dealloc ( g_kb_jI , n_CC2_o * n_CC2_v , n_CC2_o * ( wf % n_o )) ! !     :: sum_jb F_jb u_ij&#94;ab :: ! do i = 1 , n_CC2_o ! I_full = i + first_CC2_o - 1 ! do a = 1 , n_CC2_v ! A_full = a + first_CC2_v - 1 ! do j = 1 , n_CC2_o ! J_full = j + first_CC2_o - 1 ! do b = 1 , n_CC2_v ! B_full = b + first_CC2_v - 1 ! jbi = index_three ( j , b , i , n_CC2_o , n_CC2_v ) wf % omega1 ( A_full , I_full ) = wf % omega1 ( A_full , I_full ) + u_a_kbj ( a , jbi ) * wf % fock_ia ( J_full , B_full ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( u_a_kbj , n_CC2_v , ( n_CC2_o ** 2 ) * n_CC2_v ) ! end subroutine omega_mlccsd_b1_mlccsd ! ! module subroutine omega_mlccsd_a2_mlccsd ( wf , x_IC_JD ) ! !     Omega A2 term: Omega A2 = g_aibj + sum_(cd)g_aC_bD * x_Ci_Dj ! !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, 10 Mar 2017 ! !     Structure: Batching over both a and b for A2.2. !                x&#94;+_Ci_Dj = x_Ci_Dj + x_Di_Cj !                x&#94;-_Ci_Dj = x_Ci_Dj - x_Di_Cj !                g&#94;+_aC_bD = g_aC_bD + g_bC_aD !                g&#94;-_aC_bD = g_aC_bD - g_bC_aD ! !                omega_A2_ai_bj = 1/4*(g&#94;+_aC_bD*x&#94;+_Ci_Dj + g&#94;-_aC_bD*x&#94;-_Ci_Dj) !                omega_A2_aj_bi = 1/4*(g&#94;+_aC_bD*x&#94;+_Ci_Dj - g&#94;-_aC_bD*x&#94;-_Ci_Dj) ! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_IC_JD ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: g_aC_bD real ( dp ), dimension (:,:), allocatable :: g_ai_bj real ( dp ), dimension (:,:), allocatable :: g_p_ab_CD real ( dp ), dimension (:,:), allocatable :: g_m_ab_CD real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: L_Ca_J real ( dp ), dimension (:,:), allocatable :: L_aC_J real ( dp ), dimension (:,:), allocatable :: L_Db_J real ( dp ), dimension (:,:), allocatable :: L_bD_J ! !     Reordered T2 amplitudes ! real ( dp ), dimension (:,:), allocatable :: x_p_CD_ij real ( dp ), dimension (:,:), allocatable :: x_m_CD_ij ! !     Reordered omega 2 ! real ( dp ), dimension (:,:), allocatable :: omega2_p_ab_ij real ( dp ), dimension (:,:), allocatable :: omega2_m_ab_ij ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: ab = 0 , ca = 0 , cb = 0 , cd = 0 , da = 0 , db = 0 , ac = 0 , bd = 0 , ad = 0 , bc = 0 integer ( i15 ) :: ai = 0 , aj = 0 , bj = 0 , bi = 0 , ic = 0 , jc = 0 , jd = 0 , id = 0 integer ( i15 ) :: ij = 0 ! integer ( i15 ) :: aibj = 0 , biaj = 0 , cidj = 0 , cjdi = 0 ! !     Batching and memory handling variables ! integer ( i15 ) :: a_n_batch = 0 , a_first = 0 , a_last = 0 , a_length = 0 , a_max_length = 0 , a_batch = 0 integer ( i15 ) :: b_n_batch = 0 , b_first = 0 , b_last = 0 , b_length = 0 , b_max_length = 0 , b_batch = 0 integer ( i15 ) :: required = 0 , available = 0 ! !     Logical for reordering in L_ab_J when batching over the last index ! logical :: reorder ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o ! first active occupied index integer ( i15 ) :: first_CC2_v ! first active virtual index integer ( i15 ) :: first_CCSD_o ! first active occupied index integer ( i15 ) :: first_CCSD_v ! first active virtual index ! integer ( i15 ) :: last_CC2_o ! first active occupied index integer ( i15 ) :: last_CC2_v ! first active virtual index ! integer ( i15 ) :: last_CCSD_o ! first active occupied index integer ( i15 ) :: last_CCSD_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) ! call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! ! !     ::  Calculate the A2.1 term of omega :: ! !     Create g_ai_bj ! call wf % mem % alloc ( g_ai_bj , n_CCSD_o * n_CCSD_v , n_CCSD_o * n_CCSD_v ) ! integral_type = 'electronic_repulsion' call wf % get_vo_vo ( integral_type , g_ai_bj , & first_CCSD_v , last_CCSD_v , & first_CCSD_o , last_CCSD_o , & first_CCSD_v , last_CCSD_v , & first_CCSD_o , last_CCSD_o ) ! !     Add A2.1 to Omega 2 ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! do j = 1 , n_CCSD_o do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) ! if ( ai . ge . bj ) then ! aibj = index_packed ( ai , bj ) ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + g_ai_bj ( ai , bj ) ! endif enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ai_bj , n_CCSD_o * n_CCSD_v , n_CCSD_o * n_CCSD_v ) ! !     ::  Calculate the A2.2 term  of omega :: ! !     Calc of required should be fixed, is now conservative. ! required = max ( 3 * (( n_CC2_v ) ** 2 ) * ( wf % n_J ) + 2 * ( n_CC2_v ) * ( n_CC2_o ) * ( wf % n_J ), & ! Needed to get  L_db_J ( n_CC2_v ) ** 4 + 2 * ( n_CC2_v ) ** 2 * ( wf % n_J ), & ! Needed to get g_ac_bd ( n_CC2_v ) ** 4 + 2 * (( n_CC2_v ) ** 2 ) * ( packed_size ( n_CC2_v )) & ! Needed to get g+- and t+- + 2 * ( packed_size ( n_CC2_v )) * ( packed_size ( n_CC2_o )), & ! 2 * ( packed_size ( n_CC2_o )) * ( packed_size ( n_CC2_v )) & ! Needed for g+- and t+- and Omega+- + 2 * ( packed_size ( n_CC2_v )) * ( packed_size ( n_CC2_o )) & ! + 2 * ( n_CC2_v ) ** 2 * ( packed_size ( n_CC2_v ))) ! ! required = required * 4 ! Words available = get_available () ! a_max_length = 0 call num_two_batch ( required , available , a_max_length , a_n_batch , n_CCSD_v ) ! !     Initialize some variables for batching ! a_first = 0 a_last = 0 a_length = 0 ! !     Start looping over a-batches ! do a_batch = 1 , a_n_batch ! call batch_limits ( a_first , a_last , a_batch , a_max_length , n_CCSD_v ) a_length = a_last - a_first + 1 ! !        Start looping over batches of b ! b_first = 0 b_last = 0 b_length = 0 ! b_max_length = a_max_length ! do b_batch = 1 , a_batch ! call batch_limits ( b_first , b_last , b_batch , b_max_length , n_CCSD_v ) b_length = b_last - b_first + 1 ! !          Allocate g_ca_db ! call wf % mem % alloc ( g_aC_bD , ( n_CC2_v ) * a_length , ( n_CC2_v ) * b_length ) ! integral_type = 'electronic_repulsion' call wf % get_vv_vv ( integral_type , g_aC_bD , & a_first , a_last , & first_CC2_v , last_CC2_v , & b_first , b_last , & first_CC2_v , last_CC2_v ) ! ! ! if ( b_batch . eq . a_batch ) then ! ! !           Allocate for +-g, +-t ! call wf % mem % alloc ( g_p_ab_CD , packed_size ( a_length ), packed_size ( n_CC2_v )) call wf % mem % alloc ( g_m_ab_CD , packed_size ( a_length ), packed_size ( n_CC2_v )) call wf % mem % alloc ( x_p_CD_ij , packed_size ( n_CC2_v ), packed_size ( n_CCSD_o )) call wf % mem % alloc ( x_m_CD_ij , packed_size ( n_CC2_v ), packed_size ( n_CCSD_o )) ! g_p_ab_CD = zero g_m_ab_CD = zero x_p_CD_ij = zero x_m_CD_ij = zero ! !              Reorder g_ca_db to g_ab_cd and t_ci_dj to t_cd_ij ! do C = 1 , n_CC2_v do D = 1 , C ! CD = index_packed ( c , d ) ! do a = 1 , a_length ! ac = index_two ( a , C , a_length ) ad = index_two ( a , D , a_length ) ! do b = 1 , b_length if (( a + a_first - 1 ) . ge . ( b + b_first - 1 )) then ! bD = index_two ( b , D , b_length ) bC = index_two ( b , C , b_length ) ! ab = index_packed ( a , b ) ! g_p_ab_cd ( ab , cd ) = g_aC_bD ( aC , bD ) + g_aC_bD ( aD , bC ) g_m_ab_cd ( ab , cd ) = g_aC_bD ( aC , bD ) - g_aC_bD ( aD , bC ) ! if ( C . ne . D ) then g_p_ab_CD ( ab , CD ) = two * g_p_ab_CD ( ab , CD ) g_m_ab_CD ( ab , CD ) = two * g_m_ab_CD ( ab , CD ) endif ! endif enddo enddo ! do i = 1 , n_CCSD_o do j = 1 , i ! ij = index_packed ( i , j ) ! iC = index_two ( i , C , n_CC2_o ) jD = index_two ( j , D , n_CC2_o ) jC = index_two ( j , C , n_CC2_o ) iD = index_two ( i , D , n_CC2_o ) ! x_p_CD_ij ( CD , ij ) = x_IC_JD ( iC , jD ) + x_IC_JD ( iD , jC ) x_m_CD_ij ( CD , ij ) = x_IC_JD ( iC , jD ) - x_IC_JD ( iD , jC ) ! enddo enddo enddo enddo ! !              Dellocate g_ac_bd ! call wf % mem % dealloc ( g_aC_bD , ( n_CC2_v ) * a_length , ( n_CC2_v ) * b_length ) ! !              Allocate omega +- ! call wf % mem % alloc ( omega2_p_ab_ij , packed_size ( a_length ), packed_size ( n_CCSD_o )) call wf % mem % alloc ( omega2_m_ab_ij , packed_size ( a_length ), packed_size ( n_CCSD_o )) ! !              omega2_ab_ij = sum_(cd) g_ab_cd*t_cd_ij ! call dgemm ( 'N' , 'N' , & packed_size ( a_length ), & packed_size ( n_CCSD_o ), & packed_size ( n_CC2_v ), & one / four , & g_p_ab_CD , & packed_size ( a_length ), & x_p_CD_ij , & packed_size ( n_CC2_v ), & zero , & omega2_p_ab_ij , & packed_size ( a_length )) ! call dgemm ( 'N' , 'N' , & packed_size ( a_length ), & packed_size ( n_CCSD_o ), & packed_size ( n_CC2_v ), & one / four , & g_m_ab_CD , & packed_size ( a_length ), & x_m_CD_ij , & packed_size ( n_CC2_v ), & zero , & omega2_m_ab_ij , & packed_size ( a_length ) ) ! !             Deallocate +-g, +-t ! call wf % mem % dealloc ( g_p_ab_CD , packed_size ( a_length ), packed_size ( n_CC2_v )) call wf % mem % dealloc ( g_m_ab_CD , packed_size ( a_length ), packed_size ( n_CC2_v )) call wf % mem % dealloc ( x_p_CD_ij , packed_size ( n_CC2_v ), packed_size ( n_CCSD_o )) call wf % mem % dealloc ( x_m_CD_ij , packed_size ( n_CC2_v ), packed_size ( n_CCSD_o )) ! do i = 1 , n_CCSD_o do j = 1 , i ! ij = index_packed ( i , j ) ! do a = 1 , a_length ! Ai = index_two ( a + a_first - 1 , i , n_CCSD_v ) ! A is full-CCSD-space a index Aj = index_two ( a + a_first - 1 , j , n_CCSD_v ) ! A is full-CCSD-space a index ! do b = 1 , b_length ! if (( a + a_first - 1 ) . ge . ( b + b_first - 1 )) then Bj = index_two ( b + b_first - 1 , j , n_CCSD_v ) ! B is full-CCSD-space b index Bi = index_two ( b + b_first - 1 , i , n_CCSD_v ) ! B is full-CCSD-space b index ! ! ab = index_packed ( a , b ) ! AiBj = index_packed ( Ai , Bj ) BiAj = index_packed ( Bi , Aj ) ! !                            Reorder into omega2_aibj ! wf % omega2 ( AiBj , 1 ) = wf % omega2 ( AiBj , 1 ) & + omega2_p_ab_ij ( ab , ij ) + omega2_m_ab_ij ( ab , ij ) ! if ( AiBj . ne . BiAj ) then wf % omega2 ( BiAj , 1 ) = wf % omega2 ( BiAj , 1 ) & + omega2_p_ab_ij ( ab , ij ) - omega2_m_ab_ij ( ab , ij ) endif endif ! enddo enddo enddo enddo ! !              Deallocate omega +- ! call wf % mem % dealloc ( omega2_p_ab_ij , packed_size ( a_length ), packed_size ( n_CCSD_o )) call wf % mem % dealloc ( omega2_m_ab_ij , packed_size ( a_length ), packed_size ( n_CCSD_o )) else ! !              Allocate for +-g, +-t ! call wf % mem % alloc ( g_p_ab_CD , a_length * b_length , packed_size ( n_CC2_v )) call wf % mem % alloc ( g_m_ab_CD , a_length * b_length , packed_size ( n_CC2_v )) call wf % mem % alloc ( x_p_CD_ij , packed_size ( n_CC2_v ), packed_size ( n_CCSD_o )) call wf % mem % alloc ( x_m_CD_ij , packed_size ( n_CC2_v ), packed_size ( n_CCSD_o )) ! g_p_ab_CD = zero g_m_ab_CD = zero x_p_CD_ij = zero x_m_CD_ij = zero ! do C = 1 , n_CC2_v do D = 1 , C ! CD = index_packed ( C , D ) ! do a = 1 , a_length ! ac = index_two ( a , C , a_length ) ad = index_two ( a , D , a_length ) ! do b = 1 , b_length ! bD = index_two ( b , D , b_length ) bC = index_two ( b , C , b_length ) ! ab = index_two ( a , b , a_length ) ! g_p_ab_CD ( ab , CD ) = g_aC_bD ( aC , bD ) + g_aC_bD ( aD , bC ) g_m_ab_CD ( ab , CD ) = g_aC_bD ( aC , bD ) - g_aC_bD ( aD , bC ) ! if ( c . ne . d ) then g_p_ab_CD ( ab , CD ) = two * g_p_ab_CD ( ab , CD ) g_m_ab_CD ( ab , CD ) = two * g_m_ab_CD ( ab , CD ) endif ! enddo enddo ! do i = 1 , n_CCSD_o do j = 1 , i ! ij = index_packed ( i , j ) ! iC = index_two ( i , C , n_CC2_o ) jD = index_two ( j , D , n_CC2_o ) jC = index_two ( j , C , n_CC2_o ) iD = index_two ( i , D , n_CC2_o ) ! x_p_CD_ij ( CD , ij ) = x_IC_JD ( iC , jD ) + x_IC_JD ( iD , jC ) x_m_CD_ij ( CD , ij ) = x_IC_JD ( iC , jD ) - x_IC_JD ( iD , jC ) ! enddo enddo enddo enddo ! !              Dellocate g_ac_bd ! call wf % mem % dealloc ( g_aC_bD , ( n_CC2_v ) * a_length , ( n_CC2_v ) * b_length ) ! !              Allocate omega +- ! call wf % mem % alloc ( omega2_p_ab_ij , b_length * a_length , packed_size ( n_CCSD_o )) call wf % mem % alloc ( omega2_m_ab_ij , b_length * a_length , packed_size ( n_CCSD_o )) ! !               omega2_ab_ij = sum_(cd) g_ab_cd*t_cd_ij ! call dgemm ( 'N' , 'N' , & b_length * a_length , & packed_size ( n_CCSD_o ), & packed_size ( n_CC2_v ), & one / four , & g_p_ab_CD , & b_length * a_length , & x_p_CD_ij , & packed_size ( n_CC2_v ), & zero , & omega2_p_ab_ij , & b_length * a_length ) ! call dgemm ( 'N' , 'N' , & b_length * a_length , & packed_size ( n_CCSD_o ), & packed_size ( n_CC2_v ), & one / four , & g_m_ab_CD , & b_length * a_length , & x_m_CD_ij , & packed_size ( n_CC2_v ), & zero , & omega2_m_ab_ij , & b_length * a_length ) ! !          Deallocate +-g, +-t ! call wf % mem % dealloc ( g_p_ab_cd , b_length * a_length , packed_size ( n_CC2_v )) call wf % mem % dealloc ( g_m_ab_cd , b_length * a_length , packed_size ( n_CC2_v )) call wf % mem % dealloc ( x_p_cd_ij , packed_size ( n_CC2_v ), packed_size ( n_CCSD_o )) call wf % mem % dealloc ( x_m_cd_ij , packed_size ( n_CC2_v ), packed_size ( n_CCSD_o )) ! do i = 1 , n_CCSD_o do j = 1 , i ! ij = index_packed ( i , j ) ! do a = 1 , a_length ! Ai = index_two ( a + a_first - 1 , i , n_CCSD_v ) ! A is full-space a index Aj = index_two ( a + a_first - 1 , j , n_CCSD_v ) ! A is full-space a index ! do b = 1 , b_length ! Bj = index_two ( b + b_first - 1 , j , n_CCSD_v ) ! B is full-space b index Bi = index_two ( b + b_first - 1 , i , n_CCSD_v ) ! B is full-space b index ! ! ab = index_two ( a , b , a_length ) ! AiBj = index_packed ( Ai , Bj ) BiAj = index_packed ( Bi , Aj ) ! !                             Reorder into omega2_aibj ! wf % omega2 ( AiBj , 1 ) = wf % omega2 ( AiBj , 1 ) & + omega2_p_ab_ij ( ab , ij ) + omega2_m_ab_ij ( ab , ij ) ! if ( AiBj . ne . BiAj ) then wf % omega2 ( BiAj , 1 ) = wf % omega2 ( BiAj , 1 ) & + omega2_p_ab_ij ( ab , ij ) - omega2_m_ab_ij ( ab , ij ) endif ! enddo enddo enddo enddo ! !              Deallocate omega +- ! call wf % mem % dealloc ( omega2_p_ab_ij , b_length * a_length , packed_size ( n_CCSD_o )) call wf % mem % dealloc ( omega2_m_ab_ij , b_length * a_length , packed_size ( n_CCSD_o )) endif ! enddo ! End batching over b enddo ! End batching over a ! end subroutine omega_mlccsd_a2_mlccsd ! ! module subroutine omega_mlccsd_b2_mlccsd ( wf , x_kc_ld ) !! !!    Omega B2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, 11 Mar 2017 !! !!    Omega B2 = sum_(kl) x_ak_bl*(g_kilj + sum_(cd) x_ci_dj * g_kc_ld) !! !!    Structure: g_kilj is constructed first and reordered as g_kl_ij. !!    Then the contraction over cd is performed, and the results added to g_kl_ij. !!    x_ka_lb is then reordered as x_ab_kl and the contraction over kl is performed. !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_kc_ld ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: L_kc_J real ( dp ), dimension (:,:), allocatable :: L_Ki_J real ( dp ), dimension (:,:), allocatable :: g_kc_ld real ( dp ), dimension (:,:), allocatable :: g_kl_cd real ( dp ), dimension (:,:), allocatable :: g_Ki_Lj real ( dp ), dimension (:,:), allocatable :: I_KL_ij ! !     Reordered T2 apmlitudes ! real ( dp ), dimension (:,:), allocatable :: x_cd_ij real ( dp ), dimension (:,:), allocatable :: x_ab_kl ! !     Reordered omega ! real ( dp ), dimension (:,:), allocatable :: omega_ab_ij ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ab = 0 , cd = 0 integer ( i15 ) :: ai = 0 , ak = 0 , bj = 0 , bl = 0 , ci = 0 , dj = 0 integer ( i15 ) :: kc = 0 , ld = 0 , ka = 0 , lb = 0 integer ( i15 ) :: ij = 0 , ki = 0 , kl = 0 , lj = 0 ! integer ( i15 ) :: aibj = 0 , akbl = 0 , cidj = 0 ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o integer ( i15 ) :: first_CC2_v integer ( i15 ) :: first_CCSD_o integer ( i15 ) :: first_CCSD_v ! integer ( i15 ) :: last_CC2_o integer ( i15 ) :: last_CC2_v integer ( i15 ) :: last_CCSD_o integer ( i15 ) :: last_CCSD_v ! !     Calculate first/last indeces ! !     CC2 ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) ! !     CCSD ! call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! !     Create g_Ki_Lj = sum_J L_Ki_J*L_Lj_J ! call wf % mem % alloc ( g_Ki_Lj , ( n_CC2_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CCSD_o )) ! integral_type = 'electronic_repulsion' call wf % get_oo_oo ( integral_type , g_Ki_Lj , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o ) ! !     Reorder g_Ki_Lj to I_KL_ij ! call wf % mem % alloc ( I_KL_ij , ( n_CC2_o ) ** 2 , ( n_CCSD_o ) ** 2 ) ! do K = 1 , n_CC2_o do L = 1 , n_CC2_o do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o ! !                 Calculate compound indices ! Ki = index_two ( K , i , n_CC2_o ) Lj = index_two ( L , j , n_CC2_o ) KL = index_two ( K , L , n_CC2_o ) ij = index_two ( i , j , n_CCSD_o ) ! !                 Reordering g_ki_lj to g_kl_ij ! I_KL_ij ( KL , ij ) = g_Ki_Lj ( Ki , Lj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_Ki_Lj , ( n_CC2_o ) * ( n_CCSD_o ), ( n_CC2_o ) * ( n_CCSD_o )) ! !     Create g_ck_ld = sum_J L_kc_J*L_ld_J ! !     Read Cholesky vectors L_kc&#94;J ! call wf % mem % alloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KC_LD , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !     :: s2 contribution to I_kl_ij intermediate :: ! call wf % mem % alloc ( x_CD_ij , ( n_CC2_v ) ** 2 , ( n_CCSD_o ) ** 2 ) call wf % mem % alloc ( g_KL_CD , ( n_CC2_o ) ** 2 , ( n_CC2_v ) ** 2 ) ! do D = 1 , n_CC2_v do C = 1 , n_CC2_v ! CD = index_two ( C , D , n_CC2_v ) ! do L = 1 , n_CC2_o ! LD = index_two ( L , D , n_CC2_o ) ! do K = 1 , n_CC2_o ! KL = index_two ( K , L , n_CC2_o ) ! KC = index_two ( K , C , n_CC2_o ) ! g_KL_CD ( KL , CD ) = g_KC_LD ( KC , LD ) ! if (( K . le . n_CCSD_o ) . and . ( L . le . n_CCSD_o )) then ! ij = index_two ( k , l , n_CCSD_o ) x_cd_ij ( cd , ij ) = x_KC_LD ( KC , LD ) ! endif ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_KC_LD , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! call dgemm ( 'N' , 'N' , & ( n_CC2_o ) ** 2 , & ( n_CCSD_o ) ** 2 , & ( n_CC2_v ) ** 2 , & one , & g_kl_cd , & ( n_CC2_o ) ** 2 , & x_CD_ij , & ( n_CC2_v ) ** 2 , & one , & I_kl_ij , & ( n_CC2_o ) ** 2 ) ! call wf % mem % dealloc ( x_CD_ij , ( n_CC2_v ) ** 2 , ( n_CCSD_o ) ** 2 ) call wf % mem % dealloc ( g_KL_CD , ( n_CC2_o ) ** 2 , ( n_CC2_v ) ** 2 ) ! !     Reorder s_KC_LD into s_ab_KL ! call wf % mem % alloc ( x_ab_KL , ( n_CCSD_v ) ** 2 , ( n_CC2_o ) ** 2 ) ! do L = 1 , n_CC2_o do K = 1 , n_CC2_o ! KL = index_two ( K , L , n_CC2_o ) ! do b = 1 , n_CCSD_v ! Lb = index_two ( L , b , n_CC2_o ) ! do a = 1 , n_CCSD_v ! Ka = index_two ( K , a , n_CC2_o ) ab = index_two ( a , b , n_CCSD_v ) ! x_ab_KL ( ab , KL ) = x_KC_LD ( Ka , Lb ) ! enddo enddo enddo enddo ! !     omega_ab_ij = sum_(kl) s_ab_kl*I_kl_ij !                 = sum_(kl) s_ab_kl*(g_kilj + sum_(cd)(s_ci_dj + t_ci_dj)*g_kc_ld) ! call wf % mem % alloc ( omega_ab_ij , ( n_CCSD_v ) ** 2 , ( n_CCSD_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_v ) ** 2 , & ( n_CCSD_o ) ** 2 , & ( n_CC2_o ) ** 2 , & one , & x_ab_KL , & ( n_CCSD_v ) ** 2 , & I_KL_ij , & ( n_CC2_o ) ** 2 , & zero , & omega_ab_ij , & ( n_CCSD_v ) ** 2 ) ! call wf % mem % dealloc ( x_ab_KL , ( n_CCSD_v ) ** 2 , ( n_CC2_o ) ** 2 ) call wf % mem % dealloc ( I_KL_ij , ( n_CC2_o ) ** 2 , ( n_CCSD_o ) ** 2 ) ! !     Reorder into omega_aibj ! do i = 1 , n_CCSD_o do j = 1 , n_CCSD_o ! ij = index_two ( i , j , n_CCSD_o ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) ! do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! if ( ai . ge . bj ) then ! ab = index_two ( a , b , n_CCSD_v ) ! aibj = index_packed ( ai , bj ) ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega_ab_ij ( ab , ij ) ! endif ! enddo enddo enddo enddo ! call wf % mem % dealloc ( omega_ab_ij , ( n_CCSD_v ) ** 2 , ( n_CCSD_o ) ** 2 ) ! end subroutine omega_mlccsd_b2_mlccsd ! ! module subroutine omega_mlccsd_c2_mlccsd ( wf , x_lc_kd ) !! !!    Omega C2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017 !! !!    Z_ai_bj = - sum_(ck) x&#94;bc_kj*( g_ki,ac - 1/2 * sum_(dl) x&#94;ad_li*g_kd,cl ) !! !!    Omega_ai_bj = P_ij&#94;ab (1/2 Z_ai_bj + Z_aj_bi) = 1/2 Z_ai_bj + 1/2 Z_bj_ai + Z_aj_bi+ Z_bi_aj !! !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_lc_kd ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: L_Ki_J real ( dp ), dimension (:,:), allocatable :: L_Ca_J real ( dp ), dimension (:,:), allocatable :: L_aC_J real ( dp ), dimension (:,:), allocatable :: L_KD_J real ( dp ), dimension (:,:), allocatable :: g_kd_lc real ( dp ), dimension (:,:), allocatable :: g_dl_ck real ( dp ), dimension (:,:), allocatable :: g_Ki_aC real ( dp ), dimension (:,:), allocatable :: g_ai_ck ! !     Reordered X2 amplitudes ! real ( dp ), dimension (:,:), allocatable :: x_ai_dl ! !     Intermediates for matrix multiplication ! real ( dp ), dimension (:,:), allocatable :: I_ai_ck real ( dp ), dimension (:,:), allocatable :: Z_ai_bj ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ai = 0 , aj = 0 , al = 0 , bi = 0 , bj = 0 , bk = 0 , cj = 0 integer ( i15 ) :: ck = 0 , cl = 0 , di = 0 , dk = 0 , dl = 0 , ck_restricted = 0 integer ( i15 ) :: kd = 0 , lc = 0 , ca = 0 , ac = 0 , id = 0 , la = 0 integer ( i15 ) :: ki = 0 ! integer ( i15 ) :: aldi = 0 , aibj = 0 , cldk = 0 , bkcj = 0 , cjbk = 0 ! !     Batching and memory handling ! integer ( i15 ) :: required = 0 , available = 0 ! integer ( i15 ) :: n_batch = 0 , max_batch_length = 0 integer ( i15 ) :: a_batch = 0 , a_start = 0 , a_end = 0 , a_length = 0 ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o integer ( i15 ) :: first_CC2_v integer ( i15 ) :: first_CCSD_o integer ( i15 ) :: first_CCSD_v ! integer ( i15 ) :: last_CC2_o integer ( i15 ) :: last_CC2_v integer ( i15 ) :: last_CCSD_o integer ( i15 ) :: last_CCSD_v ! !     Calculate first/last indeces ! !     CC2 ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) ! !     CCSD ! call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! !     Reordering of g_ki_ac to g_ai_ck ! call wf % mem % alloc ( I_ai_CK , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     Prepare batching over a ! !     Setup of variables needed for batching ! available = get_available () required = 2 * ( n_CC2_v ** 2 ) * ( wf % n_J ) + 2 * ( n_CC2_v ) * ( n_CC2_o ) * ( wf % n_J ) required = 4 * required call num_batch ( required , available , max_batch_length , n_batch , n_CCSD_v ) ! a_start = 1 a_end = 0 a_length = 0 ! !     Start looping over batches ! do a_batch = 1 , n_batch ! !        Get batch limits  and  length of batch ! call batch_limits ( a_start , a_end , a_batch , max_batch_length , n_CCSD_v ) a_length = a_end - a_start + 1 ! !        Construct g_Ki,aC ordered as g_Ki_aC ! !        Allocate g_Ki_aC ! call wf % mem % alloc ( g_Ki_aC , ( n_CC2_o ) * ( n_CCSD_o ), ( n_CC2_v ) * a_length ) ! !        Get ab-cholesky vectors for the batch, L_ac&#94;J, then reorder from L_ac_J to L_ca_J ! integral_type = 'electronic_repulsion' call wf % get_oo_vv ( integral_type , g_Ki_aC , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o , & a_start , a_end , & first_CCSD_v , last_CCSD_v ) ! do i = 1 , n_CCSD_o do K = 1 , n_CC2_o ! Ki = index_two ( k , i , n_CC2_o ) ! do a = 1 , a_length ! ai = index_two ( a + a_start - 1 , i , n_CCSD_v ) ! do C = 1 , n_CC2_v ! aC = index_two ( a , C , a_length ) CK = index_two ( C , K , n_CC2_v ) ! I_ai_CK ( ai , CK ) = g_Ki_aC ( Ki , aC ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_Ki_aC , ( n_CC2_o ) * ( n_CCSD_o ), ( n_CC2_v ) * a_length ) ! enddo ! End of batching ! !     Reorder s_la_id to s_ai_dl ! call wf % mem % alloc ( x_ai_DL , n_CCSD_o * n_CCSD_v , n_CC2_o * n_CC2_v ) ! do L = 1 , n_CC2_o do D = 1 , n_CC2_v ! DL = index_two ( D , L , n_CC2_v ) ! do i = 1 , n_CCSD_o ! do a = 1 , n_CCSD_v ! La = index_two ( L , a , n_CC2_o ) ai = index_two ( a , i , n_CCSD_v ) iD = index_two ( i , d , n_CC2_o ) ! x_ai_DL ( ai , DL ) = x_lc_kd ( La , iD ) ! enddo enddo enddo enddo !     Create g_kd_lc ! call wf % mem % alloc ( g_KD_LC , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_KD_LC , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! call wf % mem % alloc ( g_DL_CK , n_CC2_v * n_CC2_o , n_CC2_v * n_CC2_o ) ! do L = 1 , n_CC2_o do D = 1 , n_CC2_v ! DL = index_two ( D , L , n_CC2_v ) ! do K = 1 , n_CC2_o ! KD = index_two ( K , D , n_CC2_o ) ! do C = 1 , n_CC2_v ! LC = index_two ( L , C , n_CC2_o ) CK = index_two ( C , K , n_CC2_v ) ! g_DL_CK ( DL , CK ) = g_KD_LC ( KD , LC ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_KD_LC , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & ( n_CC2_o ) * ( n_CC2_v ), & - half , & x_ai_DL , & ( n_CCSD_o ) * ( n_CCSD_v ), & g_DL_CK , & ( n_CC2_o ) * ( n_CC2_v ), & one , & I_ai_CK , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( g_DL_CK , n_CC2_v * n_CC2_o , n_CC2_v * n_CC2_o ) ! !     Create Z_ai_bj = -sum(ck) I_ai_ck*s_ck_bj (s&#94;bc_kj) ! call wf % mem % alloc ( Z_ai_bj , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call dgemm ( 'N' , 'T' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & - one , & I_ai_ck , & ( n_CCSD_o ) * ( n_CCSD_v ), & x_ai_dl , & ( n_CCSD_o ) * ( n_CCSD_v ), & zero , & Z_ai_bj , & ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( I_ai_CK , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) call wf % mem % dealloc ( x_ai_DL , n_CCSD_o * n_CCSD_v , n_CC2_o * n_CC2_v ) ! !     Omega_aibj,1 = P_ai_bj ( 1/2*Z_ai_bj + Z_aj_bi ) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! do j = 1 , n_CCSD_o do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) ! if ( ai . ge . bj ) then aj = index_two ( a , j , n_CCSD_v ) bi = index_two ( b , i , n_CCSD_v ) ! aibj = index_packed ( ai , bj ) ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + half * Z_ai_bj ( ai , bj ) + Z_ai_bj ( aj , bi ) & + half * Z_ai_bj ( bj , ai ) + Z_ai_bj ( bi , aj ) ! endif ! enddo enddo enddo enddo ! call wf % mem % dealloc ( Z_ai_bj , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! end subroutine omega_mlccsd_c2_mlccsd ! ! module subroutine omega_mlccsd_d2_mlccsd ( wf , x_KC_LD ) !! !!     Omega D2 !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Calculates the D2 term, !! !!      D2: sum_ck u_jk&#94;bc g_aikc !!        - 1/2 * sum_ck u_jk&#94;bc g_acki !!        + 1/4 * sum_ck u_jk&#94;bc sum_dl L_ldkc u_il&#94;ad, !! !!     where !! !!        u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc, !!        L_ldkc  = 2 * g_ldkc  - g_lckd. !! !!     The first, second, and third terms are referred to as D2.1, D2.2, and D2.3, !!     and comes out ordered as (ai,bj). All terms are added to the omega vector of the !!     wavefunction object wf. ! !     The routine adds the terms in the following order: D2.3, D2.1, D2.2 ! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_KC_LD ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , batch_dimension = 0 , n_batch = 0 integer ( i15 ) :: a_begin = 0 , a_end = 0 , a_batch = 0 , batch_length = 0 , a_full = 0 , ac_dim = 0 ! !     Indices ! integer ( i15 ) :: ai = 0 , aidl = 0 , al = 0 , aldi = 0 , a = 0 , i = 0 , b = 0 , ca = 0 , ac = 0 integer ( i15 ) :: j = 0 , c = 0 , d = 0 , di = 0 , dl = 0 , k = 0 , kc = 0 , kd = 0 , l = 0 , ki = 0 integer ( i15 ) :: lc = 0 , ld = 0 , aibj = 0 , bj = 0 , bjck = 0 , bk = 0 , bkcj = 0 , cj = 0 , ck = 0 integer ( i15 ) :: ia = 0 , kb = 0 , jb = 0 , jc = 0 , la = 0 , id = 0 ! real ( dp ), dimension (:,:), allocatable :: omega2_ai_bj ! For storing D2.3, D2.2 & D2.1 ! !     Vectors for D2.3 term ! real ( dp ), dimension (:,:), allocatable :: L_kc_J ! L_kc&#94;J real ( dp ), dimension (:,:), allocatable :: g_ld_kc ! g_ldkc real ( dp ), dimension (:,:), allocatable :: L_ld_kc ! L_ldkc = 2 * g_ldkc - g_lckd real ( dp ), dimension (:,:), allocatable :: u_ai_ld ! u_il&#94;ad = 2 * t_il&#94;ad - t_li&#94;ad real ( dp ), dimension (:,:), allocatable :: Z_ai_kc ! An intermediate, see below ! !     Vectors for D2.2 term ! real ( dp ), dimension (:,:), allocatable :: g_ai_kc ! g_aikc real ( dp ), dimension (:,:), allocatable :: u_kc_bj ! u_jk&#94;bc real ( dp ), dimension (:,:), allocatable :: L_ai_J ! L_ai&#94;J ! !     Vectors for D2.1 term ! real ( dp ), dimension (:,:), allocatable :: g_ai_ck ! g_acki real ( dp ), dimension (:,:), allocatable :: g_ac_ki ! g_acki; a is batched over real ( dp ), dimension (:,:), allocatable :: L_ac_J ! L_ac&#94;J; a is batched over real ( dp ), dimension (:,:), allocatable :: L_ki_J ! L_ki&#94;J real ( dp ), dimension (:,:), allocatable :: u_ck_bj ! u_jk&#94;bc ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o integer ( i15 ) :: first_CC2_v ! integer ( i15 ) :: first_CCSD_o integer ( i15 ) :: first_CCSD_v ! integer ( i15 ) :: last_CC2_o integer ( i15 ) :: last_CC2_v ! integer ( i15 ) :: last_CCSD_o integer ( i15 ) :: last_CCSD_v ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) ! call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! !     :: Calculate the D2.3 term of omega :: ! call wf % mem % alloc ( g_LD_KC ,( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_LD_KC , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !     Allocate L_ld_kc = L_ldkc and set to zero ! call wf % mem % alloc ( L_LD_KC , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     Determine L_ld_kc = L_ldkc from g_ld_kc = g_ldkc ! do L = 1 , n_CC2_o do D = 1 , n_CC2_v do K = 1 , n_CC2_o do C = 1 , n_CC2_v ! !                 Calculate the necessary indices ! LD = index_two ( L , D , n_CC2_o ) KC = index_two ( K , C , n_CC2_o ) ! LC = index_two ( L , C , n_CC2_o ) KD = index_two ( K , D , n_CC2_o ) ! !                 Set the value of L_ld_kc = 2 * g_ldkc - g_lckd ! L_LD_KC ( LD , KC ) = two * g_LD_KC ( LD , KC ) - g_LD_KC ( LC , KD ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_LD_KC , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! ! !     Determine u_ai_ld = u_il&#94;ad = 2 * x_il&#94;ad - x_li&#94;ad ! ! call wf % mem % alloc ( u_ai_LD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! do i = 1 , n_CCSD_o do l = 1 , n_CC2_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ia = index_two ( i , a , n_CC2_o ) la = index_two ( l , a , n_CC2_o ) ! do d = 1 , n_CC2_v ! ld = index_two ( l , d , n_CC2_o ) id = index_two ( i , d , n_CC2_o ) ! u_ai_LD ( ai , LD ) = two * ( x_KC_LD ( IA , LD )) - x_KC_LD ( LA , ID ) ! enddo enddo enddo enddo ! !     Allocate the intermediate Z_ai_kc = sum_dl u_ai_ld L_ld_kc and set it to zero ! call wf % mem % alloc ( Z_ai_KC , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     Form the intermediate Z_ai_kc = sum_dl u_ai_ld L_ld_kc ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & u_ai_LD , & ( n_CCSD_o ) * ( n_CCSD_v ), & L_LD_KC , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & Z_ai_KC , & ( n_CCSD_o ) * ( n_CCSD_v )) ! !     Deallocate L_ld_kc ! call wf % mem % dealloc ( L_ld_kc , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     Allocate the D2.3 term omega2_ai_bj and set it to zero ! call wf % mem % alloc ( omega2_ai_bj , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !     Form the D2.3 term, 1/4 sum_kc Z_ai_kc u_kc_bj = 1/4 sum_kc Z_ai_kc(ai,kc) u_ai_ld(bj,kc) ! call dgemm ( 'N' , 'T' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one / four , & Z_ai_kc , & ( n_CCSD_o ) * ( n_CCSD_v ), & u_ai_ld , & ( n_CCSD_o ) * ( n_CCSD_v ), & zero , & omega2_ai_bj , & ( n_CCSD_o ) * ( n_CCSD_v )) ! !     Some mathematical justification for the above matrix multiplication. We have ! !           1/4 * sum_ck (sum_dl u_il&#94;ad L_ldkc) u_jk&#94;bc = 1/4 * sum_ck Z_ai,kc u_kc,bj, ! !     where Z_ai,kc = sum_dl u_ai,ld L_ld,kc. Note that u_ai_ld(ai,ld) = u_il&#94;ad, !     which means that u_ai_ld(bj,kc)&#94;T = u_ai_ld(kc,bj) = u_kj&#94;cb = u_jk&#94;bc. ! ! !     Deallocate the Z_ai_kc intermediate ! call wf % mem % dealloc ( Z_ai_kc , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     Add the D2.3 term to the omega vector ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! do b = 1 , n_CCSD_v do j = 1 , n_CCSD_o ! bj = index_two ( b , j , n_CCSD_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_ai_bj ( ai , bj ) & + omega2_ai_bj ( bj , ai ) ! endif ! enddo enddo enddo enddo ! !     Deallocate the omega2_ai_bj and u_ai_ld(ai,ld) = u_il&#94;ad vector ! call wf % mem % dealloc ( omega2_ai_bj , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( u_ai_LD , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     :: Calculate the D2.1 term of omega :: ! !     Allocate g_ai_kc = g_aikc ! call wf % mem % alloc ( g_ai_KC , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! integral_type = 'electronic_repulsion' call wf % get_vo_ov ( integral_type , g_ai_KC , & first_CCSD_v , last_CCSD_v , & first_CCSD_o , last_CCSD_o , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! ! !     Allocate u_kc_bj and set it to zero ! call wf % mem % alloc ( u_KC_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !     Determine u_kc_bj = u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc ! do K = 1 , n_CC2_o do C = 1 , n_CC2_v ! KC = index_two ( K , C , n_CC2_o ) ! do j = 1 , n_CCSD_o ! JC = index_two ( J , C , n_CC2_o ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) KB = index_two ( k , b , n_CC2_o ) JB = index_two ( j , b , n_CC2_o ) ! u_KC_bj ( kc , bj ) = two * ( x_KC_LD ( KC , JB )) - x_KC_LD ( KB , JC ) ! enddo enddo enddo enddo ! !     Allocate omega2_ai_bj and set it to zero ! call wf % mem % alloc ( omega2_ai_bj , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !     Calculate the D2.1 term sum_ck u_jk&#94;bc g_aikc = sum_ck g_ai_kc u_kc_bj ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & one , & g_ai_kc , & ( n_CCSD_o ) * ( n_CCSD_v ), & u_kc_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & omega2_ai_bj , & ( n_CCSD_o ) * ( n_CCSD_v )) ! !     Add the D2.1 term to the omega vector ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! do j = 1 , n_CCSD_o do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_ai_bj ( ai , bj ) & + omega2_ai_bj ( bj , ai ) ! endif ! enddo enddo enddo enddo ! !    Deallocate g_ai_kc, u_kc_bj, and the omega2_ai_bj vectors ! call wf % mem % dealloc ( g_ai_KC , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) call wf % mem % dealloc ( u_KC_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! call wf % mem % dealloc ( omega2_ai_bj , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSd_o ) * ( n_CCSD_v )) ! !    :: Calculate D2.2 term of Omega :: ! !    - 1/2 * sum_ck u_jk&#94;bc g_acki = -1/2 * sum_ck g_ai_ck u_ck_bj ! !    Allocate the full g_ai_ck = g_acki and set it to zero ! call wf % mem % alloc ( g_ai_CK , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !    Prepare for batching over the index a to calculate g_ai_ck = g_acki ! !    To calculate this term, we need to first create L_ac&#94;J, then hold L_ac&#94;J and g_acki !    in memory simultaneously ! required = ( wf % n_J ) * ( n_CC2_v ) * ( n_CCSD_v ) ! Holding L_ac&#94;J ! required = required & + max ( (( n_CC2_v ) ** 2 ) * (( n_CC2_o ) ** 2 ), & ! Testing if it is more demanding ( wf % n_J ) * ( n_CC2_v ) ** 2 + 2 * ( wf % n_J ) * ( n_CC2_o ) * ( n_CC2_v )) ! to hold g_acki or to create L_ac&#94;J ! required = 4 * required ! In words ! available = get_available () batch_dimension = n_CCSD_v ! !     Determine the batching variables ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Determine g_ai_ck = g_acki successively in batches over a ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_begin , a_end , a_batch , max_batch_length , batch_dimension ) batch_length = a_end - a_begin + 1 ! !        Get ab-cholesky vectors for the batch, L_ac&#94;J, then reorder from L_ac_J to L_ca_J ! aC_dim = batch_length * ( n_CC2_v ) ! Dimension of ac for the batch over index a ! !       Allocate the integral g_ca_ki = g_acki and set to zero ! call wf % mem % alloc ( g_aC_Ki , aC_dim , ( n_CC2_o ) * ( n_CCSD_o )) ! integral_type = 'electronic_repulsion' call wf % get_vv_oo ( integral_type , g_aC_Ki , & a_begin , a_end , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CCSD_o , last_CCSD_o ) ! !        Reorder the integrals g_ca_ki (reduced a) = g_acki = g_ai_ck (full a) ! do a = 1 , batch_length ! a_full = a - 1 + a_begin ! The full matrix index a ! do i = 1 , n_CCSD_o ! ai = index_two ( a_full , i , n_CCSD_v ) ! do k = 1 , n_CC2_o ! ki = index_two ( k , i , n_CC2_o ) ! do c = 1 , n_CC2_v ! ac = index_two ( a , c , batch_length ) ck = index_two ( c , k , n_CC2_v ) ! g_ai_ck ( ai , ck ) = g_ac_ki ( ac , ki ) ! enddo enddo enddo enddo ! !       Deallocate the g_ca_ki and L_ca_J vectors ! call wf % mem % dealloc ( g_ac_ki , ac_dim , ( n_CC2_o ) * ( n_CCSD_o )) ! enddo ! End of loop over batches of a !     Allocate the u_ck_bj = u_jk&#94;bc vector and set it to zero ! call wf % mem % alloc ( u_CK_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) u_CK_bj = zero ! !     Determine u_ck_bj = u_jk&#94;bc = 2 * x_jk&#94;bc - x_kj&#94;bc ! do k = 1 , n_CC2_o do j = 1 , n_CCSD_o do c = 1 , n_CC2_v ! CK = index_two ( C , K , n_CC2_v ) KC = index_two ( K , C , n_CC2_o ) JC = index_two ( J , C , n_CC2_o ) ! do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) JB = index_two ( J , B , n_CC2_o ) KB = index_two ( K , B , n_CC2_o ) ! u_CK_bj ( CK , bj ) = two * ( x_KC_LD ( JB , KC )) - x_KC_LD ( KB , JC ) ! enddo enddo enddo enddo ! !    Allocate the D2.2 term and set it to zero ! call wf % mem % alloc ( omega2_ai_bj , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! !    Calculate the D2.2 term, - 1/2 * sum_ck u_jk&#94;bc g_acki = -1/2 * sum_ck g_ai_ck u_ck_bj ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CCSD_o ) * ( n_CCSD_v ), & ( n_CC2_o ) * ( n_CC2_v ), & - one / two , & g_ai_ck , & ( n_CCSD_o ) * ( n_CCSD_v ), & u_ck_bj , & ( n_CC2_o ) * ( n_CC2_v ), & zero , & omega2_ai_bj , & ( n_CCSD_o ) * ( n_CCSD_v )) ! !    Add the D2.2 term to the omega vector ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! do j = 1 , n_CCSD_o do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_ai_bj ( ai , bj ) & + omega2_ai_bj ( bj , ai ) ! endif ! enddo enddo enddo enddo ! !    Deallocations ! call wf % mem % dealloc ( g_ai_ck , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CC2_o ) * ( n_CC2_v )) call wf % mem % dealloc ( u_ck_bj , ( n_CC2_o ) * ( n_CC2_v ), ( n_CCSD_o ) * ( n_CCSD_v )) call wf % mem % dealloc ( L_ki_J , ( n_CC2_o ) * ( n_CCSD_o ), wf % n_J ) ! call wf % mem % dealloc ( omega2_ai_bj , ( n_CCSD_o ) * ( n_CCSD_v ), ( n_CCSD_o ) * ( n_CCSD_v )) ! end subroutine omega_mlccsd_d2_mlccsd ! ! module subroutine omega_mlccsd_e2_mlccsd ( wf , x_kc_ld ) !! !!     Omega E2 !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Calculates the E2 term, !! !!      E2: sum_c t_ij&#94;ac (F_bc - sum_dkl g_ldkc u_kl&#94;bd) !!        - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc), !! !!     where !! !!        u_kl&#94;bc = 2 * t_kl&#94;bc - t_lk&#94;bc. !! !!     The first term is referred to as the E2.1 term, and comes out ordered as (b,jai). !!     The second term is referred to as the E2.2 term, and comes out ordered as (aib,j). !! !!     Both are permuted added to the projection vector element omega2(ai,bj) of !!     the wavefunction object wf. !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_kc_ld ! !     Indices ! integer ( i15 ) :: aib = 0 , aibk = 0 , bk = 0 , bja = 0 , ibj = 0 , aibj = 0 , dlck = 0 integer ( i15 ) :: b = 0 , c = 0 , k = 0 , d = 0 , ck = 0 , ckdl = 0 , cl = 0 , cldk = 0 integer ( i15 ) :: dk = 0 , dl = 0 , kc = 0 , kdl = 0 , l = 0 , ld = 0 , a = 0 , ai = 0 integer ( i15 ) :: ia = 0 , kd = 0 , lc = 0 , jc = 0 , kb = 0 integer ( i15 ) :: bj = 0 , aicj = 0 , cj = 0 , i = 0 , j = 0 , jai = 0 , dlc = 0 , dkcl = 0 ! !     Vectors for E2.1 term ! real ( dp ), dimension (:,:), allocatable :: omega2_b_jai ! For storing the E2.1 term temporarily real ( dp ), dimension (:,:), allocatable :: L_kc_J ! L_kc&#94;J real ( dp ), dimension (:,:), allocatable :: g_ld_kc ! g_ldkc real ( dp ), dimension (:,:), allocatable :: g_kdl_c ! g_ldkc real ( dp ), dimension (:,:), allocatable :: u_b_kdl ! u_kl&#94;bd real ( dp ), dimension (:,:), allocatable :: X_b_c ! An intermediate, see below for definition real ( dp ), dimension (:,:), allocatable :: x_c_jai ! t_ij&#94;ac ! !     Vectors for E2.2 term ! real ( dp ), dimension (:,:), allocatable :: g_k_dlc ! g_ldkc real ( dp ), dimension (:,:), allocatable :: u_dlc_j ! u_lj&#94;dc real ( dp ), dimension (:,:), allocatable :: omega2_aib_j ! For storing the E2.2 term temporarily real ( dp ), dimension (:,:), allocatable :: Y_k_j ! An intermediate, see below for definition real ( dp ), dimension (:,:), allocatable :: x_aib_k ! t_ik&#94;ab ! !     Active space variables ! integer ( i15 ) :: n_CC2_o = 0 , n_CC2_v = 0 integer ( i15 ) :: n_CCSD_o = 0 , n_CCSD_v = 0 ! integer ( i15 ) :: first_CC2_o integer ( i15 ) :: first_CC2_v ! integer ( i15 ) :: first_CCSD_o integer ( i15 ) :: first_CCSD_v ! integer ( i15 ) :: last_CC2_o integer ( i15 ) :: last_CC2_v ! integer ( i15 ) :: last_CCSD_o integer ( i15 ) :: last_CCSD_v ! integer ( i15 ) :: offset ! !     Calculate first/last indeces ! call wf % get_CC2_active_indices ( first_CC2_o , first_CC2_v ) call wf % get_CC2_n_active ( n_CC2_o , n_CC2_v ) ! call wf % get_CCSD_active_indices ( first_CCSD_o , first_CCSD_v ) call wf % get_CCSD_n_active ( n_CCSD_o , n_CCSD_v ) ! last_CC2_o = first_CC2_o + n_CC2_o - 1 last_CC2_v = first_CC2_v + n_CC2_v - 1 ! last_CCSD_o = first_CCSD_o + n_CCSD_o - 1 last_CCSD_v = first_CCSD_v + n_CCSD_v - 1 ! !     :: Calculate the E2.1 term of omega :: ! !     Form g_ld_kc = g_ldkc ! call wf % mem % alloc ( g_LD_KC , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_LD_KC , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! ! !     Allocate u_b_kdl = u_kl&#94;bd ! call wf % mem % alloc ( u_b_kdl , n_CCSD_v , ( n_CC2_v ) * (( n_CC2_o ) ** 2 )) ! !     Allocate g_kdl_c = g_ldkc ! call wf % mem % alloc ( g_kdl_c , ( n_CC2_v ) * (( n_CC2_o ) ** 2 ), n_CC2_v ) ! !     Determine u_b_kdl = u_kl&#94;bd and g_kdl_c = g_ldkc ! ! do l = 1 , n_CC2_o do d = 1 , n_CC2_v ! LD = index_two ( L , D , n_CC2_o ) ! do k = 1 , n_CC2_o ! KD = index_two ( K , D , n_CC2_o ) KDL = index_three ( K , D , L , n_CC2_o , n_CC2_v ) ! do c = 1 , n_CC2_v ! Use as though \"b\" for u_b_kdl term ! KC = index_two ( K , C , n_CC2_o ) LC = index_two ( L , C , n_CC2_o ) ! !                 Set the values of u_b_kdl and g_kdl_c ! if ( C . le . n_CCSD_v ) then ! C as b u_b_KDL ( c , KDL ) = two * ( x_KC_LD ( KC , LD )) - x_KC_LD ( LC , KD ) endif ! g_KDL_C ( KDL , C ) = g_LD_KC ( LD , KC ) ! g_ldkc ! enddo enddo enddo enddo ! !     Deallocate the unordered integrals g_ld_kc = g_ldkc ! !        Note: It might be better to reorder g_kdl_c to g_k_dlc in the !        calculation of the E2.2 term. For now (8 Mar 2017), it remains !        simple & stupid. ! call wf % mem % dealloc ( g_LD_KC , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     Allocate the intermediate X_b_c = F_bc - sum_dkl g_ldkc u_kl&#94;bd and set to zero ! call wf % mem % alloc ( X_b_C , n_CCSD_v , n_CC2_v ) ! !     Copy the virtual-virtual Fock matrix into the intermediate ! do b = 1 , n_CCSD_v do c = 1 , n_CC2_v X_b_c ( b , C ) = wf % fock_ab ( b , C ) enddo enddo ! !     Add the second contribution, !     - sum_dkl g_ldkc u_kl&#94;bd = - sum_dkl u_b_kdl * g_kdl_c, to X_b_c ! call dgemm ( 'N' , 'N' , & n_CCSD_v , & n_CC2_v , & ( n_CC2_v ) * ( n_CC2_o ) ** 2 , & - one , & u_b_KDL , & n_CCSD_v , & g_KDL_C , & ( n_CC2_v ) * ( n_cc2_o ) ** 2 , & one , & X_b_C , & n_CCSD_v ) ! !     Deallocate u_b_kdl and g_kdl_c ! call wf % mem % dealloc ( u_b_KDL , n_CCSD_v , ( n_CC2_v ) * ( n_CC2_o ) ** 2 ) call wf % mem % dealloc ( g_KDL_C , ( n_CC2_v ) * ( n_CC2_o ) ** 2 , n_CC2_v ) ! !     Form the reordered t_c_jai = t_ij&#94;ac ! call wf % mem % alloc ( x_c_jai , n_CC2_v , ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 ) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ia = index_two ( i , a , n_CC2_o ) ! do j = 1 , n_CCSD_o ! jai = index_three ( j , a , i , n_CCSD_o , n_CCSD_v ) ! do c = 1 , n_CC2_v ! jc = index_two ( j , c , n_CC2_o ) ! x_c_jai ( c , jai ) = x_KC_LD ( IA , JC ) ! enddo enddo enddo enddo ! !     Form the E2.1 term ! call wf % mem % alloc ( omega2_b_jai , n_CCSD_v , ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & n_CCSD_v , & ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 , & n_CC2_v , & one , & X_b_c , & n_CCSD_v , & x_c_jai , & n_CC2_v , & zero , & omega2_b_jai , & n_CCSD_v ) ! !     Add the E2.1 term to the omega vector ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! do j = 1 , n_CCSD_o ! jai = index_three ( j , a , i , n_CCSD_o , n_CCSD_v ) ! do b = 1 , n_CCSD_v ! ibj = index_three ( i , b , j , n_CCSD_o , n_CCSD_v ) ! bj = index_two ( b , j , n_CCSD_v ) ! aibj = index_packed ( ai , bj ) ! !                 Restrict the indices to avoid adding both (ai,bj) and (bj,ai), !                 as they are identical in packed indices ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_b_jai ( b , jai ) & + omega2_b_jai ( a , ibj ) ! endif ! enddo enddo enddo enddo ! !     Deallocate the E2.1 term, the X intermediate, and the reordered amplitudes ! call wf % mem % dealloc ( omega2_b_jai , n_CCSD_v , ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 ) call wf % mem % dealloc ( X_b_c , n_CCSD_v , n_CC2_v ) call wf % mem % dealloc ( x_c_jai , n_CC2_v , ( n_CCSD_v ) * ( n_CCSD_o ) ** 2 ) ! !     :: Calculate E.2.2 term of omega :: !     Form g_ld_kc = g_ldkc ! call wf % mem % alloc ( g_LD_KC , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_LD_KC , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v , & first_CC2_o , last_CC2_o , & first_CC2_v , last_CC2_v ) ! !     Allocate g_k_dlc = g_ldkc ! call wf % mem % alloc ( g_k_dlc , n_CC2_o , ( n_CC2_o ) * (( n_CC2_v ) ** 2 )) ! !     Allocate u_dlc_j = u_lj&#94;dc ! call wf % mem % alloc ( u_dlc_j , ( n_CC2_o ) * (( n_CC2_v ) ** 2 ), n_CCSD_o ) ! !     Determine g_k_dlc = g_ldkc and u_dlc_j = u_lj&#94;dc ! do k = 1 , n_CC2_o ! Use as though \"j\" for u_dlc_j term do c = 1 , n_CC2_v ! KC = index_two ( K , C , n_CC2_o ) ! do L = 1 , n_CC2_o ! LC = index_two ( L , C , n_CC2_o ) ! do D = 1 , n_CC2_v ! DLC = index_three ( D , L , C , n_CC2_v , n_CC2_o ) ! LD = index_two ( L , D , n_CC2_o ) KD = index_two ( K , D , n_CC2_o ) ! !                 Set the value of g_k_dlc and u_dlc_j ! g_k_dlc ( K , DLC ) = g_ld_kc ( ld , kc ) ! g_ldkc if ( k . le . n_CCSD_o ) then !k = j ! u_dlc_j ( dlc , k ) = two * ( x_KC_LD ( LD , KC )) - x_KC_LD ( KD , LC ) ! u_lk&#94;dc = 2 * t_lk&#94;dc - t_kl&#94;dc ! endif enddo enddo enddo enddo ! !     Deallocate the integrals g_ld_kc = g_ldkc ! call wf % mem % dealloc ( g_LD_KC , ( n_CC2_o ) * ( n_CC2_v ), ( n_CC2_o ) * ( n_CC2_v )) ! !     Allocate the intermediate Y_k_j = F_kj  + sum_cdl u_lj&#94;dc g_ldkc !                                     = F_k_j + sum_cdl g_k_dlc * u_dlc_j ! call wf % mem % alloc ( Y_k_j , n_CC2_o , n_CCSD_o ) ! !     Copy the occupied-occupied Fock matrix, such that Y_k_j = F_kj ! do j = 1 , n_CCSD_o do k = 1 , n_CC2_o Y_k_j ( k , j ) = wf % fock_ij ( k , j ) enddo enddo ! !     Add sum_cdl g_k_dlc u_dlc_j to Y_k_j, such that !     Y_k_j = F_k_j + sum_cdl g_k_dlc u_dlc_j ! call dgemm ( 'N' , 'N' , & n_CC2_o , & n_CCSD_o , & ( n_CC2_o ) * (( n_CC2_v ) ** 2 ), & one , & g_K_DLC , & n_CC2_o , & u_dlc_j , & ( n_CC2_o ) * (( n_CC2_v ) ** 2 ), & one , & Y_k_j , & n_CC2_o ) ! !     Deallocate u_dlc_j and g_k_dlc ! call wf % mem % dealloc ( u_dlc_j , ( n_CC2_o ) * (( n_CC2_v ) ** 2 ), n_CCSD_o ) call wf % mem % dealloc ( g_k_dlc , n_CC2_o , ( n_CC2_o ) * (( n_CC2_v ) ** 2 )) ! !     Allocate t_aib_k = t_ik&#94;ab and set it to zero ! call wf % mem % alloc ( x_aib_k , ( n_CCSD_o ) * (( n_CCSD_v ) ** 2 ), n_CC2_o ) ! !     Determine t_aib_k = t_ik&#94;ab ! do k = 1 , n_CC2_o do b = 1 , n_CCSD_v ! KB = index_two ( K , B , n_CC2_o ) ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! IA = index_two ( I , A , n_CC2_o ) aib = index_three ( a , i , b , n_CCSD_v , n_CCSD_o ) ! x_aib_k ( aib , k ) = x_KC_LD ( ia , kb ) ! enddo enddo enddo enddo ! !     Allocate the E2.2 term and set to zero ! call wf % mem % alloc ( omega2_aib_j , ( n_CCSD_o ) * (( n_CCSD_v ) ** 2 ), n_CCSD_o ) ! !     Calculate the E2.2 term, !     - sum_k t_aib_k Y_k_j = - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc) ! call dgemm ( 'N' , 'N' , & ( n_CCSD_o ) * (( n_CCSD_v ) ** 2 ), & n_CCSD_o , & n_CC2_o , & - one , & x_aib_k , & ( n_CCSD_o ) * (( n_CCSD_v ) ** 2 ), & Y_k_j , & n_CC2_o , & zero , & omega2_aib_j , & ( n_CCSD_o ) * (( n_CCSD_v ) ** 2 )) ! !     Deallocate t_aib_k and Y_k_j ! call wf % mem % dealloc ( x_aib_k , ( n_CCSD_o ) * (( n_CCSD_v ) ** 2 ), n_CC2_o ) call wf % mem % dealloc ( Y_k_j , n_CC2_o , n_CCSD_o ) ! !     Add the E2.2 term to the omega vector ! do i = 1 , n_CCSD_o do a = 1 , n_CCSD_v ! ai = index_two ( a , i , n_CCSD_v ) ! do j = 1 , n_CCSD_o do b = 1 , n_CCSD_v ! bj = index_two ( b , j , n_CCSD_v ) ! aibj = index_packed ( ai , bj ) ! aib = index_three ( a , i , b , n_CCSD_v , n_CCSD_o ) bja = index_three ( b , j , a , n_CCSD_v , n_CCSD_o ) ! !                 Restrict the indices to avoid adding both (ai,bj) and (bj,ai), !                 as they are identical in packed indices ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_aib_j ( aib , j ) & + omega2_aib_j ( bja , i ) ! endif ! enddo enddo enddo enddo ! !     Deallocate the E2.2 term ! call wf % mem % dealloc ( omega2_aib_j , ( n_CCSD_o ) * (( n_CCSD_v ) ** 2 ), n_CCSD_o ) ! end subroutine omega_mlccsd_e2_mlccsd ! ! end submodule omega","tags":"","loc":"sourcefile/omega_submodule.f90~2.html","title":"omega_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ground_state_submodule.f90~~EfferentGraph sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileground_state_submodulef90EfferentGraph = svgPanZoom('#sourcefileground_state_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules ground_state Source Code ground_state_submodule.F90 Source Code submodule ( mlccsd_class ) ground_state ! !! !!     Ground state submodule (MLCCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !! !!     Consists of the following module subroutines of the MLCCSD module: !! !!     new_amplitudes:             Calculates the quasi-Newton estimate and passes the !!                                 information needed by the DIIS routine. !!     calc_ampeqs_norm:           Calculates the norm of the amplitude equations. !!     calc_quasi_Newton_doubles:  Calculates the doubles part of the quasi-Newton estimate. !!     initialize_ground_state:    Initializes the amplitudes (MP2 estimate) and the amplitude !!                                 equations. !! !! ! implicit none ! ! contains ! ! module subroutine calc_ampeqs_norm_mlccsd ( wf , ampeqs_norm ) ! !     Calculate Amplitude Equations Norm (MLCCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! implicit none ! class ( mlccsd ) :: wf ! real ( dp ) :: ampeqs_norm ! real ( dp ) :: ddot ! For dot product ! ampeqs_norm = zero ampeqs_norm = ddot ( wf % n_t1am , wf % omega1 , 1 , wf % omega1 , 1 ) ampeqs_norm = ddot ( wf % n_t2am , wf % omega2 , 1 , wf % omega2 , 1 ) + ampeqs_norm ampeqs_norm = sqrt ( ampeqs_norm ) ! end subroutine calc_ampeqs_norm_mlccsd ! ! module subroutine new_amplitudes_mlccsd ( wf ) ! !     New Amplitudes (MLCCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !     Directs the calculation of the quasi-Newton estimate Δ t_i, !     and t_i + Δ t_i, and calls the DIIS routine to save & get !     the amplitudes for the next iteration. ! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: i = 0 ! for debug purposes ! real ( dp ), dimension (:,:), allocatable :: dt ! Δ t_i real ( dp ), dimension (:,:), allocatable :: t_dt ! t_i + Δ t_i ! !     Allocate Δ t_i and t_i + Δ t_i vectors ! call wf % mem % alloc ( dt , wf % n_parameters , 1 ) call wf % mem % alloc ( t_dt , wf % n_parameters , 1 ) ! dt = zero t_dt = zero ! !     Calculate Δ t_i ! call wf % calc_quasi_Newton_singles ( dt ) call wf % calc_quasi_Newton_doubles ( dt ) ! !     Set t_i + Δ t_i ! call dcopy ( wf % n_parameters , dt , 1 , t_dt , 1 ) ! t_dt = Δ t_i ! call daxpy ( wf % n_t1am , one , wf % t1am , 1 , t_dt , 1 ) ! t_dt = t_i + Δ t_i singles call daxpy ( wf % n_t2am , one , wf % t2am , 1 , t_dt ( wf % n_t1am + 1 , 1 ), 1 ) ! t_dt = t_i + Δ t_i doubles ! !     Save estimates to file and get the next amplitudes !     (they are placed in dt on exit from diis) ! call wf % diis ( dt , t_dt ) ! !     Set the new amplitudes ! call dcopy ( wf % n_t1am , dt , 1 , wf % t1am , 1 ) call dcopy ( wf % n_t2am , dt ( wf % n_t1am + 1 , 1 ), 1 , wf % t2am , 1 ) ! !     Deallocate vectors ! call wf % mem % dealloc ( dt , wf % n_parameters , 1 ) call wf % mem % dealloc ( t_dt , wf % n_parameters , 1 ) ! end subroutine new_amplitudes_mlccsd ! ! module subroutine calc_quasi_Newton_doubles_mlccsd ( wf , dt ) ! !     Calculate quasi-Newtoni doubles estimate (CCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !     Calculates the quasi-Newton estimate Δ t_i (doubbles part) !     and places the contribution in the dt vector (of length n_parameters, !     with singles first, then doubles, etc. if inherited) ! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: dt ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 integer ( i15 ) :: ai = 0 , bj = 0 , aibj = 0 , offset = 0 ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CCSD_active_indices ( first_active_o , first_active_v ) call wf % get_CCSD_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! !     Calculate the doubles Δ t_i contribution ! do a = 1 , n_active_v do i = 1 , n_active_o do b = 1 , n_active_v do j = 1 , n_active_o ! !                 Calculate the necessary indices ! ai = index_two ( a , i , n_active_v ) bj = index_two ( b , j , n_active_v ) ! aibj = index_packed ( ai , bj ) ! dt ( wf % n_t1am + aibj , 1 ) = - wf % omega2 ( aibj , 1 ) / & ( wf % fock_diagonal ( wf % n_o + a + first_active_v - 1 , 1 ) + & wf % fock_diagonal ( wf % n_o + b + first_active_v - 1 , 1 ) - & wf % fock_diagonal ( i + first_active_o - 1 , 1 ) - & wf % fock_diagonal ( j + first_active_o - 1 , 1 )) ! enddo enddo enddo enddo ! end subroutine calc_quasi_Newton_doubles_mlccsd ! ! module subroutine initialize_ground_state_mlccsd ( wf ) !! !!    Initialize Ground State (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Initializes the amplitudes and the projection vector for the ground !!    state solver. !! implicit none ! class ( mlccsd ) :: wf ! call wf % initialize_amplitudes ! Allocate amplitudes call wf % construct_perturbative_doubles ! Set doubles amplitudes to MP2 guess call wf % initialize_omega ! Allocate projection vector ! end subroutine initialize_ground_state_mlccsd ! ! end submodule ground_state","tags":"","loc":"sourcefile/ground_state_submodule.f90.html","title":"ground_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~cholesky_submodule.f90~~EfferentGraph sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilecholesky_submodulef90EfferentGraph = svgPanZoom('#sourcefilecholesky_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules cholesky Source Code cholesky_submodule.F90 Source Code submodule ( mlccsd_class ) cholesky ! !! !!    Cholesky submodule (MLCCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! ! implicit none ! ! contains ! ! module subroutine read_transform_cholesky_for_CC2_amplitude_mlccsd ( wf ) ! implicit none ! class ( mlccsd ) :: wf ! ! integer ( i15 ) :: unit_chol_ao = 0 , ioerror = 0 integer ( i15 ) :: unit_chol_mo_ai = - 1 integer ( i15 ) :: unit_chol_mo_ia = - 1 integer ( i15 ) :: unit_chol_mo_ij = - 1 integer ( i15 ) :: unit_chol_mo_ab = - 1 integer ( i15 ) :: unit_chol_mo_ab_tmp = - 1 integer ( i15 ) :: J , i , a , ai , ia , k , ij , ij_rec , b , ab ! real ( dp ), dimension (:,:), allocatable :: C_o , C_v real ( dp ), dimension (:,:), allocatable :: chol_ao_sq , chol_ao real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: L_ij_J real ( dp ), dimension (:,:), allocatable :: L_ab_J real ( dp ), dimension (:,:), allocatable :: X ! !     Batching variables ! integer ( i15 ) :: b_batch = 0 , b_first = 0 , b_last = 0 , b_length = 0 integer ( i15 ) :: required = 0 , available = 0 , n_batch = 0 , batch_dimension = 0 integer ( i15 ) :: max_batch_length = 0 ! integer ( i15 ) :: throw_away_index = 0 real ( dp ) :: throw_away ! call wf % mem % alloc ( C_o , wf % n_ao , wf % n_o ) call wf % mem % alloc ( C_v , wf % n_ao , wf % n_v ) ! do i = 1 , wf % n_o ! C_o (:, i ) = wf % mo_coef_cc2_ccs (:, i ) ! enddo ! do a = 1 , wf % n_v ! C_v (:, a ) = wf % mo_coef_cc2_ccs (: , wf % n_o + a ) ! enddo ! !     Read AO-cholesky ! call generate_unit_identifier ( unit_chol_ao ) open ( unit = unit_chol_ao , file = 'MLCC_CHOLESKY' , status = 'old' , form = 'formatted' ) rewind ( unit_chol_ao ) ! !     Read the number of Cholesky vectors (n_J) and !     the number of atomic orbitals (n_ao) ! read ( unit_chol_ao , * ) wf % n_ao , wf % n_J ! !     Open files for mo cholesky in CCS/CC2 block diagonal basis ! call generate_unit_identifier ( unit_chol_mo_ai ) call generate_unit_identifier ( unit_chol_mo_ia ) call generate_unit_identifier ( unit_chol_mo_ij ) call generate_unit_identifier ( unit_chol_mo_ab ) ! !     ai-type ! open ( unit = unit_chol_mo_ai , file = 'cholesky_ai_cc2_amplitudes' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) ! !     ia-type ! open ( unit = unit_chol_mo_ia , file = 'cholesky_ia_cc2_amplitudes' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) ! !     ij-type ! open ( unit = unit_chol_mo_ij , file = 'cholesky_ij_cc2_amplitudes' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) ! !     ab-type ! open ( unit = unit_chol_mo_ab , file = 'cholesky_ab_cc2_amplitudes' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while creating cholesky_ai_cc2_amplitudes' stop endif ! call wf % mem % alloc ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_ai_J = zero ! do J = 1 , wf % n_J ! call wf % mem % alloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) call wf % mem % alloc ( chol_ao_sq , wf % n_ao , wf % n_ao ) chol_ao = zero chol_ao_sq = zero ! read ( unit_chol_ao , * ) ( chol_ao ( i , 1 ), i = 1 , wf % n_ao * ( wf % n_ao + 1 ) / 2 ) ! call squareup ( chol_ao , chol_ao_sq , wf % n_ao ) ! call wf % mem % dealloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) ! call wf % mem % alloc ( X , wf % n_ao , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_o , & wf % n_ao , & one , & chol_ao_sq , & wf % n_ao , & C_o , & wf % n_ao , & zero , & X , & wf % n_ao ) ! call wf % mem % dealloc ( chol_ao_sq , wf % n_ao , wf % n_ao ) ! call dgemm ( 'T' , 'N' , & wf % n_v , & wf % n_o , & wf % n_ao , & one , & C_v , & wf % n_ao , & X , & wf % n_ao , & one , & L_ai_J ( 1 , J ),& wf % n_v ) ! call wf % mem % dealloc ( X , wf % n_ao , wf % n_o ) enddo ! !     ai-type ! do ai = 1 , ( wf % n_o ) * ( wf % n_v ) write ( unit_chol_mo_ai , rec = ai ) ( L_ai_J ( ai , j ), j = 1 , wf % n_J ) enddo ! !     ia-type ! do a = 1 , ( wf % n_v ) do i = 1 , wf % n_o ia = index_two ( i , a , wf % n_o ) ai = index_two ( a , i , wf % n_v ) write ( unit_chol_mo_ia , rec = ia ) ( L_ai_J ( ai , j ), j = 1 , wf % n_J ) enddo enddo call wf % mem % dealloc ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! call wf % mem % alloc ( L_ij_J , ( wf % n_o ) * ( wf % n_o ), wf % n_J ) L_ij_J = zero ! !     Rewind ao cholesky file ! rewind ( unit_chol_ao ) read ( unit_chol_ao , * ) wf % n_ao , wf % n_J ! do J = 1 , wf % n_J ! call wf % mem % alloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) call wf % mem % alloc ( chol_ao_sq , wf % n_ao , wf % n_ao ) chol_ao = zero chol_ao_sq = zero ! read ( unit_chol_ao , * ) ( chol_ao ( i , 1 ), i = 1 , wf % n_ao * ( wf % n_ao + 1 ) / 2 ) ! call squareup ( chol_ao , chol_ao_sq , wf % n_ao ) ! call wf % mem % dealloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) ! call wf % mem % alloc ( X , wf % n_ao , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_o , & wf % n_ao , & one , & chol_ao_sq , & wf % n_ao , & C_o , & wf % n_ao , & zero , & X , & wf % n_ao ) ! call wf % mem % dealloc ( chol_ao_sq , wf % n_ao , wf % n_ao ) ! call dgemm ( 'T' , 'N' , & wf % n_o , & wf % n_o , & wf % n_ao , & one , & C_o , & wf % n_ao , & X , & wf % n_ao , & one , & L_ij_J ( 1 , J ),& wf % n_o ) ! call wf % mem % dealloc ( X , wf % n_ao , wf % n_o ) enddo ! !     ij-type ! do ij = 1 , ( wf % n_o ) * ( wf % n_o ) write ( unit_chol_mo_ij , rec = ij ) ( L_ij_J ( ij , j ), j = 1 , wf % n_J ) enddo ! call wf % mem % dealloc ( L_ij_J , ( wf % n_o ) * ( wf % n_o ), wf % n_J ) ! !     Cannot hold all vectors, must first write for each J, !     then read and write to direct access file in batches of b ! call wf % mem % alloc ( L_ab_J , wf % n_v , wf % n_v ) ! rewind ( unit_chol_ao ) read ( unit_chol_ao , * ) wf % n_ao , wf % n_J ! ! call generate_unit_identifier ( unit_chol_mo_ab_tmp ) open ( unit_chol_mo_ab_tmp , file = 'cholesky_ab_tmp' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ab_tmp ) ! do J = 1 , wf % n_J ! call wf % mem % alloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) call wf % mem % alloc ( chol_ao_sq , wf % n_ao , wf % n_ao ) chol_ao = zero chol_ao_sq = zero ! read ( unit_chol_ao , * ) ( chol_ao ( i , 1 ), i = 1 , wf % n_ao * ( wf % n_ao + 1 ) / 2 ) ! call squareup ( chol_ao , chol_ao_sq , wf % n_ao ) ! call wf % mem % dealloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) ! call wf % mem % alloc ( X , wf % n_ao , wf % n_v ) ! call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_v , & wf % n_ao , & one , & chol_ao_sq , & wf % n_ao , & C_v , & wf % n_ao , & zero , & X , & wf % n_ao ) ! call wf % mem % dealloc ( chol_ao_sq , wf % n_ao , wf % n_ao ) ! call dgemm ( 'T' , 'N' , & wf % n_v , & wf % n_v , & wf % n_ao , & one , & C_v , & wf % n_ao , & X , & wf % n_ao , & zero , & L_ab_J , & wf % n_v ) ! call wf % mem % dealloc ( X , wf % n_ao , wf % n_v ) ! write ( unit_chol_mo_ab_tmp ) (( L_ab_J ( a , b ), b = 1 , a ), a = 1 , wf % n_v ) ! enddo ! call wf % mem % dealloc ( L_ab_J , ( wf % n_v ),( wf % n_v )) ! !     Read L_ab_J in batches over b ! required = (( wf % n_v ) ** 2 ) * ( wf % n_J ) ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index b max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do b_batch = 1 , n_batch ! rewind ( unit_chol_mo_ab_tmp ) ! call batch_limits ( b_first , b_last , b_batch , max_batch_length , batch_dimension ) b_length = b_last - b_first + 1 ! call wf % mem % alloc ( L_ab_J , ((( b_length + 1 ) * b_length / 2 ) + ( wf % n_v - b_length - b_first + 1 ) * b_length ), wf % n_J ) ! if ( b_first . ne . 1 ) then ! !           Calculate index of last element to throw away ! throw_away_index = index_packed ( wf % n_v , b_first - 1 ) ! !           Throw away all elements from 1 to throw_away_index, then read from batch start ! do j = 1 , wf % n_J ! read ( unit_chol_mo_ab_tmp ) ( throw_away , i = 1 , throw_away_index ), & ( L_ab_J ( a , j ), a = 1 ,((( b_length + 1 ) * b_length / 2 ) + ( wf % n_v - b_length - b_first + 1 ) * b_length )) ! enddo ! else ! !           Read from the start of each entry ! do j = 1 , wf % n_J ! read ( unit_chol_mo_ab_tmp ) ( L_ab_J ( a , j ), & a = 1 , ((( b_length + 1 ) * b_length / 2 ) + ( wf % n_v - b_length - b_first + 1 ) * b_length )) ! enddo ! endif ! do a = 1 , wf % n_v do b = b_first , b_last ab = index_packed ( a , b ) write ( unit_chol_mo_ab , rec = ab ) ( L_ab_J ( ab , J ), J = 1 , wf % n_J ) enddo enddo ! call wf % mem % dealloc ( L_ab_J , ((( b_length + 1 ) * b_length / 2 ) + ( wf % n_v - b_length - b_first + 1 ) * b_length ), wf % n_J ) ! enddo close ( unit_chol_mo_ab_tmp , status = 'delete' ) ! close ( unit_chol_ao ) ! close ( unit_chol_mo_ai ) close ( unit_chol_mo_ia ) close ( unit_chol_mo_ij ) close ( unit_chol_mo_ab ) ! call wf % mem % dealloc ( C_o , wf % n_ao , wf % n_o ) call wf % mem % dealloc ( C_v , wf % n_ao , wf % n_v ) ! end subroutine read_transform_cholesky_for_CC2_amplitude_mlccsd ! ! module subroutine read_cholesky_ai_for_cc2_amplitudes_mlccsd ( wf , L_ai_J , a_first , a_last , i_first , i_last ) !! !!    Read Cholesky IA !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky IA (occ-vir) vectors from file and !!    places them in the incoming L_ia_J matrix !! !! !!    Optional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: L_ai_J ! L_ia&#94;J integer ( i15 ) :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ) :: i_last , a_last ! Last index (can differ from n_o/n_v when batching or for mlcc) ! !        Local routine variables ! integer ( i15 ) :: unit_chol_mo_ai = - 1 ! Unit identifier for cholesky_ia file integer ( i15 ) :: ioerror = 0 ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , ai = 0 , ai_full = 0 ! integer ( i15 ) :: active_space integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 ! n_active_o = i_last - i_first + 1 n_active_v = a_last - a_first + 1 ! !        Prepare for reading: generate unit idientifier, open, and rewind file ! call generate_unit_identifier ( unit_chol_mo_ai ) open ( unit = unit_chol_mo_ai , file = 'cholesky_ai_cc2_amplitudes' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while reading cholesky_ai_cc2_amplitudes' stop endif ! !        Read Cholesky vectors into the L_ia_J matrix ! do i = 1 , n_active_o do a = 1 , n_active_v ai = index_two ( a , i , n_active_v ) ai_full = index_two ( a + a_first - 1 , i + i_first - 1 , wf % n_v ) ! read ( unit_chol_mo_ai , rec = ai_full ) ( L_ai_J ( ai , j ), j = 1 , wf % n_J ) enddo ! enddo ! !        Close file ! close ( unit_chol_mo_ai ) ! end subroutine read_cholesky_ai_for_cc2_amplitudes_mlccsd ! ! module subroutine read_cholesky_ia_for_cc2_amplitudes_mlccsd ( wf , L_ia_J , i_first , i_last , a_first , a_last ) !! !!    Read Cholesky IA !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky IA (occ-vir) vectors from file and !!    places them in the incoming L_ia_J matrix !! !! !!    Optional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ) :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ) :: i_last , a_last ! Last index (can differ from n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ia_J ! L_ia&#94;J ! !     Local routine variables ! integer ( i15 ) :: unit_chol_mo_ia = - 1 ! Unit identifier for cholesky_ia file integer ( i15 ) :: ioerror = 0 ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , ia = 0 , ia_full = 0 ! integer ( i15 ) :: i_length , a_length ! i_length = i_last - i_first + 1 a_length = a_last - a_first + 1 ! !     Prepare for reading: generate unit idientifier, open, and rewind file ! call generate_unit_identifier ( unit_chol_mo_ia ) open ( unit = unit_chol_mo_ia , file = 'cholesky_ia_cc2_amplitudes' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while reading cholesky_ij_direct' stop endif ! !     Read Cholesky vectors into the L_ia_J matrix ! do i = 1 , i_length do a = 1 , a_length ! ia_full = index_two ( i + i_first - 1 , a + a_first - 1 , wf % n_o ) ia = index_two ( i , a , i_length ) read ( unit_chol_mo_ia , rec = ia_full ) ( L_ia_J ( ia , j ), j = 1 , wf % n_J ) ! enddo enddo ! !     Close file ! close ( unit_chol_mo_ia ) ! end subroutine read_cholesky_ia_for_cc2_amplitudes_mlccsd ! ! module subroutine read_cholesky_ij_for_cc2_amplitudes_mlccsd ( wf , L_ij_J , i_first , i_last , j_first , j_last ) !! !!    Read Cholesky IJ !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky IJ (occ-occ) vectors from file and !!    places them in the incoming L_ij_J matrix !! !!    Optional arguments: i_first, i_last, j_first, j_last can be used in order to restrict indices !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ) :: i_first , j_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ) :: i_last , j_last ! Last index (can differ from n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ij_J ! L_ij&#94;J ! !     Local routine variables ! integer ( i15 ) :: unit_chol_mo_ij = - 1 ! Unit identifier for cholesky_ij file integer ( i15 ) :: ioerror ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 , ij = 0 , ik = 0 , ij_full ! integer ( i15 ) :: i_length , j_length ! number of i and j elements ! ! i_length = i_last - i_first + 1 j_length = j_last - j_first + 1 ! !     Prepare for reading: generate unit idientifier, open file, and rewind ! call generate_unit_identifier ( unit_chol_mo_ij ) open ( unit = unit_chol_mo_ij , file = 'cholesky_ij_cc2_amplitudes' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while reading cholesky_ij_direct' stop endif ! !     Read the Cholesky vectors into the L_ij_J matrix ! do i = 1 , i_length do k = 1 , j_length ! ij_full = index_two (( i + i_first - 1 ), ( k + j_first - 1 ), wf % n_o ) ! ij = index_two ( i , k , i_length ) ! read ( unit_chol_mo_ij , rec = ij_full ) ( L_ij_J ( ij , J ), J = 1 , wf % n_J ) ! enddo enddo ! !     Close file ! close ( unit_chol_mo_ij ) ! end subroutine read_cholesky_ij_for_cc2_amplitudes_mlccsd ! ! module subroutine read_cholesky_ab_for_cc2_amplitudes_mlccsd ( wf , L_ab_J , a_first , a_last , b_first , b_last ) !! !!    Read Cholesky AB !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky AB (vir-vir) vectors from file and !!    places them in the incoming L_ab_J matrix, with batching !!    if necessary !! !!    Optional arguments: b_first, b_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ), intent ( in ) :: a_first , b_first ! First index (can differ from 1 when batching  or for mlcc) integer ( i15 ), intent ( in ) :: a_last , b_last ! Last index  (can differ from n_v when batching or for mlcc) real ( dp ), dimension ((( a_last - a_first + 1 ) * ( b_last - b_first + 1 )), wf % n_J ) :: L_ab_J ! L_ab&#94;J ! ! integer ( i15 ) :: unit_chol_mo_ab_direct = - 1 ! Unit identifier for cholesky_ab file integer ( i15 ) :: ioerror = 0 ! integer ( i15 ) :: a = 0 , b = 0 , j = 0 , i = 0 , ab = 0 , ab_full = 0 integer ( i15 ) :: a_length , b_length ! a_length = a_last - a_first + 1 b_length = b_last - b_first + 1 ! !     Prepare for reading: generate unit identifier, open, and rewind file ! call generate_unit_identifier ( unit_chol_mo_ab_direct ) open ( unit = unit_chol_mo_ab_direct , file = 'cholesky_ab_cc2_amplitudes' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while reading cholesky_ab_direct.' , ioerror stop endif ! do a = 1 , a_length do b = 1 , b_length ab_full = index_packed ( a + a_first - 1 , b + b_first - 1 ) ab = index_two ( a , b , a_length ) read ( unit_chol_mo_ab_direct , rec = ab_full ) ( L_ab_J ( ab , J ), J = 1 , wf % n_J ) enddo enddo ! !        Close file ! close ( unit_chol_mo_ab_direct ) ! ! end subroutine read_cholesky_ab_for_cc2_amplitudes_mlccsd ! ! module subroutine get_cholesky_ai_for_cc2_amplitudes_mlccsd ( wf , L_ai_J , a_first , a_last , i_first , i_last ) !! !!    Get Cholesky AI !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Read and T1-transform Cholesky AI vectors: !! !!       L_ai_J_T1 = L_ia_J - sum_j  t_aj*L_ji_J !!                          + sum_b  t_bi*L_ab_J !!                          - sum_bj t_aj*t_bi*L_jb_J !! !!    Allocations in routine: !! !!      (1) n_J*(i_length)*(a_length) + 2*n_J*(a_length)*batch_length  ->  for L_ab_J contribution (batches of b) !!      (2) n_J*(i_length)*n_v + 2*n_J*n_o*(i_length)                  ->  for L_ij_J contribution !!      (3) 2*n_J*n_o*n_v                                              ->  for L_jb_J contribution !! !! !!      (1) determines memory requirement. !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: L_ai_J integer ( i15 ) :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ) :: i_last , a_last ! Last index (can differ from n_o/n_v when batching or for mlcc) ! !     Batch variables ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , n_batch = 0 , L_off = 0 integer ( i15 ) :: a_batch = 0 , batch_start = 0 , batch_end = 0 , batch_length = 0 ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , J = 0 , i = 0 , ai = 0 , Ja = 0 , ia = 0 integer ( i15 ) :: ba = 0 , k = 0 , ik = 0 , iJ = 0 , kb = 0 , kJ = 0 , ab = 0 integer ( i15 ) :: a_length , i_length ! !     Cholesky vectors (in many different orderings) ! real ( dp ), dimension (:,:), allocatable :: L_ba_J real ( dp ), dimension (:,:), allocatable :: L_ab_J real ( dp ), dimension (:,:), allocatable :: L_Ja_b real ( dp ), dimension (:,:), allocatable :: L_Ja_i real ( dp ), dimension (:,:), allocatable :: L_ik_J real ( dp ), dimension (:,:), allocatable :: L_k_iJ real ( dp ), dimension (:,:), allocatable :: L_a_iJ real ( dp ), dimension (:,:), allocatable :: L_kJ_b real ( dp ), dimension (:,:), allocatable :: L_kJ_i real ( dp ), dimension (:,:), allocatable :: L_kb_J real ( dp ), dimension (:,:), allocatable :: t1_a_i real ( dp ), dimension (:,:), allocatable :: X1_a_i integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 ! n_active_o = i_last - i_first + 1 n_active_v = a_last - a_first + 1 ! call wf % mem % alloc ( X1_a_I , wf % n_v , wf % n_o ) ! call dgemm ( 'T' , 'N' , & wf % n_v , & wf % n_o , & wf % n_v , & one , & wf % T_v , & wf % n_v , & wf % t1am , & wf % n_v , & zero , & X1_a_I , & wf % n_v ) ! call wf % mem % alloc ( t1_a_i , wf % n_v , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & wf % n_o , & one , & X1_a_I , & wf % n_v , & wf % T_o , & wf % n_o , & zero , & t1_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X1_a_I , wf % n_v , wf % n_o ) ! !     Read L_ai&#94;J from file ! call wf % read_cholesky_ai_for_cc2_amplitudes ( L_ai_J , a_first , a_last , i_first , i_last ) ! !     :: L_ab_J contributions :: ! ! !     Allocate L_Ja_i ! call wf % mem % alloc ( L_Ja_i , ( wf % n_J ) * n_active_v , n_active_o ) L_Ja_i = zero ! !     Set batching variables ! required = 2 * ( wf % n_v ) ** 2 * ( wf % n_J ) * 4 available = get_available () max_batch_length = 0 ! n_batch = 0 a_batch = 0 ! batch_length = 0 batch_start = 0 batch_end = 0 ! !     Calculate the number of batches ! call num_batch ( required , available , max_batch_length , n_batch , n_active_v ) ! do a_batch = 1 , n_batch ! !        Get start, end, and length of batch ! call batch_limits ( batch_start , batch_end , a_batch , max_batch_length , n_active_v ) batch_length = batch_end - batch_start + 1 ! call wf % mem % alloc ( L_ab_J , batch_length * ( wf % n_v ), wf % n_J ) ! L_ab&#94;J L_ab_J = zero ! !        Read Cholesky AB vectors, batching over a ! call wf % read_cholesky_ab_for_cc2_amplitudes ( L_ab_J , batch_start , batch_end , 1 , wf % n_v ) ! call wf % mem % alloc ( L_ba_J , ( wf % n_v ) * batch_length , wf % n_J ) ! L_ab&#94;J = L_ba_J(ba,J) ! L_ba_J = zero ! do b = 1 , wf % n_v do a = 1 , batch_length ! ba = index_two ( b , a , wf % n_v ) ab = index_two ( a , b , batch_length ) ! do J = 1 , wf % n_J ! L_ba_J ( ba , J ) = L_ab_J ( ab , J ) ! enddo enddo enddo ! call wf % mem % dealloc ( L_ab_J , batch_length * ( wf % n_v ), wf % n_J ) ! call wf % mem % alloc ( L_Ja_b , batch_length * ( wf % n_J ), wf % n_v ) L_Ja_b = zero ! !        Reorder the Cholesky array L_ba_J ! do a = 1 , batch_length do b = 1 , wf % n_v do J = 1 , wf % n_J ! !                 Needed indices ! ba = index_two ( b , a , wf % n_v ) Ja = index_two ( J , a , wf % n_J ) ! L_Ja_b ( Ja , b ) = L_ba_J ( ba , J ) ! L_ab&#94;J ! enddo enddo enddo call wf % mem % dealloc ( L_ba_J , ( wf % n_v ) * batch_length , wf % n_J ) ! !        Calculate sum_b L_Ja_b*t_b_i = L_Ja_i ! L_off = index_two ( 1 , batch_start , wf % n_J ) ! ! call dgemm ( 'N' , 'N' , & batch_length * ( wf % n_J ), & n_active_o , & wf % n_v , & one , & L_Ja_b , & batch_length * ( wf % n_J ), & t1_a_i , & wf % n_v , & one , & L_Ja_i ( L_off , 1 ), & ( n_active_v ) * ( wf % n_J )) ! ! !        Deallocate  L_Ja_b ! call wf % mem % dealloc ( L_Ja_b , batch_length * ( wf % n_J ), wf % n_v ) ! enddo ! batching over a ! !     Add terms to T1-transformed Cholesky AI vector ! do i = 1 , n_active_o do a = 1 , n_active_v do J = 1 , wf % n_J ! !              Needed indices ! Ja = index_two ( J , a , wf % n_J ) ai = index_two ( a , i , n_active_v ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_Ja_i ( Ja , i ) ! enddo enddo enddo ! !     Deallocate L_Ja_i ! call wf % mem % dealloc ( L_Ja_i , ( wf % n_J ) * n_active_v , n_active_o ) ! ! !     :: L_ij_J contributions :: ! ! !     Allocate L_a_iJ, L_ik_J, L_k_iJ ! call wf % mem % alloc ( L_a_iJ , n_active_v , ( wf % n_J ) * n_active_o ) call wf % mem % alloc ( L_k_iJ , wf % n_o , n_active_o * ( wf % n_J )) ! call wf % mem % alloc ( L_ik_J , ( wf % n_o ) * n_active_o , wf % n_J ) ! !     Read Cholesky IJ vectors ! call wf % read_cholesky_ij_for_cc2_amplitudes ( L_ik_J , 1 , n_active_o , 1 , wf % n_o ) ! L_ik_J(ik,J) = L_ik&#94;J ! !     Reorder IJ Cholesky vectors ! do i = 1 , n_active_o do k = 1 , wf % n_o do J = 1 , wf % n_J ! !              Needed indices ! ik = index_two ( i , k , n_active_o ) iJ = index_two ( i , J , n_active_o ) ! L_k_iJ ( k , iJ ) = L_ik_J ( ik , J ) ! L_k_iJ(k,iJ) = L_ik&#94;J ! enddo enddo enddo ! !     Calculate -sum_k t_a_k*L_k_iJ = L_a_iJ  ! Here we assume L_ik&#94;J = L_ki&#94;J ! call dgemm ( 'N' , 'N' , & n_active_v , & n_active_o * ( wf % n_J ), & wf % n_o , & - one , & t1_a_i , & wf % n_v , & L_k_iJ , & wf % n_o , & zero , & L_a_iJ , & n_active_v ) ! !     Add terms to T1-transformation of L_ai_J ! do i = 1 , n_active_o do a = 1 , n_active_v do J = 1 , wf % n_J ! !              Needed indices ! ai = index_two ( a , i , n_active_v ) iJ = index_two ( i , J , n_active_o ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_a_iJ ( a , iJ ) ! enddo enddo enddo ! !     Deallocate L_a_iJ, L_ik_J, L_k_iJ ! call wf % mem % dealloc ( L_a_iJ , n_active_v , ( wf % n_J ) * n_active_o ) call wf % mem % dealloc ( L_k_iJ , wf % n_o , n_active_o * ( wf % n_J )) ! call wf % mem % dealloc ( L_ik_J , ( wf % n_o ) * n_active_o , wf % n_J ) ! ! !     :: L_jb_J contributions :: ! ! call wf % mem % alloc ( L_kJ_b , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) call wf % mem % alloc ( L_kb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Read the Cholesky vector L_kb_J ! call wf % read_cholesky_ia_for_cc2_amplitudes ( L_kb_J , 1 , wf % n_o , 1 , wf % n_v ) ! ! !     Reorder L_kb_J to L_kJ_b ! do k = 1 , wf % n_o do b = 1 , wf % n_v do J = 1 , wf % n_J ! kb = index_two ( k , b , wf % n_o ) kJ = index_two ( k , J , wf % n_o ) ! L_kJ_b ( kJ , b ) = L_kb_J ( kb , J ) ! enddo enddo enddo ! !     Deallocate L_kb_J ! call wf % mem % dealloc ( L_kb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Allocate L_kJ_i ! call wf % mem % alloc ( L_kJ_i , ( wf % n_o ) * ( wf % n_J ), n_active_o ) ! !     Calculate sum_b L_kJ_b*t_b_i = L_kJ_i ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_J ), & n_active_o , & wf % n_v , & one , & L_kJ_b , & ( wf % n_o ) * ( wf % n_J ), & t1_a_i , & wf % n_v , & zero , & L_kJ_i , & ( wf % n_o ) * ( wf % n_J )) ! !     Deallocate L_kJ_b ! call wf % mem % dealloc ( L_kJ_b , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) ! !     Allocate L_k_iJ ! call wf % mem % alloc ( L_k_iJ , ( wf % n_o ), n_active_o * ( wf % n_J )) ! !     Reorder L_kJ_i to L_k_iJ ! do i = 1 , n_active_o do k = 1 , wf % n_o do J = 1 , wf % n_J ! kJ = index_two ( k , J , wf % n_o ) iJ = index_two ( i , J , n_active_o ) ! L_k_iJ ( k , iJ ) = L_kJ_i ( kJ , i ) ! enddo enddo enddo ! !     Deallocate L_kJ_i ! call wf % mem % dealloc ( L_kJ_i , ( wf % n_o ) * ( wf % n_J ), n_active_o ) ! !     Allocate L_a_iJ ! call wf % mem % alloc ( L_a_iJ , n_active_v , n_active_o * ( wf % n_J )) ! !     Calculate sum_k t_a_k*L_k_iJ = L_a_iJ ! call dgemm ( 'N' , 'N' , & n_active_v , & n_active_o * ( wf % n_J ), & wf % n_o , & - one , & t1_a_i , & wf % n_v , & L_k_iJ , & wf % n_o , & zero , & L_a_iJ , & n_active_v ) ! !     Add contribution to L ai_J ! do a = 1 , n_active_v do i = 1 , n_active_o do J = 1 , wf % n_J ! iJ = index_two ( i , J , n_active_o ) ai = index_two ( a , i , n_active_v ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_a_iJ ( a , iJ ) ! enddo enddo enddo ! !     Deallocations ! call wf % mem % dealloc ( L_a_iJ , n_active_v , n_active_o * ( wf % n_J )) call wf % mem % dealloc ( L_k_iJ , wf % n_o , n_active_o * ( wf % n_J )) call wf % mem % dealloc ( t1_a_i , wf % n_v , wf % n_o ) ! end subroutine get_cholesky_ai_for_cc2_amplitudes_mlccsd ! ! end submodule cholesky","tags":"","loc":"sourcefile/cholesky_submodule.f90.html","title":"cholesky_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~excited_state_submodule.f90~2~~EfferentGraph sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileexcited_state_submodulef902EfferentGraph = svgPanZoom('#sourcefileexcited_state_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules excited_state Source Code excited_state_submodule.F90 Source Code submodule ( mlccsd_class ) excited_state ! !! !!    Excited state submodule (MLCCSD) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Aug 2017 !! !! ! implicit none ! logical :: debug = . false . logical :: timings = . false . ! ! contains ! module subroutine initialize_excited_states_mlccsd ( wf ) !! !!    Initialize excited states !!    Written by Sarai D. Folkestad, Aug 2017 !! !!    Calculates and sets n_s2am, and updates n_parameters !!    for excited state calculation !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: n_o integer ( i15 ) :: n_v ! !     Add packed number of double amplitudes ! n_o = wf % n_CC2_o + wf % n_CCSD_o n_v = wf % n_CC2_v + wf % n_CCSD_v ! wf % n_x2am = ( n_o * n_v ) * ( n_o * n_v + 1 ) / 2 ! wf % n_parameters = wf % n_t1am + wf % n_x2am ! end subroutine initialize_excited_states_mlccsd ! ! module subroutine transform_trial_vectors_mlccsd ( wf , first_trial , last_trial ) !! !!    Transformation of Trial Vectors (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Each trial vector in first_trial to last_trial is read from file and !!    transformed before the transformed vector is written to file. !! !!    Singles and doubles part of the transformed vectors are written to !!    the same record in file transformed_vec, record length is n_parameters long. !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ), intent ( in ) :: first_trial , last_trial ! Which trial_vectors we are to transform ! real ( dp ), dimension (:,:), allocatable :: c_a_i real ( dp ), dimension (:,:), allocatable :: c_aibj ! integer ( i15 ) :: unit_trial_vecs = 0 , unit_rho = 0 , ioerror = 0 integer ( i15 ) :: trial = 0 ! ! !     Allocate c_a_i and c_aibj ! call wf % mem % alloc ( c_a_i , wf % n_v , wf % n_o ) c_a_i = zero ! call wf % mem % alloc ( c_aibj , wf % n_x2am , 1 ) c_aibj = zero ! !     Open trial vector- and transformed vector files ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * wf % n_parameters , iostat = ioerror ) ! call generate_unit_identifier ( unit_rho ) open ( unit = unit_rho , file = 'transformed_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * wf % n_parameters , iostat = ioerror ) ! !     For each trial vector: read, transform and write ! do trial = first_trial , last_trial ! read ( unit_trial_vecs , rec = trial , iostat = ioerror ) c_a_i , c_aibj ! if ( wf % excited_state_specifications % right ) then ! call wf % jacobian_mlccsd_transformation ( c_a_i , c_aibj ) ! elseif ( wf % excited_state_specifications % left ) then ! write ( unit_output , * ) 'Error: Jacobian transpose not implemented for mlcc2' stop ! else ! write ( unit_output , * ) 'Error: Excited state task not recognized' stop ! endif ! !        -::- Projections -::- ! !        Test for core calculation ! if ( wf % tasks % core_excited_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from valence contributions ! call wf % cvs_rho_a_i_projection ( c_a_i ) call wf % cvs_rho_aibj_projection ( c_aibj ) ! endif ! !        Test for ionization calculation ! if ( wf % tasks % ionized_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from regular excitations ! write ( unit_output , * ) 'Error: Ionized state not implemented for mlcc2' stop ! endif ! write ( unit_rho , rec = trial , iostat = ioerror ) c_a_i , c_aibj ! enddo ! !     Close files ! close ( unit_trial_vecs ) close ( unit_rho ) ! !     Deallocate c_a_i and c_aibj ! call wf % mem % dealloc ( c_a_i , wf % n_v , wf % n_o ) call wf % mem % dealloc ( c_aibj , wf % n_x2am , 1 ) ! end subroutine transform_trial_vectors_mlccsd ! ! module subroutine print_excitation_vector_mlccsd ( wf , vec , unit_id ) !! !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: vec ! integer ( i15 ) :: unit_id ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 integer ( i15 ) :: n_active_o , n_active_v real ( dp ) :: a_active_i_active , a_active_i_inactive , a_inactive_i_active , a_inactive_i_inactive , total ! !        Print singles part ! write ( unit_id , '(2a6,a12)' ) 'a' , 'i' , 'coeff' write ( unit_id , '(t3,a)' ) '-------------------------' ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) if ( abs ( vec ( ai , 1 )) . gt . 1.0D-03 ) then write ( unit_id , '(2i6,f12.4)' ) a , i , vec ( ai , 1 ) endif ! enddo enddo flush ( unit_id ) ! !     Print doubles part ! write ( unit_id , '(/4a6, a11)' ) 'a' , 'i' , 'b' , 'j' , 'coeff' write ( unit_id , '(t3,a)' ) '---------------------------------' ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! do a = 1 , n_active_v do i = 1 , n_active_o do b = 1 , n_active_v do j = 1 , n_active_o ! ai = index_two ( a , i , n_active_v ) bj = index_two ( b , j , n_active_v ) aibj = index_packed ( ai , bj ) ! if ( abs ( vec (( wf % n_o ) * ( wf % n_v ) + aibj , 1 )) . gt . 1.0D-03 . and . ai . ge . bj ) then write ( unit_id , '(4i6,f12.4)' ) a , i , b , j , vec (( wf % n_o ) * ( wf % n_v ) + aibj , 1 ) endif ! enddo enddo enddo enddo ! ! ! call wf % get_CCSD_n_active ( n_active_o , n_active_v ) ! a_active_i_active = 0 a_inactive_i_active = 0 a_active_i_inactive = 0 a_inactive_i_inactive = 0 ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) ! if ( a . le . n_active_v . and . i . le . n_active_o ) then ! a_active_i_active = a_active_i_active + ( vec ( ai , 1 )) ** 2 ! elseif ( a . le . n_active_v . and . i . gt . n_active_o ) then ! a_active_i_inactive = a_active_i_inactive + ( vec ( ai , 1 )) ** 2 ! elseif ( a . gt . n_active_v . and . i . le . n_active_o ) then ! a_inactive_i_active = a_inactive_i_active + ( vec ( ai , 1 )) ** 2 ! elseif ( a . gt . n_active_v . and . i . gt . n_active_o ) then ! a_inactive_i_inactive = a_inactive_i_inactive + ( vec ( ai , 1 )) ** 2 ! endif enddo enddo ! !     Print active space stats: ! total = ( a_active_i_active + a_active_i_inactive + a_inactive_i_active + a_inactive_i_inactive ) write ( unit_id , '(/a10, 3a12)' ) 'T->T:' , 'S->T:' , 'T->S:' , 'S->S:' write ( unit_id , '(a50)' ) '--------------------------------------------------' write ( unit_id , '(4f12.5)' ) a_active_i_active / total ,& a_active_i_inactive / total , & a_inactive_i_active / total ,& a_inactive_i_inactive / total write ( unit_id , '(/t3,a40,f12.5/)' ) 'Singles contribution to excitation is' , total ! ! end subroutine print_excitation_vector_mlccsd ! module subroutine summary_excited_state_info_mlccsd ( wf , energies ) !! !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! integer ( i15 ) :: unit_solution = - 1 , ioerror = 0 integer ( i15 ) :: state = 0 , i = 0 , a = 0 , ai = 0 ! real ( dp ), dimension (:,:), allocatable :: solution_ai , solution_aibj real ( dp ), dimension (:,:), allocatable :: sorted_max_vec_singles , sorted_max_vec_doubles ! integer ( i15 ), dimension (:,:), allocatable :: index_list_singles , index_list_doubles ! real ( dp ) :: norm , ddot real ( dp ) :: a_active_i_active , a_active_i_inactive , a_inactive_i_active , a_inactive_i_inactive , total ! integer ( i15 ) :: n_active_o , n_active_v ! !     Open solution vector file ! call generate_unit_identifier ( unit_solution ) ! open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file , & action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening solution file' ! !     Allocations ! call wf % mem % alloc ( solution_ai , wf % n_t1am , 1 ) call wf % mem % alloc ( solution_aibj , wf % n_x2am , 1 ) ! call wf % mem % alloc ( sorted_max_vec_singles , 20 , 1 ) call wf % mem % alloc ( sorted_max_vec_doubles , 20 , 1 ) ! call wf % mem % alloc_int ( index_list_singles , 20 , 2 ) call wf % mem % alloc_int ( index_list_doubles , 20 , 4 ) ! do state = 1 , wf % excited_state_specifications % n_singlet_states ! write ( unit_output , '(/t3,a30,i3,a1/)' ) 'Analysis of excitation vector ' , state , ':' write ( unit_output , '(t6, a, f14.8)' ) 'Excitation energy [a.u.]:   ' , energies ( state , 1 ) write ( unit_output , '(t6, a, f14.8)' ) 'Excited state energy [a.u.]:' , wf % energy + energies ( state , 1 ) ! !        Read the solution ! solution_ai = zero solution_aibj = zero read ( unit_solution , rec = state ) solution_ai , solution_aibj ! !        Calculate the contribution from single excitations ! norm = sqrt ( ddot ( wf % n_t1am , solution_ai , 1 , solution_ai , 1 )) write ( unit_output , '(/t6,a,f6.4)' ) 'Single excitation contribution to excitation vector: ' , norm ! !        Analysis of excitation vectors ! write ( unit_output , '(/t6,a)' ) 'Largest contributions to excitation vector:' ! write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' write ( unit_output , '(t6,a3, 8x, a3, 8x, a10)' ) 'a' , 'i' , 'amplitude' write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' ! !        Get 20 highest amplitudes ! call wf % analyze_single_excitation_vector ( solution_ai , 20 , sorted_max_vec_singles , index_list_singles ) call wf % analyze_double_excitation_vector ( solution_aibj , 20 , sorted_max_vec_doubles , index_list_doubles ) ! !        And print them ! do i = 1 , 20 ! if ( abs ( sorted_max_vec_singles ( i , 1 )) . lt . 1.0D-03 ) then ! exit ! else ! write ( unit_output , '(t6,i3, 8x,i3, 10x, f8.5)' ) & index_list_singles ( i , 1 ),& index_list_singles ( i , 2 ),& sorted_max_vec_singles ( i , 1 ) endif enddo ! write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' write ( unit_output , '(t6,a3, 8x, a3, 8x, a3, 8x, a3, 8x, a10)' ) 'a' , 'i' , 'b' , 'j' , 'amplitude' write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' ! do i = 1 , 20 ! if ( abs ( sorted_max_vec_doubles ( i , 1 )) . lt . 1.0D-03 ) then ! exit ! else ! write ( unit_output , '(t6,i3, 8x,i3, 8x,i3, 8x, i3, 10x, f8.5)' )& index_list_doubles ( i , 1 ),& index_list_doubles ( i , 2 ),& index_list_doubles ( i , 3 ),& index_list_doubles ( i , 4 ),& sorted_max_vec_doubles ( i , 1 ) endif enddo write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' ! !        MLCC Specific print ! call wf % get_CCSD_n_active ( n_active_o , n_active_v ) do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) ! if ( a . le . n_active_v . and . i . le . n_active_o ) then ! a_active_i_active = a_active_i_active + ( solution_ai ( ai , 1 )) ** 2 ! elseif ( a . le . n_active_v . and . i . gt . n_active_o ) then ! a_active_i_inactive = a_active_i_inactive + ( solution_ai ( ai , 1 )) ** 2 ! elseif ( a . gt . n_active_v . and . i . le . n_active_o ) then ! a_inactive_i_active = a_inactive_i_active + ( solution_ai ( ai , 1 )) ** 2 ! elseif ( a . gt . n_active_v . and . i . gt . n_active_o ) then ! a_inactive_i_inactive = a_inactive_i_inactive + ( solution_ai ( ai , 1 )) ** 2 ! endif enddo enddo ! !     Print active space stats: ! total = ( a_active_i_active + a_active_i_inactive + a_inactive_i_active + a_inactive_i_inactive ) write ( unit_output , '(/t6, a10, 3a12)' ) 'T->T:' , 'S->T:' , 'T->S:' , 'S->S:' write ( unit_output , '(/t6, a50)' ) '--------------------------------------------------' write ( unit_output , '(/t6, 4f12.5)' ) a_active_i_active / total ,& a_active_i_inactive / total , & a_inactive_i_active / total ,& a_inactive_i_inactive / total enddo ! !     Deallocations ! call wf % mem % dealloc ( solution_ai , wf % n_t1am , 1 ) call wf % mem % dealloc ( solution_aibj , wf % n_x2am , 1 ) ! call wf % mem % dealloc ( sorted_max_vec_singles , 20 , 1 ) call wf % mem % dealloc ( sorted_max_vec_doubles , 20 , 1 ) ! call wf % mem % dealloc_int ( index_list_singles , 20 , 2 ) call wf % mem % dealloc_int ( index_list_doubles , 20 , 4 ) ! close ( unit_solution ) ! a_active_i_active = 0 a_inactive_i_active = 0 a_active_i_inactive = 0 a_inactive_i_inactive = 0 ! end subroutine summary_excited_state_info_mlccsd ! end submodule excited_state","tags":"","loc":"sourcefile/excited_state_submodule.f90~2.html","title":"excited_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~input_reader_submodule.f90~2~~EfferentGraph sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileinput_reader_submodulef902EfferentGraph = svgPanZoom('#sourcefileinput_reader_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules input_reader Source Code input_reader_submodule.F90 Source Code submodule ( mlccsd_class ) input_reader ! !! !!    Input reader submodule (mlccsd) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017 !! !!    Contains the following family of procedures of the mlccsd class: !! !! use input_reader ! contains ! ! subroutine mlcc_reader_mlccsd ( wf , unit_input ) !! !! !! implicit none ! integer ( i15 ) :: unit_input ! class ( mlccsd ) :: wf ! character ( len = 40 ) :: line ! !     Start at the begining of eT.inp ! ! rewind ( unit_input ) ! do ! General loop 1 ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'MLCCSD' ) then ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! do ! General loop 2 ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'CCSD' ) then ! wf % mlcc_settings % CCSD = . true . cycle ! elseif ( trim ( line ) == 'CC2' ) then ! wf % mlcc_settings % CC2 = . true . cycle ! elseif ( trim ( line ) == 'CCS' ) then ! wf % mlcc_settings % CCS = . true . cycle ! elseif ( trim ( line ) == '}' ) then ! exit ! Exit general loop 2 ! elseif ( trim ( line ) == 'end of eT input' ) then ! write ( unit_output , * ) 'Error: could not find end of MLCCSD section in eT.inp.' stop ! endif ! enddo ! exit ! Exit general loop 1 ! else write ( unit_output , * ) 'Error: missing \"{\" for MLCCSD section.' stop endif ! elseif ( trim ( line ) == 'end of eT input' ) then ! write ( unit_output , * ) 'Error: no MLCCSD input section found.' stop ! endif ! enddo ! end subroutine mlcc_reader_mlccsd ! ! module subroutine read_orbital_info_mlccsd ( wf , unit_input ) !! !! implicit none ! integer ( i15 ) :: unit_input ! class ( mlccsd ) :: wf ! character ( len = 40 ) :: line ! !     Start at the begining of eT.inp ! rewind ( unit_input ) ! do ! General loop 1 ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'CC2 orbitals' ) then ! call wf % CC2_orbitals % orbital_reader ( unit_input ) cycle ! elseif ( trim ( line ) == 'CCSD orbitals' ) then ! call wf % CCSD_orbitals % orbital_reader ( unit_input ) cycle ! elseif ( trim ( line ) == 'end of eT input' ) then ! backspace ( unit_input ) exit ! endif enddo ! end subroutine read_orbital_info_mlccsd ! ! ! end submodule input_reader","tags":"","loc":"sourcefile/input_reader_submodule.f90~2.html","title":"input_reader_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~orbital_partitioning_submodule.f90~2~~EfferentGraph sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileorbital_partitioning_submodulef902EfferentGraph = svgPanZoom('#sourcefileorbital_partitioning_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules orbital_partitioning Source Code orbital_partitioning_submodule.F90 Source Code submodule ( mlccsd_class ) orbital_partitioning ! !! !!    Orbital partitioning submodule (MLCCSD) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Apr 2017 !! !!    Contains the following family of procedures of the MLCCSD class: !! !! ! implicit none ! logical :: debug = . false . logical :: timings = . true . ! ! contains ! ! module subroutine orbital_partitioning_mlccsd ( wf ) !! !!    Orbital partitioning, !!    Written by Sarai D. Folkestad, June 2017 !! !!    Directs the partitioning for mlcc calculations. !! !!    So far only Cholesky decomposition is available. !! implicit none ! class ( mlccsd ) :: wf ! if ( wf % CCSD_orbitals % cholesky ) then ! !        If cholesky - do Cholesky decomposition ! call wf % cholesky_localization_drv ! elseif ( wf % CCSD_orbitals % cnto ) then ! !        If CNTO - do CNTO ! call wf % cnto_orbital_drv ! endif ! end subroutine orbital_partitioning_mlccsd ! ! module subroutine cholesky_localization_drv_mlccsd ( wf ) !! !!    Cholesky orbital localization driver, !!    Written by Sarai D. Folkestad, July 2017. !! !!    Driver for Cholesky density decomposition !! !!    - Collects atom and ao-basis information. !!    - Constructs occupied and vacant densities. !!    - Constructs AO Fock matrix.  (This is currently an N&#94;5 operation, should be optimized/removed) !!    - By looping over active spaces, the occupied and virtual densities are Cholesky decomposed !!      and the cholesky vectors are used to generate new localized MO's. !!    - New orbitals are tested for orthonormality (Not implemented yet, only need overlap matrix from DALTON) !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: orbitals real ( dp ), dimension (:,:), allocatable :: orbital_energies real ( dp ), dimension (:,:), allocatable :: S real ( dp ), dimension (:,:), allocatable :: S_packed real ( dp ), dimension (:,:), allocatable :: Y_1 real ( dp ), dimension (:,:), allocatable :: Y_2 ! integer ( i15 ) :: unit_overlap ! integer ( i15 ) :: n_nuclei integer ( i15 ) :: active_space = 0 , n_CC2_atoms = 0 , n_CCSD_atoms = 0 integer ( i15 ) :: n_active_orbitals_o = 0 , n_active_orbitals_v = 0 integer ( i15 ) :: offset_o = 0 , offset_v = 0 integer ( i15 ) :: n_active_aos = 0 ! integer ( i15 ), dimension (:,:), allocatable :: ao_center_info , n_ao_on_center integer ( i15 ), dimension (:,:), allocatable :: active_atoms , active_atoms_CC2 , active_atoms_CCSD integer ( i15 ), dimension (:,:), allocatable :: active_ao_index_list integer ( i15 ) :: n_vectors_o , n_vectors_v ! !     Timing variables ! real ( dp ) :: start_chol_deco = 0 , end_chol_deco = 0 ! !     IO-variables ! logical :: file_exists integer ( i15 ) :: unit_cholesky_decomp = 0 , ioerror = 0 ! !     Indices ! integer ( i15 ) :: i = 0 , j = 0 , ij = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: density_o , density_v real ( dp ), dimension (:,:), allocatable :: ao_fock real ( dp ), dimension (:,:), allocatable :: C_cc2 ! !     Start timings ! call cpu_time ( start_chol_deco ) ! !     ::::::::::::::::::::::::::::::::::::: !     -::-  Prepare for decomposition  -::- !     ::::::::::::::::::::::::::::::::::::: ! !     Prints ! write ( unit_output , '(//t3,a)' ) ':: Cholesky orbital construction' write ( unit_output , '(t3,a/)' ) ':: E. F. Kjønstad, S. D. Folkestad, Jun 2017' flush ( unit_output ) ! !     Get center info ! call read_atom_info ( n_nuclei , wf % n_ao ) ! call wf % mem % alloc_int ( n_ao_on_center , n_nuclei , 1 ) call wf % mem % alloc_int ( ao_center_info , wf % n_ao , 2 ) ! call read_center_info ( n_nuclei , wf % n_ao , n_ao_on_center , ao_center_info ) ! !     Start timings ! call cpu_time ( start_chol_deco ) ! !     Construct AO fock matrix ! call wf % mem % alloc ( density_o , wf % n_ao , wf % n_ao ) call wf % mem % alloc ( density_v , wf % n_ao , wf % n_ao ) density_o = zero density_v = zero ! call wf % construct_density_matrices ( density_o , density_v , wf % mo_coef , wf % n_o , wf % n_v ) ! call wf % mem % alloc ( ao_fock , wf % n_ao , wf % n_ao ) call wf % construct_ao_fock ( ao_fock ) ! call wf % mem % dealloc ( density_o , wf % n_ao , wf % n_ao ) call wf % mem % dealloc ( density_v , wf % n_ao , wf % n_ao ) ! !     Test for CCS region ! if ( wf % mlcc_settings % CCS ) then ! !        Test for CC2 region ! if ( wf % mlcc_settings % CC2 ) then call wf % cholesky_localization_CCSD_CC2_CCS ( ao_center_info , n_ao_on_center ,& ao_fock , n_nuclei , unit_cholesky_decomp ) ! else ! No CC2 region ! call wf % cholesky_localization_CCSD_CCS ( ao_center_info , n_ao_on_center ,& ao_fock , n_nuclei , unit_cholesky_decomp ) ! endif ! else ! No CCS region ! call wf % cholesky_localization_CCSD_CC2 ( ao_center_info , n_ao_on_center ,& ao_fock , n_nuclei , unit_cholesky_decomp ) ! endif ! !     :: Check orthogonality of new orbitals :: ! !     Read overlap matrix ! call generate_unit_identifier ( unit_overlap ) open ( unit = unit_overlap , file = 'MLCC_OVERLAP' , status = 'unknown' , form = 'formatted' , iostat = ioerror ) if ( ioerror . ne . 0 ) write ( unit_output , * ) 'WARNING: Error while opening MLCC_OVERLAP' rewind ( unit_overlap ) ! call wf % mem % alloc ( S_packed , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) read ( unit_overlap , * ) S_packed close ( unit_overlap ) ! call wf % mem % alloc ( S , wf % n_ao , wf % n_ao ) ! call squareup ( S_packed , S , wf % n_ao ) ! call wf % mem % dealloc ( S_packed , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) ! call wf % mem % alloc ( Y_1 , wf % n_mo , wf % n_ao ) call dgemm ( 'T' , 'N' , & wf % n_mo , & wf % n_ao , & wf % n_ao , & one , & wf % mo_coef , & wf % n_ao ,& S , & wf % n_ao , & zero , & Y_1 , & wf % n_mo ) ! call wf % mem % dealloc ( S , wf % n_ao , wf % n_ao ) call wf % mem % alloc ( Y_2 , wf % n_mo , wf % n_mo ) ! call dgemm ( 'N' , 'N' , & wf % n_mo , & wf % n_mo , & wf % n_ao , & one , & Y_1 , & wf % n_mo ,& wf % mo_coef , & wf % n_ao , & zero , & Y_2 , & wf % n_mo ) ! call wf % mem % dealloc ( Y_1 , wf % n_mo , wf % n_ao ) ! if (. not . ( check_orthogonality ( Y_2 , wf % n_mo , wf % n_mo ))) then write ( unit_output , * ) 'New orbitals not orthogonal' stop endif ! call wf % mem % dealloc ( Y_2 , wf % n_mo , wf % n_mo ) ! ! !     Deallocate ao-fock ! call wf % mem % dealloc ( ao_fock , wf % n_ao , wf % n_ao ) call wf % mem % dealloc_int ( n_ao_on_center , n_nuclei , 1 ) call wf % mem % dealloc_int ( ao_center_info , wf % n_ao , 2 ) ! !     Print decomposition info ! write ( unit_output , '(t3,a,a,a/)' ) 'Summary of ' , trim ( wf % name ), ' Cholesky orbital construction:' ! !     Print timings ! call cpu_time ( end_chol_deco ) write ( unit_output , '(t6,a25,f14.8/)' ) 'Total CPU time (seconds):' ,& end_chol_deco - start_chol_deco ! call wf % print_orbital_info ! flush ( unit_output ) ! end subroutine cholesky_localization_drv_mlccsd ! module subroutine cholesky_localization_CCSD_CC2_CCS_mlccsd ( wf , ao_center_info , n_ao_on_center ,& ao_fock , n_nuclei , unit_cholesky_decomp ) !! !!    Cholesky orbital localization CCS/CC2/CCSD, !!    Written by Sarai D. Folkestad, July 2017 !! !!    Cholesky partitiining routine for CCS/CC2/CCSD calculation !! implicit none ! !     Input arguments ! class ( mlccsd ) :: wf ! integer ( i15 ), dimension ( wf % n_ao , 2 ) :: ao_center_info integer ( i15 ), dimension ( n_nuclei , 1 ) :: n_ao_on_center ! real ( dp ), dimension (:,:) :: ao_fock ! integer ( i15 ) :: n_nuclei integer ( i15 ) :: unit_cholesky_decomp integer ( i15 ) :: i , j , ij ! !     Local routine variables ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: orbitals real ( dp ), dimension (:,:), allocatable :: orbital_energies real ( dp ), dimension (:,:), allocatable :: density_o real ( dp ), dimension (:,:), allocatable :: density_v real ( dp ), dimension (:,:), allocatable :: C_cc2 ! integer ( i15 ), dimension (:,:), allocatable :: active_atoms integer ( i15 ), dimension (:,:), allocatable :: active_ao_index_list ! !     Active space variables ! integer ( i15 ) :: n_active_aos integer ( i15 ) :: n_active_orbitals_o integer ( i15 ) :: n_active_orbitals_v integer ( i15 ) :: n_vectors_o , n_vectors_v integer ( i15 ) :: offset_o , offset_v , offset ! !     ::::::::::::::::::::::::::::::::::::: !     -::-  Prepare for decomposition  -::- !     ::::::::::::::::::::::::::::::::::::: ! call wf % mem % alloc ( orbitals , wf % n_ao , wf % n_mo ) call wf % mem % alloc ( orbital_energies , wf % n_mo , 1 ) ! !     :::::::::::::::::::::::::::::::: !     -::-    CC2/CCS partition   -::- !     :::::::::::::::::::::::::::::::: ! !     :: Construct canonical occupied and vacant density matrices :: ! call wf % mem % alloc ( density_o , wf % n_ao , wf % n_ao ) call wf % mem % alloc ( density_v , wf % n_ao , wf % n_ao ) density_o = zero density_v = zero ! call wf % construct_density_matrices ( density_o , density_v , wf % mo_coef , wf % n_o , wf % n_v ) ! offset_o = 1 offset_v = 1 + wf % n_o ! call wf % mem % alloc_int ( active_atoms , & wf % CCSD_orbitals % n_active_atoms + wf % CC2_orbitals % n_active_atoms , 1 ) ! do i = 1 , wf % CC2_orbitals % n_active_atoms active_atoms ( i , 1 ) = wf % CC2_orbitals % active_atoms ( i , 1 ) enddo ! do i = 1 , wf % CCSD_orbitals % n_active_atoms active_atoms ( wf % CC2_orbitals % n_active_atoms + i , 1 ) = wf % CCSD_orbitals % active_atoms ( i , 1 ) enddo ! !     Sanity check on active atoms ! if (( wf % CC2_orbitals % n_active_atoms + wf % CCSD_orbitals % n_active_atoms ) . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atoms in cholesky.inp.' stop endif ! do i = 1 , wf % CC2_orbitals % n_active_atoms + wf % CCSD_orbitals % n_active_atoms if ( active_atoms ( i , 1 ) . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atoms in cholesky.inp.' , i , active_atoms ( i , 1 ) stop endif enddo ! !     :: CC2 localized Cholesky orbitals :: ! n_active_aos = 0 ! do i = 1 , wf % CC2_orbitals % n_active_atoms + wf % CCSD_orbitals % n_active_atoms n_active_aos = n_active_aos + n_ao_on_center ( active_atoms ( i , 1 ), 1 ) enddo ! !     Construct active_ao_index_list ! call wf % mem % alloc_int ( active_ao_index_list , n_active_aos , 1 ) call construct_active_ao_index_list ( active_ao_index_list , n_active_aos , active_atoms , & wf % CC2_orbitals % n_active_atoms + wf % CCSD_orbitals % n_active_atoms ,& ao_center_info , wf % n_ao ) ! !     Occupied part ! n_vectors_o = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . true ., n_active_aos , active_ao_index_list ) ! !     Virtual part ! n_vectors_v = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v ,& . true ., n_active_aos , active_ao_index_list ) ! ! !     Save CC2 space information ! wf % n_CC2_o = n_vectors_o wf % n_CC2_v = n_vectors_v ! !     Calculate new offset ! offset_o = offset_o + n_vectors_o offset_v = offset_v + n_vectors_v ! call wf % mem % dealloc_int ( active_atoms , wf % CC2_orbitals % n_active_atoms + wf % CCSD_orbitals % n_active_atoms , 1 ) call wf % mem % dealloc_int ( active_ao_index_list , n_active_aos , 1 ) ! ! !     :: CCS localized Cholesky orbitals  :: ! !     Occupied part ! n_vectors_o = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . false ., n_active_aos ) ! !     Virtual part ! n_vectors_v = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v ,& . false ., n_active_aos ) ! !     Save inactive space information ! wf % n_CCS_o = n_vectors_o wf % n_CCS_v = n_vectors_v ! wf % first_CCS_o = offset_o wf % first_CCS_v = offset_v - wf % n_o ! !     Total number of active orbitals ! n_active_orbitals_o = wf % n_o - wf % n_CCS_o n_active_orbitals_v = wf % n_v - wf % n_CCS_v ! wf % mo_coef_cc2_ccs = orbitals wf % fock_diagonal_cc2_ccs = orbital_energies ! !     Deallocations ! call wf % mem % dealloc ( density_v , wf % n_ao , wf % n_ao ) call wf % mem % dealloc ( density_o , wf % n_ao , wf % n_ao ) ! !     :::::::::::::::::::::::::::::::: !     -::-   CCSD/CC2 partition   -::- !     :::::::::::::::::::::::::::::::: ! offset_o = 1 offset_v = 1 + wf % n_o ! !     Construct CC2 density matrix, occupied and virtual ! call wf % mem % alloc ( density_v , wf % n_ao , wf % n_ao ) call wf % mem % alloc ( density_o , wf % n_ao , wf % n_ao ) ! !     Construct CC2 density ! call wf % mem % alloc ( C_cc2 , wf % n_ao * ( wf % n_CC2_o + wf % n_CC2_v ), 1 ) ! do i = 1 , wf % n_ao do j = 1 , wf % n_CC2_o ij = index_two ( i , j , wf % n_ao ) C_cc2 ( ij , 1 ) = wf % mo_coef_cc2_ccs ( i , j ) enddo enddo ! do i = 1 , wf % n_ao do j = 1 , wf % n_CC2_v ij = index_two ( i , wf % n_CC2_o + j , wf % n_ao ) C_cc2 ( ij , 1 ) = wf % mo_coef_cc2_ccs ( i , wf % n_o + j ) enddo enddo ! call wf % construct_density_matrices ( density_o , density_v , C_cc2 , & wf % n_CC2_o , wf % n_CC2_v ) ! call wf % mem % dealloc ( C_cc2 , wf % n_ao * ( wf % n_CC2_o + wf % n_CC2_v ), 1 ) ! !     Construct active_ao_index_list ! n_active_aos = 0 ! do i = 1 , wf % CCSD_orbitals % n_active_atoms n_active_aos = n_active_aos + n_ao_on_center ( wf % CCSD_orbitals % active_atoms ( i , 1 ), 1 ) enddo ! call wf % mem % alloc_int ( active_ao_index_list , n_active_aos , 1 ) active_ao_index_list = 0 ! call construct_active_ao_index_list ( active_ao_index_list , n_active_aos , wf % CCSD_orbitals % active_atoms , & wf % CCSD_orbitals % n_active_atoms , ao_center_info , wf % n_ao ) ! !   call wf%mem%dealloc_int(active_atoms, wf%CCSD_orbitals%n_active_atoms, 1) ! !     Occupied part ! n_vectors_o = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . true ., n_active_aos , active_ao_index_list ) ! !     Virtual part ! n_vectors_v = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v ,& . true ., n_active_aos , active_ao_index_list ) ! call wf % mem % dealloc_int ( active_ao_index_list , n_active_aos , 1 ) ! ! !     Save active space information ! wf % n_CCSD_o = n_vectors_o wf % n_CCSD_v = n_vectors_v ! wf % first_CCSD_o = offset_o wf % first_CCSD_v = offset_v - wf % n_o ! !     Calculate new offset ! offset_o = offset_o + n_vectors_o offset_v = offset_v + n_vectors_v ! !     :: CC2  localized Cholesky orbitals  :: ! !     Occupied part ! n_vectors_o = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . false ., n_active_aos ) ! !     Virtual part ! n_vectors_v = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v ,& . false ., n_active_aos ) ! !     Save inactive space information ! wf % n_CC2_o = n_vectors_o wf % n_CC2_v = n_vectors_v ! wf % first_CC2_o = offset_o wf % first_CC2_v = offset_v - wf % n_o ! !     Calculate new offset ! offset_o = offset_o + n_vectors_o offset_v = offset_v + n_vectors_v ! call wf % mem % dealloc ( density_v , wf % n_ao , wf % n_ao ) call wf % mem % dealloc ( density_o , wf % n_ao , wf % n_ao ) ! wf % mo_coef = orbitals wf % fock_diagonal = orbital_energies ! call deallocator ( orbitals , wf % n_ao , wf % n_mo ) call deallocator ( orbital_energies , wf % n_mo , 1 ) ! end subroutine cholesky_localization_CCSD_CC2_CCS_mlccsd ! ! module subroutine cholesky_localization_CCSD_CCS_mlccsd ( wf , ao_center_info , n_ao_on_center ,& ao_fock , n_nuclei , unit_cholesky_decomp ) !! !!    Cholesky orbital localization CCS/CCSD, !!    Written by Sarai D. Folkestad, July 2017 !! !!    Cholesky partitiining routine for CCS/CCSD calculation !! implicit none ! !     Input arguments ! class ( mlccsd ) :: wf ! integer ( i15 ), dimension ( wf % n_ao , 2 ) :: ao_center_info integer ( i15 ), dimension ( n_nuclei , 1 ) :: n_ao_on_center ! real ( dp ), dimension (:,:) :: ao_fock ! integer ( i15 ) :: n_nuclei integer ( i15 ) :: unit_cholesky_decomp ! !     Local routine variables ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: orbitals real ( dp ), dimension (:,:), allocatable :: orbital_energies real ( dp ), dimension (:,:), allocatable :: density_o real ( dp ), dimension (:,:), allocatable :: density_v ! integer ( i15 ), dimension (:,:), allocatable :: active_ao_index_list ! !     Looping variables ! integer ( i15 ) :: i = 0 , j = 0 , ij = 0 ! ! ! integer ( i15 ) :: n_active_aos integer ( i15 ) :: n_active_orbitals_o integer ( i15 ) :: n_active_orbitals_v integer ( i15 ) :: n_vectors_o , n_vectors_v integer ( i15 ) :: offset_o , offset_v ! !     ::::::::::::::::::::::::::::: !     -::-  CCS/CCSD partition -::- !     ::::::::::::::::::::::::::::: ! ! call wf % mem % alloc ( orbitals , wf % n_ao , wf % n_mo ) call wf % mem % alloc ( orbital_energies , wf % n_mo , 1 ) ! !     :: Construct canonical occupied and vacant density matrices :: ! call wf % mem % alloc ( density_o , wf % n_ao , wf % n_ao ) call wf % mem % alloc ( density_v , wf % n_ao , wf % n_ao ) density_o = zero density_v = zero ! call wf % construct_density_matrices ( density_o , density_v , wf % mo_coef , wf % n_o , wf % n_v ) ! !     No CC2 region ! wf % n_CC2_o = 0 wf % n_CC2_v = 0 ! offset_o = 1 offset_v = 1 + wf % n_o ! !     Sanity check on active atoms ! if ( wf % CCSD_orbitals % n_active_atoms . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atoms in cholesky.inp.' stop endif ! do i = 1 , wf % CCSD_orbitals % n_active_atoms if ( wf % CCSD_orbitals % active_atoms ( i , 1 ) . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atoms in cholesky.inp.' stop endif enddo ! !     :: Constructing active (CCSD) localized Cholesky orbitals :: ! n_active_aos = 0 do i = 1 , wf % CCSD_orbitals % n_active_atoms n_active_aos = n_active_aos + n_ao_on_center ( wf % CCSD_orbitals % active_atoms ( i , 1 ), 1 ) enddo ! !     Construct active_ao_index_list ! call wf % mem % alloc_int ( active_ao_index_list , n_active_aos , 1 ) call construct_active_ao_index_list ( active_ao_index_list , n_active_aos , wf % CCSD_orbitals % active_atoms , & wf % CCSD_orbitals % n_active_atoms , ao_center_info , wf % n_ao ) ! !     Occupied part ! n_vectors_o = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . true ., n_active_aos , active_ao_index_list ) ! !     Virtual part ! n_vectors_v = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v ,& . true ., n_active_aos , active_ao_index_list ) ! !     Save active space information ! wf % n_CCSD_o = n_vectors_o wf % n_CCSD_v = n_vectors_v ! wf % first_CCSD_o = offset_o wf % first_CCSD_v = offset_v - wf % n_o ! !     Calculate new offset ! offset_o = offset_o + n_vectors_o offset_v = offset_v + n_vectors_v ! call wf % mem % dealloc_int ( active_ao_index_list , n_active_aos , 1 ) ! !     :: CCS  localized Cholesky orbitals  :: ! !     Occupied part ! n_vectors_o = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . false ., n_active_aos ) ! !     Virtual part ! n_vectors_v = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v ,& . false ., n_active_aos ) ! !     Save inactive space information ! wf % n_CCS_o = n_vectors_o wf % n_CCS_v = n_vectors_v ! wf % first_CCS_o = offset_o wf % first_CCS_v = offset_v - wf % n_o ! wf % mo_coef = orbitals wf % fock_diagonal = orbital_energies ! !     Deallocations ! call wf % mem % dealloc ( density_v , wf % n_ao , wf % n_ao ) call wf % mem % dealloc ( density_o , wf % n_ao , wf % n_ao ) ! call deallocator ( orbitals , wf % n_ao , wf % n_mo ) call deallocator ( orbital_energies , wf % n_mo , 1 ) ! end subroutine cholesky_localization_CCSD_CCS_mlccsd ! ! module subroutine cholesky_localization_CCSD_CC2_mlccsd ( wf , ao_center_info , n_ao_on_center ,& ao_fock , n_nuclei , unit_cholesky_decomp ) !! !!    Cholesky orbital localization CC2/CCSD !!    Written by Sarai D. Folkestad, July 2017 !! !!    Cholesky partitiining routine for CC2/CCSD calculation !! implicit none ! !     Input arguments ! class ( mlccsd ) :: wf ! integer ( i15 ), dimension ( wf % n_ao , 2 ) :: ao_center_info integer ( i15 ), dimension ( n_nuclei , 1 ) :: n_ao_on_center ! real ( dp ), dimension (:,:) :: ao_fock ! integer ( i15 ) :: n_nuclei integer ( i15 ) :: unit_cholesky_decomp ! !     Local routine variables ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: orbitals real ( dp ), dimension (:,:), allocatable :: orbital_energies real ( dp ), dimension (:,:), allocatable :: density_o real ( dp ), dimension (:,:), allocatable :: density_v ! integer ( i15 ), dimension (:,:), allocatable :: active_ao_index_list ! !     Looping variables ! integer ( i15 ) :: i = 0 , j = 0 , ij = 0 ! integer ( i15 ) :: n_active_aos integer ( i15 ) :: n_active_orbitals_o integer ( i15 ) :: n_active_orbitals_v integer ( i15 ) :: n_vectors_o , n_vectors_v integer ( i15 ) :: offset_o , offset_v ! call wf % mem % alloc ( orbitals , wf % n_ao , wf % n_mo ) call wf % mem % alloc ( orbital_energies , wf % n_mo , 1 ) ! do i = 1 , wf % n_ao do j = 1 , wf % n_mo ij = index_two ( i , j , wf % n_ao ) wf % mo_coef_cc2_ccs ( i , j ) = wf % mo_coef ( ij , 1 ) enddo enddo wf % fock_diagonal_cc2_ccs (:, 1 ) = wf % fock_diagonal (:, 1 ) ! !     :::::::::::::::::::::::::::::::: !     -::-   CCSD/CC2 partition   -::- !     :::::::::::::::::::::::::::::::: ! !     :: Construct canonical occupied and vacant density matrices :: ! call wf % mem % alloc ( density_o , wf % n_ao , wf % n_ao ) call wf % mem % alloc ( density_v , wf % n_ao , wf % n_ao ) density_o = zero density_v = zero ! call wf % construct_density_matrices ( density_o , density_v , wf % mo_coef , wf % n_o , wf % n_v ) ! !     No CCS region ! wf % n_CCS_o = 0 wf % n_CCS_v = 0 ! offset_o = 1 offset_v = 1 + wf % n_o ! !     Sanity check on active atoms ! if ( wf % CCSD_orbitals % n_active_atoms . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atoms in cholesky.inp.' stop endif ! do i = 1 , wf % CCSD_orbitals % n_active_atoms if ( wf % CCSD_orbitals % active_atoms ( i , 1 ) . gt . n_nuclei ) then write ( unit_output , * ) 'WARNING: Illegal chioce of atoms in cholesky.inp.' stop endif enddo ! !     :: Constructing active (CCSD) localized Cholesky orbitals :: ! n_active_aos = 0 do i = 1 , wf % CCSD_orbitals % n_active_atoms n_active_aos = n_active_aos + n_ao_on_center ( wf % CCSD_orbitals % active_atoms ( i , 1 ), 1 ) enddo ! !     Construct active_ao_index_list ! call wf % mem % alloc_int ( active_ao_index_list , n_active_aos , 1 ) call construct_active_ao_index_list ( active_ao_index_list , n_active_aos , wf % CCSD_orbitals % active_atoms , & wf % CCSD_orbitals % n_active_atoms , ao_center_info , wf % n_ao ) ! !     Occupied part ! n_vectors_o = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . true ., n_active_aos , active_ao_index_list ) ! !     Virtual part ! n_vectors_v = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v ,& . true ., n_active_aos , active_ao_index_list ) ! !     Save active space information ! wf % n_CCSD_o = n_vectors_o wf % n_CCSD_v = n_vectors_v ! wf % first_CCSD_o = offset_o wf % first_CCSD_v = offset_v - wf % n_o ! !     Calculate new offset ! offset_o = offset_o + n_vectors_o offset_v = offset_v + n_vectors_v ! call wf % mem % dealloc_int ( active_ao_index_list , n_active_aos , 1 ) ! !     :: CC2  localized Cholesky orbitals  :: ! !     Occupied part ! n_vectors_o = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_o , ao_fock , & density_o , n_vectors_o ,& . false ., n_active_aos ) ! !     Virtual part ! n_vectors_v = 0 call wf % cholesky_orbital_constructor ( orbitals , orbital_energies , offset_v , ao_fock , & density_v , n_vectors_v ,& . false ., n_active_aos ) ! !     Save inactive space information ! wf % n_CC2_o = n_vectors_o wf % n_CC2_v = n_vectors_v ! wf % first_CC2_o = offset_o wf % first_CC2_v = offset_v - wf % n_o ! wf % mo_coef = orbitals wf % fock_diagonal = orbital_energies ! !     Deallocations ! call wf % mem % dealloc ( density_v , wf % n_ao , wf % n_ao ) call wf % mem % dealloc ( density_o , wf % n_ao , wf % n_ao ) ! call wf % mem % dealloc ( orbitals , wf % n_ao , wf % n_mo ) call wf % mem % dealloc ( orbital_energies , wf % n_mo , 1 ) ! end subroutine cholesky_localization_CCSD_CC2_mlccsd ! ! module subroutine construct_MO_transformation_matrix_mlccsd ( wf ) !! !!       Construct MO transformation matrix, !!       Written by Sarai D. Fokestad, July 2017 !! !!       Constructs transformation matrix, !! !!          T = (C_CCSD)&#94;T * S * C_CC2 !! !!       between CC2 basis and CCSD basis. !!       Needed for transforming s_ij_ab from CC2 to CCSD basis. !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: X real ( dp ), dimension (:,:), allocatable :: X2 real ( dp ), dimension (:,:), allocatable :: S_packed , S ! integer ( i15 ) :: a = 0 , b = 0 , i = 0 , j = 0 ! integer ( i15 ) :: unit_overlap = - 1 , ioerror = 0 ! ! !     Read overlap matrix ! call generate_unit_identifier ( unit_overlap ) open ( unit = unit_overlap , file = 'MLCC_OVERLAP' , status = 'unknown' , form = 'formatted' , iostat = ioerror ) if ( ioerror . ne . 0 ) write ( unit_output , * ) 'WARNING: Error while opening MLCC_OVERLAP' rewind ( unit_overlap ) ! call wf % mem % alloc ( S_packed , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) read ( unit_overlap , * ) S_packed close ( unit_overlap ) ! call wf % mem % alloc ( S , wf % n_ao , wf % n_ao ) ! call squareup ( S_packed , S , wf % n_ao ) ! call wf % mem % dealloc ( S_packed , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) ! call wf % mem % alloc ( X , wf % n_mo , wf % n_ao ) ! call dgemm ( 'T' , 'N' , & wf % n_mo , & wf % n_ao , & wf % n_ao , & one , & wf % mo_coef , & wf % n_ao , & S , & wf % n_ao , & zero , & X , & wf % n_mo ) ! call wf % mem % dealloc ( S , wf % n_ao , wf % n_ao ) call wf % mem % alloc ( X2 , wf % n_mo , wf % n_mo ) ! call dgemm ( 'N' , 'N' , & wf % n_mo , & wf % n_mo , & wf % n_ao , & one , & X , & wf % n_mo , & wf % mo_coef_cc2_ccs , & wf % n_ao , & zero , & X2 , & wf % n_mo ) ! call wf % mem % dealloc ( X , wf % n_mo , wf % n_ao ) ! call wf % mem % dealloc ( wf % mo_coef_cc2_ccs , wf % n_ao , wf % n_mo ) call wf % mem % alloc ( wf % T_o , wf % n_o , wf % n_o ) call wf % mem % alloc ( wf % T_v , wf % n_v , wf % n_v ) ! !     Construct active occupied and active virtual transformation matrices ! do i = 1 , wf % n_o do j = 1 , wf % n_o wf % T_o ( i , j ) = X2 ( i , j ) enddo enddo ! do a = 1 , wf % n_v do b = 1 , wf % n_v wf % T_v ( a , b ) = X2 ( wf % n_o + a , wf % n_o + b ) enddo enddo ! call wf % mem % dealloc ( X2 , wf % n_mo , wf % n_mo ) ! end subroutine construct_MO_transformation_matrix_mlccsd ! ! module subroutine cnto_orbital_drv_mlccsd ( wf ) !! !!    CNTO orbital driver, !!    Written by Sarai D. Folkestad, June 2017. !! !!    A CC2 calculation ground state and excited states is performed. !!    The M and N matrices are then constructed, !! !!       M_i_j = sum_{a} R_ai R_aj + 1/2sum_{abk}(1+ δ_ai,bk δ_i,j )R_aibkR_ajbk !!       N_a_b = sum_{i} R_ai R_bi + 1/2sum_{ijc}(1+ δ_ai,cj δ_a,b )R_aicjR_bicj. !! !!    where R_ai is the i'th single part of the excitation vector obtained from the CC2 calculation !!    and R_aibj is the doubles part of the excitation vectors. !! !!    The transformation matrices for the occupied and virtual part !!    are constructed by diagonalizing M and N. The number of active occupied !!    and virtual orbitals are determined from δ_o and δ_v !! !!       1 - sum_i λ&#94;o_i < δ_o !!       1 - sum_i λ&#94;v_i < δ_v !! !!    Where the orbitals of highest eigenvalues λ&#94;o/λ&#94;v are selected first. !! !!    Fock matrix is block diagonalized in active and inactive blocks in order to obtain !!    the orbitals and orbital energies used in the CCSD calculation. !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ) :: start_cnto = 0 , end_cnto = 0 ! integer ( i15 ) :: cc2_n_parameters = 0 , cc2_n_x2am = 0 , n_cc2_o = 0 , n_cc2_v = 0 ! !     Prints ! ! write ( unit_output , '(//t3,a)' ) ':: CNTO orbital partitioning for MLCC2 calculation ' write ( unit_output , '(t3,a/)' ) ':: E. F. Kjønstad, S. D. Folkestad, Jun 2017' write ( unit_output , '(/a35,e10.2)' ) 'Threshold for occupied orbitals:' , wf % CC2_orbitals % delta_o write ( unit_output , '(a35,e10.2/)' ) 'Threshold for virtual orbitals: ' , wf % CC2_orbitals % delta_v ! ! !     Timings ! call cpu_time ( start_cnto ) ! !     :: Run lower level method :: ! if ( wf % tasks % excited_state . or . wf % tasks % core_excited_state ) then ! call wf % ccsd_cnto_lower_level_method ( cc2_n_parameters , cc2_n_x2am , n_cc2_o , n_cc2_v ) ! else ! write ( unit_output , * ) 'WARNING: cntos without excited state calculation makes no sense.' endif ! !     :: Construct orbitals :: ! call wf % ccsd_cnto_orbitals ( cc2_n_parameters , cc2_n_x2am , n_cc2_o , n_cc2_v ) ! !     Print summary ! write ( unit_output , '(/t3,a,a,a/)' ) 'Summary of ' , trim ( wf % name ), ' CNTO orbital construction:' ! !     Print timings ! call cpu_time ( end_cnto ) ! if ( timings ) write ( unit_output , '(/t6,a26,f14.8/)' ) 'Total CPU time (seconds): ' , end_cnto - start_cnto ! call wf % print_orbital_info flush ( unit_output ) ! end subroutine cnto_orbital_drv_mlccsd ! ! module subroutine ccsd_cnto_lower_level_method_mlccsd ( wf , cc2_n_parameters , cc2_n_x2am , n_cc2_o , n_cc2_v ) !! !!    CNTO lower level calculation (MLCCSD), !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Runs lower level method for CNTOs !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: cc2_n_x2am , cc2_n_parameters integer ( i15 ) :: n_CC2_o , n_CC2_v ! type ( mlcc2 ), allocatable :: cc2_wf ! integer ( i15 ) :: i = 0 , j = 0 , ij = 0 ! !     :::::::::::::::::::::::::::::::::::::::::::::::: !     -::- Running lower level method calculation -::- !     :::::::::::::::::::::::::::::::::::::::::::::::: ! !     Allocate lower level method ! allocate ( cc2_wf ) ! !     Set calculation tasks ! cc2_wf % tasks = wf % tasks ! !     Set calculation settings ! cc2_wf % settings = wf % settings ! cc2_wf % core_excited_state_specifications = wf % core_excited_state_specifications cc2_wf % excited_state_specifications = wf % excited_state_specifications ! !     Set convergence threshold for lower lying method ! cc2_wf % ground_state_specifications % energy_threshold = 1.0D-04 cc2_wf % ground_state_specifications % residual_threshold = 1.0D-04 ! cc2_wf % excited_state_specifications % energy_threshold = 1.0D-04 cc2_wf % excited_state_specifications % residual_threshold = 1.0D-04 ! !     Set mlcc settings ! ! cc2_wf % mlcc_settings = wf % mlcc_settings cc2_wf % mlcc_settings % CCSD = . false . ! cc2_wf % CC2_orbitals = wf % CC2_orbitals ! !     Test for user specified start vector ! if ( wf % excited_state_specifications % user_specified_start_vector ) then ! !        Since orbitals will swap order, start vector in higher level method must be removed ! wf % excited_state_specifications % user_specified_start_vector = . false . call wf % mem % dealloc_int ( wf % excited_state_specifications % start_vectors , wf % excited_state_specifications % n_singlet_states , 1 ) ! endif ! !     :: Initialize lower level method :: ! cc2_wf % name = 'CC2' ! !     Set implemented generic methods ! cc2_wf % implemented % ground_state = . true . cc2_wf % implemented % excited_state = . true . cc2_wf % implemented % core_excited_state = . true . ! !     Read Hartree-Fock info from SIRIUS ! call cc2_wf % read_hf_info ! if ( cc2_wf % mlcc_settings % CCS ) then ! call cc2_wf % orbital_partitioning ! else ! !        Do full space CC2 calculation ! cc2_wf % n_CC2_o = wf % n_o cc2_wf % n_CC2_v = wf % n_v ! cc2_wf % first_CC2_o = 1 cc2_wf % first_CC2_v = 1 ! endif ! !     Initialize amplitudes and associated attributes ! call cc2_wf % initialize_amplitudes call cc2_wf % initialize_omega ! !     Set the number of parameters in the wavefunction !     (that are solved for in the ground and excited state solvers) ! cc2_wf % n_parameters = cc2_wf % n_t1am ! !     Read Cholesky AO integrals and transform to MO basis ! call cc2_wf % read_transform_cholesky ! !     Initialize fock matrix ! call cc2_wf % initialize_fock_matrix ! !     Call driver of lower level method ! call cc2_wf % drv ! cc2_n_parameters = cc2_wf % n_parameters cc2_n_x2am = cc2_wf % n_x2am ! do i = 1 , wf % n_ao do j = 1 , wf % n_mo ij = index_two ( i , j , wf % n_ao ) wf % mo_coef_cc2_ccs ( i , j ) = cc2_wf % mo_coef ( ij , 1 ) enddo enddo ! wf % fock_diagonal_cc2_ccs = cc2_wf % fock_diagonal ! wf % mo_coef = cc2_wf % mo_coef wf % fock_diagonal = cc2_wf % fock_diagonal ! n_CC2_o = cc2_wf % n_CC2_o n_CC2_v = cc2_wf % n_CC2_v ! !     Save info on CCS space ! wf % n_CCS_o = cc2_wf % n_CCS_o wf % n_CCS_v = cc2_wf % n_CCS_v ! wf % first_CCS_o = cc2_wf % first_CCS_o wf % first_CCS_v = cc2_wf % first_CCS_v ! !     Deallocate lower level method ! deallocate ( cc2_wf ) ! end subroutine ccsd_cnto_lower_level_method_mlccsd ! ! module subroutine ccsd_cnto_orbitals_mlccsd ( wf , cc2_n_parameters , cc2_n_x2am , n_cc2_o , n_cc2_v ) !! !!    CNTO Oritals (MLCCSD), !!    Written by Sarai D. Folkestad Aug. 2017 !! !!    Constructs the CNTO orbitals based on exitation vectors from lower level method !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: cc2_n_x2am , cc2_n_parameters integer ( i15 ) :: n_CC2_o , n_CC2_v ! integer ( i15 ) :: unit_solution = - 1 integer ( i15 ) :: ioerror = 0 integer ( i15 ) :: state ! real ( dp ), dimension (:,:), allocatable :: solution real ( dp ), dimension (:,:), allocatable :: R real ( dp ), dimension (:,:), allocatable :: R_sum real ( dp ), dimension (:,:), allocatable :: R_sum_restricted real ( dp ), dimension (:,:), allocatable :: R_a_i real ( dp ), dimension (:,:), allocatable :: R_ai_bj real ( dp ), dimension (:,:), allocatable :: R_aib_k real ( dp ), dimension (:,:), allocatable :: R_a_icj real ( dp ), dimension (:,:), allocatable :: M_i_j real ( dp ), dimension (:,:), allocatable :: N_a_b real ( dp ), dimension (:,:), allocatable :: M real ( dp ), dimension (:,:), allocatable :: N real ( dp ), dimension (:,:), allocatable :: X real ( dp ), dimension (:,:), allocatable :: eigenvalues_o real ( dp ), dimension (:,:), allocatable :: eigenvalues_v real ( dp ), dimension (:,:), allocatable :: work real ( dp ), dimension (:,:), allocatable :: C_o real ( dp ), dimension (:,:), allocatable :: C_v real ( dp ), dimension (:,:), allocatable :: C_o_transformed real ( dp ), dimension (:,:), allocatable :: C_v_transformed real ( dp ), dimension (:,:), allocatable :: fock_o real ( dp ), dimension (:,:), allocatable :: fock_v real ( dp ), dimension (:,:), allocatable :: orbital_energies ! integer ( i15 ) :: info integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 , c = 0 , k = 0 integer ( i15 ) :: ai = 0 , ij = 0 , cj = 0 , bj = 0 , bk = 0 , ai_full integer ( i15 ) :: aibj = 0 , aibk = 0 , aib = 0 , icj = 0 ! real ( dp ) :: ddot , sum_o , sum_v , norm ! !     :::::::::::::::::::::::::::::::::::::::::::::::: !     -::- Construct CNTO transformation matrices -::- !     :::::::::::::::::::::::::::::::::::::::::::::::: ! !     Open file of CC2 solution vectors ! call generate_unit_identifier ( unit_solution ) ! !     Determine file name ! if ( wf % tasks % excited_state ) wf % excited_state_specifications % solution_file = 'right_valence' if ( wf % tasks % core_excited_state ) wf % excited_state_specifications % solution_file = 'right_core' ! open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file ,& action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( cc2_n_parameters ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening solution file' , ioerror ! !     Reading CC2 excitation vectors and summing them ! call wf % mem % alloc ( R , cc2_n_parameters , 1 ) call wf % mem % alloc ( R_sum , cc2_n_parameters , 1 ) R_sum = zero ! do state = 1 , wf % excited_state_specifications % n_singlet_states ! read ( unit = unit_solution , rec = state ) R ! call daxpy ( cc2_n_parameters , one , R , 1 , R_sum , 1 ) ! enddo ! !     Done with file, delete it ! close ( unit_solution , status = 'delete' ) ! call wf % mem % dealloc ( R , cc2_n_parameters , 1 ) ! call wf % mem % alloc ( R_sum_restricted , n_CC2_o * n_CC2_v + cc2_n_x2am , 1 ) ! !     Restict to CC2 active indices (only changes vector if there is a CCS space) !     This is done so that the CCSD space will always lie inside of the CC2 space ! do a = 1 , n_CC2_v do i = 1 , n_CC2_o ai = index_two ( a , i , n_CC2_v ) ai_full = index_two ( a , i , wf % n_v ) R_sum_restricted ( ai , 1 ) = R_sum ( ai_full , 1 ) enddo enddo ! do a = 1 , n_CC2_v do i = 1 , n_CC2_o ai = index_two ( a , i , n_CC2_v ) do b = 1 , n_CC2_v do j = 1 , n_CC2_o bj = index_two ( b , j , n_CC2_v ) aibj = index_packed ( ai , bj ) R_sum_restricted (( n_CC2_o ) * ( n_CC2_v ) + aibj , 1 ) & = R_sum (( wf % n_o ) * ( wf % n_v ) + aibj , 1 ) enddo enddo enddo enddo ! call wf % mem % dealloc ( R_sum , cc2_n_parameters , 1 ) ! !     Normalize restricted sum of CC2 excitation vectors R_sum_restricted !     in order to get Tr(M) = 1, and Tr(N) = 1 ! norm = sqrt ( ddot ( cc2_n_x2am + n_CC2_o * n_CC2_v , R_sum_restricted , 1 , R_sum_restricted , 1 )) call dscal ( cc2_n_x2am + n_CC2_o * n_CC2_v , one / norm , R_sum_restricted , 1 ) ! call wf % mem % alloc ( R_a_i , n_cc2_v , n_cc2_o ) ! do a = 1 , n_cc2_v do i = 1 , n_cc2_o ai = index_two ( a , i , n_CC2_v ) R_a_i ( a , i ) = R_sum_restricted ( ai , 1 ) enddo enddo ! call wf % mem % alloc ( R_ai_bj , n_cc2_o * n_cc2_v , n_cc2_o * n_cc2_v ) ! do ai = 1 , n_cc2_o * n_cc2_v do bj = 1 , n_cc2_o * n_cc2_v aibj = index_packed ( ai , bj ) R_ai_bj ( ai , bj ) = R_sum_restricted ( aibj + n_cc2_o * n_cc2_v , 1 ) enddo enddo ! call wf % mem % dealloc ( R_sum_restricted , n_CC2_o * n_CC2_v + cc2_n_x2am , 1 ) ! !     -::- Construct M and N -::- ! call wf % mem % alloc ( M_i_j , n_CC2_o , n_CC2_o ) call wf % mem % alloc ( N_a_b , n_CC2_v , n_CC2_v ) ! !     Singles contribution ! call dgemm ( 'T' , 'N' , & n_CC2_o , & n_CC2_o , & n_CC2_v , & one , & R_a_i , & n_CC2_v , & R_a_i , & n_CC2_v , & zero , & M_i_j , & n_CC2_o ) ! call dgemm ( 'N' , 'T' , & n_CC2_v , & n_CC2_v , & n_CC2_o , & one , & R_a_i , & n_CC2_v , & R_a_i , & n_CC2_v , & zero , & N_a_b , & n_CC2_v ) ! ! call wf % mem % dealloc ( R_a_i , n_cc2_v , n_cc2_o ) ! !     Doubles contribution ! call wf % mem % alloc ( R_aib_k , ( n_CC2_v ** 2 ) * ( n_CC2_o ), n_CC2_o ) ! do a = 1 , n_CC2_v do b = 1 , n_CC2_v do k = 1 , n_CC2_o do i = 1 , n_CC2_o aib = index_three ( a , i , b , n_CC2_v , n_CC2_o ) ai = index_two ( a , i , n_CC2_v ) bk = index_two ( b , k , n_CC2_v ) R_aib_k ( aib , k ) = R_ai_bj ( ai , bk ) enddo enddo enddo enddo ! call dgemm ( 'T' , 'N' , & n_CC2_o , & n_CC2_o , & ( n_CC2_v ** 2 ) * ( n_CC2_o ), & half , & R_aib_k , & ! R_ai,bk ( n_CC2_v ** 2 ) * ( n_CC2_o ), & R_aib_k , & ! R_aj,bk ( n_CC2_v ** 2 ) * ( n_CC2_o ), & one , & M_i_j , & n_CC2_o ) ! call wf % mem % dealloc ( R_aib_k , ( n_CC2_v ** 2 ) * ( n_CC2_o ), n_CC2_o ) ! do i = 1 , n_CC2_o do a = 1 , n_CC2_v ai = index_two ( a , i , n_CC2_v ) M_i_j ( i , i ) = M_i_j ( i , i ) + half * R_ai_bj ( ai , ai ) enddo enddo ! call wf % mem % alloc ( R_a_icj , n_CC2_v , ( n_CC2_o ** 2 ) * ( n_CC2_v )) ! do a = 1 , n_CC2_v do c = 1 , n_CC2_v do j = 1 , n_CC2_o do i = 1 , n_CC2_o icj = index_three ( i , c , j , n_CC2_o , n_CC2_v ) ai = index_two ( a , i , n_CC2_v ) cj = index_two ( c , j , n_CC2_v ) R_a_icj ( a , icj ) = R_ai_bj ( ai , cj ) enddo enddo enddo enddo call dgemm ( 'N' , 'T' , & n_CC2_v , & n_CC2_v , & ( n_CC2_o ** 2 ) * ( n_CC2_v ), & half , & R_a_icj , & ! R_ai,cj n_CC2_v , & R_a_icj , & ! R_bi,cj n_CC2_v , & one , & N_a_b , & n_CC2_v ) ! call wf % mem % dealloc ( R_a_icj , n_CC2_v , ( n_CC2_o ** 2 ) * ( n_CC2_v )) ! do a = 1 , n_CC2_v do i = 1 , n_CC2_o ai = index_two ( a , i , n_CC2_v ) N_a_b ( a , a ) = N_a_b ( a , a ) + half * R_ai_bj ( ai , ai ) enddo enddo ! call wf % mem % dealloc ( R_ai_bj , n_cc2_o * n_cc2_v , n_cc2_o * n_cc2_v ) ! !     -::- Diagonalize M and N matrix -::- ! call wf % mem % alloc ( eigenvalues_o , n_cc2_o , 1 ) call wf % mem % alloc ( work , 4 * ( n_cc2_o ), 1 ) work = zero ! call dsyev ( 'V' , 'U' , & n_cc2_o , & M_i_j , & n_cc2_o , & eigenvalues_o , & work , & 4 * ( n_cc2_o ), & info ) ! call wf % mem % dealloc ( work , 4 * ( n_cc2_o ), 1 ) ! call wf % mem % alloc ( eigenvalues_v , n_cc2_v , 1 ) call wf % mem % alloc ( work , 4 * ( n_cc2_v ), 1 ) work = zero ! call dsyev ( 'V' , 'U' , & n_cc2_v , & N_a_b , & n_cc2_v , & eigenvalues_v , & work , & 4 * ( n_cc2_v ), & info ) ! call wf % mem % dealloc ( work , 4 * ( n_cc2_v ), 1 ) ! !     -::- Reorder M and N -::- ! !     dsyev orderes eigenvalues and corresponding eigenvectors in ascending order. !     We wish to select active space according to highest eigenvalues, thus we must reorder ! call wf % mem % alloc ( M , n_cc2_o , n_cc2_o ) ! do i = 1 , n_cc2_o ! j = i - 1 M (:, i ) = M_i_j (:, n_cc2_o - j ) ! enddo ! call wf % mem % dealloc ( M_i_j , n_CC2_o , n_CC2_o ) ! call wf % mem % alloc ( N , n_cc2_v , n_cc2_v ) ! do a = 1 , n_cc2_v ! b = a - 1 N (:, a ) = N_a_b (:, n_cc2_v - b ) ! enddo ! call wf % mem % dealloc ( N_a_b , n_CC2_v , n_CC2_v ) ! !     :::::::::::::::::::::::::::: !     -::- Transform C matrix -::- !     :::::::::::::::::::::::::::: ! call wf % mem % alloc ( C_o , wf % n_ao , n_cc2_o ) call wf % mem % alloc ( C_v , wf % n_ao , n_cc2_v ) C_o = zero C_v = zero ! do i = 1 , wf % n_ao ! do j = 1 , n_cc2_o ij = index_two ( i , j , wf % n_ao ) C_o ( i , j ) = wf % mo_coef ( ij , 1 ) enddo ! do j = 1 , n_cc2_v ij = index_two ( i , j + wf % n_o , wf % n_ao ) C_v ( i , j ) = wf % mo_coef ( ij , 1 ) enddo ! enddo ! call wf % mem % alloc ( C_o_transformed , wf % n_ao , n_cc2_o ) call dgemm ( 'N' , 'N' , & wf % n_ao , & n_cc2_o , & n_cc2_o , & one , & C_o , & wf % n_ao , & M , & n_cc2_o , & zero , & C_o_transformed , & wf % n_ao ) ! call wf % mem % dealloc ( C_o , wf % n_ao , n_cc2_o ) ! call wf % mem % alloc ( C_v_transformed , wf % n_ao , n_cc2_v ) call dgemm ( 'N' , 'N' , & wf % n_ao , & n_cc2_v , & n_cc2_v , & one , & C_v , & wf % n_ao , & N , & n_cc2_v , & zero , & C_v_transformed , & wf % n_ao ) ! call wf % mem % dealloc ( C_v , wf % n_ao , n_cc2_v ) call wf % mem % dealloc ( N , n_cc2_v , n_cc2_v ) call wf % mem % dealloc ( M , n_cc2_o , n_cc2_o ) ! do i = 1 , wf % n_ao ! do j = 1 , n_cc2_o ij = index_two ( i , j , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_o_transformed ( i , j ) enddo ! do j = 1 , n_cc2_v ij = index_two ( i , j + wf % n_o , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_v_transformed ( i , j ) enddo ! enddo ! call wf % mem % dealloc ( C_o_transformed , wf % n_ao , n_cc2_o ) call wf % mem % dealloc ( C_v_transformed , wf % n_ao , n_cc2_v ) ! !     :::::::::::::::::::::::::::::::: !     -::- Active space selection -::- !     :::::::::::::::::::::::::::::::: ! sum_o = 1 - eigenvalues_o ( n_CC2_o , 1 ) wf % n_CCSD_o = 1 ! do while (( sum_o . gt . wf % CCSD_orbitals % delta_o ) . and . ( wf % n_CCSD_o . lt . n_cc2_o )) ! sum_o = sum_o - eigenvalues_o ( n_CC2_o - ( wf % n_CCSD_o ), 1 ) wf % n_CCSD_o = wf % n_CCSD_o + 1 ! enddo ! sum_v = 1 - eigenvalues_v ( n_CC2_v , 1 ) wf % n_CCSD_v = 1 ! do while ( sum_v . gt . wf % CCSD_orbitals % delta_v . and . ( wf % n_CCSD_v . lt . n_cc2_v )) ! sum_v = sum_v - eigenvalues_v ( n_CC2_v - ( wf % n_CCSD_v ), 1 ) wf % n_CCSD_v = wf % n_CCSD_v + 1 ! enddo ! !     Save information to object ! wf % first_CCSD_o = 1 wf % first_CCSD_v = 1 ! wf % n_CC2_o = n_cc2_o - wf % n_CCSD_o wf % n_CC2_v = n_cc2_v - wf % n_CCSD_v ! wf % first_CC2_o = 1 + wf % n_CCSD_o wf % first_CC2_v = 1 + wf % n_CCSD_v ! call wf % mem % dealloc ( eigenvalues_o , n_cc2_o , 1 ) call wf % mem % dealloc ( eigenvalues_v , n_cc2_v , 1 ) ! !     :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: !     -::- Finding orbital energies and new block diagonal C matrix -::- !     :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ! !     Initialize amplitudes and associated attributes ! call wf % initialize_amplitudes ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize fock matrix ! call wf % initialize_fock_matrix ! !     -::- Occupied orbitals -::- ! !     Diagonalize active-active block ! if ( wf % n_CCSD_o . gt . 0 ) then ! call wf % mem % alloc ( work , 4 * ( wf % n_CCSD_o ), 1 ) call wf % mem % alloc ( orbital_energies , ( wf % n_CCSD_o ), 1 ) work = zero ! call dsyev ( 'V' , 'U' , & ( wf % n_CCSD_o ), & wf % fock_ij , & wf % n_o , & orbital_energies , & work , & 4 * ( wf % n_CCSD_o ), & info ) ! call wf % mem % dealloc ( work , 4 * ( wf % n_CCSD_o ), 1 ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Diagonalization of active virtual block not successful. ' stop endif ! !        Setting orbital energies ! do j = 1 , wf % n_CCSD_o ! wf % fock_diagonal ( j , 1 ) = orbital_energies ( j , 1 ) ! enddo ! call wf % mem % dealloc ( orbital_energies , ( wf % n_CCSD_o ), 1 ) endif ! !     Diagonalize inactive-inactive block ! if ( wf % n_CC2_o . gt . 0 ) then call wf % mem % alloc ( work , 4 * wf % n_CC2_o , 1 ) call wf % mem % alloc ( orbital_energies , wf % n_CC2_o , 1 ) orbital_energies = zero work = zero ! call dsyev ( 'V' , 'U' , & wf % n_CC2_o , & wf % fock_ij ( wf % first_CC2_o , wf % first_CC2_o ),& wf % n_o , & orbital_energies , & work , & 4 * wf % n_CC2_o , & info ) ! call wf % mem % dealloc ( work , 4 * wf % n_CC2_o , 1 ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Diagonalization of inactive virtual block not successful.' stop endif ! !        Setting orbital energies ! do j = 1 , wf % n_CC2_o ! wf % fock_diagonal ( j + wf % first_CC2_o - 1 , 1 ) = orbital_energies ( j , 1 ) ! enddo call wf % mem % dealloc ( orbital_energies , wf % n_CC2_o , 1 ) endif ! !     Transform C-matrix to block diagonal (active occupied block) ! call wf % mem % alloc ( C_o , wf % n_ao , wf % n_o ) C_o = zero ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_o ij = index_two ( i , j , wf % n_ao ) C_o ( i , j ) = wf % mo_coef ( ij , 1 ) enddo ! enddo ! if ( wf % n_CCSD_o . gt . 0 ) then ! call wf % mem % alloc ( C_o_transformed , wf % n_ao , wf % n_CCSD_o ) ! call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_CCSD_o , & wf % n_CCSD_o , & one , & C_o , & wf % n_ao , & wf % fock_ij , & wf % n_o , & zero , & C_o_transformed , & wf % n_ao ) ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_CCSD_o ij = index_two ( i , j , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_o_transformed ( i , j ) enddo ! enddo ! call wf % mem % dealloc ( C_o_transformed , wf % n_ao , wf % n_CCSD_o ) endif ! !     Transform C-matrix to block diagonal (inactive occupied block) ! if ( wf % n_CC2_o . gt . 0 ) then call wf % mem % alloc ( C_o_transformed , wf % n_ao , wf % n_CC2_o ) call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_CC2_o , & wf % n_CC2_o , & one , & C_o ( 1 , wf % first_CC2_o ), & wf % n_ao , & wf % fock_ij ( wf % first_CC2_o , wf % first_CC2_o ), & wf % n_o , & zero , & C_o_transformed , & wf % n_ao ) ! call wf % mem % dealloc ( C_o , wf % n_ao , wf % n_o ) ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_CC2_o ij = index_two ( i , j + wf % first_CC2_o - 1 , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_o_transformed ( i , j ) enddo ! enddo ! call wf % mem % dealloc ( C_o_transformed , wf % n_ao , wf % n_CC2_o ) endif ! !     -::- Vacant orbitals -::- ! !     Diagonalize active-active block ! if ( wf % n_CCSD_v . gt . 0 ) then call wf % mem % alloc ( work , 4 * ( wf % n_CCSD_v ), 1 ) call wf % mem % alloc ( orbital_energies , ( wf % n_CCSD_v ), 1 ) work = zero ! call dsyev ( 'V' , 'U' , & ( wf % n_CCSD_v ), & wf % fock_ab , & wf % n_v , & orbital_energies , & work , & 4 * ( wf % n_CCSD_v ), & info ) ! call wf % mem % dealloc ( work , 4 * ( wf % n_CCSD_v ), 1 ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Diagonalization of active virtual block not successful. ' stop endif ! !        Setting orbital energies ! do j = 1 , wf % n_CCSD_v ! wf % fock_diagonal ( j + wf % n_o , 1 ) = orbital_energies ( j , 1 ) ! enddo ! call wf % mem % dealloc ( orbital_energies , ( wf % n_CCSD_v ), 1 ) ! endif ! !     Diagonalize inactive-inactive block ! if ( wf % n_CC2_v . gt . 0 ) then call wf % mem % alloc ( work , 4 * wf % n_CC2_v , 1 ) call wf % mem % alloc ( orbital_energies , wf % n_CC2_v , 1 ) orbital_energies = zero work = zero ! call dsyev ( 'V' , 'U' , & wf % n_CC2_v , & wf % fock_ab ( wf % first_CC2_v , wf % first_CC2_v ), & wf % n_v , & orbital_energies , & work , & 4 * ( wf % n_CC2_v ), & info ) ! call wf % mem % dealloc ( work , 4 * wf % n_CC2_v , 1 ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Diagonalization of inactive virtual block not successful.' stop endif ! !        Setting orbital energies ! do j = 1 , wf % n_CC2_v ! wf % fock_diagonal ( j + wf % n_o + wf % first_CC2_v - 1 , 1 ) = orbital_energies ( j , 1 ) ! enddo call wf % mem % dealloc ( orbital_energies , wf % n_CC2_v , 1 ) ! endif ! !     Transform C-matrix to block diagonal (active virtual block) ! call wf % mem % alloc ( C_v , wf % n_ao , wf % n_v ) C_v = zero ! do i = 1 , wf % n_ao ! do j = 1 , wf % n_v ij = index_two ( i , j + wf % n_o , wf % n_ao ) C_v ( i , j ) = wf % mo_coef ( ij , 1 ) enddo ! enddo ! if ( wf % n_CCSD_v . gt . 0 ) then ! call wf % mem % alloc ( C_v_transformed , wf % n_ao , wf % n_CCSD_v ) call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_CCSD_v ,& wf % n_CCSD_v ,& one , & C_v , & wf % n_ao , & wf % fock_ab , & wf % n_v , & zero , & C_v_transformed , & wf % n_ao ) ! do i = 1 , wf % n_ao do j = 1 , wf % n_CCSD_v ij = index_two ( i , j + wf % n_o , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_v_transformed ( i , j ) enddo enddo ! call wf % mem % dealloc ( C_v_transformed , wf % n_ao , wf % n_CCSD_v ) ! endif ! !     Transform C-matrix block diagonal (inactive virtual block) ! if ( wf % n_CC2_v . gt . 0 ) then ! call wf % mem % alloc ( C_v_transformed , wf % n_ao , wf % n_CC2_v ) call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_CC2_v , & wf % n_CC2_v , & one , & C_v ( 1 , wf % first_CC2_v ), & wf % n_ao , & wf % fock_ab ( wf % first_CC2_v , wf % first_CC2_v ), & wf % n_v , & zero , & C_v_transformed , & wf % n_ao ) ! do i = 1 , wf % n_ao do j = 1 , wf % n_CC2_v ij = index_two ( i , j + wf % n_o + wf % first_CC2_v - 1 , wf % n_ao ) wf % mo_coef ( ij , 1 ) = C_v_transformed ( i , j ) enddo enddo ! call wf % mem % dealloc ( C_v_transformed , wf % n_ao , wf % n_CC2_v ) ! endif ! call wf % mem % dealloc ( C_v , wf % n_ao , wf % n_v ) ! end subroutine ccsd_cnto_orbitals_mlccsd ! ! module subroutine print_orbital_info_mlccsd ( wf ) !! !!    Print CNTO info, !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Prints information on CNTO partitioning !! implicit none ! class ( mlccsd ) :: wf ! write ( unit_output , '(t6,a11)' ) 'CCSD space:' write ( unit_output , '(t6,a34, i3)' ) 'Number of occupied orbitals:      ' , wf % n_CCSD_o write ( unit_output , '(t6,a34, i3/)' ) 'Number of virtual orbitals:       ' , wf % n_CCSD_v ! write ( unit_output , '(t6,a10)' ) 'CC2 space:' write ( unit_output , '(t6,a34, i3)' ) 'Number of occupied orbitals:      ' , wf % n_CC2_o write ( unit_output , '(t6,a34, i3/)' ) 'Number of virtual orbitals:       ' , wf % n_CC2_v ! write ( unit_output , '(t6,a10)' ) 'CCS space:' write ( unit_output , '(t6,a34, i3)' ) 'Number of occupied orbitals:      ' , wf % n_CCS_o write ( unit_output , '(t6,a34, i3/)' ) 'Number of virtual orbitals:       ' , wf % n_CCS_v flush ( unit_output ) ! end subroutine print_orbital_info_mlccsd ! end submodule orbital_partitioning","tags":"","loc":"sourcefile/orbital_partitioning_submodule.f90~2.html","title":"orbital_partitioning_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~omega_submodule.f90~3~~EfferentGraph sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~cc3_class.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~cc3_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileomega_submodulef903EfferentGraph = svgPanZoom('#sourcefileomega_submodulef903EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules omega Source Code omega_submodule.F90 Source Code submodule ( cc3_class ) omega ! !! !!    Omega submodule (CC3) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Contains the following subroutines: !! !!    construct_omega: constructs the projection vector by adding the CC3 !!                     and CCSD contributions to omega1 and omega2. !!    omega_integrals: constructs the integrals needed for the CC3 contributions, !!                     and saves them to disk. !!    omega_cc3_a1:    adds the A1 term to omega1 (for a given i, j, and k). !!    omega_cc3_a2:    adds the A2 term to omega2 (for a given i, j, and k). !!    omega_cc3_b2:    adds the B2 term to omega2 (for a given i, j, and k). !! !!    The submodule was based on the MLCC3 routines implemented by Rolf H. Myhre !!    and Henrik Koch in the Dalton quantum chemistry program. !! !!    Note: the construction of omega has not yet been optimized, and is rather !!    slow. Among other things, the factor of 1/6 (i >= j >= k) that can be saved !!    in the construction of t_ijk&#94;abc has not been implemented. Todo. !! ! implicit none ! contains ! module subroutine construct_omega_cc3 ( wf ) !! !!    Construct Omega (CC3) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Directs the calculation of the projection vector (omega1, omega2) !!    for the CC3 level of theory. !! implicit none ! class ( cc3 ) :: wf ! real ( dp ), dimension (:,:), allocatable :: t_abc ! Triples, t_ijk&#94;abc, fixed ijk ! real ( dp ), dimension (:,:), allocatable :: omega_ai_bj ! Unpacked holder of CC3 contributions ! to the omega2 vector ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 integer ( i15 ) :: a = 0 , b = 0 , ai = 0 , bj = 0 , aibj = 0 ! !     Set the omega vector to zero ! wf % omega1 = zero wf % omega2 = zero ! !     :: CC3 integrals :: ! !     Calculate and save to disk the integrals needed !     to form the triples amplitudes & CC3 omega contributions ! call wf % omega_integrals ! !     :: CC3 contributions to omega :: ! !     We construct the triples amplitudes t_abc (= t_ijk&#94;abc) !     for a given set of occupied indices, i, j, k, adding !     the appropriate CC3 omega contributions. ! call wf % mem % alloc ( t_abc , ( wf % n_v ) ** 3 , 1 ) t_abc = zero ! call wf % mem % alloc ( omega_ai_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) omega_ai_bj = zero ! do i = 1 , wf % n_o do j = 1 , wf % n_o do k = 1 , wf % n_o ! !              Calculate the triples amplitudes: ! !              Calculate W_abc = P_ijk&#94;abc ( sum_d t_ij&#94;ad g_bdck - sum_l t_il&#94;ab g_ljck ) !              and divide by orbital energy difference, t_abc = - W_abc / e_abc ! t_abc = zero call wf % calc_triples ( t_abc , i , j , k ) ! !              Add the CC3 omega terms, using the calculated triples amplitudes: ! call wf % omega_cc3_a1 ( t_abc , i , j , k ) ! call wf % omega_cc3_a2 ( omega_ai_bj , t_abc , i , j , k ) call wf % omega_cc3_b2 ( omega_ai_bj , t_abc , i , j , k ) ! enddo enddo enddo ! !     Pack in squared omega into the wavefunction's packed omega vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega_ai_bj ( ai , bj ) + & omega_ai_bj ( bj , ai ) endif ! enddo enddo enddo enddo ! call wf % mem % dealloc ( omega_ai_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( t_abc , ( wf % n_v ) ** 3 , 1 ) ! !     :: CCSD contributions to omega :: ! !     Construct singles contributions (CCSD) ! call wf % omega_ccsd_a1 call wf % omega_ccsd_b1 call wf % omega_ccsd_c1 call wf % omega_ccs_a1 ! !     Construct doubles contributions (CCSD) ! call wf % omega_ccsd_a2 call wf % omega_ccsd_b2 call wf % omega_ccsd_c2 call wf % omega_ccsd_d2 call wf % omega_ccsd_e2 ! end subroutine construct_omega_cc3 ! ! module subroutine omega_integrals_cc3 ( wf ) !! !!     Omega Integrals (CC3) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!     Calculates g_bdck and saves to disk in the order bcd, k (one record per d and k) !!     Calculates g_ljck and saves to disk in the order lc, jk (one record per j and k) !!     Calculates g_jbkc and saves to disk in the order bc, kj (one record per k and j) !!     Calculates g_ilkc and saves to disk in the order cl, ik (one record per i and k) !!     Calculates g_dbkc and saves to disk in the order bcd, k (one record per d and k) !! implicit none ! class ( cc3 ) :: wf ! integer ( i15 ) :: unit_bdck = 0 , unit_ljck = 0 integer ( i15 ) :: unit_jbkc = 0 , unit_ilkc = 0 , unit_dbkc = 0 ! integer ( i15 ) :: rec_number = 0 , ioerror = 0 ! real ( dp ), dimension (:,:), allocatable :: L_bd_J real ( dp ), dimension (:,:), allocatable :: L_db_J real ( dp ), dimension (:,:), allocatable :: L_ck_J real ( dp ), dimension (:,:), allocatable :: L_lj_J real ( dp ), dimension (:,:), allocatable :: L_kc_J ! real ( dp ), dimension (:,:), allocatable :: g_bd_ck ! g_bdck real ( dp ), dimension (:,:), allocatable :: g_bcd_k ! g_bdck or g_dbkc ! real ( dp ), dimension (:,:), allocatable :: g_lj_ck ! g_ljck real ( dp ), dimension (:,:), allocatable :: g_lc_jk ! g_ljck ! real ( dp ), dimension (:,:), allocatable :: g_jb_kc ! g_jbkc real ( dp ), dimension (:,:), allocatable :: g_bc_kj ! g_jbkc ! real ( dp ), dimension (:,:), allocatable :: g_il_kc ! g_ilkc real ( dp ), dimension (:,:), allocatable :: g_cl_ik ! g_ilkc ! real ( dp ), dimension (:,:), allocatable :: g_bd_kc ! g_dbkc ! integer ( i15 ) :: d = 0 , c = 0 , b = 0 , k = 0 , i = 0 integer ( i15 ) :: bcd = 0 , ck = 0 , j = 0 , jk = 0 , l = 0 integer ( i15 ) :: lc = 0 , lj = 0 , bc = 0 , jb = 0 , kc = 0 integer ( i15 ) :: kj = 0 , cl = 0 , il = 0 , ik = 0 ! logical :: reorder = . false . ! !     :: g_bdck integrals :: ! call generate_unit_identifier ( unit_bdck ) open ( unit = unit_bdck , file = 'bdck' , action = 'write' , status = 'replace' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) ** 2 , iostat = ioerror ) ! do d = 1 , wf % n_v ! !        Read Cholesky vectors L_bd_J and L_ck_J ! call wf % mem % alloc ( L_bd_J , ( wf % n_v ), wf % n_J ) L_bd_J = zero ! !        Get ab-cholesky vectors for the batch, L_bd_J = L_bd&#94;J ! call wf % get_cholesky_ab ( L_bd_J , 1 , wf % n_v , d , d ) ! call wf % mem % alloc ( L_ck_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) L_ck_J = zero ! call wf % get_cholesky_ai ( L_ck_J ) ! !        Form the integral g_bd_ck = g_bdck ! call wf % mem % alloc ( g_bd_ck , wf % n_v , ( wf % n_v ) * ( wf % n_o )) g_bd_ck = zero ! call dgemm ( 'N' , 'T' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ), & wf % n_J , & one , & L_bd_J , & wf % n_v , & L_ck_J , & ( wf % n_v ) * ( wf % n_o ), & zero , & g_bd_ck , & wf % n_v ) ! !        Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ck_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) call wf % mem % dealloc ( L_bd_J , ( wf % n_v ), wf % n_J ) ! !        Reorder the integral as g_bcd_k ! call wf % mem % alloc ( g_bcd_k , ( wf % n_v ) ** 2 , wf % n_o ) g_bcd_k = zero ! do c = 1 , wf % n_v do b = 1 , wf % n_v do k = 1 , wf % n_o ! ck = index_two ( c , k , wf % n_v ) bcd = index_two ( b , c , wf % n_v ) ! d is fixed ! g_bcd_k ( bcd , k ) = g_bd_ck ( b , ck ) ! enddo enddo enddo ! !        Deallocate g_bd_ck ! call wf % mem % dealloc ( g_bd_ck , wf % n_v , ( wf % n_v ) * ( wf % n_o )) ! !        Write the integral g_bcd_k to disk ! do k = 1 , wf % n_o ! rec_number = index_two ( d , k , wf % n_v ) write ( unit_bdck , rec = rec_number , iostat = ioerror ) ( g_bcd_k ( i , k ), i = 1 , ( wf % n_v ) ** 2 ) ! enddo ! call wf % mem % dealloc ( g_bcd_k , ( wf % n_v ) ** 2 , wf % n_o ) ! enddo ! End of do's over d ! !     Close bdck file ! close ( unit_bdck ) ! !     :: g_dbkc integrals :: ! call generate_unit_identifier ( unit_dbkc ) open ( unit = unit_dbkc , file = 'dbkc' , action = 'write' , status = 'replace' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) ** 2 , iostat = ioerror ) ! call wf % mem % alloc ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % get_cholesky_ia ( L_kc_J ) ! do d = 1 , wf % n_v ! !        Read Cholesky vector L_bd_J(bd,J) = L_db&#94;J ! call wf % mem % alloc ( L_db_J , ( wf % n_v ), wf % n_J ) L_db_J = zero ! !        Get ab-cholesky vectors for the batch, L_db&#94;J =  L_db_J ! call wf % get_cholesky_ab ( L_db_J , d , d , 1 , wf % n_v ) ! !        Form the integral g_bd_kc = g_dbkc ! call wf % mem % alloc ( g_bd_kc , wf % n_v , ( wf % n_v ) * ( wf % n_o )) g_bd_kc = zero ! call dgemm ( 'N' , 'T' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ), & wf % n_J , & one , & L_db_J , & wf % n_v , & L_kc_J , & ( wf % n_v ) * ( wf % n_o ), & zero , & g_bd_kc , & wf % n_v ) ! !        Deallocate Cholesky vector ! call wf % mem % dealloc ( L_bd_J , ( wf % n_v ), wf % n_J ) ! !        Reorder the integral as g_bcd_k ! call wf % mem % alloc ( g_bcd_k , ( wf % n_v ) ** 2 , wf % n_o ) g_bcd_k = zero ! do c = 1 , wf % n_v do b = 1 , wf % n_v do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) bcd = index_two ( b , c , wf % n_v ) ! d is fixed ! g_bcd_k ( bcd , k ) = g_bd_kc ( b , kc ) ! g_dbkc ! enddo enddo enddo ! !        Deallocate g_bd_ck ! call wf % mem % dealloc ( g_bd_kc , wf % n_v , ( wf % n_v ) * ( wf % n_o )) ! !        Write the integral g_bcd_k to disk (= g_dbkc) ! do k = 1 , wf % n_o ! rec_number = index_two ( d , k , wf % n_v ) write ( unit_dbkc , rec = rec_number , iostat = ioerror ) & ( g_bcd_k ( i , k ), i = 1 , ( wf % n_v ) ** 2 ) ! enddo ! call wf % mem % dealloc ( g_bcd_k , ( wf % n_v ) ** 2 , wf % n_o ) ! enddo ! End of do's over d ! call wf % mem % dealloc ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! close ( unit_dbkc ) ! !     :: g_ljck integrals :: ! call generate_unit_identifier ( unit_ljck ) open ( unit = unit_ljck , file = 'ljck' , action = 'write' , status = 'replace' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_o ) * ( wf % n_v ), iostat = ioerror ) ! call wf % mem % alloc ( L_lj_J , ( wf % n_o ) ** 2 , wf % n_J ) call wf % mem % alloc ( L_ck_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) ! call wf % get_cholesky_ij ( L_lj_J ) call wf % get_cholesky_ai ( L_ck_J ) ! !     Form g_lj_ck ! call wf % mem % alloc ( g_lj_ck , ( wf % n_o ) ** 2 , ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) ** 2 , & ( wf % n_v ) * ( wf % n_o ), & wf % n_J , & one , & L_lj_J , & ( wf % n_o ) ** 2 , & L_ck_J , & ( wf % n_v ) * ( wf % n_o ), & zero , & g_lj_ck , & ( wf % n_o ) ** 2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_lj_J , ( wf % n_o ) ** 2 , wf % n_J ) call wf % mem % dealloc ( L_ck_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Reorder to g_lc_jk ! call wf % mem % alloc ( g_lc_jk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) g_lc_jk = zero ! do c = 1 , wf % n_v do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) ! do k = 1 , wf % n_o ! ck = index_two ( c , k , wf % n_v ) ! do j = 1 , wf % n_o ! lj = index_two ( l , j , wf % n_o ) jk = index_two ( j , k , wf % n_o ) ! g_lc_jk ( lc , jk ) = g_lj_ck ( lj , ck ) ! enddo enddo enddo enddo ! !     Deallocate unordered integral ! call wf % mem % dealloc ( g_lj_ck , ( wf % n_o ) ** 2 , ( wf % n_v ) * ( wf % n_o )) ! !     Write the integrals to the ljck file, !     ordered as lc, jk ! do k = 1 , wf % n_o do j = 1 , wf % n_o ! jk = index_two ( j , k , wf % n_o ) rec_number = jk write ( unit_ljck , rec = rec_number , iostat = ioerror ) ( g_lc_jk ( i , jk ), i = 1 , ( wf % n_o ) * ( wf % n_v )) ! enddo enddo ! call wf % mem % dealloc ( g_lc_jk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) ! !     Close ljck file ! close ( unit_ljck ) ! !     :: g_jbkc integrals :: ! call generate_unit_identifier ( unit_jbkc ) open ( unit = unit_jbkc , file = 'jbkc' , action = 'write' , status = 'replace' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) ** 2 , iostat = ioerror ) ! call wf % mem % alloc ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! call wf % get_cholesky_ia ( L_kc_J ) ! call wf % mem % alloc ( g_jb_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_jb_kc = zero ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_jb_kc , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate Cholesky vector L_kc_J ! call wf % mem % dealloc ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Reorder g_jb_kc to g_bc_kj ! call wf % mem % alloc ( g_bc_kj , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) g_bc_kj = zero ! do c = 1 , wf % n_v do b = 1 , wf % n_v ! bc = index_two ( b , c , wf % n_v ) ! do j = 1 , wf % n_o ! jb = index_two ( j , b , wf % n_o ) ! do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) kj = index_two ( k , j , wf % n_o ) ! g_bc_kj ( bc , kj ) = g_jb_kc ( jb , kc ) ! g_jbkc ! enddo enddo enddo enddo ! !     Deallocate unordered integral g_jb_kc ! call wf % mem % dealloc ( g_jb_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Write the integrals to the jbkc file, !     ordered as bc, kj ! do k = 1 , wf % n_o do j = 1 , wf % n_o ! kj = index_two ( k , j , wf % n_o ) rec_number = kj write ( unit_jbkc , rec = rec_number , iostat = ioerror ) ( g_bc_kj ( i , kj ), i = 1 , ( wf % n_v ) ** 2 ) ! enddo enddo ! call wf % mem % dealloc ( g_bc_kj , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! !     Close jbkc file ! close ( unit_jbkc ) ! !     :: g_ilkc integrals :: ! call generate_unit_identifier ( unit_ilkc ) open ( unit = unit_ilkc , file = 'ilkc' , action = 'write' , status = 'replace' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) * ( wf % n_o ), iostat = ioerror ) ! call wf % mem % alloc ( L_lj_J , ( wf % n_o ) ** 2 , wf % n_J ) call wf % mem % alloc ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! call wf % get_cholesky_ij ( L_lj_J ) call wf % get_cholesky_ia ( L_kc_J ) ! call wf % mem % alloc ( g_il_kc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) g_il_kc = zero ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_lj_J , & ( wf % n_o ) ** 2 , & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_il_kc , & ( wf % n_o ) ** 2 ) ! call wf % mem % dealloc ( L_lj_J , ( wf % n_o ) ** 2 , wf % n_J ) call wf % mem % dealloc ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Reorder g_il_kc to g_cl_ik ! call wf % mem % alloc ( g_cl_ik , ( wf % n_v ) * ( wf % n_o ), ( wf % n_o ) ** 2 ) g_cl_ik = zero ! do k = 1 , wf % n_o do i = 1 , wf % n_o ! ik = index_two ( i , k , wf % n_o ) ! do l = 1 , wf % n_o ! il = index_two ( i , l , wf % n_o ) ! do c = 1 , wf % n_v ! kc = index_two ( k , c , wf % n_o ) cl = index_two ( c , l , wf % n_v ) ! g_cl_ik ( cl , ik ) = g_il_kc ( il , kc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_il_kc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Write the g_ilkc integrals to the ilkc file, !     ordered as cl, ik ! do i = 1 , wf % n_o do k = 1 , wf % n_o ! ik = index_two ( i , k , wf % n_o ) rec_number = ik write ( unit_ilkc , rec = rec_number , iostat = ioerror ) ( g_cl_ik ( j , ik ), j = 1 , ( wf % n_v ) * ( wf % n_o )) ! enddo enddo ! !     Close the ilkc file ! close ( unit_ilkc ) ! call wf % mem % dealloc ( g_cl_ik , ( wf % n_v ) * ( wf % n_o ), ( wf % n_o ) ** 2 ) ! end subroutine omega_integrals_cc3 ! ! module subroutine calc_triples_cc3 ( wf , w_abc , i , j , k ) !! !!    Calculate Triples (CC3) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Calculate W_abc = P_ijk&#94;abc ( sum_d t_ij&#94;ad g_bdck - sum_l t_il&#94;ab g_ljck ) !!    and divide by orbital energy difference, t_abc = - W_abc / e_abc. On exit, !!    w_abc = t_abc, the CC3 triples amplitude t_ijk&#94;abc for a given set of occupied !!    indices i, j, and k. !! implicit none ! class ( cc3 ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 3 , 1 ) :: w_abc ! integer ( i15 ), intent ( in ) :: i , j , k ! real ( dp ), dimension (:,:), allocatable :: t_a_b ! Holds t_pq&#94;ab, where p,q is i,j, or k ! real ( dp ), dimension (:,:), allocatable :: t_ab_l ! Holds t_pl&#94;ab, where p is i, j, or k ! real ( dp ), dimension (:,:), allocatable :: g_bc_d ! g_ckbd for the given k ! g_bc_d(bc,d) = g_ckbd (holds for j & i also) ! real ( dp ), dimension (:,:), allocatable :: g_l_c ! g_ljck for given j and k ! real ( dp ), dimension (:,:), allocatable :: w ! Holds differently ordered contributions to w_abc ! real ( dp ) :: e_abc ! Orbital energy difference e_ijk&#94;abc real ( dp ) :: e_ijk ! e_i + e_j + e_k ! integer ( i15 ) :: a = 0 , d = 0 , ai = 0 , dj = 0 , aidj = 0 , l = 0 integer ( i15 ) :: abc = 0 , acb = 0 , b = 0 , c = 0 , aidk = 0 , dk = 0 integer ( i15 ) :: bj = 0 , bjdk = 0 , bca = 0 , bac = 0 , jk = 0 , ab = 0 integer ( i15 ) :: aibl = 0 , bl = 0 , kj = 0 , al = 0 , albj = 0 , ik = 0 integer ( i15 ) :: ki = 0 , cba = 0 , albk = 0 , bk = 0 , ij = 0 , ji = 0 integer ( i15 ) :: ck = 0 , djck = 0 ! integer ( i15 ) :: unit_bdck = - 1 , unit_ljck = - 1 integer ( i15 ) :: ioerror = 0 , iostat = 0 , rec_number = 0 ! ! !     :: The g_ckbd terms, i.e., P_ijk&#94;abc sum_d t_ij&#94;ad g_bdck :: ! ! !     Term 1. sum_d t_ij&#94;ad g_bdck = sum_d t_a_b(a,d) g_bc_d(bc,d) ! call wf % mem % alloc ( t_a_b , wf % n_v , wf % n_v ) t_a_b = zero ! do a = 1 , wf % n_v do d = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) dj = index_two ( d , j , wf % n_v ) ! aidj = index_packed ( ai , dj ) ! t_a_b ( a , d ) = wf % t2am ( aidj , 1 ) ! t_a_b(a,d) = t_ij&#94;ad ! enddo enddo ! !     Read g_bdck, ordered as g_bc_d for k fixed ! call generate_unit_identifier ( unit_bdck ) open ( unit = unit_bdck , file = 'bdck' , action = 'read' , status = 'old' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) ** 2 , iostat = ioerror ) ! call wf % mem % alloc ( g_bc_d , ( wf % n_v ) ** 2 , wf % n_v ) g_bc_d = zero ! do d = 1 , wf % n_v ! rec_number = index_two ( d , k , wf % n_v ) read ( unit_bdck , rec = rec_number , iostat = ioerror ) ( g_bc_d ( l , d ), l = 1 , ( wf % n_v ) ** 2 ) ! enddo ! call dgemm ( 'N' , 'T' , & wf % n_v , & ( wf % n_v ) ** 2 , & wf % n_v , & one , & t_a_b , & wf % n_v , & g_bc_d , & ( wf % n_v ) ** 2 , & one , & w_abc , & wf % n_v ) ! !     Term 2. sum_d t_ij&#94;db g_adck = sum_d g_bc_d(ac,d) t_a_d(d,b) -> ordered (ac,b) ! !     Note: t_a_d(a,d) = t_ij&#94;ad, !        => t_a_d(d,b) = t_ij&#94;db ! !           g_bc_d(bc,d) = g_bdck !        => g_bc_d(ac,d) = g_adck ! call wf % mem % alloc ( w , ( wf % n_v ) ** 3 , 1 ) w = zero ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & wf % n_v , & wf % n_v , & one , & g_bc_d , & ( wf % n_v ) ** 2 , & t_a_b , & wf % n_v , & zero , & w , & ( wf % n_v ) ** 2 ) ! Note: wait to add to w_abc ! !     Term 3. sum_d t_ik&#94;ad g_bjcd ! t_a_b = zero ! do a = 1 , wf % n_v do d = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) dk = index_two ( d , k , wf % n_v ) ! aidk = index_packed ( ai , dk ) ! t_a_b ( a , d ) = wf % t2am ( aidk , 1 ) ! t_a_b(a,d) = t_ik&#94;ad ! enddo enddo ! !     g_bc_d(bc,d) = g_bdck !  => g_bc_d(cb,d) = g_cdbk = g_bkcd -> switch k with j ! g_bc_d = zero ! do d = 1 , wf % n_v ! rec_number = index_two ( d , j , wf % n_v ) read ( unit_bdck , rec = rec_number , iostat = ioerror ) ( g_bc_d ( l , d ), l = 1 , ( wf % n_v ) ** 2 ) ! enddo ! !     Now, sum_d t_ik&#94;ad g_bjcd = sum_d t_a_b(a,d) g_bc_d(cb,d) -> ordered as a,cb ! call dgemm ( 'N' , 'T' , & wf % n_v , & ( wf % n_v ) ** 2 , & wf % n_v , & one , & t_a_b , & wf % n_v , & g_bc_d , & ( wf % n_v ) ** 2 , & one , & ! Accumulate from previous term w , & ( wf % n_v )) ! !     Add w(acb) to w_abc(abc) ! do b = 1 , wf % n_v do c = 1 , wf % n_v do a = 1 , wf % n_v ! acb = index_three ( a , c , b , wf % n_v , wf % n_v ) abc = index_three ( a , b , c , wf % n_v , wf % n_v ) ! w_abc ( abc , 1 ) = w_abc ( abc , 1 ) + w ( acb , 1 ) ! enddo enddo enddo ! !     Term 4. sum_d t_ik&#94;dc g_bjad = sum_d g_bc_d(ab,d) t_a_b(d,c) -> ordered as ab, c ! !     Note: g_bc_d(cb,d) = g_bjcd !        => g_bc_d(ab,d) = g_bjad ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & wf % n_v , & wf % n_v , & one , & g_bc_d , & ( wf % n_v ) ** 2 , & t_a_b , & wf % n_v , & one , & w_abc , & ( wf % n_v ) ** 2 ) ! !     Term 5. sum_d t_jk&#94;bd g_cdai ! t_a_b = zero ! do b = 1 , wf % n_v do d = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) dk = index_two ( d , k , wf % n_v ) ! bjdk = index_packed ( bj , dk ) ! t_a_b ( b , d ) = wf % t2am ( bjdk , 1 ) ! t_a_b(b,d) = t_jk&#94;bd ! enddo enddo ! !     g_bc_d(bc,d) = g_bdck !  => g_bc_d(ca,d) = g_cdak -> switch k with i ! g_bc_d = zero ! do d = 1 , wf % n_v ! rec_number = index_two ( d , i , wf % n_v ) read ( unit_bdck , rec = rec_number , iostat = ioerror ) ( g_bc_d ( l , d ), l = 1 , ( wf % n_v ) ** 2 ) ! enddo ! !     sum_d t_jk&#94;bd g_cdai = sum_d t_a_b(b,d) g_bc_d(ca,d) -> ordered as b,ca ! w = zero ! call dgemm ( 'N' , 'T' , & wf % n_v , & ( wf % n_v ) ** 2 , & wf % n_v , & one , & t_a_b , & wf % n_v , & g_bc_d , & ( wf % n_v ) ** 2 , & zero , & w , & ( wf % n_v )) ! !     Add w(bca) to w_abc(abc) ! do a = 1 , wf % n_v do c = 1 , wf % n_v do b = 1 , wf % n_v ! bca = index_three ( b , c , a , wf % n_v , wf % n_v ) abc = index_three ( a , b , c , wf % n_v , wf % n_v ) ! w_abc ( abc , 1 ) = w_abc ( abc , 1 ) + w ( bca , 1 ) ! enddo enddo enddo ! !     Term 6. sum_d t_jk&#94;dc g_bdai = sum_d g_bc_d(ba,d) t_a_b(d,c) -> ordered as ba,c ! !     Note: g_bc_d(ca,d) = g_cdai !        => g_bc_d(ba,d) = g_bdai ! t_a_b = zero ! do c = 1 , wf % n_v do d = 1 , wf % n_v ! dj = index_two ( d , j , wf % n_v ) ck = index_two ( c , k , wf % n_v ) ! djck = index_packed ( dj , ck ) ! t_a_b ( d , c ) = wf % t2am ( djck , 1 ) ! t_a_b(d,c) = t_jk&#94;dc ! enddo enddo ! w = zero call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & wf % n_v , & wf % n_v , & one , & g_bc_d , & ( wf % n_v ) ** 2 , & t_a_b , & wf % n_v , & zero , & w , & ( wf % n_v ) ** 2 ) ! !     Add w(bac) to w_abc(abc) ! do c = 1 , wf % n_v do b = 1 , wf % n_v do a = 1 , wf % n_v ! bac = index_three ( b , a , c , wf % n_v , wf % n_v ) abc = index_three ( a , b , c , wf % n_v , wf % n_v ) ! w_abc ( abc , 1 ) = w_abc ( abc , 1 ) + w ( bac , 1 ) ! enddo enddo enddo ! !     Close integral file ! close ( unit_bdck ) ! !     Deallocations ! call wf % mem % dealloc ( g_bc_d , ( wf % n_v ) ** 2 , wf % n_v ) call wf % mem % dealloc ( t_a_b , wf % n_v , wf % n_v ) ! !     :: The g_ljck terms, i.e., - P_ijk&#94;abc sum_l t_il&#94;ab g_ljck :: ! !     Read the integrals g_ljck from file ! call generate_unit_identifier ( unit_ljck ) open ( unit = unit_ljck , file = 'ljck' , action = 'read' , status = 'old' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_o ) * ( wf % n_v ), iostat = ioerror ) ! !     Read into g_l_c, ordered as lc, jk, such that g_l_c(l,c) = g_cklj ! call wf % mem % alloc ( g_l_c , wf % n_o , wf % n_v ) g_l_c = zero ! jk = index_two ( j , k , wf % n_o ) rec_number = jk read ( unit_ljck , rec = rec_number , iostat = ioerror ) g_l_c ! !     Set the amplitudes ! call wf % mem % alloc ( t_ab_l , ( wf % n_v ) ** 2 , wf % n_o ) t_ab_l = zero ! do a = 1 , wf % n_v do b = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) ! do l = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) bl = index_two ( b , l , wf % n_v ) ! aibl = index_packed ( ai , bl ) ! t_ab_l ( ab , l ) = wf % t2am ( aibl , 1 ) ! t_ab_l(ab,l) = t_il&#94;ab ! enddo enddo enddo ! !     Term 1. - sum_l t_il&#94;ab g_cklj = - sum_l t_ab_l(ab,l) g_l_c(l,c) -> ordered as ab, c ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & wf % n_v , & wf % n_o , & - one , & t_ab_l , & ( wf % n_v ) ** 2 , & g_l_c , & wf % n_o , & one , & w_abc , & ( wf % n_v ) ** 2 ) ! !     Term 2. sum_l t_il&#94;ac g_bjlk = sum_l t_ab_l(ac,l) * ? ! !     Note: g_l_c(l,c) = g_cklj !        => g_l_c(l,b) = g_bklj -> switch k and j ! g_l_c = zero ! kj = index_two ( k , j , wf % n_o ) rec_number = kj read ( unit_ljck , rec = rec_number , iostat = ioerror ) g_l_c ! !     Now g_l_c(l,b) = g_bjlk, giving ! !        sum_l t_il&#94;ac g_bjlk = sum_l t_ab_l(ac,l) g_l_c(l,b) -> ordered as ac,b ! w = zero ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & wf % n_v , & wf % n_o , & - one , & t_ab_l , & ( wf % n_v ) ** 2 , & g_l_c , & wf % n_o , & zero , & w , & ( wf % n_v ) ** 2 ) ! !     Add w(acb) to w_abc(abc) ! do b = 1 , wf % n_v do c = 1 , wf % n_v do a = 1 , wf % n_v ! acb = index_three ( a , c , b , wf % n_v , wf % n_v ) abc = index_three ( a , b , c , wf % n_v , wf % n_v ) ! w_abc ( abc , 1 ) = w_abc ( abc , 1 ) + w ( acb , 1 ) ! enddo enddo enddo ! !     Term 3. - sum_l t_lj&#94;ab g_ckli ! t_ab_l = zero ! do a = 1 , wf % n_v do b = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) ! do l = 1 , wf % n_o ! al = index_two ( a , l , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! albj = index_packed ( al , bj ) ! t_ab_l ( ab , l ) = wf % t2am ( albj , 1 ) ! t_ab_l(ab,l) = t_lj&#94;ab ! enddo enddo enddo ! !     Note: g_l_c(l,b) = g_bjlk !        => g_l_c(l,c) = g_cjlk, switch kj -> ik ! g_l_c = zero ! ik = index_two ( i , k , wf % n_o ) rec_number = ik read ( unit_ljck , rec = rec_number , iostat = ioerror ) g_l_c ! g_l_c(l,c) = g_ckli ! !     - sum_l t_lj&#94;ab g_ckli = - sum_l t_ab_l(ab,l) g_l_c(l,c) -> ordered as ab, c ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & wf % n_v , & wf % n_o , & - one , & t_ab_l , & ( wf % n_v ) ** 2 , & g_l_c , & wf % n_o , & one , & w_abc , & ( wf % n_v ) ** 2 ) ! !     Term 4. - sum_l t_lj&#94;cb g_ailk ! !     Note: g_l_c(l,c) = g_ckli !        => g_l_c(l,a) = g_akli, switch i and k ! g_l_c = zero ! ki = index_two ( k , i , wf % n_o ) rec_number = ki read ( unit_ljck , rec = rec_number , iostat = ioerror ) g_l_c ! g_l_c(l,a) = g_ailk ! !     - sum_l t_lj&#94;cb g_ailk = - sum_l t_ab_l(cb,l) g_l_c(l,a) -> ordered as cb, a ! w = zero ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & wf % n_v , & wf % n_o , & - one , & t_ab_l , & ( wf % n_v ) ** 2 , & g_l_c , & wf % n_o , & zero , & w , & ( wf % n_v ) ** 2 ) ! !     Add w(cba) to w_abc(abc) ! do b = 1 , wf % n_v do c = 1 , wf % n_v do a = 1 , wf % n_v ! cba = index_three ( c , b , a , wf % n_v , wf % n_v ) abc = index_three ( a , b , c , wf % n_v , wf % n_v ) ! w_abc ( abc , 1 ) = w_abc ( abc , 1 ) + w ( cba , 1 ) ! enddo enddo enddo ! !     Term 5. - sum_l t_lk&#94;ac g_bjli ! t_ab_l = zero ! do a = 1 , wf % n_v do b = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) ! do l = 1 , wf % n_o ! al = index_two ( a , l , wf % n_v ) bk = index_two ( b , k , wf % n_v ) ! albk = index_packed ( al , bk ) ! t_ab_l ( ab , l ) = wf % t2am ( albk , 1 ) ! t_ab_l(ab,l) = t_lk&#94;ab ! enddo enddo enddo ! !     Note: g_l_c(l,c) = g_cilk !        => g_l_c(l,b) = g_bilk, switch ki with ij ! g_l_c = zero ! ij = index_two ( i , j , wf % n_o ) rec_number = ij read ( unit_ljck , rec = rec_number , iostat = ioerror ) g_l_c ! g_l_c(l,b) = g_bjli ! !     - sum_l t_lk&#94;ac g_bjli = - sum_l t_ab_l(ac,l) g_l_c(l,b) -> ordered as ac, b ! w = zero ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & wf % n_v , & wf % n_o , & - one , & t_ab_l , & ( wf % n_v ) ** 2 , & g_l_c , & wf % n_o , & zero , & w , & ( wf % n_v ) ** 2 ) ! !     Add w(acb) to w_abc(abc) ! do b = 1 , wf % n_v do c = 1 , wf % n_v do a = 1 , wf % n_v ! acb = index_three ( a , c , b , wf % n_v , wf % n_v ) abc = index_three ( a , b , c , wf % n_v , wf % n_v ) ! w_abc ( abc , 1 ) = w_abc ( abc , 1 ) + w ( acb , 1 ) ! enddo enddo enddo ! !     Term 6. - sum_l t_lk&#94;bc g_ailj ! !     Note: g_l_c(l,b) = g_bjli !        => g_l_c(l,a) = g_ajli, switch i and j ! g_l_c = zero ! ji = index_two ( j , i , wf % n_o ) rec_number = ji read ( unit_ljck , rec = rec_number , iostat = ioerror ) g_l_c ! g_l_c(l,a) = g_ailj ! !     - sum_l t_lk&#94;bc g_ailj = - sum_l g_l_c(l,a) t_ab_l(bc,l) -> transposed, comes out a, bc ! call dgemm ( 'T' , 'T' , & wf % n_v , & ( wf % n_v ) ** 2 , & wf % n_o , & - one , & g_l_c , & wf % n_o , & t_ab_l , & ( wf % n_v ) ** 2 , & one , & w_abc , & wf % n_v ) ! !     Close integral file ljck ! close ( unit_ljck ) ! !     Divide by orbital energy difference (w_abc -> t_abc) ! e_ijk = wf % fock_diagonal ( i , 1 ) + wf % fock_diagonal ( j , 1 ) + wf % fock_diagonal ( k , 1 ) ! if ( i . eq . j . and . j . eq . k ) then ! w_abc = zero ! else ! do c = 1 , wf % n_v do b = 1 , wf % n_v do a = 1 , wf % n_v ! abc = index_three ( a , b , c , wf % n_v , wf % n_v ) ! if ( a . eq . b . and . b . eq . c ) then ! w_abc ( abc , 1 ) = zero ! else ! e_abc = - one / ( wf % fock_diagonal ( wf % n_o + a , 1 ) + & wf % fock_diagonal ( wf % n_o + b , 1 ) + & wf % fock_diagonal ( wf % n_o + c , 1 ) - e_ijk ) ! w_abc ( abc , 1 ) = e_abc * w_abc ( abc , 1 ) ! endif ! enddo enddo enddo endif ! !     Deallocations ! call wf % mem % dealloc ( t_ab_l , ( wf % n_v ) ** 2 , wf % n_o ) call wf % mem % dealloc ( g_l_c , wf % n_o , wf % n_v ) call wf % mem % dealloc ( w , ( wf % n_v ) ** 3 , 1 ) ! end subroutine calc_triples_cc3 ! ! module subroutine omega_cc3_a1_cc3 ( wf , t_abc , i , j , k ) !! !!    Omega A1 (CC3) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Calculates the A1 term, !! !!       sum_bc (t_ijk&#94;abc - t_ijk&#94;cba) L_jbkc, !! !!    for a given set of i, j, and k, and adds the contribution to !!    the singles projection vector (omega1). !! implicit none ! class ( cc3 ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 3 , 1 ) :: t_abc ! real ( dp ), dimension (:,:), allocatable :: g_b_c ! g_jbkc real ( dp ), dimension (:,:), allocatable :: L_bc ! L_jbkc = 2 g_jbkc - g_jckb ! real ( dp ), dimension (:,:), allocatable :: u_a_bc ! t_ijk&#94;abc - t_ijk&#94;cba ! integer ( i15 ) :: unit_jbkc = 0 integer ( i15 ) :: rec_number = 0 , ioerror = 0 ! integer ( i15 ), intent ( in ) :: i , j , k ! integer ( i15 ) :: b = 0 , c = 0 , a = 0 , abc = 0 , cba = 0 , bc = 0 ! !     Read the integrals g_jbkc, ordered as bc for a given j and k ! call wf % mem % alloc ( g_b_c , wf % n_v , wf % n_v ) g_b_c = zero ! call generate_unit_identifier ( unit_jbkc ) open ( unit = unit_jbkc , file = 'jbkc' , action = 'read' , status = 'old' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) ** 2 , iostat = ioerror ) ! rec_number = index_two ( k , j , wf % n_o ) read ( unit_jbkc , rec = rec_number , iostat = ioerror ) g_b_c ! !     Calculate L_bc(bc, 1) = L_jbkc = 2 g_b_c(b,c) - g_b_c(c,b) ! call wf % mem % alloc ( L_bc , ( wf % n_v ) ** 2 , 1 ) L_bc = zero ! do c = 1 , wf % n_v do b = 1 , wf % n_v ! bc = index_two ( b , c , wf % n_v ) L_bc ( bc , 1 ) = two * g_b_c ( b , c ) - g_b_c ( c , b ) ! enddo enddo ! !     Deallocate g_b_c ! call wf % mem % dealloc ( g_b_c , wf % n_v , wf % n_v ) ! !     Close jbkc file ! close ( unit_jbkc ) ! !     Form u_a_bc(a,bc) = t_abc(abc, 1) - t_abc(cba, 1) ! call wf % mem % alloc ( u_a_bc , wf % n_v , ( wf % n_v ) ** 2 ) u_a_bc = zero ! do c = 1 , wf % n_v do b = 1 , wf % n_v ! bc = index_two ( b , c , wf % n_v ) ! do a = 1 , wf % n_v ! abc = index_three ( a , b , c , wf % n_v , wf % n_v ) cba = index_three ( c , b , a , wf % n_v , wf % n_v ) ! u_a_bc ( a , bc ) = t_abc ( abc , 1 ) - t_abc ( cba , 1 ) ! enddo enddo enddo ! !     Calculate the A1 contribution, ! !        sum_bc (t_ijk&#94;abc - t_ijk&#94;cba) L_jbkc !                          = sum_bc u_a_bc(a,bc) L_bc(bc,1) ! call dgemm ( 'N' , 'N' , & wf % n_v , & 1 , & ( wf % n_v ) ** 2 , & one , & u_a_bc , & wf % n_v , & L_bc , & ( wf % n_v ) ** 2 , & one , & wf % omega1 ( 1 , i ), & wf % n_v ) ! !     Deallocations ! call wf % mem % dealloc ( u_a_bc , wf % n_v , ( wf % n_v ) ** 2 ) call wf % mem % dealloc ( L_bc , ( wf % n_v ) ** 2 , 1 ) ! end subroutine omega_cc3_a1_cc3 ! ! module subroutine omega_cc3_a2_cc3 ( wf , omega_ai_bj , t_abc , i , j , k ) !! !!    Omega A2 (CC3) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Calculates the A2 term, !! !!       sum_c (t_ijk&#94;abc - t_ijk&#94;cba) F_kc, !! !!    for a given set of i, j, and k, and adds the contribution to !!    the doubles projection vector (omega2), element ai_bj. !! implicit none ! class ( cc3 ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: omega_ai_bj real ( dp ), dimension (( wf % n_v ) ** 3 , 1 ) :: t_abc ! integer ( i15 ), intent ( in ) :: i , j , k ! real ( dp ), dimension (:,:), allocatable :: u_ab_c ! t_ijk&#94;abc - t_ijk&#94;cba ! real ( dp ), dimension (:,:), allocatable :: F_c ! F_kc ! real ( dp ), dimension (:,:), allocatable :: omega_ab ! sum_c u_ab_c * F_c ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , ab = 0 , abc = 0 , cba = 0 integer ( i15 ) :: ai = 0 , bj = 0 ! !     Set u_ab_c(ab,c) = t_ijk&#94;abc - t_ijk&#94;cba ! call wf % mem % alloc ( u_ab_c , ( wf % n_v ) ** 2 , wf % n_v ) u_ab_c = zero ! do c = 1 , wf % n_v do b = 1 , wf % n_v do a = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) ! abc = index_three ( a , b , c , wf % n_v , wf % n_v ) cba = index_three ( c , b , a , wf % n_v , wf % n_v ) ! u_ab_c ( ab , c ) = t_abc ( abc , 1 ) - t_abc ( cba , 1 ) ! enddo enddo enddo ! !     Set F_c(c, 1) = F_kc ! call wf % mem % alloc ( F_c , wf % n_v , 1 ) F_c = zero ! do c = 1 , wf % n_v ! F_c ( c , 1 ) = wf % fock_ia ( k , c ) ! enddo ! !     Allocate and compute the A2 contribution, ! !        sum_c (t_ijk&#94;abc - t_ijk&#94;cba) F_kc = sum_c u_ab_c(ab,c) F_c(c, 1) ! call wf % mem % alloc ( omega_ab , ( wf % n_v ) ** 2 , 1 ) omega_ab = zero ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & 1 , & wf % n_v , & one , & u_ab_c , & ( wf % n_v ) ** 2 , & F_c , & wf % n_v , & zero , & omega_ab , & ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( F_c , wf % n_v , 1 ) call wf % mem % dealloc ( u_ab_c , ( wf % n_v ) ** 2 , wf % n_v ) ! !     Add the contribution into the unpacked !     projection vector ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do b = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! omega_ai_bj ( ai , bj ) = omega_ai_bj ( ai , bj ) + omega_ab ( ab , 1 ) ! enddo enddo ! call wf % mem % dealloc ( omega_ab , ( wf % n_v ) ** 2 , 1 ) ! end subroutine omega_cc3_a2_cc3 ! ! module subroutine omega_cc3_b2_cc3 ( wf , omega_ai_bj , t_abc , i , j , k ) !! !!    Omega B2 (CC3) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Calculates the B2 term, !! !!       omega(al,bj) = - sum_c  (2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb) g_ilkc !!       omega(ai,dj) = + sum_bc (2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb) g_dbkc !! !!    for a given set of i, j, and k, and adds the contribution to !!    the doubles projection vector (omega2). !! implicit none ! class ( cc3 ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: omega_ai_bj real ( dp ), dimension (( wf % n_v ) ** 3 , 1 ) :: t_abc ! integer ( i15 ), intent ( in ) :: i , j , k ! integer ( i15 ) :: unit_ilkc = 0 , unit_dbkc = 0 integer ( i15 ) :: rec_number = 0 , ioerror = 0 ! real ( dp ), dimension (:,:), allocatable :: g_c_l ! g_ilkc ! real ( dp ), dimension (:,:), allocatable :: g_bc_d ! g_dbkc ! real ( dp ), dimension (:,:), allocatable :: v_abc ! (2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb) ! real ( dp ), dimension (:,:), allocatable :: omega_ab_l ! Holds omega(al,bj) real ( dp ), dimension (:,:), allocatable :: omega_a_d ! Holds omega(ai,dj) ! integer ( i15 ) :: abc = 0 , cba = 0 , acb = 0 , a = 0 , b = 0 , c = 0 integer ( i15 ) :: ab = 0 , al = 0 , bj = 0 , l = 0 , d = 0 , ai = 0 , dj = 0 ! !     Form v_abc(abc, 1) = 2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb ! call wf % mem % alloc ( v_abc , ( wf % n_v ) ** 3 , 1 ) v_abc = zero ! do c = 1 , wf % n_v do b = 1 , wf % n_v do a = 1 , wf % n_v ! abc = index_three ( a , b , c , wf % n_v , wf % n_v ) cba = index_three ( c , b , a , wf % n_v , wf % n_v ) acb = index_three ( a , c , b , wf % n_v , wf % n_v ) ! v_abc ( abc , 1 ) = two * t_abc ( abc , 1 ) - t_abc ( cba , 1 ) & - t_abc ( acb , 1 ) ! enddo enddo enddo ! !     Read in g_ilkc integrals, g_c_l(c,l) = g_ilkc ! call generate_unit_identifier ( unit_ilkc ) open ( unit = unit_ilkc , file = 'ilkc' , action = 'read' , status = 'old' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) * ( wf % n_o ), iostat = ioerror ) ! call wf % mem % alloc ( g_c_l , wf % n_v , wf % n_o ) g_c_l = zero ! rec_number = index_two ( i , k , wf % n_o ) read ( unit_ilkc , rec = rec_number , iostat = ioerror ) g_c_l ! close ( unit_ilkc ) ! !     Construct the first contribution ! call wf % mem % alloc ( omega_ab_l , ( wf % n_v ) ** 2 , wf % n_o ) omega_ab_l = zero ! !     - sum_c  (2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb) g_ilkc !     = - sum_c v_abc g_c_l -> comes out ab, l ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & wf % n_o , & wf % n_v , & - one , & v_abc , & ( wf % n_v ) ** 2 , & g_c_l , & wf % n_v , & zero , & omega_ab_l , & ( wf % n_v ) ** 2 ) ! !     Add the contribution to the projection vector ! do l = 1 , wf % n_o do b = 1 , wf % n_v do a = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) ! al = index_two ( a , l , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! omega_ai_bj ( al , bj ) = omega_ai_bj ( al , bj ) + omega_ab_l ( ab , l ) ! enddo enddo enddo ! call wf % mem % dealloc ( g_c_l , wf % n_v , wf % n_o ) ! !     Read the g_dbkc integrals, ordered as bcd, k, !     into g_bc_d, such that g_bc_d(bc, d) = g_dbkc ! call generate_unit_identifier ( unit_dbkc ) open ( unit = unit_dbkc , file = 'dbkc' , action = 'read' , status = 'old' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) ** 2 , iostat = ioerror ) ! call wf % mem % alloc ( g_bc_d , ( wf % n_v ) ** 2 , wf % n_v ) g_bc_d = zero ! do d = 1 , wf % n_v ! rec_number = index_two ( d , k , wf % n_v ) read ( unit_dbkc , rec = rec_number , iostat = ioerror ) ( g_bc_d ( l , d ), l = 1 , ( wf % n_v ) ** 2 ) ! enddo ! close ( unit_dbkc ) ! !     Calculate the second contribution, !     sum_bc (2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb) g_dbkc = sum_bc v_abc g_bc_d -> a,d ! call wf % mem % alloc ( omega_a_d , wf % n_v , wf % n_v ) omega_a_d = zero ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & ( wf % n_v ) ** 2 , & one , & v_abc , & wf % n_v , & g_bc_d , & ( wf % n_v ) ** 2 , & zero , & omega_a_d , & wf % n_v ) ! !     Add the second contribution to the omega vector ! do d = 1 , wf % n_v do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) dj = index_two ( d , j , wf % n_v ) ! omega_ai_bj ( ai , dj ) = omega_ai_bj ( ai , dj ) + omega_a_d ( a , d ) ! enddo enddo ! call wf % mem % dealloc ( g_bc_d , ( wf % n_v ) ** 2 , wf % n_v ) call wf % mem % dealloc ( omega_ab_l , ( wf % n_v ) ** 2 , wf % n_o ) call wf % mem % dealloc ( omega_a_d , wf % n_v , wf % n_v ) call wf % mem % dealloc ( v_abc , ( wf % n_v ) ** 3 , 1 ) ! end subroutine omega_cc3_b2_cc3 ! ! end submodule omega","tags":"","loc":"sourcefile/omega_submodule.f90~3.html","title":"omega_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ionized_state_submodule.f90~~EfferentGraph sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileionized_state_submodulef90EfferentGraph = svgPanZoom('#sourcefileionized_state_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules ionized_state Source Code ionized_state_submodule.F90 Source Code submodule ( ccsd_class ) ionized_state ! !! !!    Ionized state submodule(CCSD) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, October 2017 !! !!    Contains the following family of procedures of the CCS class: !! !! ! implicit none ! ! contains ! ! module subroutine ionization_residual_projection_ccsd ( wf , residual ) !! !!       Residual projection for CVS !!       Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( ccsd ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! integer ( i15 ) :: i = 0 , a = 0 , diffuse_mo = 0 , ai = 0 , mo = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 ! !        Find MO corresponding to super diffuse orbital ! !        Super diffuse AO is the last AO (for dalton integrals and HF this corresponds to !        the ghost atom being declared at the end of the MOLECULE.INP file). Must locate the MO !        with weight 1.0D0 on this AO. ! do mo = 1 , wf % n_mo ! i = index_two ( wf % n_ao , mo , wf % n_ao ) if ( abs ( wf % mo_coef ( i , 1 ) - 1.0D0 ) . lt . 1.0D-7 ) diffuse_mo = mo ! enddo ! !        Project out elements not corresponding to ionization ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! if ( a . ne . ( diffuse_mo - wf % n_o )) then ! ai = index_two ( a , i , wf % n_v ) residual ( ai , 1 ) = 0.0d0 ! endif enddo enddo ! do a = 1 , wf % n_v do b = 1 , wf % n_v do i = 1 , wf % n_o do j = 1 , wf % n_o ! if (. not .(( a . eq . ( diffuse_mo - wf % n_o ) ) . or . ( b . eq . ( diffuse_mo - wf % n_o ))) ) then ! bj = index_two ( b , j , wf % n_v ) aibj = index_packed ( ai , bj ) residual (( wf % n_o * wf % n_v ) + aibj , 1 ) = 0.0d0 ! endif ! enddo enddo ! enddo enddo ! end subroutine ionization_residual_projection_ccsd ! ! module subroutine ionization_rho_aibj_projection_ccsd ( wf , rho_aibj ) !! !!       Residual projection for CVS !!       Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( ccsd ) :: wf real ( dp ), dimension (:,:) :: rho_aibj ! integer ( i15 ) :: i = 0 , a = 0 , diffuse_mo = 0 , ai = 0 , mo = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 ! !        Find MO corresponding to super diffuse orbital ! !        Super diffuse AO is the last AO (for dalton integrals and HF this corresponds to !        the ghost atom being declared at the end of the MOLECULE.INP file). Must locate the MO !        with weight 1.0D0 on this AO. ! do mo = 1 , wf % n_mo ! i = index_two ( wf % n_ao , mo , wf % n_ao ) if ( abs ( wf % mo_coef ( i , 1 ) - 1.0D0 ) . lt . 1.0D-7 ) diffuse_mo = mo ! enddo ! !        Project out elements not corresponding to ionization do i = 1 , wf % n_o do a = 1 , wf % n_v do j = 1 , wf % n_o do b = 1 , wf % n_v ! if (( a . ne . ( diffuse_mo - wf % n_o ) ). and . ( b . ne . ( diffuse_mo - wf % n_o )) ) then ! bj = index_two ( b , j , wf % n_v ) ai = index_two ( a , i , wf % n_v ) ! if ( ai . ge . bj ) then ! aibj = index_packed ( ai , bj ) rho_aibj ( aibj , 1 ) = 0.0d0 ! endif ! endif ! enddo enddo ! enddo enddo ! end subroutine ionization_rho_aibj_projection_ccsd ! ! end submodule ionized_state","tags":"","loc":"sourcefile/ionized_state_submodule.f90.html","title":"ionized_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~jacobian_submodule.f90~3~~EfferentGraph sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilejacobian_submodulef903EfferentGraph = svgPanZoom('#sourcefilejacobian_submodulef903EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules jacobian Source Code jacobian_submodule.F90 Source Code submodule ( ccsd_class ) jacobian ! !! !!    Jacobian submodule (CCSD) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017 !! !!    Contains the following family of procedures of the CCS class: !! !!    jacobian_transformation: performs the transformation by the CCSD !!                             Jacobian matrix A, placing the result in the !!                             incoming vector. !!    jacobian_ccsd_x1:        adds the X1 term to the transformed singles vector; x = a, b, c, d !!    jacobian_ccsd_x2:        adds the X2 term to the transformed doubles vector; x = a, b, ..., k !! ! implicit none ! character ( len = 40 ) :: integral_type ! contains ! ! module subroutine jacobian_ccsd_transformation_ccsd ( wf , c_a_i , c_aibj ) !! !!    Jacobian transformation (CCSD) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Directs the transformation by the CCSD Jacobi matrix, !! !!       A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >, !! !!    where the basis employed for the brackets is biorthonormal. !!    The transformation is rho = A c, i.e., !! !!       rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck !!                  + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl). !! !!    On exit, c is overwritten by rho. That is, c_a_i = rho_a_i, !!    and c_aibj = rho_aibj. !! implicit none ! class ( ccsd ) :: wf ! !     Incoming vector c ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_t2am , 1 ) :: c_aibj ! c_aibj ! !     Local unpacked and reordered vectors ! real ( dp ), dimension (:,:), allocatable :: rho_a_i ! rho_ai   = (A c)_ai real ( dp ), dimension (:,:), allocatable :: rho_ai_bj ! rho_ai_bj = (A c)_aibj ! real ( dp ), dimension (:,:), allocatable :: c_ai_bj ! Unpacked c_aibj real ( dp ), dimension (:,:), allocatable :: c_ab_ij ! c_ai_bj, reordered ! real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_sym ! Symmetrized rho_ai_bj, temporary real ( dp ), dimension (:,:), allocatable :: rho_ab_ij ! rho_ai_bj, reordered ! !     Indices ! integer ( i15 ) :: a = 0 , ab = 0 , ai = 0 , b = 0 integer ( i15 ) :: bj = 0 , i = 0 , ij = 0 , j = 0 , aibj = 0 ! !     Timings ! real ( dp ) :: begin_timer , end_timer ! real ( dp ) :: ccsd_a1_time real ( dp ) :: ccsd_b1_time real ( dp ) :: ccsd_c1_time real ( dp ) :: ccsd_d1_time real ( dp ) :: ccs_a1_time real ( dp ) :: ccs_b1_time ! real ( dp ) :: ccsd_a2_time real ( dp ) :: ccsd_b2_time real ( dp ) :: ccsd_c2_time real ( dp ) :: ccsd_d2_time real ( dp ) :: ccsd_e2_time real ( dp ) :: ccsd_f2_time real ( dp ) :: ccsd_g2_time real ( dp ) :: ccsd_h2_time real ( dp ) :: ccsd_i2_time real ( dp ) :: ccsd_j2_time real ( dp ) :: ccsd_k2_time ! !     Allocate and zero the transformed vector (singles part) ! call wf % mem % alloc ( rho_a_i , wf % n_v , wf % n_o ) rho_a_i = zero ! !     :: CCS contributions to the singles c vector :: ! call cpu_time ( begin_timer ) call wf % jacobian_ccs_a1 ( rho_a_i , c_a_i ) call cpu_time ( end_timer ) ccs_a1_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccs_b1 ( rho_a_i , c_a_i ) call cpu_time ( end_timer ) ccs_b1_time = end_timer - begin_timer ! !     :: CCSD contributions to the transformed singles vector :: ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_a1 ( rho_a_i , c_a_i ) call cpu_time ( end_timer ) ccsd_a1_time = end_timer - begin_timer ! !     Allocate the incoming unpacked doubles vector ! call wf % mem % alloc ( c_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) c_ai_bj = zero ! call squareup ( c_aibj , c_ai_bj , ( wf % n_o ) * ( wf % n_v )) ! Pack out vector ! !     Scale the doubles vector by 1 + delta_ai,bj, i.e. !     redefine to c_ckdl = c_ckdl (1 + delta_ck,dl) ! do i = 1 , ( wf % n_o ) * ( wf % n_v ) ! c_ai_bj ( i , i ) = two * c_ai_bj ( i , i ) ! enddo ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_b1 ( rho_a_i , c_ai_bj ) call cpu_time ( end_timer ) ccsd_b1_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_c1 ( rho_a_i , c_ai_bj ) call cpu_time ( end_timer ) ccsd_c1_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_d1 ( rho_a_i , c_ai_bj ) call cpu_time ( end_timer ) ccsd_d1_time = end_timer - begin_timer ! !     :: CCSD contributions to the transformed doubles vector :: ! !     Allocate unpacked transformed vector ! call wf % mem % alloc ( rho_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) rho_ai_bj = zero ! !     Contributions from singles vector c ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_a2 ( rho_ai_bj , c_a_i ) call cpu_time ( end_timer ) ccsd_a2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_b2 ( rho_ai_bj , c_a_i ) call cpu_time ( end_timer ) ccsd_b2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_c2 ( rho_ai_bj , c_a_i ) call cpu_time ( end_timer ) ccsd_c2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_d2 ( rho_ai_bj , c_a_i ) call cpu_time ( end_timer ) ccsd_d2_time = end_timer - begin_timer ! !     Done with singles vector c; overwrite it with !     transformed vector for exit ! call dcopy (( wf % n_o ) * ( wf % n_v ), rho_a_i , 1 , c_a_i , 1 ) ! !     Contributions from doubles vector c ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_e2 ( rho_ai_bj , c_ai_bj ) call cpu_time ( end_timer ) ccsd_e2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_f2 ( rho_ai_bj , c_ai_bj ) call cpu_time ( end_timer ) ccsd_f2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_g2 ( rho_ai_bj , c_ai_bj ) call cpu_time ( end_timer ) ccsd_g2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_h2 ( rho_ai_bj , c_ai_bj ) call cpu_time ( end_timer ) ccsd_h2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_i2 ( rho_ai_bj , c_ai_bj ) call cpu_time ( end_timer ) ccsd_i2_time = end_timer - begin_timer ! !     Last two terms are already symmetric (J2 and K2). Perform the symmetrization !     rho_ai_bj = P_ij&#94;ab rho_ai_bj now, for convenience ! !     Allocate temporary symmetric transformed vector ! call wf % mem % alloc ( rho_ai_bj_sym , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) rho_ai_bj_sym = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! rho_ai_bj_sym ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj ( bj , ai ) ! enddo enddo enddo enddo ! rho_ai_bj = rho_ai_bj_sym ! !     Done with temporary vector; deallocate ! call wf % mem % dealloc ( rho_ai_bj_sym , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     In preparation for last two terms, reorder !     rho_ai_bj to rho_ab_ij, and c_ai_bj to c_ab_ij ! call wf % mem % alloc ( rho_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) call wf % mem % alloc ( c_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! rho_ab_ij = zero c_ab_ij = zero ! do j = 1 , wf % n_o do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ab = index_two ( a , b , wf % n_v ) ! c_ab_ij ( ab , ij ) = c_ai_bj ( ai , bj ) rho_ab_ij ( ab , ij ) = rho_ai_bj ( ai , bj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( c_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( rho_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_j2 ( rho_ab_ij , c_ab_ij ) call cpu_time ( end_timer ) ccsd_j2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % jacobian_ccsd_k2 ( rho_ab_ij , c_ab_ij ) call cpu_time ( end_timer ) ccsd_k2_time = end_timer - begin_timer ! !     Done with reordered doubles c; deallocate ! call wf % mem % dealloc ( c_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! !     Order rho_ab_ij back into rho_ai_bj & divide by !     the biorthonormal factor 1 + delta_ai,bj ! call wf % mem % alloc ( rho_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) rho_ai_bj = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do a = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) ai = index_two ( a , i , wf % n_v ) ! if ( a . eq . b . and . i . eq . j ) then ! rho_ai_bj ( ai , bj ) = half * rho_ab_ij ( ab , ij ) ! else ! rho_ai_bj ( ai , bj ) = rho_ab_ij ( ab , ij ) ! endif ! enddo enddo enddo enddo ! !     Done with reordered transformed vector; deallocate ! call wf % mem % dealloc ( rho_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! !     Overwrite the incoming doubles c vector & pack in ! c_aibj = zero call packin ( c_aibj , rho_ai_bj , ( wf % n_o ) * ( wf % n_v )) ! !     Remaining deallocations ! call wf % mem % dealloc ( rho_a_i , wf % n_v , wf % n_o ) call wf % mem % dealloc ( rho_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Print timings ! if ( wf % settings % print_level == 'developer' ) then ! write ( unit_output , '(t3,a/)' ) 'Breakdown of CCSD Jacobian timings:' ! write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCS  A1 (seconds):' , ccs_a1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCS  B1 (seconds):' , ccs_b1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD A1 (seconds):' , ccsd_a1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD B1 (seconds):' , ccsd_b1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD C1 (seconds):' , ccsd_c1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD D1 (seconds):' , ccsd_d1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD A2 (seconds):' , ccsd_a2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD B2 (seconds):' , ccsd_b2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD C2 (seconds):' , ccsd_c2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD D2 (seconds):' , ccsd_d2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD E2 (seconds):' , ccsd_e2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD F2 (seconds):' , ccsd_f2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD G2 (seconds):' , ccsd_g2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD H2 (seconds):' , ccsd_h2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD I2 (seconds):' , ccsd_i2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD J2 (seconds):' , ccsd_j2_time write ( unit_output , '(t3,a27,f14.8/)' ) 'Time in CCSD K2 (seconds):' , ccsd_k2_time ! flush ( unit_output ) ! endif ! end subroutine jacobian_ccsd_transformation_ccsd ! ! module subroutine jacobian_ccsd_a1_ccsd ( wf , rho_a_i , c_a_i ) !! !!    Jacobian CCSD A1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    rho_ai&#94;A1 = sum_ckdl L_lckd (u_li&#94;ca c_dk  - t_li&#94;cd c_ak - t_lk&#94;ad c_ci) !! !!    The term is added as rho_a_i(a,i) = rho_a_i(a,i) + rho_ai&#94;A1, !!    where c_a_i(a,i) = c_ai above. !! implicit none ! class ( ccsd ) :: wf ! !     Vectors sent to the routine ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! rho_ai ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: g_lc_kd ! g_lckd real ( dp ), dimension (:,:), allocatable :: L_lc_dk ! L_lckd reordered real ( dp ), dimension (:,:), allocatable :: L_lkd_c ! L_lckd ! !     Intermediates ! real ( dp ), dimension (:,:), allocatable :: X_lc real ( dp ), dimension (:,:), allocatable :: X_i_k real ( dp ), dimension (:,:), allocatable :: X_a_c ! !     Amplitudes ! real ( dp ), dimension (:,:), allocatable :: t_i_lcd ! t_li&#94;cd real ( dp ), dimension (:,:), allocatable :: t_a_lkd ! t_lk&#94;ad real ( dp ), dimension (:,:), allocatable :: u_ai_lc ! u_li&#94;ca reordered ! !     Indices ! integer ( i15 ) :: a = 0 , c = 0 , d = 0 , i = 0 , k = 0 , l = 0 integer ( i15 ) :: ai = 0 , al = 0 , dk = 0 , ci = 0 , cl = 0 , di = 0 integer ( i15 ) :: kc = 0 , kd = 0 , ld = 0 , lc = 0 integer ( i15 ) :: lkd = 0 , lcd = 0 , lad integer ( i15 ) :: cial = 0 , clai = 0 , cldi = 0 ! ! !     :: Term 1: sum_ckdl L_lckd u_li&#94;ca c_dk :: ! !     g_lc_kd = g_lckd ! call wf % mem % alloc ( g_lc_kd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_lc_kd ) ! call wf % mem % alloc ( L_lc_dk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) L_lc_dk = zero ! !     L_lc_dk = L_lckd = 2*g_lckd - g_ldkc = 2*g_lc_kd(lc,kd) - g_lc_kd(ld,kc) ! do k = 1 , wf % n_o do d = 1 , wf % n_v ! dk = index_two ( d , k , wf % n_v ) kd = index_two ( k , d , wf % n_o ) ! do c = 1 , wf % n_v ! kc = index_two ( k , c , wf % n_o ) ! do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) ld = index_two ( l , d , wf % n_o ) ! L_lc_dk ( lc , dk ) = two * g_lc_kd ( lc , kd ) - g_lc_kd ( ld , kc ) ! L_lckd ! enddo enddo enddo enddo ! !     Deallocate g_lc_kd ! call wf % mem % dealloc ( g_lc_kd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     X_lc = sum_kd L_lckd c_dk = sum_kd L_lc_dk c_dk ! call wf % mem % alloc ( X_lc , ( wf % n_o ) * ( wf % n_v ), 1 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & L_lc_dk , & ( wf % n_o ) * ( wf % n_v ), & c_a_i , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_lc , & ( wf % n_o ) * ( wf % n_v )) ! !     Form u_ai_lc = u_li&#94;ca = 2 * t_li&#94;ca - t_il&#94;ca = 2 * t2am(clai,1) - t2am(cial,1) ! call wf % initialize_amplitudes ! Allocate t amplitudes, then set them to zero call wf % read_double_amplitudes ! Read the converged amplitudes from disk ! call wf % mem % alloc ( u_ai_lc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) u_ai_lc = zero ! do c = 1 , wf % n_v do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) cl = index_two ( c , l , wf % n_v ) ! do i = 1 , wf % n_o ! ci = index_two ( c , i , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) al = index_two ( a , l , wf % n_v ) ! clai = index_packed ( cl , ai ) cial = index_packed ( ci , al ) ! u_ai_lc ( ai , lc ) = two * ( wf % t2am ( clai , 1 )) - wf % t2am ( cial , 1 ) ! enddo enddo enddo enddo ! !     rho_a_i =+ sum_lc u_ai_lc X_lc ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & 1 , & ( wf % n_v ) * ( wf % n_o ), & one , & u_ai_lc , & ( wf % n_v ) * ( wf % n_o ), & X_lc , & ( wf % n_v ) * ( wf % n_o ), & one , & rho_a_i , & ( wf % n_v ) * ( wf % n_o )) ! !     Deallocations (keep L_lc_dk = L_lckd) ! call wf % mem % dealloc ( u_ai_lc , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) call wf % mem % dealloc ( X_lc , ( wf % n_v ) * ( wf % n_o ), 1 ) ! ! !     :: Term 2. - sum_ckdl L_lckd t_li&#94;cd c_ak :: ! !     Reorder amplitudes to t_lcd_i = t_li&#94;cd ! call wf % mem % alloc ( t_i_lcd , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) t_i_lcd = zero ! do i = 1 , wf % n_o do d = 1 , wf % n_v ! di = index_two ( d , i , wf % n_v ) ! do c = 1 , wf % n_v do l = 1 , wf % n_o ! cl = index_two ( c , l , wf % n_v ) ! cldi = index_packed ( cl , di ) ! lcd = index_three ( l , c , d , wf % n_o , wf % n_v ) ! t_i_lcd ( i , lcd ) = wf % t2am ( cldi , 1 ) ! enddo enddo enddo enddo ! !     Done with doubles amplitudes: deallocate ! call wf % destruct_amplitudes ! !     Calculate X_i_k = sum_cdl L_lcd_k t_i_lcd ! call wf % mem % alloc ( X_i_k , wf % n_o , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & t_i_lcd , & ( wf % n_o ), & L_lc_dk , & ! L_lcd_k ( wf % n_o ) * ( wf % n_v ) ** 2 , & zero , & X_i_k , & wf % n_o ) ! !     Calculate rho_a_i =+ - sum_k c_a_i(a,k) X_i_k(i, k) ! call dgemm ( 'N' , 'T' , & wf % n_v , & wf % n_o , & wf % n_o , & - one , & c_a_i , & ! c_a_k wf % n_v , & X_i_k , & wf % n_o , & one , & rho_a_i , & wf % n_v ) ! !     Deallocations (keep L_lcd_k = L_lc,kd) ! call wf % mem % dealloc ( X_i_k , wf % n_o , wf % n_o ) ! !     :: Term 3: - sum_ckdl L_lckd t_lk&#94;ad c_ci :: ! !     Reorder to L_lkd_c = L_lckd = L_k_lcd ! call wf % mem % alloc ( L_lkd_c , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) L_lkd_c = zero ! do c = 1 , wf % n_v do d = 1 , wf % n_v do k = 1 , wf % n_o do l = 1 , wf % n_o ! lkd = index_three ( l , k , d , wf % n_o , wf % n_o ) lc = index_two ( l , c , wf % n_o ) dk = index_two ( d , k , wf % n_v ) ! L_lkd_c ( lkd , c ) = L_lc_dk ( lc , dk ) ! L_lckd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( L_lc_dk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Reorder amplitudes to t_a_lkd = t_lk&#94;ad ! call wf % mem % alloc ( t_a_lkd , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) t_a_lkd = zero ! do d = 1 , wf % n_v do k = 1 , wf % n_o ! do l = 1 , wf % n_o ! lkd = index_three ( l , k , d , wf % n_o , wf % n_o ) ! do a = 1 , wf % n_v ! lad = index_three ( l , a , d , wf % n_o , wf % n_v ) ! t_a_lkd ( a , lkd ) = t_i_lcd ( k , lad ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( t_i_lcd , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! !     Calculate X_a_c = sum_kdl t_a_lkd L_lkd_c ! call wf % mem % alloc ( X_a_c , wf % n_v , wf % n_v ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & t_a_lkd , & wf % n_v , & L_lkd_c , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & zero , & X_a_c , & wf % n_v ) ! call wf % mem % dealloc ( L_lkd_c , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) call wf % mem % dealloc ( t_a_lkd , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !     Calculate rho_a_i =+ - sum_c X_a_c(a,c) c_a_i(c,i) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & wf % n_v , & - one , & X_a_c , & wf % n_v , & c_a_i , & wf % n_v , & one , & rho_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_a_c , wf % n_v , wf % n_v ) ! end subroutine jacobian_ccsd_a1_ccsd ! ! module subroutine jacobian_ccsd_b1_ccsd ( wf , rho_a_i , c_ai_bj ) !! !!    Jacobian CCSD B1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    rho_ai&#94;B1 = sum_bj F_jb (2*c_ai_bj  -  c_aj_bi) !!              = sum_bj F_jb v_ai_jb !! !!    The term is added as rho_a_i(a,i) = rho_a_i(a,i) + rho_ai&#94;A1, !!    where c_a_i(a,i) = c_ai above. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_v )) :: c_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! rho_ai ! real ( dp ), dimension (:,:), allocatable :: v_ai_jb real ( dp ), dimension (:,:), allocatable :: F_bj ! integer ( i15 ) :: a = 0 , b = 0 integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: ai = 0 , aj = 0 , bi = 0 , jb = 0 , bj = 0 ! !     Construct v_ai_jb = 2*c_aibj - c_ajbi ! call wf % mem % alloc ( v_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) v_ai_jb = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) jb = index_two ( j , b , wf % n_o ) ! do i = 1 , wf % n_o ! bi = index_two ( b , i , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) aj = index_two ( a , j , wf % n_v ) ! v_ai_jb ( ai , jb ) = two * c_ai_bj ( ai , bj ) - c_ai_bj ( aj , bi ) ! enddo enddo enddo enddo ! !     sum_bj F_jb*v_ai_jb ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & v_ai_jb , & ( wf % n_o ) * ( wf % n_v ), & wf % fock_ia , & ! F_jb ( wf % n_o ) * ( wf % n_v ), & one , & rho_a_i , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( v_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_ccsd_b1_ccsd ! module subroutine jacobian_ccsd_c1_ccsd ( wf , rho_a_i , c_ai_bj ) !! !!    Jacobian CCSD C1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    rho_ai&#94;C1 = - sum_bjk L_jikb c_aj_bk !!              = - sum_bjk (2*g_jikb - g_kijb) c_aj_bk !! !!    The term is added as rho_a_i(a,i) = rho_a_i(a,i) + rho_ai&#94;A1, !!    where c_ai_bj(ai,bj) = c_aibj above. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_v )) :: c_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! rho_ai ! real ( dp ), dimension (:,:), allocatable :: g_ji_kb real ( dp ), dimension (:,:), allocatable :: L_jbk_i real ( dp ), dimension (:,:), allocatable :: c_a_jbk ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 integer ( i15 ) :: a = 0 , b = 0 ! integer ( i15 ) :: ji = 0 , ik = 0 , ki = 0 integer ( i15 ) :: jb = 0 , kb = 0 integer ( i15 ) :: aj = 0 , bk = 0 ! integer ( i15 ) :: jbk = 0 ! integer ( i15 ) :: ajbk = 0 ! !     Construct the integral g_ji_kb = sum_J L_ji_J * L_kb_J ! call wf % mem % alloc ( g_ji_kb , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_ji_kb ) ! !     Constructing L_jikb = 2*g_jikb - g_jbki ! call wf % mem % alloc ( L_jbk_i , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_o ) L_jbk_i = zero ! do b = 1 , wf % n_v do k = 1 , wf % n_o ! kb = index_two ( k , b , wf % n_o ) ! do j = 1 , wf % n_o ! jb = index_two ( j , b , wf % n_o ) jbk = index_three ( j , b , k , wf % n_o , wf % n_v ) ! do i = 1 , wf % n_o ! ji = index_two ( j , i , wf % n_o ) ki = index_two ( k , i , wf % n_o ) ! L_jbk_i ( jbk , i ) = two * g_ji_kb ( ji , kb ) - g_ji_kb ( ki , jb ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ji_kb , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     - sum_bjk L_jbk_i * c_a_jbk ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & ( wf % n_v ) * (( wf % n_o ) ** 2 ), & - one , & c_ai_bj , & ! c_aj_bk = c_a_jbk wf % n_v , & L_jbk_i , & ( wf % n_v ) * (( wf % n_o ) ** 2 ), & one , & rho_a_i , & wf % n_v ) ! call wf % mem % dealloc ( L_jbk_i , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_o ) ! end subroutine jacobian_ccsd_c1_ccsd ! ! ! module subroutine jacobian_ccsd_d1_ccsd ( wf , rho_a_i , c_bi_cj ) !! !!    Jacobian CCSD D1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    rho_ai&#94;D1 =  sum_bcj L_abjc c_bicj !! !!    The term is added as rho_a_i(a,i) = rho_a_i(a,i) + rho_ai&#94;A1, !!    where c_bi_cj(bi,cj) = c_bicj above. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_v )) :: c_bi_cj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! !     Variables for batching ! integer ( i15 ) :: required = 0 , available = 0 integer ( i15 ) :: batch_dimension = 0 , max_batch_length = 0 , n_batch = 0 integer ( i15 ) :: a_batch = 0 , a_first = 0 , a_last = 0 , a_length = 0 ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: g_ab_jc ! g_abjc real ( dp ), dimension (:,:), allocatable :: L_a_cjb ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: jb = 0 , jc = 0 , bi = 0 , cj = 0 integer ( i15 ) :: ca = 0 , ab = 0 , ac = 0 ! integer ( i15 ) :: cjb = 0 ! integer ( i15 ) :: bicj = 0 ! !     Prepare for batching over index a ! required = max ( 2 * ( wf % n_J ) * (( wf % n_v ) ** 2 ) + 2 * ( wf % n_J ) * ( wf % n_v ) * ( wf % n_o ), & ( wf % n_J ) * (( wf % n_v ) ** 2 ) + ( wf % n_J ) * ( wf % n_v ) * ( wf % n_o ) + (( wf % n_v ) ** 3 ) * ( wf % n_o ), & 2 * (( wf % n_v ) ** 3 ) * ( wf % n_o )) ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_first , a_last , a_batch , max_batch_length , batch_dimension ) a_length = a_last - a_first + 1 ! !        Form g_ab_jc = g_abjc ! call wf % mem % alloc ( g_ab_jc , a_length * ( wf % n_v ), ( wf % n_v ) * ( wf % n_o )) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , & g_ab_jc , & a_first , & a_last , & 1 , & wf % n_v , & 1 , & wf % n_o , & 1 , & wf % n_v ) ! !        Construct L_abjc ordered as L_a_cjb ! call wf % mem % alloc ( L_a_cjb , a_length , (( wf % n_v ) ** 2 ) * ( wf % n_o )) L_a_cjb = zero ! do b = 1 , wf % n_v do j = 1 , wf % n_o do c = 1 , wf % n_v ! cjb = index_three ( c , j , b , wf % n_v , wf % n_o ) ! jb = index_two ( j , b , wf % n_o ) jc = index_two ( j , c , wf % n_o ) ! do a = 1 , a_length ! ac = index_two ( a , c , a_length ) ab = index_two ( a , b , a_length ) ! L_a_cjb ( a , cjb ) = two * g_ab_jc ( ab , jc ) - g_ab_jc ( ac , jb ) ! enddo ! enddo enddo enddo ! call wf % mem % dealloc ( g_ab_jc , a_length * ( wf % n_v ), ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & a_length , & wf % n_o , & ( wf % n_o ) * (( wf % n_v ) ** 2 ), & one , & L_a_cjb , & a_length , & c_bi_cj , & ! c_cjb_i ( wf % n_o ) * (( wf % n_v ) ** 2 ), & one , & rho_a_i ( a_first , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( L_a_cjb , a_length , (( wf % n_v ) ** 2 ) * ( wf % n_o )) ! enddo ! End batching over a ! end subroutine jacobian_ccsd_d1_ccsd ! ! module subroutine jacobian_ccsd_a2_ccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD A2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    rho_ai_bj&#94;A2 = sum_c g_aibc c_cj - sum_k g_aikj c_bk !! !!    The term is added as rho_ai_bj(ai,bj) = rho_ai_bj(ai,bj) + rho_ai_bj&#94;A2, !!    where c_a_i(a,i) = c_ai above. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj ! ! real ( dp ), dimension (:,:), allocatable :: g_ai_kj ! g_aikj real ( dp ), dimension (:,:), allocatable :: g_k_aij ! g_aikj reordered real ( dp ), dimension (:,:), allocatable :: g_ai_bc ! g_aibc, batching over b real ( dp ), dimension (:,:), allocatable :: g_bc_ai ! g_aibc = g_bcai, batching over b ! real ( dp ), dimension (:,:), allocatable :: rho_b_aij ! rho_ai_bj, term 1 (see below) real ( dp ), dimension (:,:), allocatable :: rho_aib_j ! rho_ai_bj, term 2 (batching over b) ! integer ( i15 ) :: a = 0 , ai = 0 , aij = 0 , b = 0 , bj = 0 , i = 0 , j = 0 integer ( i15 ) :: k = 0 , kj = 0 , c = 0 , cb = 0 , aib = 0 , bc = 0 ! logical :: reorder ! real ( dp ) :: begin_reorder real ( dp ) :: end_reorder ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , batch_dimension = 0 integer ( i15 ) :: n_batch = 0 , b_begin = 0 , b_end = 0 , b_batch = 0 , batch_length = 0 ! integer ( i15 ) :: aib_offset = 0 ! ! !     :: Term 1. - sum_k g_aikj c_bk :: ! !     Calculate g_ai_kj ! call wf % mem % alloc ( g_ai_kj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) ! integral_type = 'electronic_repulsion' call wf % get_vo_oo ( integral_type , g_ai_kj ) ! !     Reorder to g_k_aij = g_aikj = g_ai_kj ! call wf % mem % alloc ( g_k_aij , wf % n_o , ( wf % n_v ) * ( wf % n_o ) ** 2 ) g_k_aij = zero ! do j = 1 , wf % n_o do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! do k = 1 , wf % n_o ! kj = index_two ( k , j , wf % n_o ) ! g_k_aij ( k , aij ) = g_ai_kj ( ai , kj ) ! g_aikj ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ai_kj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) ! !     Calculate rho_b_aij = - sum_k c_bk g_aikj = - sum_k c_a_i(b, k) g_k_aij(k, aij) ! call wf % mem % alloc ( rho_b_aij , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_o , & - one , & c_a_i , & wf % n_v , & g_k_aij , & wf % n_o , & zero , & rho_b_aij , & wf % n_v ) ! call wf % mem % dealloc ( g_k_aij , wf % n_o , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !     Add rho_b_aij to rho_ai_bj ! do j = 1 , wf % n_o do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_b_aij ( b , aij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_b_aij , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! ! !     :: Term 2. rho_ai_bj =+ sum_c g_aibc c_cj :: ! !     We do the matrix multiplication as g_aib_c c_cj, !     batching over the b index. ! call wf % mem % alloc ( rho_aib_j , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! rho_ai_bj formed in batch rho_aib_j = zero ! !     We hold L_bc&#94;J and g_aibc in two orderings. The construction of L_bc&#94;J !     requires 2*n_v*n_o*n_J + n_J*n_v**2 extra memory. ! required = max ( 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ) + & 2 * ( wf % n_J ) * ( wf % n_v ) ** 2 , & ! Constr of L_bc&#94;J ( wf % n_J ) * ( wf % n_v ) ** 2 + & ( wf % n_o ) * ( wf % n_v ) ** 3 ) ! Holding L_bc&#94;J and g_aibc ! required = 4 * required ! Words ! available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index b max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! do b_batch = 1 , n_batch ! !        Get batching limits ! call batch_limits ( b_begin , b_end , b_batch , max_batch_length , batch_dimension ) batch_length = b_end - b_begin + 1 ! call wf % mem % alloc ( g_ai_bc , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * batch_length ) ! integral_type = 'electronic_repulsion' call wf % get_vo_vv ( integral_type , & g_ai_bc , & 1 , & wf % n_v , & 1 , & wf % n_o , & b_begin , & b_end , & 1 , & wf % n_v ) ! !        Calculate the contribution to rho_aib_j = sum_c g_aib_c c_cj ! aib_offset = index_three ( 1 , 1 , b_begin , wf % n_v , wf % n_o ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ) * batch_length , & wf % n_o , & wf % n_v , & one , & g_ai_bc , & ( wf % n_v ) * ( wf % n_o ) * batch_length , & c_a_i , & wf % n_v , & one , & rho_aib_j ( aib_offset , 1 ), & ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( g_ai_bc , ( wf % n_v ) * ( wf % n_o ), wf % n_v * batch_length ) ! enddo ! End of batches over b ! !     Now that rho_aib_j has been made in batches, add it to rho_ai_bj ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aib = index_three ( a , i , b , wf % n_v , wf % n_o ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aib_j ( aib , j ) ! enddo enddo enddo enddo ! !     Deallocations ! call wf % mem % dealloc ( rho_aib_j , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! end subroutine jacobian_ccsd_a2_ccsd ! ! module subroutine jacobian_ccsd_b2_ccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD B2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    rho_ai_bj&#94;B2 = - sum_kc (F_kc t_ij&#94;ac c_bk + F_kc t_ik&#94;ab c_cj) !! !!    The term is added as rho_ai_bj(ai,bj) = rho_ai_bj(ai,bj) + rho_ai_bj&#94;B2, !!    where c_a_i(a,i) = c_ai above. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj ! real ( dp ), dimension (:,:), allocatable :: t_c_aij ! t_ij&#94;ac real ( dp ), dimension (:,:), allocatable :: t_aib_k ! t_ik&#94;ab ! real ( dp ), dimension (:,:), allocatable :: X_k_aij ! An intermediate real ( dp ), dimension (:,:), allocatable :: X_k_j ! An intermediate ! real ( dp ), dimension (:,:), allocatable :: rho_b_aij ! rho_ai_bj, unordered, term 1 real ( dp ), dimension (:,:), allocatable :: rho_aib_j ! rho_ai_bj, unordered, term 2 ! integer ( i15 ) :: a = 0 , c = 0 , i = 0 , j = 0 , b = 0 , k = 0 integer ( i15 ) :: ai = 0 , cj = 0 , aicj = 0 , aij = 0 , bj = 0 integer ( i15 ) :: bk = 0 , aibk = 0 , aib = 0 ! ! !     :: Term 1. - sum_kc F_kc t_ij&#94;ac c_bk :: ! !     Read the amplitudes from disk ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! !     Order the amplitudes as t_c_aij = t_ij&#94;ac ! call wf % mem % alloc ( t_c_aij , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! do j = 1 , wf % n_o do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! do c = 1 , wf % n_v ! cj = index_two ( c , j , wf % n_v ) ! aicj = index_packed ( ai , cj ) ! t_c_aij ( c , aij ) = wf % t2am ( aicj , 1 ) ! enddo enddo enddo enddo ! !     Form the intermediate X_k_aij = sum_c F_k_c t_c_aij ! call wf % mem % alloc ( X_k_aij , wf % n_o , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_v , & one , & wf % fock_ia , & wf % n_o , & t_c_aij , & wf % n_v , & zero , & X_k_aij , & wf % n_o ) ! call wf % mem % dealloc ( t_c_aij , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !     Form rho_b_aij = sum_k c_a_i(b,k) X_k_aij(k,aij) ! call wf % mem % alloc ( rho_b_aij , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_o , & - one , & c_a_i , & wf % n_v , & X_k_aij , & wf % n_o , & zero , & rho_b_aij , & wf % n_v ) ! call wf % mem % dealloc ( X_k_aij , wf % n_o , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !     Add rho_b_aij to rho_ai_bj ! do j = 1 , wf % n_o do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_b_aij ( b , aij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_b_aij , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! ! !     :: Term 2. - sum_kc F_kc t_ik&#94;ab c_cj :: ! !     Form X_k_j = sum_c F_kc c_cj = sum_c fock_ia(k,c) c_a_i(c,j) ! call wf % mem % alloc ( X_k_j , wf % n_o , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & wf % n_v , & one , & wf % fock_ia , & wf % n_o , & c_a_i , & wf % n_v , & zero , & X_k_j , & wf % n_o ) ! !     Order the amplitudes as t_aib_k = t_ik&#94;ab ! call wf % mem % alloc ( t_aib_k , (( wf % n_v ) ** 2 ) * ( wf % n_o ), wf % n_o ) t_aib_k = zero ! do k = 1 , wf % n_o do b = 1 , wf % n_v ! bk = index_two ( b , k , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aib = index_three ( a , i , b , wf % n_v , wf % n_o ) ! aibk = index_packed ( ai , bk ) ! t_aib_k ( aib , k ) = wf % t2am ( aibk , 1 ) ! enddo enddo enddo enddo ! !     Deallocate doubles amplitudes ! call wf % destruct_amplitudes ! !     Form rho_aib_j = - sum_k t_aib_k X_k_j !     (Interpret rho_ai_bj as rho_aib_j) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & wf % n_o , & wf % n_o , & - one , & t_aib_k , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & X_k_j , & wf % n_o , & one , & rho_ai_bj , & ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( X_k_j , wf % n_o , wf % n_o ) call wf % mem % dealloc ( t_aib_k , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! end subroutine jacobian_ccsd_b2_ccsd ! ! module subroutine jacobian_ccsd_c2_ccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD C2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    rho_ai_bj&#94;C2 = sum_kcl g_ljkc (t_ki&#94;ac c_bl + t_li&#94;bc c_ak + t_lk&#94;ba c_ci) !!                 - sum_kcl L_ljkc (t_il&#94;ab c_ck + t_ik&#94;ac c_bl) !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj ! real ( dp ), dimension (:,:), allocatable :: g_lj_kc ! g_ljkc real ( dp ), dimension (:,:), allocatable :: g_kj_lc ! g_ljkc real ( dp ), dimension (:,:), allocatable :: L_lj_ck ! L_ljkc ! real ( dp ), dimension (:,:), allocatable :: X_lj_ai ! An intermediate, term 1 real ( dp ), dimension (:,:), allocatable :: X_kj_bi ! An intermediate, term 2 real ( dp ), dimension (:,:), allocatable :: X_kjl_i ! An intermediate, term 3 real ( dp ), dimension (:,:), allocatable :: X_kl_ij ! X_kjl_i reordered real ( dp ), dimension (:,:), allocatable :: X_lj ! An intermediate, term 4 real ( dp ), dimension (:,:), allocatable :: Y_lj_ai ! An intermediate, term 5 ! real ( dp ), dimension (:,:), allocatable :: t_kc_ai ! t_ki&#94;ac real ( dp ), dimension (:,:), allocatable :: t_lc_bi ! t_li&#94;bc real ( dp ), dimension (:,:), allocatable :: t_ba_kl ! t_lk&#94;ba real ( dp ), dimension (:,:), allocatable :: t_aib_l ! t_il&#94;ab real ( dp ), dimension (:,:), allocatable :: t_ck_ai ! t_ik&#94;ac ! real ( dp ), dimension (:,:), allocatable :: rho_b_jai ! rho_ai_bj, term 1 & 5 real ( dp ), dimension (:,:), allocatable :: rho_a_jbi ! rho_ai_bj, term 2 real ( dp ), dimension (:,:), allocatable :: rho_ba_ij ! rho_ai_bj, term 3 ! integer ( i15 ) :: ci = 0 , i = 0 , k = 0 , kc = 0 , c = 0 , ak = 0 , ai = 0 , akci = 0 integer ( i15 ) :: a = 0 , j = 0 , b = 0 , bj = 0 , jai = 0 , kj = 0 , jbi = 0 , l = 0 , lc = 0 integer ( i15 ) :: lj = 0 , blci = 0 , bl = 0 , bi = 0 , ij = 0 , kjl = 0 , kl = 0 , ba = 0 integer ( i15 ) :: blak = 0 , jk = 0 , ck = 0 , aib = 0 , aibl = 0 ! ! !     :: Term 1. sum_kcl g_ljkc t_ki&#94;ac c_bl :: ! !     Form g_lj_kc = g_ljkc ! call wf % mem % alloc ( g_lj_kc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_lj_kc ) ! !     Read the amplitudes from disk ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! !     Order as t_kc_ai = t_ki&#94;ac ! call wf % mem % alloc ( t_kc_ai , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_kc_ai = zero ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do c = 1 , wf % n_v ! ci = index_two ( c , i , wf % n_v ) ! do k = 1 , wf % n_o ! ak = index_two ( a , k , wf % n_v ) kc = index_two ( k , c , wf % n_o ) ! akci = index_packed ( ak , ci ) ! t_kc_ai ( kc , ai ) = wf % t2am ( akci , 1 ) ! t_ki&#94;ac ! enddo enddo enddo enddo ! !     Form X_lj_ai = sum_ck g_lj_kc t_kc_ai ! call wf % mem % alloc ( X_lj_ai , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & g_lj_kc , & ( wf % n_o ) ** 2 , & t_kc_ai , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_lj_ai , & ( wf % n_o ) ** 2 ) ! ! !     Calculate rho_b_jai = sum_l c_bl X_lj_ai !     (Interpret the X array as an X_l_jai object in the matrix multiplication) ! call wf % mem % alloc ( rho_b_jai , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_o , & one , & c_a_i , & wf % n_v , & X_lj_ai , & ! \"X_l_jai\" wf % n_o , & zero , & rho_b_jai , & wf % n_v ) ! call wf % mem % dealloc ( X_lj_ai , ( wf % n_o ) ** 2 , ( wf % n_v ) * ( wf % n_o )) ! !     Add rho_b_jai to rho_ai_bj ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o ! jai = index_three ( j , a , i , wf % n_o , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_b_jai ( b , jai ) ! enddo enddo enddo enddo ! !     Final deallocations for term 1 (keep g_lj_kc for later use) ! call wf % mem % dealloc ( rho_b_jai , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !     :: Term 2. sum_kcl g_ljkc t_li&#94;bc c_ak :: ! !     Reorder to g_kj_lc = g_lj_kc = g_ljkc ! call wf % mem % alloc ( g_kj_lc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) g_kj_lc = zero ! do c = 1 , wf % n_v do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) ! do j = 1 , wf % n_o ! lj = index_two ( l , j , wf % n_o ) ! do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) kj = index_two ( k , j , wf % n_o ) ! g_kj_lc ( kj , lc ) = g_lj_kc ( lj , kc ) ! g_ljkc ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_lj_kc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Form the intermediate X_kj_bi = sum_lc g_kj_lc t_lc_bi ! call wf % mem % alloc ( X_kj_bi , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & g_kj_lc , & ( wf % n_o ) ** 2 , & t_kc_ai , & ! t_lc_bi ( wf % n_o ) * ( wf % n_v ), & zero , & X_kj_bi , & ( wf % n_o ) ** 2 ) ! call wf % mem % dealloc ( t_kc_ai , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * ( wf % n_o )) ! !     Calculate rho_a_jbi = sum_k c_ak X_kj_bi ! call wf % mem % alloc ( rho_a_jbi , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_o , & one , & c_a_i , & wf % n_v , & X_kj_bi , & ! \"X_k_jbi\" wf % n_o , & zero , & rho_a_jbi , & wf % n_v ) ! call wf % mem % dealloc ( X_kj_bi , ( wf % n_o ) ** 2 , ( wf % n_v ) * ( wf % n_o )) ! !     Add rho_a_jbi to rho_ai_bj ! do i = 1 , wf % n_o do b = 1 , wf % n_v do j = 1 , wf % n_o ! jbi = index_three ( j , b , i , wf % n_o , wf % n_v ) ! bj = index_two ( b , j , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_a_jbi ( a , jbi ) ! enddo enddo enddo enddo ! !     Deallocations for term 2 (keep g_kj_lc = g_ljkc) ! call wf % mem % dealloc ( rho_a_jbi , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !     :: Term 3. sum_kcl g_ljkc t_lk&#94;ba c_ci :: ! !     Form the intermediate X_kjl_i = sum_c g_ljkc c_ci = sum_c g_kj_lc c_c_i ! !     Note: interpret g_kj_lc as g_kjl_c in matrix multiplication. ! call wf % mem % alloc ( X_kjl_i , ( wf % n_o ) ** 3 , wf % n_o ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 3 , & wf % n_o , & wf % n_v , & one , & g_kj_lc , & ! \"g_kjl_c\" ( wf % n_o ) ** 3 , & c_a_i , & wf % n_v , & zero , & X_kjl_i , & ( wf % n_o ) ** 3 ) ! !     Reorder to X_kl_ij = X_kjl_i ! call wf % mem % alloc ( X_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) X_kl_ij = zero ! do j = 1 , wf % n_o do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do l = 1 , wf % n_o do k = 1 , wf % n_o ! kl = index_two ( k , l , wf % n_o ) ! kjl = index_three ( k , j , l , wf % n_o , wf % n_o ) ! X_kl_ij ( kl , ij ) = X_kjl_i ( kjl , i ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( X_kjl_i , ( wf % n_o ) ** 3 , wf % n_o ) ! !     Order amplitudes as t_kl_ba = t_lk&#94;ba ! call wf % mem % alloc ( t_ba_kl , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) t_ba_kl = zero ! do a = 1 , wf % n_v do b = 1 , wf % n_v ! ba = index_two ( b , a , wf % n_v ) ! do l = 1 , wf % n_o ! bl = index_two ( b , l , wf % n_v ) ! do k = 1 , wf % n_o ! ak = index_two ( a , k , wf % n_v ) kl = index_two ( k , l , wf % n_o ) ! blak = index_packed ( bl , ak ) ! t_ba_kl ( ba , kl ) = wf % t2am ( blak , 1 ) ! t_lk&#94;ba ! enddo enddo enddo enddo ! !     Calculate rho_ba_ij = sum_kcl g_ljkc t_lk&#94;ba c_ci !                         = sum kl ( sum_c g_ljkc c_ci ) t_lk&#94;ba !                         = sum_kl t_ba_kl X_kl_ij ! call wf % mem % alloc ( rho_ba_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & one , & t_ba_kl , & ( wf % n_v ) ** 2 , & X_kl_ij , & ( wf % n_o ) ** 2 , & zero , & rho_ba_ij , & ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( t_ba_kl , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( X_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! !     Add rho_ba_ij into rho_ai_bj ! do j = 1 , wf % n_o do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do b = 1 , wf % n_v ! ba = index_two ( b , a , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ba_ij ( ba , ij ) ! enddo enddo enddo enddo ! !     Deallocations for term 3 (keep g_kj_lc = g_ljkc) ! call wf % mem % dealloc ( rho_ba_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! ! !     :: Term 4. - sum_kcl L_ljkc t_il&#94;ab c_ck :: ! !     Form L_lj_ck = L_ljkc = 2 * g_ljkc - g_lckj = 2 * g_ljkc - g_kjlc = g_kj_lc(kj,lc) - g_kj_lc(lj,kc) ! call wf % mem % alloc ( L_lj_ck , ( wf % n_o ) ** 2 , ( wf % n_v ) * ( wf % n_o )) ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) kc = index_two ( k , c , wf % n_o ) ! do j = 1 , wf % n_o ! kj = index_two ( k , j , wf % n_o ) ! do l = 1 , wf % n_o ! lj = index_two ( l , j , wf % n_o ) lc = index_two ( l , c , wf % n_o ) ! L_lj_ck ( lj , ck ) = two * g_kj_lc ( kj , lc ) - g_kj_lc ( lj , kc ) ! L_ljkc ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kj_lc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Calculate the intermediate X_lj = sum_ck L_lj_ck c_ck ! call wf % mem % alloc ( X_lj , ( wf % n_o ) ** 2 , 1 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & L_lj_ck , & ( wf % n_o ) ** 2 , & c_a_i , & ! Interpret as \"c_ck\" ( wf % n_o ) * ( wf % n_v ), & zero , & X_lj , & ( wf % n_o ) ** 2 ) ! !     Order the amplitudes as t_aib_l = t_il&#94;ab ! call wf % mem % alloc ( t_aib_l , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) t_aib_l = zero ! do l = 1 , wf % n_o do b = 1 , wf % n_v ! bl = index_two ( b , l , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aib = index_three ( a , i , b , wf % n_v , wf % n_o ) ! aibl = index_packed ( ai , bl ) ! t_aib_l ( aib , l ) = wf % t2am ( aibl , 1 ) ! t_il&#94;ab ! enddo enddo enddo enddo ! !     Form rho_ai_bj =+ - sum_l t_il&#94;ab X_lj = - sum_l t_aib_l X_lj ! !     Note: interpret rho_ai_bj as rho_aib_j in the !           matrix multiplication, and X_lj as X_l_j) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & wf % n_o , & wf % n_o , & - one , & t_aib_l , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & X_lj , & ! \"X_l_j\" wf % n_o , & one , & rho_ai_bj , & ! \"rho_aib_j\" ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( t_aib_l , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) call wf % mem % dealloc ( X_lj , ( wf % n_o ) ** 2 , 1 ) ! !     :: Term 5. - sum_kcl L_ljkc t_ik&#94;ac c_bl :: ! !     Square up the amplitudes, t_ck_ai(ck, ai) = t_ki&#94;ca = t_ik&#94;ac ! call wf % mem % alloc ( t_ck_ai , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_ck_ai = zero ! call squareup ( wf % t2am , t_ck_ai , ( wf % n_o ) * ( wf % n_v )) ! !     Form the intermediate Y_lj_ai = sum_kc L_ljkc t_ik&#94;ac = sum_kc L_lj_ck t_ck_ai ! call wf % mem % alloc ( Y_lj_ai , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & L_lj_ck , & ( wf % n_o ) ** 2 , & t_ck_ai , & ( wf % n_o ) * ( wf % n_v ), & zero , & Y_lj_ai , & ( wf % n_o ) ** 2 ) ! call wf % mem % dealloc ( t_ck_ai , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Calculate rho_b_jai =+ - sum_l c_bl Y_lj_ai ! !     Note: interpret Y_lj_ai as Y_l_jai in the matrix multiplication ! call wf % mem % alloc ( rho_b_jai , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_o , & - one , & c_a_i , & wf % n_v , & Y_lj_ai , & ! \"Y_l_jai\" wf % n_o , & zero , & rho_b_jai , & wf % n_v ) ! !     Add rho_b_jai to rho_ai_bj ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o ! jai = index_three ( j , a , i , wf % n_o , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_b_jai ( b , jai ) ! enddo enddo enddo enddo ! !     Deallocations and cleanup ! call wf % mem % dealloc ( Y_lj_ai , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( L_lj_ck , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( rho_b_jai , ( wf % n_v ), ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call wf % destruct_amplitudes ! end subroutine jacobian_ccsd_c2_ccsd ! ! module subroutine jacobian_ccsd_d2_ccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD D2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    rho_ai_bj&#94;D2 = - sum_kcd g_kcbd (t_ij&#94;cd c_ak + t_kj&#94;ad c_ci + t_ik&#94;ca c_dj) !!                       + sum_kcd L_kcbd (t_ik&#94;ac c_dj + t_ij&#94;ad c_ck) !! !!    Note: the code is structured so that we batch over the index b, !!          where the integrals are made as g_kc_db = g_kcbd and held !!          in some ordering or other throughout a given batch (i.e., !!          all five terms are constructed gradually in the batches). !! !!    The term is added as rho_ai_bj(ai,bj) = rho_ai_bj(ai,bj) + rho_ai_bj&#94;D2, !!    where c_a_i(a,i) = c_ai above. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj ! real ( dp ), dimension (:,:), allocatable :: g_bd_kc ! g_kcbd real ( dp ), dimension (:,:), allocatable :: g_cd_kb ! g_kcbd reordered real ( dp ), dimension (:,:), allocatable :: g_ckb_d ! g_kcbd reordered real ( dp ), dimension (:,:), allocatable :: L_ckb_d ! L_kcbd = 2 g_kcbd - g-kdbc ! real ( dp ), dimension (:,:), allocatable :: t_ij_cd ! t_ij&#94;cd real ( dp ), dimension (:,:), allocatable :: t_dk_aj ! t_kj&#94;ad real ( dp ), dimension (:,:), allocatable :: t_ai_ck ! t_ik&#94;ca real ( dp ), dimension (:,:), allocatable :: t_d_aij ! t_ij&#94;ad ! real ( dp ), dimension (:,:), allocatable :: X_ij_kb ! An intermediate, term 1 real ( dp ), dimension (:,:), allocatable :: X_k_ijb ! The above intermediate, reordered real ( dp ), dimension (:,:), allocatable :: X_i_dkb ! An intermediate, term 2 real ( dp ), dimension (:,:), allocatable :: X_ib_dk ! The above intermediate, reordered real ( dp ), dimension (:,:), allocatable :: X_ckb_j ! An intermediate, term 3 real ( dp ), dimension (:,:), allocatable :: Y_ckb_j ! An intermediate, term 4 real ( dp ), dimension (:,:), allocatable :: X_bd ! An intermediate, term 5 ! real ( dp ), dimension (:,:), allocatable :: rho_a_ijb ! rho_ai_bj, batching over b real ( dp ), dimension (:,:), allocatable :: rho_ib_aj ! rho_ai_bj, batching over b real ( dp ), dimension (:,:), allocatable :: rho_aib_j ! rho_ai_bj, batching over b real ( dp ), dimension (:,:), allocatable :: rho_b_aij ! rho_ai_bj, batching over b ! logical :: reorder ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , batch_dimension = 0 integer ( i15 ) :: n_batch = 0 , b_begin = 0 , b_end = 0 , b_batch = 0 , batch_length = 0 ! !     Indices ! integer ( i15 ) :: b = 0 , c = 0 , cd = 0 , ci = 0 , dj = 0 , cidj = 0 , d = 0 , db = 0 , bd = 0 integer ( i15 ) :: k = 0 , j = 0 , kb = 0 , kc = 0 , i = 0 , ij = 0 , ijb = 0 integer ( i15 ) :: a = 0 , ai = 0 , bj = 0 , ib = 0 , dkb = 0 , dk = 0 , akdj = 0 , ak = 0 integer ( i15 ) :: aj = 0 , ck = 0 , ckb = 0 , ciak = 0 , aib = 0 , aidj = 0 , aij = 0 ! !     Read amplitudes from disk ! call wf % initialize_amplitudes ! Move into batching loop call wf % read_double_amplitudes ! !     Determine batch size, etc. !     (Redo estimate once loop is done) ! required = max ( 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ) + & 2 * ( wf % n_J ) * ( wf % n_v ) ** 2 , & ! Constr of L_bc&#94;J ( wf % n_J ) * ( wf % n_v ) ** 2 + & ( wf % n_o ) * ( wf % n_v ) ** 3 ) ! Holding L_bc&#94;J and g_aibc ! required = 4 * required ! Words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index b max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! do b_batch = 1 , n_batch ! !        Get batching limits ! call batch_limits ( b_begin , b_end , b_batch , max_batch_length , batch_dimension ) batch_length = b_end - b_begin + 1 ! !        :: Term 1. - sum_kcd g_kcbd t_ij&#94;cd c_ak :: ! !        Form g_kc_db = g_kcbd ! call wf % mem % alloc ( g_bd_kc , ( wf % n_v ) * batch_length , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , g_bd_kc , b_begin , b_end , 1 , wf % n_v , 1 , wf % n_o , 1 , wf % n_v ) ! !        Reorder to g_cd_kb = g_kc_db = g_kcbd ! call wf % mem % alloc ( g_cd_kb , ( wf % n_v ) ** 2 , ( wf % n_o ) * batch_length ) ! do b = 1 , batch_length do k = 1 , wf % n_o ! kb = index_two ( k , b , wf % n_o ) ! do d = 1 , wf % n_v ! bd = index_two ( b , d , batch_length ) ! do c = 1 , wf % n_v ! kc = index_two ( k , c , wf % n_o ) cd = index_two ( c , d , wf % n_v ) ! g_cd_kb ( cd , kb ) = g_bd_kc ( bd , kc ) ! g_kcbd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_bd_kc , ( wf % n_v ) * batch_length , ( wf % n_o ) * ( wf % n_v )) ! !        Order amplitudes as t_ij_cd = t_ij&#94;cd ! call wf % mem % alloc ( t_ij_cd , ( wf % n_o ) ** 2 , ( wf % n_v ) ** 2 ) t_ij_cd = zero ! do d = 1 , wf % n_v do c = 1 , wf % n_v ! cd = index_two ( c , d , wf % n_v ) ! do j = 1 , wf % n_o ! dj = index_two ( d , j , wf % n_v ) ! do i = 1 , wf % n_o ! ci = index_two ( c , i , wf % n_v ) ij = index_two ( i , j , wf % n_o ) ! cidj = index_packed ( ci , dj ) ! t_ij_cd ( ij , cd ) = wf % t2am ( cidj , 1 ) ! t_ij&#94;cd ! enddo enddo enddo enddo ! !        Form intermediate X_ij_kb = sum_cd g_kcdb t_ij&#94;cd !                                  = sum_cd t_ij_cd g_cd_kb ! call wf % mem % alloc ( X_ij_kb , ( wf % n_o ) ** 2 , ( wf % n_o ) * batch_length ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) * batch_length , & ( wf % n_v ) ** 2 , & one , & t_ij_cd , & ( wf % n_o ) ** 2 , & g_cd_kb , & ( wf % n_v ) ** 2 , & zero , & X_ij_kb , & ( wf % n_o ) ** 2 ) ! call wf % mem % dealloc ( t_ij_cd , ( wf % n_o ) ** 2 , ( wf % n_v ) ** 2 ) ! !        sum_kcd g_kcbd t_ij&#94;cd c_ak = sum_k X_ij_kb c_ak !        Reorder to X_k_ijb = X_ij_kb ! call wf % mem % alloc ( X_k_ijb , ( wf % n_o ), batch_length * ( wf % n_o ) ** 2 ) X_k_ijb = zero ! do b = 1 , batch_length do j = 1 , wf % n_o do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! ijb = index_three ( i , j , b , wf % n_o , wf % n_o ) ! do k = 1 , wf % n_o ! kb = index_two ( k , b , wf % n_o ) ! X_k_ijb ( k , ijb ) = X_ij_kb ( ij , kb ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( X_ij_kb , ( wf % n_o ) ** 2 , ( wf % n_o ) * batch_length ) ! !        Form rho_a_ijb = - sum_k c_ak X_k_ijb = - sum_k c_a_i(a,k) X_k_ijb(k, ijb) ! call wf % mem % alloc ( rho_a_ijb , wf % n_v , batch_length * ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & batch_length * ( wf % n_o ) ** 2 , & wf % n_o , & - one , & c_a_i , & wf % n_v , & X_k_ijb , & wf % n_o , & zero , & rho_a_ijb , & wf % n_v ) ! call wf % mem % dealloc ( X_k_ijb , wf % n_o , batch_length * ( wf % n_o ) ** 2 ) ! !        Add rho_a_ijb (batch over b) to rho_ai_bj (full space) ! do b = 1 , batch_length ! Loop over restricted space do j = 1 , wf % n_o ! Bj = index_two ( b + b_begin - 1 , j , wf % n_v ) ! b in full space ! do i = 1 , wf % n_o ! ijb = index_three ( i , j , b , wf % n_o , wf % n_o ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! rho_ai_bj ( ai , Bj ) = rho_ai_bj ( ai , Bj ) + rho_a_ijb ( a , ijb ) ! enddo enddo enddo enddo ! !        Deallocations for term 1 (keep g_cd_kb = g_kcbd) ! call wf % mem % dealloc ( rho_a_ijb , wf % n_v , batch_length * ( wf % n_o ) ** 2 ) ! ! !        :: Term 2. - sum_kcd g_kcbd t_kj&#94;ad c_ci :: ! !        Form the intermediate X_i_dkb = sum_c g_kcbd c_ci !                                      = sum_c c_ci g_cd_kb !                                      = sum_c c_a_i&#94;T(i,c) g_cd_kb(c, dkb) ! !        Note: g_cd_kb is interpreted as g_c_dkb in the matrix multiplication. ! call wf % mem % alloc ( X_i_dkb , wf % n_o , ( wf % n_v ) * ( wf % n_o ) * batch_length ) ! call dgemm ( 'T' , 'N' , & wf % n_o , & ( wf % n_v ) * ( wf % n_o ) * batch_length , & wf % n_v , & one , & c_a_i , & wf % n_v , & g_cd_kb , & ! \"g_c_dkb\" wf % n_v , & zero , & X_i_dkb , & wf % n_o ) ! !        sum_kcd g_kcbd t_kj&#94;ad c_ci = sum_kd (sum_c c_ci g_kcbd) t_kj&#94;ad !                                    = sum_kd X_i_dkb t_kj&#94;ad !                                    = sum_kd X_ib_dk t_dk_aj ! !        Reorder to X_ib_dk = X_i_dkb ! call wf % mem % alloc ( X_ib_dk , ( wf % n_o ) * batch_length , ( wf % n_v ) * ( wf % n_o )) ! do k = 1 , wf % n_o do d = 1 , wf % n_v ! dk = index_two ( d , k , wf % n_v ) ! do b = 1 , batch_length ! dkb = index_three ( d , k , b , wf % n_v , wf % n_o ) ! do i = 1 , wf % n_o ! ib = index_two ( i , b , wf % n_o ) ! X_ib_dk ( ib , dk ) = X_i_dkb ( i , dkb ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( X_i_dkb , wf % n_o , ( wf % n_o ) * ( wf % n_v ) * batch_length ) ! !        Order the amplitudes as t_dk_aj = t_kj&#94;ad ! call wf % mem % alloc ( t_dk_aj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_dk_aj = zero ! do j = 1 , wf % n_o do a = 1 , wf % n_v ! aj = index_two ( a , j , wf % n_v ) ! do k = 1 , wf % n_o ! ak = index_two ( a , k , wf % n_v ) ! do d = 1 , wf % n_v ! dj = index_two ( d , j , wf % n_v ) dk = index_two ( d , k , wf % n_v ) ! akdj = index_packed ( ak , dj ) ! t_dk_aj ( dk , aj ) = wf % t2am ( akdj , 1 ) ! t_kj&#94;ad ! enddo enddo enddo enddo ! !        Calculate rho_ib_aj = - sum_kcd g_kcbd t_kj&#94;ad c_ci !                            = - sum_dk X_ib_dk t_dk_aj ! call wf % mem % alloc ( rho_ib_aj , ( wf % n_o ) * batch_length , ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * batch_length , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & X_ib_dk , & ( wf % n_o ) * batch_length , & t_dk_aj , & ( wf % n_o ) * ( wf % n_v ), & zero , & rho_ib_aj , & ( wf % n_o ) * batch_length ) ! call wf % mem % dealloc ( X_ib_dk , ( wf % n_o ) * batch_length , ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( t_dk_aj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Add rho_ib_aj (batch over b) ro rho_ai_bj (full space) ! do j = 1 , wf % n_o do a = 1 , wf % n_v ! aj = index_two ( a , j , wf % n_v ) ! do b = 1 , batch_length ! Bj = index_two ( b + b_begin - 1 , j , wf % n_v ) ! b is full space index ! do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) ib = index_two ( i , b , wf % n_o ) ! rho_ai_bj ( ai , Bj ) = rho_ai_bj ( ai , Bj ) + rho_ib_aj ( ib , aj ) ! enddo enddo enddo enddo ! !        Deallocations for term 2 (keep g_cd_kb = g_kcbd) ! call wf % mem % dealloc ( rho_ib_aj , ( wf % n_o ) * batch_length , ( wf % n_v ) * ( wf % n_o )) ! ! !        :: Term 3. - sum_kcd g_kcbd t_ik&#94;ca c_dj :: ! !        sum_d g_kcbd c_dj = sum_d g_cd_kb c_dj ! !        Reorder integrals to g_cd_kb to g_ckb_d ! call wf % mem % alloc ( g_ckb_d , ( wf % n_o ) * ( wf % n_v ) * batch_length , wf % n_v ) g_ckb_d = zero ! do d = 1 , wf % n_v do b = 1 , batch_length do k = 1 , wf % n_o ! kb = index_two ( k , b , wf % n_o ) ! do c = 1 , wf % n_v ! cd = index_two ( c , d , wf % n_v ) ! ckb = index_three ( c , k , b , wf % n_v , wf % n_o ) ! g_ckb_d ( ckb , d ) = g_cd_kb ( cd , kb ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_cd_kb , ( wf % n_v ) ** 2 , ( wf % n_o ) * batch_length ) ! !        Form the intermediate X_ckb_j = sum_d g_kcbd c_dj = sum_d g_ckb_d c_d_j ! call wf % mem % alloc ( X_ckb_j , ( wf % n_v ) * ( wf % n_o ) * batch_length , wf % n_o ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ) * batch_length , & wf % n_o , & wf % n_v , & one , & g_ckb_d , & ( wf % n_v ) * ( wf % n_o ) * batch_length , & c_a_i , & wf % n_v , & zero , & X_ckb_j , & ( wf % n_v ) * ( wf % n_o ) * batch_length ) ! !        Order amplitudes as t_ai_ck = t_ik&#94;ca ! call wf % mem % alloc ( t_ai_ck , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) t_ai_ck = zero ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do i = 1 , wf % n_o ! ci = index_two ( c , i , wf % n_v ) ! do a = 1 , wf % n_v ! ak = index_two ( a , k , wf % n_v ) ai = index_two ( a , i , wf % n_v ) ! ciak = index_packed ( ci , ak ) ! t_ai_ck ( ai , ck ) = wf % t2am ( ciak , 1 ) ! t_ik&#94;ca ! enddo enddo enddo enddo ! !        Form rho_aib_j = -sum_kcd g_kcbd t_ik&#94;ca c_dj = sum_ck t_ai_ck X_ckb_j ! !        Note: X_ckb_j is interpreted as X_ck_bj in the matrix multiplication. !        Note: rho_aib_j is interpreted as rho_ai_bj in the matrix multiplication. ! call wf % mem % alloc ( rho_aib_j , ( wf % n_v ) * ( wf % n_o ) * batch_length , wf % n_o ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_o ) * batch_length , & ( wf % n_v ) * ( wf % n_o ), & - one , & t_ai_ck , & ( wf % n_v ) * ( wf % n_o ), & X_ckb_j , & ! \"X_ck_bj\" ( wf % n_v ) * ( wf % n_o ), & zero , & rho_aib_j , & ! \"rho_ai_bj\" ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( X_ckb_j , ( wf % n_v ) * ( wf % n_o ) * batch_length , wf % n_o ) call wf % mem % dealloc ( t_ai_ck , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !        Add rho_aib_j to rho_ai_bj ! do j = 1 , wf % n_o do b = 1 , batch_length ! Bj = index_two ( b + b_begin - 1 , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aib = index_three ( a , i , b , wf % n_v , wf % n_o ) ! rho_ai_bj ( ai , Bj ) = rho_ai_bj ( ai , Bj ) + rho_aib_j ( aib , j ) ! enddo enddo enddo enddo ! !        Deallocations for term 3 (keep g_ckb_d = g_kcbd) ! call wf % mem % dealloc ( rho_aib_j , ( wf % n_o ) * ( wf % n_v ) * batch_length , wf % n_o ) ! ! !        :: Term 4.  sum_kcd L_kcbd t_ik&#94;ac c_dj :: ! !        sum_d L_kcbd c_dj = sum_d L_ckb_d c_dj ! !        Form L_ckb_d = L_kcbd = 2 * g_kcbd - g_kdbc = 2 * g_ckb_d(ckb, d) - g_ckb_d(dkb, c) ! call wf % mem % alloc ( L_ckb_d , ( wf % n_o ) * ( wf % n_v ) * batch_length , wf % n_v ) L_ckb_d = zero ! do d = 1 , wf % n_v do b = 1 , batch_length do k = 1 , wf % n_o ! dkb = index_three ( d , k , b , wf % n_v , wf % n_o ) ! do c = 1 , wf % n_v ! ckb = index_three ( c , k , b , wf % n_v , wf % n_o ) ! L_ckb_d ( ckb , d ) = two * g_ckb_d ( ckb , d ) - g_ckb_d ( dkb , c ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ckb_d , ( wf % n_o ) * ( wf % n_v ) * batch_length , wf % n_v ) ! !        Form the intermediate Y_ckb_j = sum_d L_kcbd c_dj = sum_d L_ckb_d c_dj ! call wf % mem % alloc ( Y_ckb_j , ( wf % n_v ) * ( wf % n_o ) * batch_length , wf % n_o ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ) * batch_length , & wf % n_o , & wf % n_v , & one , & L_ckb_d , & ( wf % n_v ) * ( wf % n_o ) * batch_length , & c_a_i , & wf % n_v , & zero , & Y_ckb_j , & ( wf % n_v ) * ( wf % n_o ) * batch_length ) ! !        Order amplitudes as t_ai_ck = t_ik&#94;ac = t2am(aick, 1) ! call wf % mem % alloc ( t_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_ai_ck = zero ! call squareup ( wf % t2am , t_ai_ck , ( wf % n_o ) * ( wf % n_v )) ! !        Form rho_aib_j =  sum_ck t_ai_ck Y_ckb_j ! !        Note: we interpret Y_ckb_j as Y_ck_bj in the matrix multiplication !        Note: we interpret rho_aib_j as rho_ai_bj in the matrix multiplication ! call wf % mem % alloc ( rho_aib_j , ( wf % n_o ) * ( wf % n_v ) * batch_length , wf % n_o ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * batch_length , & ( wf % n_o ) * ( wf % n_v ), & one , & t_ai_ck , & ( wf % n_o ) * ( wf % n_v ), & Y_ckb_j , & ! \"Y_ck_bj\" ( wf % n_o ) * ( wf % n_v ), & zero , & rho_aib_j , & ! \"rho_ai_bj\" ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( Y_ckb_j , ( wf % n_v ) * ( wf % n_o ) * batch_length , wf % n_o ) call wf % mem % dealloc ( t_ai_ck , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !        Add rho_aib_j to rho_ai_bj ! do j = 1 , wf % n_o do b = 1 , batch_length ! Bj = index_two ( b + b_begin - 1 , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! aib = index_three ( a , i , b , wf % n_v , wf % n_o ) ! ai = index_two ( a , i , wf % n_v ) ! rho_ai_bj ( ai , Bj ) = rho_ai_bj ( ai , Bj ) + rho_aib_j ( aib , j ) ! enddo enddo enddo enddo ! !        Deallocations for term 4 (keep L_ckb_d = L_kcbd) ! call wf % mem % dealloc ( rho_aib_j , ( wf % n_v ) * ( wf % n_o ) * batch_length , wf % n_o ) ! ! !        :: Term 5.  sum_kcd L_kcbd t_ij&#94;ad c_ck :: ! !        Form the intermediate X_1,bd = sum_ck c_ck L_kcbd = sum_ck c_1,ck L_ckb_d ! !        Note: L_ckb_d is interpreted as L_ck_bd in the matrix multiplication !        Note: c_a_i is interpreted as c_1,ai in the matrix multiplication ! call wf % mem % alloc ( X_bd , 1 , batch_length * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & 1 , & batch_length * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & c_a_i , & ! \"c_1,ai\" 1 , & L_ckb_d , & ! \"L_ck_bd\" ( wf % n_o ) * ( wf % n_v ), & zero , & X_bd , & 1 ) ! !        Order amplitudes as t_d_aij = t_ij&#94;ad ! call wf % mem % alloc ( t_d_aij , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) t_d_aij = zero ! do j = 1 , wf % n_o do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! do d = 1 , wf % n_v ! dj = index_two ( d , j , wf % n_v ) ! aidj = index_packed ( ai , dj ) ! t_d_aij ( d , aij ) = wf % t2am ( aidj , 1 ) ! enddo enddo enddo enddo ! !        Form rho_b_aij =  sum_kcd L_kcbd t_ij&#94;ad c_ck !                       =  sum_d X_bd t_d_aij ! !        Note: X_bd is interpreted as X_b_d in the matrix multiplication ! call wf % mem % alloc ( rho_b_aij , batch_length , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & batch_length , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_v , & one , & X_bd , & ! \"X_b_d\" batch_length , & t_d_aij , & wf % n_v , & zero , & rho_b_aij , & batch_length ) ! call wf % mem % dealloc ( X_bd , 1 , batch_length * ( wf % n_v )) call wf % mem % dealloc ( t_d_aij , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !        Add rho_b_aij to rho_ai_bj ! do j = 1 , wf % n_o do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! do b = 1 , batch_length ! Bj = index_two ( b + b_begin - 1 , j , wf % n_v ) ! rho_ai_bj ( ai , Bj ) = rho_ai_bj ( ai , Bj ) + rho_b_aij ( b , aij ) ! enddo enddo enddo enddo ! !        Final deallocations in batching loop ! call wf % mem % dealloc ( rho_b_aij , batch_length , ( wf % n_v ) * ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( L_ckb_d , ( wf % n_v ) * ( wf % n_o ) * batch_length , wf % n_v ) ! enddo ! End of batches over b ! !    Destroy amplitudes from memory ! call wf % destruct_amplitudes ! end subroutine jacobian_ccsd_d2_ccsd ! ! module subroutine jacobian_ccsd_e2_ccsd ( wf , rho_ai_bj , c_ai_ck ) !! !!    Jacobian CCSD E2 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    rho_ai_bj&#94;E2 = 2 sum_dlck t_bj,dl * L_kc,ld * c_ai,ck !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_ck ! real ( dp ), dimension (:,:), allocatable :: t_dl_bj real ( dp ), dimension (:,:), allocatable :: g_kc_ld real ( dp ), dimension (:,:), allocatable :: L_ck_dl real ( dp ), dimension (:,:), allocatable :: X_ck_bj ! integer ( i15 ) :: c = 0 , d = 0 , k = 0 , l = 0 integer ( i15 ) :: ck = 0 , dl = 0 , kc = 0 , kd = 0 , lc = 0 , ld = 0 ! !     Read T2 amplitudes from disk ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_dl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_dl_bj = zero ! call squareup ( wf % t2am , t_dl_bj , ( wf % n_o ) * ( wf % n_v )) ! call wf % destruct_amplitudes ! !     Construct g_kcld ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! !     Construct L_kc,ld ordered as L_ck_dl ! call wf % mem % alloc ( L_ck_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) L_ck_dl = zero ! do l = 1 , wf % n_o do d = 1 , wf % n_v ! dl = index_two ( d , l , wf % n_v ) ld = index_two ( l , d , wf % n_o ) ! do k = 1 , wf % n_o ! kd = index_two ( k , d , wf % n_o ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) kc = index_two ( k , c , wf % n_o ) lc = index_two ( l , c , wf % n_o ) ! L_ck_dl ( ck , dl ) = two * g_kc_ld ( kc , ld ) - g_kc_ld ( kd , lc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Intermediate X_ck_bj = sum_dl L_ck_dl * t_dl_bj ! call wf % mem % alloc ( X_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & L_ck_dl , & ( wf % n_o ) * ( wf % n_v ), & t_dl_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_ck_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( t_dl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( L_ck_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     rho_ai_bj = 2 * sum_ck c_ai_ck * X_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & two , & c_ai_ck , & ( wf % n_o ) * ( wf % n_v ), & X_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & rho_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( X_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_ccsd_e2_ccsd ! module subroutine jacobian_ccsd_f2_ccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian CCSD F2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;F2 =   - sum_ckld t_ai,ck * L_kc,ld * c_bl,dj !!                        - sum_ckdl t_ai,dj * L_kc,ld * c_bl,ck !!                        - sum_ckdl t_ai_bl * L_kc,ld * c_ck,dj !! !!       L_kc,ld = 2*g_kc,ld - g_kd,lc = 2*g_kc_ld(kc,ld) - 2*g_kc_ld(kd,lc) !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj ! real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: g_kc_ld ! real ( dp ), dimension (:,:), allocatable :: L_ck_dl real ( dp ), dimension (:,:), allocatable :: L_d_lck real ( dp ), dimension (:,:), allocatable :: L_l_ckd ! real ( dp ), dimension (:,:), allocatable :: c_dl_bj real ( dp ), dimension (:,:), allocatable :: c_clk_b real ( dp ), dimension (:,:), allocatable :: c_ckd_j ! real ( dp ), dimension (:,:), allocatable :: t_ai_ck real ( dp ), dimension (:,:), allocatable :: t_aij_d real ( dp ), dimension (:,:), allocatable :: t_aib_l ! real ( dp ), dimension (:,:), allocatable :: Y_d_b real ( dp ), dimension (:,:), allocatable :: Z_l_j real ( dp ), dimension (:,:), allocatable :: X_ck_bj ! real ( dp ), dimension (:,:), allocatable :: rho_aij_b real ( dp ), dimension (:,:), allocatable :: rho_aib_j ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ai = 0 , bj = 0 , bk = 0 , bl = 0 , ck = 0 , cl = 0 , dj = 0 , dl = 0 integer ( i15 ) :: kc = 0 , kd = 0 , ld = 0 , lc = 0 ! integer ( i15 ) :: aij = 0 , aib = 0 , lck = 0 , ckd = 0 ! integer ( i15 ) :: bldj = 0 , aidj = 0 , bkcl = 0 , aibl = 0 ! !        :: Construct L_kc,ld :: call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! call wf % mem % alloc ( L_ck_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) L_ck_dl = zero ! !        Construct L_kc,ld ordered as L_ck_dl ! do c = 1 , wf % n_v do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) ck = index_two ( c , k , wf % n_v ) ! do d = 1 , wf % n_v do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) ld = index_two ( l , d , wf % n_o ) dl = index_two ( d , l , wf % n_v ) kd = index_two ( k , d , wf % n_o ) ! L_ck_dl ( ck , dl ) = two * g_kc_ld ( kc , ld ) - g_kc_ld ( kd , lc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        :: Term 1: - sum_ckld t_ai,ck * L_kc,ld * c_bl,dj :: ! !        Reorder c_bl_dj as c_dl_bj ! call wf % mem % alloc ( c_dl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) c_dl_bj = zero ! do l = 1 , wf % n_o do j = 1 , wf % n_o do d = 1 , wf % n_v ! dj = index_two ( d , j , wf % n_v ) dl = index_two ( d , l , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) bl = index_two ( b , l , wf % n_v ) ! c_dl_bj ( dl , bj ) = c_ai_bj ( bl , dj ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( X_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        X_ck_bj = sum_dl L_ck_dl*c_dl_bj = sum_dl L_kc,ld*c_bl,dj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & L_ck_dl , & ( wf % n_o ) * ( wf % n_v ), & c_dl_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_ck_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( c_dl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( L_ck_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_ai_ck = zero ! call squareup ( wf % t2am , t_ai_ck , ( wf % n_o ) * ( wf % n_v )) call wf % destruct_amplitudes ! !        rho_ai_bj = sum_ck t_ai_ck*X_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & t_ai_ck , & ( wf % n_o ) * ( wf % n_v ), & X_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & rho_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( X_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( t_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        :: Term 2: - sum_ckdl t_ai,dj * L_kc,ld * c_bl,ck ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! !        Construct L_ck,dl reordered as L_d_clk ! call wf % mem % alloc ( L_d_lck , wf % n_v , ( wf % n_v ) * (( wf % n_o ) ** 2 )) L_d_lck = zero ! do k = 1 , wf % n_o do l = 1 , wf % n_o do c = 1 , wf % n_v ! lck = index_three ( l , c , k , wf % n_o , wf % n_v ) ! kc = index_two ( k , c , wf % n_o ) lc = index_two ( l , c , wf % n_o ) ! do d = 1 , wf % n_v ! ld = index_two ( l , d , wf % n_o ) kd = index_two ( k , d , wf % n_o ) ! L_d_lck ( d , lck ) = two * g_kc_ld ( kc , ld ) - g_kc_ld ( kd , lc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Y_d_b = sum_clk L_d_lck * c_b_lck !        Here dgemm is tricked to believe that c_bl_ck is c_b_lck ! call wf % mem % alloc ( Y_d_b , wf % n_v , wf % n_v ) ! call dgemm ( 'N' , 'T' , & wf % n_v , & wf % n_v , & (( wf % n_o ) ** 2 ) * wf % n_v , & one , & L_d_lck , & wf % n_v , & c_ai_bj , & wf % n_v , & zero , & Y_d_b , & wf % n_v ) ! call wf % mem % dealloc ( L_d_lck , wf % n_v , ( wf % n_v ) * (( wf % n_o ) ** 2 )) ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_aij_d , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) t_aij_d = zero ! !        Reorder T2 amplitudes ! do j = 1 , wf % n_o do i = 1 , wf % n_o do d = 1 , wf % n_v ! dj = index_two ( d , j , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! aidj = index_packed ( ai , dj ) ! t_aij_d ( aij , d ) = wf % t2am ( aidj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! call wf % mem % alloc ( rho_aij_b , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) ! !        rho_aij_b = sum_d t_aij_d*Y_d_b ! call dgemm ( 'N' , 'N' , & (( wf % n_o ) ** 2 ) * ( wf % n_v ), & wf % n_v , & wf % n_v , & - one , & t_aij_d , & (( wf % n_o ) ** 2 ) * ( wf % n_v ), & Y_d_b , & wf % n_v , & zero , & rho_aij_b , & (( wf % n_o ) ** 2 ) * ( wf % n_v )) ! call wf % mem % dealloc ( t_aij_d , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) call wf % mem % dealloc ( Y_d_b , wf % n_v , wf % n_v ) ! !        Adding term 2 to rho_ai_bj ! do j = 1 , wf % n_o do i = 1 , wf % n_o do a = 1 , wf % n_v ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! ai = index_two ( a , i , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aij_b ( aij , b ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aij_b , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) ! !        :: Term 3: - sum_ckdl t_ai,bl * L_kc,ld * c_ck,dj :: ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! call wf % mem % alloc ( L_l_ckd ,( wf % n_o ), ( wf % n_o ) * (( wf % n_v ) ** 2 )) L_l_ckd = zero ! !        Construct L_kc,dl ordered as L_l_ckd ! do c = 1 , wf % n_v do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) ! do d = 1 , wf % n_v ! ckd = index_three ( c , k , d , wf % n_v , wf % n_o ) ! do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) ld = index_two ( l , d , wf % n_o ) kd = index_two ( k , d , wf % n_o ) ! L_l_ckd ( l , ckd ) = two * g_kc_ld ( kc , ld ) - g_kc_ld ( kd , lc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % alloc ( Z_l_j , wf % n_o , wf % n_o ) ! !        Z_l_j = sum_ckd L_l_ckd * c_ckd_l ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & (( wf % n_v ) ** 2 ) * wf % n_o , & one , & L_l_ckd , & wf % n_o , & c_ai_bj , & ! c_ai_bj(ck,dl)= c_ckd_l (( wf % n_v ) ** 2 ) * wf % n_o , & zero , & Z_l_j , & wf % n_o ) ! call wf % mem % dealloc ( L_l_ckd ,( wf % n_o ), ( wf % n_o ) * (( wf % n_v ) ** 2 )) ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_aib_l , ( wf % n_o ) * (( wf % n_v )), wf % n_o * ( wf % n_v )) t_aib_l = zero call squareup ( wf % t2am , t_aib_l , wf % n_o * ( wf % n_v )) ! call wf % destruct_amplitudes ! !        rho_ai_bj = sum_l t_aib_l * Z_l_j ! call dgemm ( 'N' , 'N' , & (( wf % n_v ) ** 2 ) * ( wf % n_o ), & wf % n_o , & wf % n_o , & - one , & t_aib_l , & (( wf % n_v ) ** 2 ) * ( wf % n_o ), & Z_l_j , & wf % n_o , & one , & rho_ai_bj , & (( wf % n_v ) ** 2 ) * ( wf % n_o )) ! call wf % mem % dealloc ( t_aib_l , ( wf % n_o ) * (( wf % n_v )), wf % n_o * ( wf % n_v )) call wf % mem % dealloc ( Z_l_j , wf % n_o , wf % n_o ) ! end subroutine jacobian_ccsd_f2_ccsd ! ! module subroutine jacobian_ccsd_g2_ccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian CCSD G2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;G2 =  - sum_ckdl t_bl,dj * L_kc,ld * c_ai,ck !!                       - sum_ckdl t_ck_bl * L_kc,ld * c_ai,dj !!                       - sum_ckld t_ck,dj * L_kc,ld * c_ai,bl !! !!       L_kc,ld = 2*g_kc,ld - g_kd,lc = 2*g_kc_ld(kc,ld) - 2*g_kc_ld(kd,lc) !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj ! real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: g_kc_ld ! real ( dp ), dimension (:,:), allocatable :: L_ck_dl real ( dp ), dimension (:,:), allocatable :: L_d_clk real ( dp ), dimension (:,:), allocatable :: L_l_ckd ! real ( dp ), dimension (:,:), allocatable :: c_ai_ck real ( dp ), dimension (:,:), allocatable :: c_aib_l real ( dp ), dimension (:,:), allocatable :: c_aij_d ! real ( dp ), dimension (:,:), allocatable :: t_dl_bj real ( dp ), dimension (:,:), allocatable :: t_clk_b real ( dp ), dimension (:,:), allocatable :: t_ckd_j ! real ( dp ), dimension (:,:), allocatable :: X_ck_bj real ( dp ), dimension (:,:), allocatable :: Y_d_b real ( dp ), dimension (:,:), allocatable :: Z_l_j ! real ( dp ), dimension (:,:), allocatable :: rho_aij_b real ( dp ), dimension (:,:), allocatable :: rho_aib_j ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ai = 0 , bj = 0 , bk = 0 , bl = 0 , ck = 0 , cl = 0 , dj = 0 , dl = 0 integer ( i15 ) :: kc = 0 , lc = 0 , kd = 0 , ld = 0 ! integer ( i15 ) :: aib = 0 , aij = 0 , ckd = 0 , clk = 0 ! integer ( i15 ) :: ckbl = 0 , ckdj = 0 , bldj = 0 ! !        :: Term 1: - sum_ckdl t_bl,dj * L_kc,ld * c_ai,ck  :: ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! call wf % mem % alloc ( L_ck_dl ,( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) L_ck_dl = zero ! !        Construct L_kc_ld ordered as L_ck_dl ! do c = 1 , wf % n_v do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) ck = index_two ( c , k , wf % n_v ) ! do d = 1 , wf % n_v do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) ld = index_two ( l , d , wf % n_o ) dl = index_two ( d , l , wf % n_v ) kd = index_two ( k , d , wf % n_o ) ! L_ck_dl ( ck , dl ) = two * g_kc_ld ( kc , ld ) - g_kc_ld ( kd , lc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Reorder t_bl_dj as t_dl_bj ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_dl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_dl_bj = zero ! do l = 1 , wf % n_o do j = 1 , wf % n_o do d = 1 , wf % n_v ! dj = index_two ( d , j , wf % n_v ) dl = index_two ( d , l , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) bl = index_two ( b , l , wf % n_v ) ! bldj = index_packed ( bl , dj ) ! t_dl_bj ( dl , bj ) = wf % t2am ( bldj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! call wf % mem % alloc ( X_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        X_ck_bj = sum_dl t_bl,dj * L_kc,ld = sum_dl L_ck_dl t_dl_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & L_ck_dl , & ( wf % n_o ) * ( wf % n_v ), & t_dl_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_ck_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( t_dl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( L_ck_dl ,( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        rho_ai_bj =+ - sum_ck c_ai,ck X_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & c_ai_bj , & ( wf % n_o ) * ( wf % n_v ), & X_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & rho_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( X_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        :: Term 2: - sum_ckdl t_ck_bl * L_kc,ld * c_ai,dj ! ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! !        Reorder L_ck_dl to L_d_clk ! call wf % mem % alloc ( L_d_clk , wf % n_v , ( wf % n_v ) * (( wf % n_o ) ** 2 )) L_d_clk = zero ! do k = 1 , wf % n_o do l = 1 , wf % n_o do c = 1 , wf % n_v ! clk = index_three ( c , l , k , wf % n_v , wf % n_o ) ! kc = index_two ( k , c , wf % n_o ) lc = index_two ( l , c , wf % n_o ) ! do d = 1 , wf % n_v ! ld = index_two ( l , d , wf % n_o ) kd = index_two ( k , d , wf % n_o ) ! L_d_clk ( d , clk ) = two * g_kc_ld ( kc , ld ) - g_kc_ld ( kd , lc ) ! enddo enddo enddo enddo call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Reorder t_ck,bl as t_clk_b ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_clk_b , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) t_clk_b = zero ! do k = 1 , wf % n_o do l = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! clk = index_three ( c , l , k , wf % n_v , wf % n_o ) ! do b = 1 , wf % n_v ! bl = index_two ( b , l , wf % n_v ) ! ckbl = index_packed ( ck , bl ) ! t_clk_b ( clk , b ) = wf % t2am ( ckbl , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !        Y_d_b = sum_clk L_d_clk * c_clk_b ! call wf % mem % alloc ( Y_d_b , wf % n_v , wf % n_v ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & (( wf % n_o ) ** 2 ) * wf % n_v , & one , & L_d_clk , & wf % n_v , & t_clk_b , & (( wf % n_o ) ** 2 ) * wf % n_v , & zero , & Y_d_b , & wf % n_v ) ! call wf % mem % dealloc ( t_clk_b , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) call wf % mem % dealloc ( L_d_clk , wf % n_v , ( wf % n_v ) * (( wf % n_o ) ** 2 )) ! call wf % mem % alloc ( c_aij_d , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) c_aij_d = zero ! !        Reorder c_ai_dj to c_aij_d ! do j = 1 , wf % n_o do i = 1 , wf % n_o do d = 1 , wf % n_v ! dj = index_two ( d , j , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! c_aij_d ( aij , d ) = c_ai_bj ( ai , dj ) ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! call wf % mem % alloc ( rho_aij_b , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) ! !        rho_aij_b = sum_d c_aij_d * Y_d_b ! call dgemm ( 'N' , 'N' , & (( wf % n_o ) ** 2 ) * ( wf % n_v ), & wf % n_v , & wf % n_v , & - one , & c_aij_d , & (( wf % n_o ) ** 2 ) * ( wf % n_v ), & Y_d_b , & wf % n_v , & zero , & rho_aij_b , & (( wf % n_o ) ** 2 ) * ( wf % n_v )) ! call wf % mem % dealloc ( c_aij_d , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) call wf % mem % dealloc ( Y_d_b , wf % n_v , wf % n_v ) ! !        Adding term 2 to rho_ai_bj ! do j = 1 , wf % n_o do i = 1 , wf % n_o do a = 1 , wf % n_v ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! ai = index_two ( a , i , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aij_b ( aij , b ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aij_b , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) ! !        :: Term 3: - sum_ckld t_ck,dj * L_kc,ld * c_ai,bl :: ! ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! call wf % mem % alloc ( L_l_ckd ,( wf % n_o ), ( wf % n_o ) * (( wf % n_v ) ** 2 )) L_l_ckd = zero ! !        Construct L_kc_ld ordered as  L_l_ckd ! do c = 1 , wf % n_v do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) ! do d = 1 , wf % n_v do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) ld = index_two ( l , d , wf % n_o ) kd = index_two ( k , d , wf % n_o ) ! ckd = index_three ( c , k , d , wf % n_v , wf % n_o ) ! L_l_ckd ( l , ckd ) = two * g_kc_ld ( kc , ld ) - g_kc_ld ( kd , lc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Reorder t_ck,dj to t_ckd_j ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_ckd_j , (( wf % n_v )) * ( wf % n_o ), wf % n_o * ( wf % n_v )) t_ckd_j = zero call squareup ( wf % t2am , t_ckd_j , wf % n_o * ( wf % n_v )) ! call wf % destruct_amplitudes ! call wf % mem % alloc ( Z_l_j , wf % n_o , wf % n_o ) ! !        Z_l_j = sum_ckd L_l_ckd*t_ckd_j ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & (( wf % n_v ) ** 2 ) * wf % n_o , & one , & L_l_ckd , & wf % n_o , & t_ckd_j , & (( wf % n_v ) ** 2 ) * wf % n_o , & zero , & Z_l_j , & wf % n_o ) ! call wf % mem % dealloc ( L_l_ckd ,( wf % n_o ), ( wf % n_o ) * (( wf % n_v ) ** 2 )) call wf % mem % dealloc ( t_ckd_j , (( wf % n_v )) * ( wf % n_o ), wf % n_o * ( wf % n_v )) ! !        rho_aib_j = sum_l c_aib_l*Z_l_j ! call dgemm ( 'N' , 'N' , & (( wf % n_v ) ** 2 ) * ( wf % n_o ), & wf % n_o , & wf % n_o , & - one , & c_ai_bj , & (( wf % n_v ) ** 2 ) * ( wf % n_o ), & Z_l_j , & wf % n_o , & one , & rho_ai_bj , & (( wf % n_v ) ** 2 ) * ( wf % n_o )) ! call wf % mem % dealloc ( Z_l_j , wf % n_o , wf % n_o ) ! end subroutine jacobian_ccsd_g2_ccsd ! module subroutine jacobian_ccsd_h2_ccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian CCSD H2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;H2 =  sum_ckdl t_ci,ak * g_kc,ld * c_bl,dj !!                     + sum_ckdl t_cj,al * g_kc,ld * c_bk,di !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj ! real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: g_kc_ld real ( dp ), dimension (:,:), allocatable :: g_lc_kd ! real ( dp ), dimension (:,:), allocatable :: t_ai_kc real ( dp ), dimension (:,:), allocatable :: t_aj_lc ! real ( dp ), dimension (:,:), allocatable :: c_ld_bj real ( dp ), dimension (:,:), allocatable :: c_kd_bi ! real ( dp ), dimension (:,:), allocatable :: X_ai_ld real ( dp ), dimension (:,:), allocatable :: Y_aj_kd ! real ( dp ), dimension (:,:), allocatable :: rho_aj_bi ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ak = 0 , ai = 0 , aj = 0 , al = 0 , bi = 0 , bj = 0 , bk = 0 , bl = 0 , ci = 0 , cj = 0 , di = 0 , dj = 0 integer ( i15 ) :: kc = 0 , kd = 0 , ld = 0 , lc = 0 integer ( i15 ) :: akci = 0 , alcj = 0 ! !        :: Term 1: sum_ckld t_ci,ak * g_kc,ld * c_bl,dj :: ! !        Construct g_kc_ld ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! !        t_ak,ci ordered as t_ai_kc ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_ai_kc , ( wf % n_o ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_v )) t_ai_kc = zero ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do c = 1 , wf % n_v do k = 1 , wf % n_o ! ci = index_two ( c , i , wf % n_v ) ak = index_two ( a , k , wf % n_v ) kc = index_two ( k , c , wf % n_o ) ! akci = index_packed ( ak , ci ) ! t_ai_kc ( ai , kc ) = wf % t2am ( akci , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! call wf % mem % alloc ( X_ai_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        X_ai_ld = sum_ck t_ai_kc*g_kc_ld ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & t_ai_kc , & ( wf % n_o ) * ( wf % n_v ), & g_kc_ld , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_ai_ld , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( t_ai_kc , ( wf % n_o ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % alloc ( c_ld_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) c_ld_bj = zero ! !        Reorder c_bl,dj as c_ld_bj ! do l = 1 , wf % n_o do b = 1 , wf % n_v ! bl = index_two ( b , l , wf % n_v ) ! do j = 1 , wf % n_o ! bj = index_two ( b , j , wf % n_v ) ! do d = 1 , wf % n_v ! dj = index_two ( d , j , wf % n_v ) ld = index_two ( l , d , wf % n_o ) ! c_ld_bj ( ld , bj ) = c_ai_bj ( bl , dj ) ! enddo enddo enddo enddo ! !        rho_ai_bj += sum_ld X_ai_ld*c_ld_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & X_ai_ld , & ( wf % n_o ) * ( wf % n_v ), & c_ld_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & rho_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( c_ld_bj , ( wf % n_o ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( X_ai_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        :: Term 2: sum_ckdl t_cj,al * g_kc,ld * c_bk,di ! !        Construct g_kc_ld ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! !        Reorder g_kc_ld to g_lc_kd ! call wf % mem % alloc ( g_lc_kd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_lc_kd = zero ! do c = 1 , wf % n_v do d = 1 , wf % n_v do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) kd = index_two ( k , d , wf % n_o ) ! do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) ld = index_two ( l , d , wf % n_o ) ! g_lc_kd ( lc , kd ) = g_kc_ld ( kc , ld ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        t_al,cj ordered as t_aj_lc ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_aj_lc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_aj_lc = zero ! do j = 1 , wf % n_o do a = 1 , wf % n_v ! aj = index_two ( a , j , wf % n_v ) ! do c = 1 , wf % n_v ! cj = index_two ( c , j , wf % n_v ) ! do l = 1 , wf % n_o ! al = index_two ( a , l , wf % n_v ) lc = index_two ( l , c , wf % n_o ) ! alcj = index_packed ( al , cj ) ! t_aj_lc ( aj , lc ) = wf % t2am ( alcj , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! call wf % mem % alloc ( Y_aj_kd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Y_aj_kd = sum_lc t_aj_lc * g_lc_kd ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & t_aj_lc , & ( wf % n_o ) * ( wf % n_v ), & g_lc_kd , & ( wf % n_o ) * ( wf % n_v ), & zero , & Y_aj_kd , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( g_lc_kd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( t_aj_lc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Reorder c_bk,di as c_kd_bi ! call wf % mem % alloc ( c_kd_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) c_kd_bi = zero ! do i = 1 , wf % n_o do k = 1 , wf % n_o do d = 1 , wf % n_v ! kd = index_two ( k , d , wf % n_o ) di = index_two ( d , i , wf % n_v ) ! do b = 1 , wf % n_v ! bk = index_two ( b , k , wf % n_v ) bi = index_two ( b , i , wf % n_v ) ! c_kd_bi ( kd , bi ) = c_ai_bj ( bk , di ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( rho_aj_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        rho_aj_bi = sum_kd  Y_aj_kd * c_kd_bi ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & Y_aj_kd , & ( wf % n_o ) * ( wf % n_v ), & c_kd_bi , & ( wf % n_o ) * ( wf % n_v ), & zero , & rho_aj_bi , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( c_kd_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( Y_aj_kd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Reorder into rho_ai_bj ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o ! aj = index_two ( a , j , wf % n_v ) ! do b = 1 , wf % n_v ! bi = index_two ( b , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aj_bi ( aj , bi ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aj_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_ccsd_h2_ccsd ! ! module subroutine jacobian_ccsd_i2_ccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian CCSD I2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;I2 =  sum_c F_bc * c_ai,cj - sum_k F_jk * c_ai,bk !!                     + sum_ck L_bj,kc * c_ai,ck !!                     - sum_ck ( g_kc,bj * c_ak,ci + g_ki,bc * c_ak,cj ) !! !!       Batch over c to construct  g_ki_bc !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj ! real ( dp ), dimension (:,:), allocatable :: c_aij_c real ( dp ), dimension (:,:), allocatable :: c_aib_k real ( dp ), dimension (:,:), allocatable :: c_ai_ck real ( dp ), dimension (:,:), allocatable :: c_aj_ck ! real ( dp ), dimension (:,:), allocatable :: rho_aij_b real ( dp ), dimension (:,:), allocatable :: rho_aib_j real ( dp ), dimension (:,:), allocatable :: rho_aj_bi ! real ( dp ), dimension (:,:), allocatable :: L_bj_J real ( dp ), dimension (:,:), allocatable :: L_kc_J real ( dp ), dimension (:,:), allocatable :: L_kj_J real ( dp ), dimension (:,:), allocatable :: L_bc_J ! real ( dp ), dimension (:,:), allocatable :: g_bj_kc real ( dp ), dimension (:,:), allocatable :: g_bc_kj real ( dp ), dimension (:,:), allocatable :: g_ck_bj ! reordering of g_bj_kc and g_bc_kj ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 ! integer ( i15 ) :: ai = 0 , aj = 0 , ak = 0 , bi = 0 , bj = 0 , bk = 0 , ci = 0 , cj = 0 , ck = 0 integer ( i15 ) :: bc = 0 integer ( i15 ) :: kc = 0 integer ( i15 ) :: kj = 0 ! integer ( i15 ) :: aij = 0 , aib = 0 ! integer ( i15 ) :: offset = 0 ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , n_batch = 0 , batch_dimension = 0 integer ( i15 ) :: c_batch = 0 , c_first = 0 , c_last = 0 , c_length = 0 ! !        :: sum_c F_bc * c_ai,cj :: ! !        Reorder c_ai,cj to c_aij_c ! call wf % mem % alloc ( c_aij_c , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) c_aij_c = zero ! do j = 1 , wf % n_o do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! do c = 1 , wf % n_v ! cj = index_two ( c , j , wf % n_v ) ! c_aij_c ( aij , c ) = c_ai_bj ( ai , cj ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( rho_aij_b , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) ! !        rho_ai_bj += sum_c F_bc * c_ai,cj = sum_c c_aij_c(aij,c) F_ab(b,c) = sum_c c_aij_c(aij,c) F_ab&#94;T(c,b) ! call dgemm ( 'N' , 'T' , & ( wf % n_v ) * (( wf % n_o ) ** 2 ), & wf % n_v , & wf % n_v , & one , & c_aij_c , & ( wf % n_v ) * (( wf % n_o ) ** 2 ), & wf % fock_ab , & wf % n_v , & zero , & rho_aij_b , & ( wf % n_v ) * (( wf % n_o ) ** 2 )) ! call wf % mem % dealloc ( c_aij_c , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) ! !        Reorder rho_aij_b into rho_ai_bj ! do i = 1 , wf % n_o do j = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aij_b ( aij , b ) ! enddo enddo enddo enddo ! ! call wf % mem % dealloc ( rho_aij_b , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) ! !       ::  - sum_k F_jk * c_ai,bk  :: ! !        rho_ai_bj += - sum_k F_jk * c_ai,bk = - sum_k c_aib_k(aib,k) F_ij(k,j)&#94;T ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * (( wf % n_v ) ** 2 ), & wf % n_o , & wf % n_o , & - one , & c_ai_bj , & ( wf % n_o ) * (( wf % n_v ) ** 2 ), & wf % fock_ij , & wf % n_o , & one , & rho_ai_bj , & ( wf % n_o ) * (( wf % n_v ) ** 2 )) ! !        ::   sum_ck L_bj,kc*c_ai,ck - sum_ck ( g_kc,bj*c_ak,ci + g_ki,bc*c_ak,cj ) :: ! !         sum_ck ( g_bj,kc*(2*c_ai,ck - c_ak,ci) - g_bc,kj*c_ai,ck - g_ki,bc*c_ak,cj ) ! !        Construct g_bj,kc ! call wf % mem % alloc ( g_bj_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vo_ov ( integral_type , g_bj_kc ) ! !        Reordering g_bj_kc to g_ck_bj ! call wf % mem % alloc ( g_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ck_bj = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) kc = index_two ( k , c , wf % n_o ) ! g_ck_bj ( ck , bj ) = g_bj_kc ( bj , kc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_bj_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !       rho_ai_bj += sum_ck 2*c_ai_ck * g_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & two , & c_ai_bj , & ( wf % n_o ) * ( wf % n_v ), & g_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & rho_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! !        Reorder c_ak,ci to c_ai_ck ! call wf % mem % alloc ( c_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) c_ai_ck = zero ! do i = 1 , wf % n_o do k = 1 , wf % n_o do a = 1 , wf % n_v ! ak = index_two ( a , k , wf % n_v ) ai = index_two ( a , i , wf % n_v ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ci = index_two ( c , i , wf % n_v ) ! c_ai_ck ( ai , ck ) = c_ai_bj ( ak , ci ) ! enddo enddo enddo enddo ! !        rho_ai_bj += - sum_ck g_ck_bj*c_ai_ck ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & c_ai_ck , & ( wf % n_o ) * ( wf % n_v ), & g_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & rho_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( c_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( g_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % alloc ( g_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ck_bj = zero ! !       Start batching over c ! required = 2 * ( wf % n_J ) * (( wf % n_v ) ** 2 ) & + 4 * ( wf % n_J ) * ( wf % n_v ) * ( wf % n_o ) & + 2 * ( wf % n_J ) * (( wf % n_o ) ** 2 ) ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !       Loop over the number of a batches ! do c_batch = 1 , n_batch ! !          For each batch, get the limits for the a index ! call batch_limits ( c_first , c_last , c_batch , max_batch_length , batch_dimension ) c_length = c_last - c_first + 1 ! !        Construct g_bc_kj ! call wf % mem % alloc ( g_bc_kj , ( wf % n_v ) * c_length , ( wf % n_o ) ** 2 ) g_bc_kj = zero ! integral_type = 'electronic_repulsion' call wf % get_vv_oo ( integral_type , & g_bc_kj , & 1 , & wf % n_v , & c_first , & c_last , & 1 , & wf % n_o , & 1 , & wf % n_o ) ! ! !       Reorder g_bc_kj ! do c = 1 , c_length do b = 1 , wf % n_v ! bc = index_two ( b , c , wf % n_v ) ! do j = 1 , wf % n_o ! bj = index_two ( b , j , wf % n_v ) ! do k = 1 , wf % n_o ! kj = index_two ( k , j , wf % n_o ) ck = index_two ( c + c_first - 1 , k , wf % n_v ) ! g_ck_bj ( ck , bj ) = g_bc_kj ( bc , kj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_bc_kj , ( wf % n_v ) * c_length , ( wf % n_o ) ** 2 ) ! enddo ! !        rho_ai_bj += - sum_ck c_ai_ck * g_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & c_ai_bj , & ( wf % n_o ) * ( wf % n_v ), & g_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & rho_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! !        Reorder  c_ak,cj to c_aj_ck ! call wf % mem % alloc ( c_aj_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) c_aj_ck = zero ! do j = 1 , wf % n_o do k = 1 , wf % n_o do a = 1 , wf % n_v ! ak = index_two ( a , k , wf % n_v ) aj = index_two ( a , j , wf % n_v ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) cj = index_two ( c , j , wf % n_v ) ! c_aj_ck ( aj , ck ) = c_ai_bj ( ak , cj ) ! enddo enddo enddo enddo ! call wf % mem % alloc ( rho_aj_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & c_aj_ck , & ( wf % n_o ) * ( wf % n_v ), & g_ck_bj , & ! g_ck_bi(ck,bi) = g_bc,ki ( wf % n_o ) * ( wf % n_v ), & zero , & rho_aj_bi , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( g_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( c_aj_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Reorder rho_aj_bi into rho_ai_bj ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o ! aj = index_two ( a , j , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) bi = index_two ( b , i , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aj_bi ( aj , bi ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_aj_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_ccsd_i2_ccsd ! ! module subroutine jacobian_ccsd_j2_ccsd ( wf , rho_ab_ij , c_ab_ij ) !! !!       Jacobian CCSD J2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ab_ij&#94;J2 =    sum_ckld t_ci,dj * g_kc,ld * c_ak,bl !!                       + sum_ckdl t_ak,bl * g_kc,ld * c_ci,dj !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: rho_ab_ij real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: c_ab_ij ! real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: g_kc_ld real ( dp ), dimension (:,:), allocatable :: g_kl_cd ! real ( dp ), dimension (:,:), allocatable :: t_ab_ij ! real ( dp ), dimension (:,:), allocatable :: X_kl_ij ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ab = 0 , cd = 0 integer ( i15 ) :: ai = 0 , bj = 0 integer ( i15 ) :: kl = 0 , ij = 0 integer ( i15 ) :: kc = 0 , ld = 0 ! integer ( i15 ) :: aibj = 0 ! !        Constructing g_kc_ld ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! call wf % mem % alloc ( g_kl_cd , ( wf % n_o ) ** 2 , ( wf % n_v ) ** 2 ) g_kl_cd = zero ! !        Reorder g_kc_ld to g_kl_cd ! do c = 1 , wf % n_v do d = 1 , wf % n_v ! cd = index_two ( c , d , wf % n_v ) ! do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) ! do l = 1 , wf % n_o ! kl = index_two ( k , l , wf % n_o ) ld = index_two ( l , d , wf % n_o ) ! g_kl_cd ( kl , cd ) = g_kc_ld ( kc , ld ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Reordered T2 amplitudes ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) t_ab_ij = zero ! do j = 1 , wf % n_o do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ab = index_two ( a , b , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! t_ab_ij ( ab , ij ) = wf % t2am ( aibj , 1 ) ! enddo enddo enddo enddo call wf % destruct_amplitudes ! !        X_kl_ij = g_kl_cd * t_cd_ij ! call wf % mem % alloc ( X_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & g_kl_cd , & ( wf % n_o ) ** 2 , & t_ab_ij , & ( wf % n_v ) ** 2 , & zero , & X_kl_ij , & ( wf % n_o ) ** 2 ) ! !        rho_ab_ij += c_ab_kl * X_kl_ij ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & one , & c_ab_ij , & ( wf % n_v ) ** 2 , & X_kl_ij , & ( wf % n_o ) ** 2 , & one , & rho_ab_ij , & ( wf % n_v ) ** 2 ) ! !        X_kl_ij = g_kl_cd * c_cd_ij ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & g_kl_cd , & ( wf % n_o ) ** 2 , & c_ab_ij , & ( wf % n_v ) ** 2 , & zero , & X_kl_ij , & ( wf % n_o ) ** 2 ) !! !         rho_ab_ij += t_ab_kl * X_kl_ij !! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & one , & t_ab_ij , & ( wf % n_v ) ** 2 , & X_kl_ij , & ( wf % n_o ) ** 2 , & one , & rho_ab_ij , & ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( X_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( g_kl_cd , ( wf % n_o ) ** 2 , ( wf % n_v ) ** 2 ) call wf % mem % dealloc ( t_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! end subroutine jacobian_ccsd_j2_ccsd ! ! module subroutine jacobian_ccsd_k2_ccsd ( wf , rho_ab_ij , c_ab_ij ) !! !!       Jacobian CCSD K2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ab_ij&#94;K2 =    sum_kl g_ki,lj * c_ak,bl !!                       + sum_cd g_ac,bd * c_ci,dj !! !!       For the last term we batch over a and b and !!       add each batch to rho_ai_bj !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: rho_ab_ij real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: c_ab_ij ! real ( dp ), dimension (:,:), allocatable :: g_ki_lj real ( dp ), dimension (:,:), allocatable :: g_kl_ij real ( dp ), dimension (:,:), allocatable :: g_ac_bd real ( dp ), dimension (:,:), allocatable :: g_ab_cd ! real ( dp ), dimension (:,:), allocatable :: rho_batch_ab_ij ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 ! integer ( i15 ) :: ab = 0 , bd = 0 , ac = 0 , cd = 0 , full_ab = 0 , ac = 0 , bd = 0 integer ( i15 ) :: ij = 0 , ki = 0 , kl = 0 , lj = 0 ! !        Batching and memory handling variables ! integer ( i15 ) :: a_n_batch = 0 , a_first = 0 , a_last = 0 , a_length = 0 , a_max_length = 0 , a_batch = 0 integer ( i15 ) :: b_n_batch = 0 , b_first = 0 , b_last = 0 , b_length = 0 , b_max_length = 0 , b_batch = 0 ! integer ( i15 ) :: required = 0 , available = 0 ! call wf % mem % alloc ( g_ki_lj , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! integral_type = 'electronic_repulsion' call wf % get_oo_oo ( integral_type , g_ki_lj ) ! !        Reorder g_ki_lj to g_kl_ij ! call wf % mem % alloc ( g_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) g_kl_ij = zero ! do j = 1 , wf % n_o do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do k = 1 , wf % n_o ! ki = index_two ( k , i , wf % n_o ) ! do l = 1 , wf % n_o ! kl = index_two ( k , l , wf % n_o ) lj = index_two ( l , j , wf % n_o ) ! g_kl_ij ( kl , ij ) = g_ki_lj ( ki , lj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ki_lj , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! !        rho_ab_ij += sum_kl g_ki,lj * c_ak,bl = sum_kl c_ab_ij(ab,kl) g_kl_ij(kl,ij) ! ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & one , & c_ab_ij , & ( wf % n_v ) ** 2 , & g_kl_ij , & ( wf % n_o ) ** 2 , & one , & rho_ab_ij , & ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( g_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! !        Prepare for batching over a and b ! !        ::  sum_cd g_ac,bd * c_ci,dj :: ! required = max ( 3 * ( wf % n_v ) ** 2 * ( wf % n_J ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & ! Needed to get L_db_J ( wf % n_v ) ** 4 + 2 * ( wf % n_v ) ** 2 * ( wf % n_J )) ! Needed to get g_ac_bd ! required = required * 4 ! Words available = get_available () ! a_max_length = 0 call num_two_batch ( required , available , a_max_length , a_n_batch , wf % n_v ) ! !        Initialize some variables for batching ! a_first = 0 a_last = 0 a_length = 0 ! !        Start looping over a-batches ! do a_batch = 1 , a_n_batch ! call batch_limits ( a_first , a_last , a_batch , a_max_length , wf % n_v ) a_length = a_last - a_first + 1 ! !           Start looping over batches of b ! b_first = 0 b_last = 0 b_length = 0 ! b_max_length = a_max_length ! do b_batch = 1 , a_n_batch ! call batch_limits ( b_first , b_last , b_batch , b_max_length , wf % n_v ) b_length = b_last - b_first + 1 ! !              Allocate g_ca_db = g_acbd ! call wf % mem % alloc ( g_ac_bd , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) ! !              g_ca_db = sum_J L_ca_J*L_db_J ! integral_type = 'electronic_repulsion' call wf % get_vv_vv ( integral_type , & g_ac_bd , & a_first , & a_last , & 1 , & wf % n_v , & b_first , & b_last , & 1 , & wf % n_v ) ! !              sum_cd g_ac,bd * c_ci,dj = sum_cd g_ac,bd c_cd,ij = sum_cd g_ab_cd c_cd_ij ! !              Reorder g_ca_db into g_ab_cd !              (Here, g_ab_cd = g_acbd = g_ca_db.) ! call wf % mem % alloc ( g_ab_cd , a_length * b_length , ( wf % n_v ) ** 2 ) g_ab_cd = zero ! do b = 1 , b_length do a = 1 , a_length ! ab = index_two ( a , b , a_length ) ! do d = 1 , wf % n_v ! bd = index_two ( b , d , b_length ) ! do c = 1 , wf % n_v ! ac = index_two ( a , c , a_length ) cd = index_two ( c , d , wf % n_v ) ! g_ab_cd ( ab , cd ) = g_ac_bd ( ac , bd ) ! = g_acbd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ac_bd , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) ! call wf % mem % alloc ( rho_batch_ab_ij , a_length * b_length , ( wf % n_o ) ** 2 ) ! !              rho_ab_ij += sum_cd g_ac,bd * c_ci,dj = sum_cd g_ab_cd(ab, cd) c_ab_ij(cd, ij) ! call dgemm ( 'N' , 'N' , & a_length * b_length , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & g_ab_cd , & a_length * b_length , & c_ab_ij , & ( wf % n_v ) ** 2 , & zero , & rho_batch_ab_ij , & a_length * b_length ) ! call wf % mem % dealloc ( g_ab_cd , a_length * b_length , ( wf % n_v ) ** 2 ) ! !              Reorder into rho_ab_ij ! do b = 1 , b_length do a = 1 , a_length ! ab = index_two ( a , b , a_length ) ! full_ab = index_two ( a + a_first - 1 , b + b_first - 1 , wf % n_v ) ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! rho_ab_ij ( full_ab , ij ) = rho_ab_ij ( full_ab , ij ) + rho_batch_ab_ij ( ab , ij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_batch_ab_ij , a_length * b_length , ( wf % n_o ) ** 2 ) ! enddo ! End batches of b enddo ! End batches of a ! end subroutine jacobian_ccsd_k2_ccsd ! ! end submodule jacobian","tags":"","loc":"sourcefile/jacobian_submodule.f90~3.html","title":"jacobian_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~jacobian_transpose_submodule.f90~~EfferentGraph sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilejacobian_transpose_submodulef90EfferentGraph = svgPanZoom('#sourcefilejacobian_transpose_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules jacobian_transpose Source Code jacobian_transpose_submodule.F90 Source Code submodule ( ccsd_class ) jacobian_transpose ! !! !!    Jacobian transpose submodule (CCSD) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Contains the following family of procedures of the CCSD class: !! !!    jacobian_transpose_ccsd_transformation: performs the transformation by the CCSD !!                                            Jacobian transpose matrix A&#94;T, placing the result in the !!                                            incoming vector. !!    jacobian_transpose_ccsd_x1:             adds the X1 term to the transformed singles vector; !!                                            x = a, b, c, ..., g !!    jacobian_transpose_ccsd_x2:             adds the X2 term to the transformed doubles vector; !!                                            x = a, b, ..., i !! ! implicit none ! character ( len = 40 ) :: integral_type ! contains ! ! module subroutine jacobian_transpose_ccsd_transformation_ccsd ( wf , b_a_i , b_aibj ) !! !!    Jacobian transpose transformation (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the transpose Jacobian transformation, i.e., the transformation !!    by the transpose of the Jacobian matrix !! !!       A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | R >. !! !!    The transformation is performed as sigma&#94;T = b&#94;T A, where b is the vector !!    sent to the routine. On exit, the vector b is equal to sigma (the transformed !!    vector). !! implicit none ! class ( ccsd ) :: wf ! !     Incoming vector b ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i real ( dp ), dimension ( wf % n_t2am , 1 ) :: b_aibj ! !     Local unpacked and reordered vectors ! real ( dp ), dimension (:,:), allocatable :: b_ai_bj ! Unpacked b_aibj real ( dp ), dimension (:,:), allocatable :: b_ab_ij ! b_ai_bj, reordered ! real ( dp ), dimension (:,:), allocatable :: sigma_ai_bj_sym ! Symmetrized sigma_ai_bj, temporary real ( dp ), dimension (:,:), allocatable :: sigma_ab_ij ! sigma_ai_bj, reordered ! real ( dp ), dimension (:,:), allocatable :: sigma_a_i real ( dp ), dimension (:,:), allocatable :: sigma_ai_bj ! !     Indices ! integer ( i15 ) :: a = 0 , ab = 0 , ai = 0 , b = 0 integer ( i15 ) :: bj = 0 , i = 0 , ij = 0 , j = 0 , aibj = 0 ! !     Allocate the transformed singles vector ! call wf % mem % alloc ( sigma_a_i , wf % n_v , wf % n_o ) sigma_a_i = zero ! !     Calculate and add the CCS contributions to the !     singles transformed vector ! call wf % jacobian_transpose_ccs_a1 ( sigma_a_i , b_a_i ) call wf % jacobian_transpose_ccs_b1 ( sigma_a_i , b_a_i ) ! !     Calculate and add the CCSD contributions to the !     singles transformed vector ! call wf % jacobian_transpose_ccsd_a1 ( sigma_a_i , b_a_i ) call wf % jacobian_transpose_ccsd_b1 ( sigma_a_i , b_a_i ) ! call wf % mem % alloc ( b_ai_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) b_ai_bj = zero ! call squareup ( b_aibj , b_ai_bj , ( wf % n_v ) * ( wf % n_o )) ! call wf % jacobian_transpose_ccsd_c1 ( sigma_a_i , b_ai_bj ) call wf % jacobian_transpose_ccsd_d1 ( sigma_a_i , b_ai_bj ) call wf % jacobian_transpose_ccsd_e1 ( sigma_a_i , b_ai_bj ) call wf % jacobian_transpose_ccsd_f1 ( sigma_a_i , b_ai_bj ) call wf % jacobian_transpose_ccsd_g1 ( sigma_a_i , b_ai_bj ) ! !     Add the CCSD contributions to the doubles vector arising from !     the incoming singles vector ! call wf % mem % alloc ( sigma_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) sigma_ai_bj = zero ! call wf % jacobian_transpose_ccsd_a2 ( sigma_ai_bj , b_a_i ) ! !     Done with singles vector b; overwrite it with !     transformed vector for exit ! call dcopy (( wf % n_o ) * ( wf % n_v ), sigma_a_i , 1 , b_a_i , 1 ) ! !     Unpack incoming doubles vector, and add the CCSD terms arising !     from this vector ! call wf % mem % alloc ( b_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) b_ai_bj = zero ! call squareup ( b_aibj , b_ai_bj , ( wf % n_o ) * ( wf % n_v )) ! call wf % jacobian_transpose_ccsd_b2 ( sigma_ai_bj , b_ai_bj ) call wf % jacobian_transpose_ccsd_c2 ( sigma_ai_bj , b_ai_bj ) call wf % jacobian_transpose_ccsd_d2 ( sigma_ai_bj , b_ai_bj ) call wf % jacobian_transpose_ccsd_e2 ( sigma_ai_bj , b_ai_bj ) call wf % jacobian_transpose_ccsd_f2 ( sigma_ai_bj , b_ai_bj ) call wf % jacobian_transpose_ccsd_g2 ( sigma_ai_bj , b_ai_bj ) ! !     Last two terms are already symmetric (h2 and i2). Perform the symmetrization !     sigma_ai_bj = P_ij&#94;ab sigma_ai_bj now, for convenience ! !     Allocate temporary symmetric transformed vector ! call wf % mem % alloc ( sigma_ai_bj_sym , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) sigma_ai_bj_sym = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! sigma_ai_bj_sym ( ai , bj ) = sigma_ai_bj ( ai , bj ) + sigma_ai_bj ( bj , ai ) ! enddo enddo enddo enddo ! sigma_ai_bj = sigma_ai_bj_sym ! !     Done with temporary vector; deallocate ! call wf % mem % dealloc ( sigma_ai_bj_sym , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     In preparation for last two terms, reorder !     sigma_ai_bj to rho_ab_ij, and b_ai_bj to b_ab_ij ! call wf % mem % alloc ( sigma_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) call wf % mem % alloc ( b_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! sigma_ab_ij = zero b_ab_ij = zero ! do j = 1 , wf % n_o do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ab = index_two ( a , b , wf % n_v ) ! b_ab_ij ( ab , ij ) = b_ai_bj ( ai , bj ) sigma_ab_ij ( ab , ij ) = sigma_ai_bj ( ai , bj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( b_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( sigma_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call wf % jacobian_transpose_ccsd_h2 ( sigma_ab_ij , b_ab_ij ) call wf % jacobian_transpose_ccsd_i2 ( sigma_ab_ij , b_ab_ij ) ! !     Done with reordered doubles b; deallocate ! call wf % mem % dealloc ( b_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! !     Order sigma_ab_ij back into sigma_ai_bj ! call wf % mem % alloc ( sigma_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) sigma_ai_bj = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do a = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) ai = index_two ( a , i , wf % n_v ) sigma_ai_bj ( ai , bj ) = sigma_ab_ij ( ab , ij ) ! enddo enddo enddo enddo ! !     Done with reordered transformed vector; deallocate ! call wf % mem % dealloc ( sigma_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! !     Overwrite the incoming doubles c vector & pack in ! b_aibj = zero call packin ( b_aibj , sigma_ai_bj , ( wf % n_o ) * ( wf % n_v )) ! !     Final deallocations ! call wf % mem % dealloc ( sigma_a_i , wf % n_v , wf % n_o ) call wf % mem % dealloc ( sigma_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( b_ai_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! end subroutine jacobian_transpose_ccsd_transformation_ccsd ! ! module subroutine jacobian_transpose_ccsd_a1_ccsd ( wf , sigma_a_i , b_a_i ) !! !!    Jacobian transpose CCSD A1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the A1 term, !! !!       sum_ckdl b_ck L_iald u_kl&#94;cd, !! !!    abd adds it to the transformed vector sigma_a_i. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i ! real ( dp ), dimension (:,:), allocatable :: u_ld_ck ! real ( dp ), dimension (:,:), allocatable :: X_ld ! An intermediate, see below ! real ( dp ), dimension (:,:), allocatable :: g_ia_ld ! g_iald real ( dp ), dimension (:,:), allocatable :: L_ai_ld ! L_iald ! integer ( i15 ) :: k = 0 , c = 0 , d = 0 , l = 0 , ck = 0 , dk = 0 , dl = 0 integer ( i15 ) :: ld = 0 , cl = 0 , ckdl = 0 , cldk = 0 , i = 0 , a = 0 integer ( i15 ) :: id = 0 , la = 0 , ia = 0 , ai = 0 ! !     Read the amplitudes from disk ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! !     Form u_ld_ck = u_kl&#94;cd = 2 * t_kl&#94;cd - t_lk&#94;cd ! call wf % mem % alloc ( u_ld_ck , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do d = 1 , wf % n_v ! dk = index_two ( d , k , wf % n_v ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ld = index_two ( l , d , wf % n_o ) cl = index_two ( c , l , wf % n_v ) ! ckdl = index_packed ( ck , dl ) cldk = index_packed ( cl , dk ) ! u_ld_ck ( ld , ck ) = two * ( wf % t2am ( ckdl , 1 )) - wf % t2am ( cldk , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !     Form the intermediate X_ld = sum_ck u_ld_ck b_ck ! call wf % mem % alloc ( X_ld , ( wf % n_v ) * ( wf % n_o ), 1 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & 1 , & ( wf % n_v ) * ( wf % n_o ), & one , & u_ld_ck , & ( wf % n_v ) * ( wf % n_o ), & b_a_i , & ! \"b_ck\" ( wf % n_v ) * ( wf % n_o ), & zero , & X_ld , & ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( u_ld_ck , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     Form L_ai_ld = L_iald = 2 * g_iald - g_idla !                           = 2 * g_ia_ld(ia,ld) - g_ia_ld(id,la) ! call wf % mem % alloc ( g_ia_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_ia_ld ) ! call wf % mem % alloc ( L_ai_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) L_ai_ld = zero ! do d = 1 , wf % n_v do l = 1 , wf % n_o ! ld = index_two ( l , d , wf % n_o ) ! do i = 1 , wf % n_o ! id = index_two ( i , d , wf % n_o ) ! do a = 1 , wf % n_v ! la = index_two ( l , a , wf % n_o ) ia = index_two ( i , a , wf % n_o ) ai = index_two ( a , i , wf % n_v ) ! L_ai_ld ( ai , ld ) = two * g_ia_ld ( ia , ld ) - g_ia_ld ( id , la ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ia_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Calculate and add sum_ckdl b_ck L_iald u_kl&#94;cd !                       = sum_ld L_ai_ld X_ld ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & L_ai_ld , & ( wf % n_o ) * ( wf % n_v ), & X_ld , & ( wf % n_o ) * ( wf % n_v ), & one , & sigma_a_i , & ! \"sigma_ai\" ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( L_ai_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( X_ld , ( wf % n_o ) * ( wf % n_v ), 1 ) ! end subroutine jacobian_transpose_ccsd_a1_ccsd ! ! module subroutine jacobian_transpose_ccsd_b1_ccsd ( wf , sigma_a_i , b_a_i ) !! !!    Jacobian transpose CCSD B1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the B1 term, !! !!       - sum_ckdl (b_al L_kcid t_kl&#94;cd + b_ci L_ldka t_kl&#94;cd), !! !!    abd adds it to the transformed vector sigma_a_i. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i ! real ( dp ), dimension (:,:), allocatable :: g_kc_id ! g_kcid real ( dp ), dimension (:,:), allocatable :: L_kcd_i ! L_kcid ! real ( dp ), dimension (:,:), allocatable :: t_l_kcd ! t_kl&#94;cd ! real ( dp ), dimension (:,:), allocatable :: L_a_ldk ! L_ldka real ( dp ), dimension (:,:), allocatable :: t_ldk_c ! t_kl&#94;cd ! real ( dp ), dimension (:,:), allocatable :: X_l_i ! An intermediate, term 1 real ( dp ), dimension (:,:), allocatable :: X_a_c ! An intermediate, term 2 ! !     Indices ! integer ( i15 ) :: i = 0 , d = 0 , c = 0 , k = 0 , id = 0 , ic = 0 , kd = 0 , kc = 0 , kcd = 0 integer ( i15 ) :: ck = 0 , dl = 0 , ckdl = 0 , l = 0 , ldk = 0 , lda = 0 , a = 0 ! !     :: Term 1. - sum_ckdl b_al L_kcid t_kl&#94;cd :: ! !     Form L_kcd_i = L_kcid = 2 * g_kcid - g_kdic !                           = 2 * g_kc_id(kc,id) - g_kc_id(kd,ic) ! call wf % mem % alloc ( g_kc_id , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_id ) ! call wf % mem % alloc ( L_kcd_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) L_kcd_i = zero ! do i = 1 , wf % n_o do d = 1 , wf % n_v ! id = index_two ( i , d , wf % n_o ) ! do c = 1 , wf % n_v ! ic = index_two ( i , c , wf % n_o ) ! do k = 1 , wf % n_o ! kd = index_two ( k , d , wf % n_o ) kc = index_two ( k , c , wf % n_o ) ! kcd = index_three ( k , c , d , wf % n_o , wf % n_v ) ! L_kcd_i ( kcd , i ) = two * g_kc_id ( kc , id ) - g_kc_id ( kd , ic ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_id , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form t_l_kcd = t_kl&#94;cd ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_l_kcd , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) t_l_kcd = zero ! do d = 1 , wf % n_v do c = 1 , wf % n_v do k = 1 , wf % n_o ! ck = index_two ( c , k , wf % n_v ) ! kcd = index_three ( k , c , d , wf % n_o , wf % n_v ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! ckdl = index_packed ( ck , dl ) ! t_l_kcd ( l , kcd ) = wf % t2am ( ckdl , 1 ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !     Calculate the intermediate X_l_i = sum_kcd t_l_kcd L_kcd_i ! call wf % mem % alloc ( X_l_i , wf % n_o , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & t_l_kcd , & wf % n_o , & L_kcd_i , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & zero , & X_l_i , & wf % n_o ) ! !     Add - sum_ckdl b_al L_kcid t_kl&#94;cd = sum_l b_al X_l_i ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & wf % n_o , & - one , & b_a_i , & ! b_al wf % n_v , & X_l_i , & wf % n_o , & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_l_i , wf % n_o , wf % n_o ) ! !     :: Term 2. - sum_ckdl b_ci L_ldka t_kl&#94;cd :: ! !     Form L_a_ldk = L_ldka = L_kcd_i(lda,k) ! call wf % mem % alloc ( L_a_ldk , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) L_a_ldk = zero ! do k = 1 , wf % n_o do d = 1 , wf % n_v do l = 1 , wf % n_o ! ldk = index_three ( l , d , k , wf % n_o , wf % n_v ) ! do a = 1 , wf % n_v ! lda = index_three ( l , d , a , wf % n_o , wf % n_v ) ! L_a_ldk ( a , ldk ) = L_kcd_i ( lda , k ) ! L_ldka ! enddo enddo enddo enddo ! call wf % mem % dealloc ( L_kcd_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! !     Form t_ldk_c = t_kl&#94;cd = t_l_kcd(l, kcd) ! call wf % mem % alloc ( t_ldk_c , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) t_ldk_c = zero ! do c = 1 , wf % n_v do k = 1 , wf % n_o do d = 1 , wf % n_v ! kcd = index_three ( k , c , d , wf % n_o , wf % n_v ) ! do l = 1 , wf % n_o ! ldk = index_three ( l , d , k , wf % n_o , wf % n_v ) ! t_ldk_c ( ldk , c ) = t_l_kcd ( l , kcd ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( t_l_kcd , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! !     Calculate the intermediate X_a_c = sum_ldk L_a_ldk t_ldk_c ! call wf % mem % alloc ( X_a_c , wf % n_v , wf % n_v ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & L_a_ldk , & wf % n_v , & t_ldk_c , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & zero , & X_a_c , & wf % n_v ) ! call wf % mem % dealloc ( L_a_ldk , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( t_ldk_c , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! !     Add - sum_ckdl b_ci L_ldka t_kl&#94;cd = - sum_c X_a_c b_ci ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & wf % n_v , & - one , & X_a_c , & wf % n_v , & b_a_i , & ! b_ci wf % n_v , & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_a_c , wf % n_v , wf % n_v ) ! end subroutine jacobian_transpose_ccsd_b1_ccsd ! ! module subroutine jacobian_transpose_ccsd_c1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!    Jacobian transpose CCSD C1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the C1 term, !! !!       sum_cdl b_cidl g_dlca - sum_kdl b_akdl g_dlik, !! !!    and adds it to the transformed vector sigma_a_i. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! real ( dp ), dimension (:,:), allocatable :: g_dl_ca ! g_dlca real ( dp ), dimension (:,:), allocatable :: g_a_dlc ! g_dlca ! real ( dp ), dimension (:,:), allocatable :: b_dlc_i ! b_cidl ! real ( dp ), dimension (:,:), allocatable :: g_ik_dl ! g_dlik = g_ikdl real ( dp ), dimension (:,:), allocatable :: g_kdl_i ! g_dlik ! integer ( i15 ) :: c = 0 , l = 0 , d = 0 , i = 0 , dl = 0 , dlc = 0 , ci = 0 integer ( i15 ) :: a = 0 , ca = 0 , k = 0 , kdl = 0 , ik = 0 ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 integer ( i15 ) :: batch_dimension = 0 , max_batch_length = 0 , n_batch = 0 ! integer ( i15 ) :: a_batch = 0 , a_length = 0 , a_first = 0 , a_last = 0 ! !     :: Term 1. sum_cdl b_cidl g_dlca :: ! !     Reorder b_ci_dl = b_cidl to b_dlc_i ! call wf % mem % alloc ( b_dlc_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) b_dlc_i = zero ! do c = 1 , wf % n_v do l = 1 , wf % n_o do d = 1 , wf % n_v ! dl = index_two ( d , l , wf % n_v ) ! dlc = index_three ( d , l , c , wf % n_v , wf % n_o ) ! do i = 1 , wf % n_o ! ci = index_two ( c , i , wf % n_v ) ! b_dlc_i ( dlc , i ) = b_ai_bj ( ci , dl ) ! b_cidl ! enddo enddo enddo enddo ! !     Prepare batching over index a ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_first , a_last , a_batch , max_batch_length , batch_dimension ) a_length = a_last - a_first + 1 ! !        Form g_dl_ca ! call wf % mem % alloc ( g_dl_ca , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * a_length ) ! integral_type = 'electronic_repulsion' call wf % get_vo_vv ( integral_type , & g_dl_ca , & 1 , & wf % n_v , & 1 , & wf % n_o , & 1 , & wf % n_v , & a_first , & a_last ) ! !        Add sum_dlc g_dlc_a&#94;T b_dlc_i ! call dgemm ( 'T' , 'N' , & a_length , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & g_dl_ca , & ! \"g_dlc_a\" ( wf % n_o ) * ( wf % n_v ) ** 2 , & b_dlc_i , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & sigma_a_i ( a_first , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( g_dl_ca , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * a_length ) ! enddo ! End of batches over a ! call wf % mem % dealloc ( b_dlc_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! !     :: Term 2. - sum_kdl b_akdl g_dlik = - sum_kdl b_akdl g_ikdl :: ! !     Form g_ik_dl ! call wf % mem % alloc ( g_ik_dl , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_vo ( integral_type , g_ik_dl ) ! !     Add - sum_kdl b_akdl g_dlik = - sum_kdl b_akdl g_kdl_i ! !     Note: we interpret b_ai_bj as b_a_ibj, such that b_ai_bj(a,kdl) = b_akdl ! call dgemm ( 'N' , 'T' , & wf % n_v , & wf % n_o , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & - one , & b_ai_bj , & ! \"b_a_kdl\" wf % n_v , & g_ik_dl , & ! \"g_i_kdl\" ( wf % n_o ), & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( g_ik_dl , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_transpose_ccsd_c1_ccsd ! ! module subroutine jacobian_transpose_ccsd_d1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!    Jacobian transpose CCSD D1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the D1 term, !! !!       - sum_ckdl (b_ckal F_id t_kl&#94;cd + b_ckdi F_la t_kl&#94;cd), !! !!    and adds it to the transformed vector sigma_a_i. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! real ( dp ), dimension (:,:), allocatable :: t_lck_d ! t_kl&#94;cd ! real ( dp ), dimension (:,:), allocatable :: X_a_d ! An intermediate, term 1 real ( dp ), dimension (:,:), allocatable :: X_l_i ! An intermediate, term 2 ! integer ( i15 ) :: l = 0 , k = 0 , c = 0 , ck = 0 , a = 0 , al = 0 integer ( i15 ) :: d = 0 , dl = 0 , ckdl = 0 , ckd = 0 , lck = 0 ! !     :: Term 1. - sum_ckdl b_ckal F_id t_kl&#94;cd :: ! !     Read amplitudes and order as t_lck_d = t_kl&#94;cd ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_lck_d , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) t_lck_d = zero ! do d = 1 , wf % n_v do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! ckdl = index_packed ( ck , dl ) ! lck = index_three ( l , c , k , wf % n_o , wf % n_v ) ! t_lck_d ( lck , d ) = wf % t2am ( ckdl , 1 ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !     Form the intermediate X_a_d = sum_ckl b_a_lck t_lck_d = sum_ckl b_ckal t_kl&#94;cd ! call wf % mem % alloc ( X_a_d , wf % n_v , wf % n_v ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & b_ai_bj , & ! b_a_lck = b_alck = b_ckal wf % n_v , & t_lck_d , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & zero , & X_a_d , & wf % n_v ) ! !     Add - sum_ckdl b_ckal F_id t_kl&#94;cd !           = - sum_d X_a_d F_id !           = - sum_d X_a_d F_i_a&#94;T(d,i) ! call dgemm ( 'N' , 'T' , & wf % n_v , & wf % n_o , & wf % n_v , & - one , & X_a_d , & wf % n_v , & wf % fock_ia , & ! F_i_a wf % n_o , & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_a_d , wf % n_v , wf % n_v ) ! !     :: Term 2. - sum_ckdl b_ckdi F_la t_kl&#94;cd ! !     Form the intermediate X_l_i = sum_ckd t_l_ckd b_ckd_i  = sum_ckd b_ckdi t_kl&#94;cd ! !     Note: we interpret b_ai_bj as b_aib_j, such that b_aib_j(ckd, i) = b_ckdi !           we interpret t_lck_d as t_l_ckd, such that t_l_ckd(l,ckd) = t_kl&#94;cd ! call wf % mem % alloc ( X_l_i , wf % n_o , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & t_lck_d , & ! \"t_l_ckd\" wf % n_o , & b_ai_bj , & ! \"b_ckd_i\" ( wf % n_o ) * ( wf % n_v ) ** 2 , & zero , & X_l_i , & wf % n_o ) ! call wf % mem % dealloc ( t_lck_d , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! !     Add - sum_ckdl b_ckdi F_la t_kl&#94;cd = - sum_l F_la X_l_i = - sum_l F_i_a&#94;T(a,l) X_l_i(l,i) ! call dgemm ( 'T' , 'N' , & wf % n_v , & wf % n_o , & wf % n_o , & - one , & wf % fock_ia , & wf % n_o , & X_l_i , & wf % n_o , & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_l_i , wf % n_o , wf % n_o ) ! end subroutine jacobian_transpose_ccsd_d1_ccsd ! ! module subroutine jacobian_transpose_ccsd_e1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!    Jacobian transpose CCSD E1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the E1 term, !! !!       sum_ckdle (b_ckdi L_dale t_kl&#94;ce + b_ckdl L_deia t_kl&#94;ce) !!      -sum_ckdlm (b_ckal L_ilmd t_km&#94;cd + b_ckdl L_mlia t_km&#94;cd) !! !!    and adds it to the transformed vector sigma_a_i. !! !!    The routine adds the third and forth terms first. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! real ( dp ), dimension (:,:), allocatable :: t_dm_ck ! t_km&#94;cd real ( dp ), dimension (:,:), allocatable :: t_m_ckd ! t_km&#94;cd real ( dp ), dimension (:,:), allocatable :: t_el_ck ! t_lk&#94;ec real ( dp ), dimension (:,:), allocatable :: t_ckl_e ! t_lk&#94;ec ! real ( dp ), dimension (:,:), allocatable :: g_il_md ! g_ilmd real ( dp ), dimension (:,:), allocatable :: g_ml_ia ! g_mlia ! real ( dp ), dimension (:,:), allocatable :: L_il_dm ! L_ilmd real ( dp ), dimension (:,:), allocatable :: L_ai_ml ! L_mlia ! real ( dp ), dimension (:,:), allocatable :: X_il_ck ! An intermediate, term 3 real ( dp ), dimension (:,:), allocatable :: X_lck_i ! Reordered intermediate, term 3 ! real ( dp ), dimension (:,:), allocatable :: X_m_l ! An intermediate, term 4 ! real ( dp ), dimension (:,:), allocatable :: b_a_lck ! b_ckal real ( dp ), dimension (:,:), allocatable :: b_d_ckl ! b_ckdl ! real ( dp ), dimension (:,:), allocatable :: g_da_le ! g_dale real ( dp ), dimension (:,:), allocatable :: L_a_eld ! L_dale ! real ( dp ), dimension (:,:), allocatable :: g_de_ia ! g_deia real ( dp ), dimension (:,:), allocatable :: L_ai_de ! L_deia ! real ( dp ), dimension (:,:), allocatable :: X_el_di ! An intermediate, term 1 ! real ( dp ), dimension (:,:), allocatable :: X_d_e ! An intermediate, term 2 ! integer ( i15 ) :: ml = 0 , md = 0 , ma = 0 , m = 0 , lck = 0 , l = 0 , il = 0 , ck = 0 , i = 0 integer ( i15 ) :: dm = 0 , ckd = 0 , k = 0 , id = 0 , ia = 0 , c = 0 , d = 0 , al = 0 , ai = 0 integer ( i15 ) :: a = 0 , le = 0 , la = 0 , eld = 0 , e = 0 , de = 0 , da = 0 , ie = 0 , el = 0 integer ( i15 ) :: dl = 0 , ckl = 0 ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 integer ( i15 ) :: batch_dimension = 0 , max_batch_length = 0 , n_batch = 0 ! integer ( i15 ) :: a_batch = 0 , a_length = 0 , a_first = 0 , a_last = 0 ! integer ( i15 ) :: e_batch = 0 , e_length = 0 , e_first = 0 , e_last = 0 ! !     :: Term 3. - sum_ckdlm b_ckal L_ilmd t_km&#94;cd :: ! !     Read the amplitudes from disk ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_dm_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_dm_ck = zero ! call squareup ( wf % t2am , t_dm_ck , ( wf % n_o ) * ( wf % n_v )) ! t_dm_ck(dm,ck) = t_mk&#94;dc = t_km&#94;cd ! call wf % destruct_amplitudes ! !     Form g_il_md = g_ilmd ! call wf % mem % alloc ( g_il_md , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_il_md ) ! !     Form L_il_dm = L_ilmd = 2 * g_ilmd - g_idml !                           = 2 * g_ilmd - g_mlid !                           = 2 * g_il_md(il,md) - g_il_md(ml,id) ! call wf % mem % alloc ( L_il_dm , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) L_il_dm = zero ! do m = 1 , wf % n_o do d = 1 , wf % n_v ! dm = index_two ( d , m , wf % n_v ) md = index_two ( m , d , wf % n_o ) ! do l = 1 , wf % n_o ! ml = index_two ( m , l , wf % n_o ) ! do i = 1 , wf % n_o ! id = index_two ( i , d , wf % n_o ) il = index_two ( i , l , wf % n_o ) ! L_il_dm ( il , dm ) = two * g_il_md ( il , md ) - g_il_md ( ml , id ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_il_md , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Form the intermediate X_il_ck = sum_md L_ilmd t_km&#94;cd !                                   = sum_md L_ilmd t_mk&#94;dc !                                   = sum_md L_il_dm t_dm_ck ! call wf % mem % alloc ( X_il_ck , ( wf % n_o ) ** 2 , ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & L_il_dm , & ( wf % n_o ) ** 2 , & t_dm_ck , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_il_ck , & ( wf % n_o ) ** 2 ) ! call wf % mem % dealloc ( L_il_dm , ( wf % n_o ) ** 2 , ( wf % n_v ) * ( wf % n_o )) ! !     Add - sum_ckdlm b_ckal L_ilmd t_km&#94;cd !         = - sum_ckl b_a_lck X_i_lck&#94;T ! call dgemm ( 'N' , 'T' , & wf % n_v , & wf % n_o , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & - one , & b_ai_bj , & ! \"b_a_lck\" (= b_al_ck = b_ai_bj) wf % n_v , & X_il_ck , & ! \"X_i_lck\" wf % n_o , & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_il_ck , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     :: Term 4. - sum_ckdlm b_ckdl L_mlia t_km&#94;cd :: ! !     Form the intermediate X_m_l = sum_ckd t_km&#94;cd b_ckdl !                                 = sum_ckd t_ckd_m&#94;T b_ckd_l ! !     Note: we interpret b_ai_bj as b_aib_j, such that b_aib_j(ckd,l) = b_ckdl !           we interpret t_dm_ck as t_ckd_m ! call wf % mem % alloc ( X_m_l , wf % n_o , wf % n_o ) ! call dgemm ( 'T' , 'N' , & wf % n_o , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & t_dm_ck , & ! t_ckd_m ( wf % n_o ) * ( wf % n_v ) ** 2 , & b_ai_bj , & ! \"b_aib_j\" ( wf % n_o ) * ( wf % n_v ) ** 2 , & zero , & X_m_l , & wf % n_o ) ! call wf % mem % dealloc ( t_dm_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form g_ml_ia = g_mlia ! call wf % mem % alloc ( g_ml_ia , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_ml_ia ) ! !     Form L_ai_ml = L_mlia = 2 * g_mlia - g_mail !                           = 2 * g_mlia - g_ilma ! call wf % mem % alloc ( L_ai_ml , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) L_ai_ml = zero ! do l = 1 , wf % n_o do m = 1 , wf % n_o ! ml = index_two ( m , l , wf % n_o ) ! do i = 1 , wf % n_o ! il = index_two ( i , l , wf % n_o ) ! do a = 1 , wf % n_v ! ma = index_two ( m , a , wf % n_o ) ia = index_two ( i , a , wf % n_o ) ai = index_two ( a , i , wf % n_v ) ! L_ai_ml ( ai , ml ) = two * g_ml_ia ( ml , ia ) - g_ml_ia ( il , ma ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ml_ia , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Add - sum_ckdlm b_ckdl L_mlia t_km&#94;cd = - sum_lm L_ai_ml X_m_l ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & 1 , & ( wf % n_o ) ** 2 , & - one , & L_ai_ml , & ( wf % n_o ) * ( wf % n_v ), & X_m_l , & ! \"X_ml\" ( wf % n_o ) ** 2 , & one , & sigma_a_i , & ! \"sigma_ai\" ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( L_ai_ml , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( X_m_l , wf % n_o , wf % n_o ) ! !     :: Term 1. sum_ckdle b_ckdi L_dale t_kl&#94;ce :: ! !     Read amplitudes from disk ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_el_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_el_ck = zero ! call squareup ( wf % t2am , t_el_ck , ( wf % n_o ) * ( wf % n_v )) ! call wf % destruct_amplitudes ! !     Form the intermediate X_el_di = sum_ck t_kl&#94;ce b_ckdi = sum_ck t_lk&#94;ec b_ckdi !                                   = sum_ck t_el_ck b_ck_di ! call wf % mem % alloc ( X_el_di , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & t_el_ck , & ( wf % n_o ) * ( wf % n_v ), & b_ai_bj , & ! \"b_ck_di\" ( wf % n_o ) * ( wf % n_v ), & zero , & X_el_di , & ( wf % n_o ) * ( wf % n_v )) ! !     sum_dle L_dale X_el_di ! ... reorder L_dale to L_a_eld & interpret X_el_di as X_eld_i ! !     Prepare batching over index a ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_first , a_last , a_batch , max_batch_length , batch_dimension ) a_length = a_last - a_first + 1 ! !        Form g_da_le ! call wf % mem % alloc ( g_da_le , ( wf % n_v ) * a_length , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , & g_da_le , & 1 , & wf % n_v , & a_first , & a_last , & 1 , & wf % n_o , & 1 , & wf % n_v ) ! !        Form  L_a_eld = L_dale = 2 * g_dale - g_dela !                               = 2 * g_da_le(da, le) - g_da_le(de, la) ! call wf % mem % alloc ( L_a_eld , a_length , ( wf % n_o ) * ( wf % n_v ) ** 2 ) L_a_eld = zero ! do d = 1 , wf % n_v do l = 1 , wf % n_o do e = 1 , wf % n_v ! de = index_two ( d , e , wf % n_v ) le = index_two ( l , e , wf % n_o ) ! eld = index_three ( e , l , d , wf % n_v , wf % n_o ) ! do a = 1 , a_length ! la = index_two ( l , a , wf % n_o ) da = index_two ( d , a , wf % n_v ) ! L_a_eld ( a , eld ) = two * g_da_le ( da , le ) - g_da_le ( de , la ) ! L_dale ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_da_le , ( wf % n_v ) * a_length , ( wf % n_o ) * ( wf % n_v )) ! !        Add sum_ckdle b_ckdi L_dale t_kl&#94;ce !            = sum_eld L_a_eld X_el_di ! !        Note: we interpret X_el_di as X_eld_i ! call dgemm ( 'N' , 'N' , & a_length , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & L_a_eld , & a_length , & X_el_di , & ! \"X_eld_i\" ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & sigma_a_i ( a_first , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( L_a_eld , a_length , ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! enddo ! End of batches over a ! !     :: Term 2. sum_ckdle b_ckdl L_deia t_kl&#94;ce :: ! !     Form the intermediate X_d_e = sum_ckl b_ckdl t_kl&#94;ce = sum_ckl b_d_lck t_e_lck&#94;T ! call wf % mem % alloc ( X_d_e , wf % n_v , wf % n_v ) ! call dgemm ( 'N' , 'T' , & wf % n_v , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & b_ai_bj , & ! \"b_d_lck\" = b_dlck = b_ckdl wf % n_v , & t_el_ck , & ! \"t_e_lck\" wf % n_v , & zero , & X_d_e , & wf % n_v ) ! call wf % mem % dealloc ( t_el_ck , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     sum_ckdle b_ckdl L_deia t_kl&#94;ce = sum_de L_deia X_d_e ! !     Prepare batching over index e ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do e_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( e_first , e_last , e_batch , max_batch_length , batch_dimension ) e_length = e_last - e_first + 1 ! !        Form g_de_ia = g_deia ! call wf % mem % alloc ( g_de_ia , ( wf % n_v ) * e_length , ( wf % n_v ) * ( wf % n_o )) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , & g_de_ia , & 1 , & wf % n_v , & e_first , & e_last , & 1 , & wf % n_o , & 1 , & wf % n_v ) ! !        Form L_ai_de = L_deia = 2 * g_deia - g_daie !                              = 2 * g_de_ia(de,ia) - g_de_ia(da,ie) ! !        E: This will not work when batching. We need to split it up in two !        g terms, and batch for each particular contribution. ! call wf % mem % alloc ( L_ai_de , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * e_length ) L_ai_de = zero ! do e = 1 , e_length do d = 1 , wf % n_v ! de = index_two ( d , e , wf % n_v ) ! do i = 1 , wf % n_o ! ie = index_two ( i , e , wf % n_o ) ! do a = 1 , wf % n_v ! da = index_two ( d , a , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ai = index_two ( a , i , wf % n_v ) ! L_ai_de ( ai , de ) = two * g_de_ia ( de , ia ) - g_de_ia ( da , ie ) ! L_deia ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_de_ia , ( wf % n_v ) * e_length , ( wf % n_o ) * ( wf % n_v )) ! !        Calculate the contribution to the sum, ! !           sum_de L_ai_de X_d_e ! !        for the given batch of e: ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & 1 , & ( wf % n_v ) * e_length , & one , & L_ai_de , & ( wf % n_v ) * ( wf % n_o ), & X_d_e ( 1 , e_first ), & ! Trick dgemm into thinking this is an X_de array, ( wf % n_v ) * e_length , & ! with e restricted. one , & sigma_a_i , & ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( L_ai_de , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * e_length ) ! enddo ! End of batches over e ! call wf % mem % dealloc ( X_d_e , wf % n_v , wf % n_v ) ! end subroutine jacobian_transpose_ccsd_e1_ccsd ! ! module subroutine jacobian_transpose_ccsd_f1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!    Jacobian transpose CCSD F1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the F1 term, !! !!       sum_ckdlm (b_akdl t_lm&#94;cd g_ikmc + b_ckal t_ml&#94;cd g_mkid + b_ckdi t_ml&#94;cd g_mkla) !! !!    and adds it to the transformed vector sigma_a_i. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! real ( dp ), dimension (:,:), allocatable :: t_mc_dl ! t_lm&#94;cd real ( dp ), dimension (:,:), allocatable :: t_cl_dm ! t_ml&#94;cd real ( dp ), dimension (:,:), allocatable :: t_cd_ml ! t_ml&#94;cd ! real ( dp ), dimension (:,:), allocatable :: b_ak_cl ! b_ckal real ( dp ), dimension (:,:), allocatable :: b_ki_cd ! b_ckdi ! real ( dp ), dimension (:,:), allocatable :: g_ik_mc ! g_ikmc real ( dp ), dimension (:,:), allocatable :: g_kdm_i ! g_mkid real ( dp ), dimension (:,:), allocatable :: g_a_mkl ! g_mkla ! real ( dp ), dimension (:,:), allocatable :: X_ik_dl ! An intermediate, term 1 ! real ( dp ), dimension (:,:), allocatable :: X_ak_dm ! An intermediate, term 2 ! real ( dp ), dimension (:,:), allocatable :: X_ki_ml ! An intermediate, term 3 real ( dp ), dimension (:,:), allocatable :: X_mkl_i ! Reordered intermediate, term 3 ! integer ( i15 ) :: m = 0 , c = 0 , mc = 0 , k = 0 , l = 0 , kdl = 0 , d = 0 , i = 0 , ik = 0 integer ( i15 ) :: dl = 0 , dm = 0 , cldm = 0 , cl = 0 , mkl = 0 , ml = 0 , mk = 0 , lc = 0 integer ( i15 ) :: ki = 0 , kdm = 0 , kam = 0 , id = 0 , di = 0 , ck = 0 , cd = 0 , al = 0 integer ( i15 ) :: ak = 0 , a = 0 ! !     :: Term 1. sum_ckdlm b_akdl t_lm&#94;cd g_ikmc :: ! !     X_ik_dl = sum_mc t_lm&#94;cd g_ikmc = sum_mc g_ik_mc t_mc_dl ! !     Order amplitudes as t_mc_dl = t_lm&#94;cd ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_mc_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_mc_dl = zero ! do l = 1 , wf % n_o do d = 1 , wf % n_v ! dl = index_two ( d , l , wf % n_v ) ! do c = 1 , wf % n_v ! cl = index_two ( c , l , wf % n_v ) ! do m = 1 , wf % n_o ! dm = index_two ( d , m , wf % n_v ) mc = index_two ( m , c , wf % n_o ) ! cldm = index_packed ( cl , dm ) ! t_mc_dl ( mc , dl ) = wf % t2am ( cldm , 1 ) ! t_lm&#94;cd ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !     Form the integral g_ik_mc ! call wf % mem % alloc ( g_ik_mc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_ik_mc ) ! !     Form the intermediate X_ik_dl = sum_mc t_lm&#94;cd g_ikmc = sum_mc g_ik_mc t_mc_dl ! call wf % mem % alloc ( X_ik_dl , ( wf % n_o ) ** 2 , ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & one , & g_ik_mc , & ( wf % n_o ) ** 2 , & t_mc_dl , & ( wf % n_v ) * ( wf % n_o ), & zero , & X_ik_dl , & ( wf % n_o ) ** 2 ) ! !     Add sum_ckdlm b_akdl t_lm&#94;cd g_ikmc !         = sum_kdl b_a_kdl X_i_kdl&#94;T ! !     Note: we interpret b_ai_bj as b_a_ibj !           we interpret X_ik_dl as X_i_kdl ! call dgemm ( 'N' , 'T' , & wf % n_v , & wf % n_o , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & b_ai_bj , & ! \"b_a_ibj\" wf % n_v , & X_ik_dl , & ! \"X_i_kdl\" wf % n_o , & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_ik_dl , ( wf % n_o ) ** 2 , ( wf % n_v ) * ( wf % n_o )) ! !     :: Term 2. sum_ckdlm b_ckal t_ml&#94;cd g_mkid :: ! !     X_ak_dm = sum_cl b_ckal t_ml&#94;cd !             = sum_cl b_ak_cl t_cl_dm ! !     We have t_mc_dl(mc,dl) = t_lm&#94;cd !     Reorder t_cl_dm(cl,dm) = t_mc_dl(lc,dm) = t_ml&#94;cd ! call wf % mem % alloc ( t_cl_dm , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) t_cl_dm = zero ! do m = 1 , wf % n_o do d = 1 , wf % n_v ! dm = index_two ( d , m , wf % n_v ) ! do l = 1 , wf % n_o do c = 1 , wf % n_v ! lc = index_two ( l , c , wf % n_o ) cl = index_two ( c , l , wf % n_v ) ! t_cl_dm ( cl , dm ) = t_mc_dl ( lc , dm ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( t_mc_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Reorder to b_ak_cl = b_ckal ! call wf % mem % alloc ( b_ak_cl , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) b_ak_cl = zero ! do l = 1 , wf % n_o do c = 1 , wf % n_v ! cl = index_two ( c , l , wf % n_v ) ! do k = 1 , wf % n_o ! ck = index_two ( c , k , wf % n_v ) ! do a = 1 , wf % n_v ! al = index_two ( a , l , wf % n_v ) ak = index_two ( a , k , wf % n_v ) ! b_ak_cl ( ak , cl ) = b_ai_bj ( ck , al ) ! b_ckal ! enddo enddo enddo enddo ! !     Form the intermediate X_ak_dm = sum_cl b_ak_cl t_cl_dm ! call wf % mem % alloc ( X_ak_dm , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & one , & b_ak_cl , & ( wf % n_v ) * ( wf % n_o ), & t_cl_dm , & ( wf % n_v ) * ( wf % n_o ), & zero , & X_ak_dm , & ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( b_ak_cl , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     sum_ckdlm b_ckal t_ml&#94;cd g_mkid = sum_kdm X_ak_dm g_mkid ! !     We have g_ik_mc(ik,mc) = g_ikmc !     Reorder to g_kdm_i(kdm,i) = g_mkid = g_ik_mc(mk, id) ! call wf % mem % alloc ( g_kdm_i , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_o ) g_kdm_i = zero ! do i = 1 , wf % n_o do m = 1 , wf % n_o do d = 1 , wf % n_v ! id = index_two ( i , d , wf % n_o ) ! do k = 1 , wf % n_o ! mk = index_two ( m , k , wf % n_o ) ! kdm = index_three ( k , d , m , wf % n_o , wf % n_v ) ! g_kdm_i ( kdm , i ) = g_ik_mc ( mk , id ) ! g_mkid ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ik_mc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Add sum_ckdlm b_ckal t_ml&#94;cd g_mkid = sum_kdm X_ak_dm g_mkid !                                         = sum_kdm X_ak_dm g_kdm_i ! !     Note: we interpret X_ak_dm as X_a_kdm ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & X_ak_dm , & ! \"X_a_kdm\" wf % n_v , & g_kdm_i , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_ak_dm , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     :: Term 3. sum_ckdlm b_ckdi t_ml&#94;cd g_mkla :: ! !     X_ki_ml = sum_cd b_ckdi t_ml&#94;cd ! !     We have t_cl_dm(cl,dm) = t_ml&#94;cd !     Reorder to t_cd_ml(cd,ml) = t_cl_dm(cl,dm) = t_ml&#94;cd ! call wf % mem % alloc ( t_cd_ml , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) t_cd_ml = zero ! do l = 1 , wf % n_o do m = 1 , wf % n_o ! ml = index_two ( m , l , wf % n_o ) ! do d = 1 , wf % n_v ! dm = index_two ( d , m , wf % n_v ) ! do c = 1 , wf % n_v ! cl = index_two ( c , l , wf % n_v ) cd = index_two ( c , d , wf % n_v ) ! t_cd_ml ( cd , ml ) = t_cl_dm ( cl , dm ) ! t_ml&#94;cd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( t_cl_dm , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Reorder to b_ki_cd = b_ckdi ! call wf % mem % alloc ( b_ki_cd , ( wf % n_o ) ** 2 , ( wf % n_v ) ** 2 ) b_ki_cd = zero ! do d = 1 , wf % n_v do c = 1 , wf % n_v ! cd = index_two ( c , d , wf % n_v ) ! do i = 1 , wf % n_o ! di = index_two ( d , i , wf % n_v ) ! do k = 1 , wf % n_o ! ck = index_two ( c , k , wf % n_v ) ki = index_two ( k , i , wf % n_o ) ! b_ki_cd ( ki , cd ) = b_ai_bj ( ck , di ) ! b_ckdi ! enddo enddo enddo enddo ! !     Form intermediate X_ki_ml = sum_cd b_ckdi t_ml&#94;cd = sum_cd b_ki_cd t_cd_ml ! call wf % mem % alloc ( X_ki_ml , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & b_ki_cd , & ( wf % n_o ) ** 2 , & t_cd_ml , & ( wf % n_v ) ** 2 , & zero , & X_ki_ml , & ( wf % n_o ) ** 2 ) ! call wf % mem % dealloc ( t_cd_ml , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( b_ki_cd , ( wf % n_o ) ** 2 , ( wf % n_v ) ** 2 ) ! !     sum_ckdlm b_ckdi t_ml&#94;cd g_mkla = sum_klm g_mkla X_ki_ml ! !     Reorder to X_mkl_i ! call wf % mem % alloc ( X_mkl_i , ( wf % n_o ) ** 3 , wf % n_o ) X_mkl_i = zero ! do l = 1 , wf % n_o do k = 1 , wf % n_o do m = 1 , wf % n_o ! ml = index_two ( m , l , wf % n_o ) ! mkl = index_three ( m , k , l , wf % n_o , wf % n_o ) ! do i = 1 , wf % n_o ! ki = index_two ( k , i , wf % n_o ) ! X_mkl_i ( mkl , i ) = X_ki_ml ( ki , ml ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( X_ki_ml , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! !     We have g_kdm_i(kdm,i) = g_mkid !     Reorder to g_a_mkl(a,mkl) = g_mkla = g_kdm_i(kam,l) ! call wf % mem % alloc ( g_a_mkl , wf % n_v , ( wf % n_o ) ** 3 ) g_a_mkl = zero ! do l = 1 , wf % n_o do k = 1 , wf % n_o do m = 1 , wf % n_o ! mkl = index_three ( m , k , l , wf % n_o , wf % n_o ) ! do a = 1 , wf % n_v ! kam = index_three ( k , a , m , wf % n_o , wf % n_v ) ! g_a_mkl ( a , mkl ) = g_kdm_i ( kam , l ) ! g_mkla ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kdm_i , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_o ) ! !     Add sum_ckdlm b_ckdi t_ml&#94;cd g_mkla = sum_klm g_a_mkl X_mkl_i ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & ( wf % n_o ) ** 3 , & one , & g_a_mkl , & wf % n_v , & X_mkl_i , & ( wf % n_o ) ** 3 , & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( g_a_mkl , wf % n_v , ( wf % n_o ) ** 3 ) call wf % mem % dealloc ( X_mkl_i , ( wf % n_o ) ** 3 , wf % n_o ) ! end subroutine jacobian_transpose_ccsd_f1_ccsd ! ! module subroutine jacobian_transpose_ccsd_g1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!    Jacobian transpose CCSD G1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the G1 term, !! !!       - sum_ckdle (b_akdl t_kl&#94;ce g_icde + b_cidl t_kl&#94;ce g_kade + b_cldi t_kl&#94;ce g_keda) !! !!    and adds it to the transformed vector sigma_a_i. !! !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! real ( dp ), dimension (:,:), allocatable :: b_di_cl ! b_cidl ! real ( dp ), dimension (:,:), allocatable :: X_di_ek ! An intermediate, term 2 real ( dp ), dimension (:,:), allocatable :: X_kde_i ! Reordered intermediate, term 2 ! real ( dp ), dimension (:,:), allocatable :: X_ked_i ! Reordered intermediate, term 3 ! real ( dp ), dimension (:,:), allocatable :: X_id_kl ! An intermediate, term 1 real ( dp ), dimension (:,:), allocatable :: X_kdl_i ! Reordered intermediate, term 1 ! real ( dp ), dimension (:,:), allocatable :: t_cl_ek ! t_kl&#94;ce real ( dp ), dimension (:,:), allocatable :: t_ce_kl ! t_kl&#94;ce ! real ( dp ), dimension (:,:), allocatable :: g_ka_de ! g_kade real ( dp ), dimension (:,:), allocatable :: g_a_kde ! g_kade real ( dp ), dimension (:,:), allocatable :: g_ke_da ! g_keda real ( dp ), dimension (:,:), allocatable :: g_ic_de ! g_icde real ( dp ), dimension (:,:), allocatable :: g_id_ce ! g_icde ! integer ( i15 ) :: l = 0 , kde = 0 , ka = 0 , k = 0 , i = 0 , el = 0 , ek = 0 , e = 0 integer ( i15 ) :: dl = 0 , di = 0 , de = 0 , d = 0 , cl = 0 , ckel = 0 , ci = 0 , ck = 0 , ked = 0 integer ( i15 ) :: c = 0 , a = 0 , kl = 0 , ke = 0 , id = 0 , ic = 0 , kdl = 0 , da = 0 , ce = 0 ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 integer ( i15 ) :: batch_dimension = 0 , max_batch_length = 0 , n_batch = 0 ! integer ( i15 ) :: a_batch = 0 , a_length = 0 , a_first = 0 , a_last = 0 integer ( i15 ) :: e_batch = 0 , e_length = 0 , e_first = 0 , e_last = 0 , offset_kde = 0 integer ( i15 ) :: d_batch = 0 , d_length = 0 , d_first = 0 , d_last = 0 , offset_id = 0 ! !     :: Term 2. - sum_ckdle b_cidl t_kl&#94;ce g_kade :: ! !     X_di_ek = sum_cl b_cidl t_kl&#94;ce = sum_cl b_di_cl t_cl_ek ! !     Reorder to b_di_cl = b_cidl ! call wf % mem % alloc ( b_di_cl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) b_di_cl = zero ! do l = 1 , wf % n_o do c = 1 , wf % n_v ! cl = index_two ( c , l , wf % n_v ) ! do i = 1 , wf % n_o ! ci = index_two ( c , i , wf % n_v ) ! do d = 1 , wf % n_v ! di = index_two ( d , i , wf % n_v ) dl = index_two ( d , l , wf % n_v ) ! b_di_cl ( di , cl ) = b_ai_bj ( ci , dl ) ! b_cidl ! enddo enddo enddo enddo ! !     Order amplitudes as t_cl_ek = t_kl&#94;ce ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_cl_ek , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_cl_ek = zero ! do k = 1 , wf % n_o do e = 1 , wf % n_v ! ek = index_two ( e , k , wf % n_v ) ! do l = 1 , wf % n_o ! el = index_two ( e , l , wf % n_v ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) cl = index_two ( c , l , wf % n_v ) ! ckel = index_packed ( ck , el ) ! t_cl_ek ( cl , ek ) = wf % t2am ( ckel , 1 ) ! t_kl&#94;ce ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !     Form the intermediate X_di_ek = sum_cl b_di_cl t_cl_ek ! call wf % mem % alloc ( X_di_ek , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & b_di_cl , & ( wf % n_o ) * ( wf % n_v ), & t_cl_ek , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_di_ek , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( b_di_cl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     - sum_ckdle b_cidl t_kl&#94;ce g_kade = sum_kde g_kade X_di_ek ! !     Reorder X_di_ek to X_kde_i ! call wf % mem % alloc ( X_kde_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) X_kde_i = zero ! do i = 1 , wf % n_o do e = 1 , wf % n_v do d = 1 , wf % n_v ! di = index_two ( d , i , wf % n_v ) ! do k = 1 , wf % n_o ! ek = index_two ( e , k , wf % n_v ) ! kde = index_three ( k , d , e , wf % n_o , wf % n_v ) ! X_kde_i ( kde , i ) = X_di_ek ( di , ek ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( X_di_ek , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Prepare batching over index e ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do e_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( e_first , e_last , e_batch , max_batch_length , batch_dimension ) e_length = e_last - e_first + 1 ! !        Form g_ka_de = g_kade ! call wf % mem % alloc ( g_ka_de , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * e_length ) ! integral_type = 'electronic_repulsion' call wf % get_ov_vv ( integral_type , & g_ka_de , & 1 , & wf % n_o , & 1 , & wf % n_v , & 1 , & wf % n_v , & e_first , & e_last ) ! !        Reorder to g_a_kde = g_ka_de = g_kade ! call wf % mem % alloc ( g_a_kde , wf % n_v , ( wf % n_o ) * ( wf % n_v ) * e_length ) g_a_kde = zero ! do e = 1 , e_length do d = 1 , wf % n_v ! de = index_two ( d , e , wf % n_v ) ! do k = 1 , wf % n_o ! kde = index_three ( k , d , e , wf % n_o , wf % n_v ) ! do a = 1 , wf % n_v ! ka = index_two ( k , a , wf % n_o ) ! g_a_kde ( a , kde ) = g_ka_de ( ka , de ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ka_de , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * e_length ) ! !        Add the contribution of ! !           - sum_ckdle b_cidl t_kl&#94;ce g_kade = sum_kde g_a_kde X_kde_i ! !        arising from the present batch over e ! offset_kde = index_three ( 1 , 1 , e_first , wf % n_o , wf % n_v ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) * e_length , & - one , & g_a_kde , & wf % n_v , & X_kde_i ( offset_kde , 1 ), & ! First element to use ( wf % n_o ) * ( wf % n_v ) ** 2 , & ! Full space dimension of X_kde_i one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( g_a_kde , wf % n_v , ( wf % n_o ) * ( wf % n_v ) * e_length ) ! enddo ! End of batches over e ! call wf % mem % dealloc ( X_kde_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! !     :: Term 3. - sum_ckdle b_cldi t_kl&#94;ce g_keda :: ! !     X_di_ek = sum_cl b_cldi t_kl&#94;ce = sum_cl b_di_cl t_cl_ek ! !     We have t_cl_ek = t_kl&#94;ce, so this can be used unaltered !     b_ai_bj(cl,di) = b_cldi & hence b_ai&#94;bj&#94;T(di,cl) = b_cldi ! call wf % mem % alloc ( X_di_ek , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'T' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & b_ai_bj , & ! \"b_cl_di\" ( wf % n_o ) * ( wf % n_v ), & t_cl_ek , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_di_ek , & ( wf % n_o ) * ( wf % n_v )) ! !     - sum_kde X_di_ek g_keda ! !     Reorder X_di_ek to X_ked_i ! call wf % mem % alloc ( X_ked_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) X_ked_i = zero ! do i = 1 , wf % n_o do e = 1 , wf % n_v do d = 1 , wf % n_v ! di = index_two ( d , i , wf % n_v ) ! do k = 1 , wf % n_o ! ek = index_two ( e , k , wf % n_v ) ! ked = index_three ( k , e , d , wf % n_o , wf % n_v ) ! X_ked_i ( ked , i ) = X_di_ek ( di , ek ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( X_di_ek , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Prepare batching over a ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_first , a_last , a_batch , max_batch_length , batch_dimension ) a_length = a_last - a_first + 1 ! !        Form g_ke_da = g_keda ! call wf % mem % alloc ( g_ke_da , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * a_length ) ! integral_type = 'electronic_repulsion' call wf % get_ov_vv ( integral_type , & g_ke_da , & 1 , & wf % n_o , & 1 , & wf % n_v , & 1 , & wf % n_v , & a_first , & a_last ) ! !        Add ! !            - sum_ckdle b_cldi t_kl&#94;ce g_keda !                 = -sum_kde g_ked_a&#94;T X_ked_i ! !        for the current batch of a's ! call dgemm ( 'T' , 'N' , & a_length , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & - one , & g_ke_da , & ! \"g_ked_a\" ( wf % n_o ) * ( wf % n_v ) ** 2 , & X_ked_i , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & sigma_a_i ( a_first , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( g_ke_da , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * a_length ) ! enddo ! End of batches over a ! call wf % mem % dealloc ( X_ked_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! !     :: Term 1. - sum_ckdle b_akdl t_kl&#94;ce g_icde :: ! !     X_id_kl = sum_ce t_kl&#94;ce g_icde = sum_ce g_id_ce t_ce_kl ! !     We have t_cl_ek = t_kl&#94;ce !     Reorder to t_ce_kl = t_cl_ek = t_kl&#94;ce ! call wf % mem % alloc ( t_ce_kl , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) t_ce_kl = zero ! do l = 1 , wf % n_o do k = 1 , wf % n_o ! kl = index_two ( k , l , wf % n_o ) ! do e = 1 , wf % n_v ! ek = index_two ( e , k , wf % n_v ) ! do c = 1 , wf % n_v ! cl = index_two ( c , l , wf % n_v ) ce = index_two ( c , e , wf % n_v ) ! t_ce_kl ( ce , kl ) = t_cl_ek ( cl , ek ) ! t_kl&#94;ce ! enddo enddo enddo enddo ! call wf % mem % dealloc ( t_cl_ek , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % alloc ( X_id_kl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) X_id_kl = zero ! !     Prepare for batching over d ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index d max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do d_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( d_first , d_last , d_batch , max_batch_length , batch_dimension ) d_length = d_last - d_first + 1 ! !        Form g_ic_de = g_icde ! call wf % mem % alloc ( g_ic_de , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * d_length ) ! integral_type = 'electronic_repulsion' call wf % get_ov_vv ( integral_type , & g_ic_de , & 1 , & wf % n_o , & 1 , & wf % n_v , & d_first , & d_last , & 1 , & wf % n_v ) ! !        Reorder to g_id_ce = g_ic_de ! call wf % mem % alloc ( g_id_ce , ( wf % n_o ) * d_length , ( wf % n_v ) ** 2 ) g_id_ce = zero ! do e = 1 , wf % n_v do c = 1 , wf % n_v ! ce = index_two ( c , e , wf % n_v ) ! do d = 1 , d_length ! de = index_two ( d , e , d_length ) ! do i = 1 , wf % n_o ! ic = index_two ( i , c , wf % n_o ) id = index_two ( i , d , wf % n_o ) ! g_id_ce ( id , ce ) = g_ic_de ( ic , de ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ic_de , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) ** 2 ) ! !        Add the contribution ! !           X_id_kl = sum_ce t_kl&#94;ce g_icde = sum_ce g_id_ce t_ce_kl ! !        from the current batch of d ! offset_id = index_two ( 1 , d_first , wf % n_o ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * d_length , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & g_id_ce , & ( wf % n_o ) * d_length , & t_ce_kl , & ( wf % n_v ) ** 2 , & one , & X_id_kl ( offset_id , 1 ), & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( g_id_ce , ( wf % n_o ) * d_length , ( wf % n_v ) ** 2 ) ! enddo ! End of batches over d ! call wf % mem % dealloc ( t_ce_kl , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! !     - sum_ckdle b_akdl t_kl&#94;ce g_icde = sum_kdl b_akdl X_id_kl ! !     Reorder to X_kdl_i = X_id_kl ! call wf % mem % alloc ( X_kdl_i , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_o ) X_kdl_i = zero ! do i = 1 , wf % n_o do l = 1 , wf % n_o do k = 1 , wf % n_o ! kl = index_two ( k , l , wf % n_o ) ! do d = 1 , wf % n_v ! id = index_two ( i , d , wf % n_o ) ! kdl = index_three ( k , d , l , wf % n_o , wf % n_v ) ! X_kdl_i ( kdl , i ) = X_id_kl ( id , kl ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( X_id_kl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) ! !     Add - sum_ckdle b_akdl t_kl&#94;ce g_icde = - sum_dkl b_a_kdl X_kdl_i ! !     Note: we interpret b_ai_bj as b_a_ibj ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & - one , & b_ai_bj , & ! \"b_a_ibj\" wf % n_v , & X_kdl_i , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & sigma_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_kdl_i , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_o ) ! end subroutine jacobian_transpose_ccsd_g1_ccsd ! ! module subroutine jacobian_transpose_ccsd_a2_ccsd ( wf , sigma_ai_bj , b_a_i ) !! !!    Jacobian transpose CCSD A2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the A2 term, !! !!       2 F_jb b_ai - F_ib b_aj - sum_k L_ikjb b_ak + sum_c L_cajb b_ci !! !!    and adds it to the transformed vector sigma_ai_bj. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! real ( dp ), dimension (:,:), allocatable :: g_ik_jb ! g_ikjb real ( dp ), dimension (:,:), allocatable :: L_k_ibj ! L_ikjb ! real ( dp ), dimension (:,:), allocatable :: g_ca_jb ! g_cajb real ( dp ), dimension (:,:), allocatable :: g_cb_ja ! g_cbja ! real ( dp ), dimension (:,:), allocatable :: sigma_i_ajb ! sigma_ai_bj contribution real ( dp ), dimension (:,:), allocatable :: sigma_i_bja ! sigma_ai_bj contribution ! integer ( i15 ) :: i = 0 , a = 0 , j = 0 , b = 0 , ai = 0 , bj = 0 , k = 0 , jk = 0 , jb = 0 integer ( i15 ) :: ik = 0 , ibj = 0 , ib = 0 , bja = 0 , ajb = 0 ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 integer ( i15 ) :: batch_dimension = 0 , max_batch_length = 0 , n_batch = 0 ! integer ( i15 ) :: a_batch = 0 , a_length = 0 , a_first = 0 , a_last = 0 integer ( i15 ) :: b_batch = 0 , b_length = 0 , b_first = 0 , b_last = 0 ! !     :: Term 1 & 2. 2 F_jb b_ai - F_ib b_aj :: ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! sigma_ai_bj ( ai , bj ) = sigma_ai_bj ( ai , bj ) & + two * ( wf % fock_ia ( j , b )) * b_a_i ( a , i ) & - ( wf % fock_ia ( i , b )) * b_a_i ( a , j ) ! enddo enddo enddo enddo ! !     :: Term 3. - sum_k L_ikjb b_ak :: ! !     Form g_ik_jb = g_ikjb ! ! call wf % mem % alloc ( g_ik_jb , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_ik_jb ) ! !     Form L_k_ibj = L_ikjb = 2 * g_ikjb - g_ibjk !                           = 2 * g_ikjb - g_jkib !                           = 2 * g_ik_jb(ik,jb) - g_ik_jb(jk,ib) ! call wf % mem % alloc ( L_k_ibj , wf % n_o , ( wf % n_v ) * ( wf % n_o ) ** 2 ) L_k_ibj = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! jb = index_two ( j , b , wf % n_o ) ! do i = 1 , wf % n_o ! ib = index_two ( i , b , wf % n_o ) ! ibj = index_three ( i , b , j , wf % n_o , wf % n_v ) ! do k = 1 , wf % n_o ! jk = index_two ( j , k , wf % n_o ) ik = index_two ( i , k , wf % n_o ) ! L_k_ibj ( k , ibj ) = two * g_ik_jb ( ik , jb ) - g_ik_jb ( jk , ib ) ! L_ikjb ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ik_jb , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Add - sum_k L_ikjb b_ak = - sum_k b_ak L_k_ibj ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_o , & - one , & b_a_i , & ! \"b_a_k\" wf % n_v , & L_k_ibj , & wf % n_o , & one , & sigma_ai_bj , & ! \"sigma_a_ibj\" wf % n_v ) ! call wf % mem % dealloc ( L_k_ibj , wf % n_o , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !     :: Term 4. 2 sum_c g_cajb b_ci - sum_c g_cbja b_ci :: ! !     2 sum_c g_cajb ! !     Prepare for batching over a ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_first , a_last , a_batch , max_batch_length , batch_dimension ) a_length = a_last - a_first + 1 ! !        Form g_ca_jb ! call wf % mem % alloc ( g_ca_jb , ( wf % n_v ) * a_length , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , & g_ca_jb , & 1 , & wf % n_v , & a_first , & a_last , & 1 , & wf % n_o , & 1 , & wf % n_v ) ! !        Add 2 sum_c g_cajb b_ci = 2 sum_c b_c_i&#94;T(i,c) g_c_ajb ! call wf % mem % alloc ( sigma_i_ajb , wf % n_o , ( wf % n_o ) * ( wf % n_v ) * a_length ) ! call dgemm ( 'T' , 'N' , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) * a_length , & wf % n_v , & two , & b_a_i , & ! \"b_c_i\" wf % n_v , & g_ca_jb , & ! \"g_c_ajb\" wf % n_v , & zero , & sigma_i_ajb , & wf % n_o ) ! call wf % mem % dealloc ( g_ca_jb , ( wf % n_v ) * a_length , ( wf % n_o ) * ( wf % n_v )) ! do i = 1 , wf % n_o do a = 1 , a_length ! Ai = index_two ( a + a_first - 1 , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! ajb = index_three ( a , j , b , a_length , wf % n_o ) ! sigma_ai_bj ( Ai , bj ) = sigma_ai_bj ( Ai , bj ) + sigma_i_ajb ( i , ajb ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_i_ajb , wf % n_o , ( wf % n_o ) * ( wf % n_v ) * a_length ) ! enddo ! End of batches over a ! !     - sum_c g_cbja b_ci ! !     Prepare for batching over b ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index b max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of b batches ! do b_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( b_first , b_last , b_batch , max_batch_length , batch_dimension ) b_length = b_last - b_first + 1 ! !        Form g_cb_ja = g_cbja ! call wf % mem % alloc ( g_cb_ja , ( wf % n_v ) * b_length , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' ! call wf % get_vv_ov ( integral_type , & g_cb_ja , & 1 , & wf % n_v , & b_first , & b_last , & 1 , & wf % n_o , & 1 , & wf % n_v ) ! !         Form - sum_c g_cbja b_ci = - sum_c b_ci&#94;T(i,c) g_c_bja ! call wf % mem % alloc ( sigma_i_bja , wf % n_o , ( wf % n_o ) * ( wf % n_v ) * b_length ) ! call dgemm ( 'T' , 'N' , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) * b_length , & wf % n_v , & - one , & b_a_i , & ! \"b_c_i\" wf % n_v , & g_cb_ja , & ! \"g_c_bja\" wf % n_v , & zero , & sigma_i_bja , & wf % n_o ) ! call wf % mem % dealloc ( g_cb_ja , ( wf % n_v ) * b_length , ( wf % n_o ) * ( wf % n_v )) ! !        Add it to sigma_ai_bj ! do j = 1 , wf % n_o do b = 1 , b_length ! Bj = index_two ( b + b_first - 1 , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! bja = index_three ( b , j , a , b_length , wf % n_o ) ! sigma_ai_bj ( ai , Bj ) = sigma_ai_bj ( ai , Bj ) & + sigma_i_bja ( i , bja ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_i_bja , wf % n_o , b_length * ( wf % n_o ) * ( wf % n_v )) ! enddo ! End of batches over b ! end subroutine jacobian_transpose_ccsd_a2_ccsd ! ! module subroutine jacobian_transpose_ccsd_b2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!    Jacobian transpose CCSD B2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the B2 term, !! !!       sum_c b_aicj F_cb - sum_k b_aibk F_jk + sum_ck b_aick L_ckjb !! !!    and adds it to the transformed vector sigma_ai_bj. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! real ( dp ), dimension (:,:), allocatable :: b_aij_c ! b_aicj ! real ( dp ), dimension (:,:), allocatable :: sigma_aij_b ! sigma_ai_bj contribution ! real ( dp ), dimension (:,:), allocatable :: g_ck_jb ! g_ckjb real ( dp ), dimension (:,:), allocatable :: g_ck_bj ! g_ckjb & g_cbjk ! real ( dp ), dimension (:,:), allocatable :: g_cb_jk ! g_cbjk real ( dp ), dimension (:,:), allocatable :: g_cb_jk_restricted ! g_cbjk, batch over b ! integer ( i15 ) :: c = 0 , j = 0 , i = 0 , a = 0 , cj = 0 , ai = 0 , bj = 0 , aij = 0 , b = 0 integer ( i15 ) :: jb = 0 , jk = 0 , k = 0 , ck = 0 , cb = 0 , cb_restricted = 0 , bj_full = 0 ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 integer ( i15 ) :: batch_dimension = 0 , max_batch_length = 0 , n_batch = 0 ! integer ( i15 ) :: b_batch = 0 , b_length = 0 , b_first = 0 , b_last = 0 , cb_offset = 0 ! !     :: Term 1. sum_c b_aicj F_cb :: ! !     Reorder to b_aij_c = b_aicj ! call wf % mem % alloc ( b_aij_c , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) b_aij_c = zero ! do c = 1 , wf % n_v do j = 1 , wf % n_o ! cj = index_two ( c , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! b_aij_c ( aij , c ) = b_ai_bj ( ai , cj ) ! b_aicj ! enddo enddo enddo enddo ! !     Calculate and add sum_c b_aicj F_cb = sum_c b_aij_c F_c_b ! call wf % mem % alloc ( sigma_aij_b , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_v , & wf % n_v , & one , & b_aij_c , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % fock_ab , & ! \"F_c_b\" wf % n_v , & zero , & sigma_aij_b , & ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call wf % mem % dealloc ( b_aij_c , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! sigma_ai_bj ( ai , bj ) = sigma_ai_bj ( ai , bj ) + sigma_aij_b ( aij , b ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_aij_b , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! !     :: Term 2. - sum_k b_aibk F_jk :: ! !     - sum_k b_aibk F_jk = - sum_k b_aib_k F_jk&#94;T(k,j) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & wf % n_o , & wf % n_o , & - one , & b_ai_bj , & ! \"b_aib_k\" ( wf % n_o ) * ( wf % n_v ) ** 2 , & wf % fock_ij , & ! \"F_j_k\" wf % n_o , & one , & sigma_ai_bj , & ! \"sigma_aib_j\" ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! !     :: Term 3. sum_ck b_aick L_ckjb :: ! !     Form g_ck_jb ! call wf % mem % alloc ( g_ck_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vo_ov ( integral_type , g_ck_jb ) ! !     Reorder to g_ck_bj = g_ck_jb = g_ckjb ! call wf % mem % alloc ( g_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ck_bj = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) jb = index_two ( j , b , wf % n_o ) ! do I = 1 , ( wf % n_o ) * ( wf % n_v ) ! g_ck_bj ( I , bj ) = g_ck_jb ( I , jb ) ! g_ckjb ! enddo enddo enddo ! call wf % mem % dealloc ( g_ck_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Add 2 * sum_ck b_aick g_ckjb = 2 * sum_ck b_aick g_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & two , & b_ai_bj , & ! \"b_ai_ck\" ( wf % n_o ) * ( wf % n_v ), & g_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & sigma_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( g_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     - sum_ck b_aick g_cbjk ! !     Prepare to batch over b to make g_cb_jk = g_cbjk successively ! call wf % mem % alloc ( g_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! g_cbjk reordered g_ck_bj = zero ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index b max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of b batches ! do b_batch = 1 , n_batch ! !        For each batch, get the limits for the b index ! call batch_limits ( b_first , b_last , b_batch , max_batch_length , batch_dimension ) b_length = b_last - b_first + 1 ! !        Form g_cb_jk = g_cbjk ! call wf % mem % alloc ( g_cb_jk_restricted , ( wf % n_v ) * b_length , ( wf % n_o ) ** 2 ) ! integral_type = 'electronic_repulsion' call wf % get_vv_oo ( integral_type , & g_cb_jk_restricted , & 1 , & wf % n_v , & b_first , & b_last , & 1 , & wf % n_o , & 1 , & wf % n_o ) ! !        Place in reordered full space vector and deallocate restricted vector ! do k = 1 , wf % n_o do j = 1 , wf % n_o do b = b_first , b_last do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) jk = index_two ( j , k , wf % n_o ) ! cb_restricted = index_two ( c , b - b_first + 1 , wf % n_v ) ! bj_full = index_two ( b , j , wf % n_v ) ! g_ck_bj ( ck , bj_full ) = g_cb_jk_restricted ( cb_restricted , jk ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_cb_jk_restricted , ( wf % n_v ) * b_length , ( wf % n_o ) ** 2 ) ! enddo ! End of batches over b ! !     Add  - sum_ck b_aick g_cbjk = - sum_ck b_ai_ck g_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & b_ai_bj , & ! \"b_ai_ck\" ( wf % n_o ) * ( wf % n_v ), & g_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & sigma_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( g_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_transpose_ccsd_b2_ccsd ! ! module subroutine jacobian_transpose_ccsd_c2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!    Jacobian transpose CCSD C2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the C2 term, !! !!       - sum_ck (b_ajck g_ibck + b_akcj g_ikcb) !! !!    and adds it to the transformed vector sigma_ai_bj. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! real ( dp ), dimension (:,:), allocatable :: L_ib_J real ( dp ), dimension (:,:), allocatable :: L_ck_J real ( dp ), dimension (:,:), allocatable :: L_ik_J real ( dp ), dimension (:,:), allocatable :: L_cb_J ! real ( dp ), dimension (:,:), allocatable :: g_ib_ck ! g_ibck real ( dp ), dimension (:,:), allocatable :: g_cb_ik ! g_cbik real ( dp ), dimension (:,:), allocatable :: g_ck_bi ! g_cbik ! real ( dp ), dimension (:,:), allocatable :: sigma_aj_ib ! sigma_ai_bj contribution real ( dp ), dimension (:,:), allocatable :: sigma_aj_bi ! sigma_ai_bj contribution ! real ( dp ), dimension (:,:), allocatable :: b_aj_ck ! b_akcj ! integer ( i15 ) :: k = 0 , j = 0 , ik = 0 , ib = 0 , i = 0 , ck = 0 , cj = 0 , cb = 0 , c = 0 integer ( i15 ) :: bj = 0 , bi = 0 , b = 0 , ak = 0 , aj = 0 , ai = 0 , a = 0 ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 integer ( i15 ) :: batch_dimension = 0 , max_batch_length = 0 , n_batch = 0 ! integer ( i15 ) :: b_batch = 0 , b_length = 0 , b_first = 0 , b_last = 0 , cb_offset = 0 ! !     :: Term 1. - sum_ck b_ajck g_ibck :: ! !     Form g_ib_ck ! call wf % mem % alloc ( g_ib_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_vo ( integral_type , g_ib_ck ) ! !     Calculate and add - sum_ck b_ajck g_ibck = - sum_ck b_aj_ck g_ib_ck&#94;T(ck,ib) ! call wf % mem % alloc ( sigma_aj_ib , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & b_ai_bj , & ! \"b_aj_ck\" ( wf % n_o ) * ( wf % n_v ), & g_ib_ck , & ( wf % n_o ) * ( wf % n_v ), & zero , & sigma_aj_ib , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( g_ib_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o ! ib = index_two ( i , b , wf % n_o ) ! do a = 1 , wf % n_v ! aj = index_two ( a , j , wf % n_v ) ai = index_two ( a , i , wf % n_v ) ! sigma_ai_bj ( ai , bj ) = sigma_ai_bj ( ai , bj ) + sigma_aj_ib ( aj , ib ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_aj_ib , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     :: Term 2. - sum_ck b_akcj g_ikcb = - sum_ck b_akcj g_cbik :: ! !     Make g_ck_bi = g_cbik in batches over b ! call wf % mem % alloc ( g_ck_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ck_bi = zero ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index b max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of b batches ! do b_batch = 1 , n_batch ! !        For each batch, get the limits for the b index ! call batch_limits ( b_first , b_last , b_batch , max_batch_length , batch_dimension ) b_length = b_last - b_first + 1 ! !        Form g_cb_ik = g_cbik ! call wf % mem % alloc ( g_cb_ik , ( wf % n_v ) * b_length , ( wf % n_o ) ** 2 ) ! integral_type = 'electronic_repulsion' call wf % get_vv_oo ( integral_type , & g_cb_ik , & 1 , & wf % n_v , & b_first , & b_last , & 1 , & wf % n_o , & 1 , & wf % n_o ) ! !        Place in reordered integral g_ck_bi = g_cbik ! do k = 1 , wf % n_o do i = 1 , wf % n_o do b = b_first , b_last do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) bi = index_two ( b , i , wf % n_v ) ! Full space cb = index_two ( c , b - b_first + 1 , wf % n_v ) ! Restricted ik = index_two ( i , k , wf % n_o ) ! g_ck_bi ( ck , bi ) = g_cb_ik ( cb , ik ) ! g_cbik ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_cb_ik , ( wf % n_v ) * b_length , ( wf % n_o ) ** 2 ) ! enddo ! End of batches over b ! !     Reorder to b_aj_ck = b_akcj ! call wf % mem % alloc ( b_aj_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) b_aj_ck = zero ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do j = 1 , wf % n_o ! cj = index_two ( c , j , wf % n_v ) ! do a = 1 , wf % n_v ! ak = index_two ( a , k , wf % n_v ) aj = index_two ( a , j , wf % n_v ) ! b_aj_ck ( aj , ck ) = b_ai_bj ( ak , cj ) ! b_akcj ! enddo enddo enddo enddo ! !     Form and add - sum_ck b_akcj g_cbik = - sum_ck b_aj_ck g_ck_bi ! call wf % mem % alloc ( sigma_aj_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & b_aj_ck , & ( wf % n_o ) * ( wf % n_v ), & g_ck_bi , & ( wf % n_o ) * ( wf % n_v ), & zero , & sigma_aj_bi , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( b_aj_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( g_ck_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o ! bi = index_two ( b , i , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) aj = index_two ( a , j , wf % n_v ) ! sigma_ai_bj ( ai , bj ) = sigma_ai_bj ( ai , bj ) + sigma_aj_bi ( aj , bi ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_aj_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_transpose_ccsd_c2_ccsd ! ! module subroutine jacobian_transpose_ccsd_d2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!    Jacobian transpose CCSD D2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the D2 term, !! !!       2 * sum_ckdl b_aick L_jbld t_kl&#94;cd !! !!    and adds it to the transformed vector sigma_ai_bj. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! real ( dp ), dimension (:,:), allocatable :: t_ck_dl ! t_kl&#94;cd ! real ( dp ), dimension (:,:), allocatable :: X_ck_bj ! An intermediate ! real ( dp ), dimension (:,:), allocatable :: g_jb_ld ! g_jbld real ( dp ), dimension (:,:), allocatable :: L_dl_bj ! L_jbld ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 , l = 0 , lb = 0 , jd = 0 integer ( i15 ) :: dl = 0 , d = 0 , ld = 0 , bj = 0 , jb = 0 ! !     Form g_jb_ld = g_jbld ! call wf % mem % alloc ( g_jb_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_jb_ld ) ! !     Form L_dl_bj = L_jbld = 2 * g_jbld - g_jdlb !                           = 2 * g_jb_ld(jb,ld) - g_jb_ld(jd,lb) ! call wf % mem % alloc ( L_dl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) L_dl_bj = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) jb = index_two ( j , b , wf % n_o ) ! do l = 1 , wf % n_o ! lb = index_two ( l , b , wf % n_o ) ! do d = 1 , wf % n_v ! jd = index_two ( j , d , wf % n_o ) ld = index_two ( l , d , wf % n_o ) dl = index_two ( d , l , wf % n_v ) ! L_dl_bj ( dl , bj ) = two * g_jb_ld ( jb , ld ) - g_jb_ld ( jd , lb ) ! L_jbld ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_jb_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form t_ck_dl = t_kl&#94;cd ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_ck_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_ck_dl = zero ! call squareup ( wf % t2am , t_ck_dl , ( wf % n_o ) * ( wf % n_v )) ! call wf % destruct_amplitudes ! !     Form the intermediate X_ck_bj = sum_dl t_ck_dl L_dl_bj ! call wf % mem % alloc ( X_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & t_ck_dl , & ( wf % n_o ) * ( wf % n_v ), & L_dl_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_ck_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( t_ck_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( L_dl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Add 2 * sum_ckdl b_aick L_jbld t_kl&#94;cd = 2 * sum_ck b_ai_ck X_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & two , & b_ai_bj , & ! \"b_ai_ck\" ( wf % n_o ) * ( wf % n_v ), & X_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & sigma_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( X_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_transpose_ccsd_d2_ccsd ! ! module subroutine jacobian_transpose_ccsd_e2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!    Jacobian transpose CCSD E2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the E2 term, !! !!       - sum_ckdl (b_aibl t_kl&#94;cd L_kcjd + b_aicl t_kl&#94;cd L_jbkd + b_aicj t_kl&#94;cd L_ldkb) !! !!    and adds it to the transformed vector sigma_ai_bj. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! real ( dp ), dimension (:,:), allocatable :: g_kc_jd real ( dp ), dimension (:,:), allocatable :: L_j_ckd ! L_kcjd real ( dp ), dimension (:,:), allocatable :: L_dk_bj ! L_jbkd real ( dp ), dimension (:,:), allocatable :: L_ldk_b ! L_ldkb ! real ( dp ), dimension (:,:), allocatable :: t_ck_dl ! t_kl&#94;cd real ( dp ), dimension (:,:), allocatable :: t_cl_dk ! t_kl&#94;cd ! real ( dp ), dimension (:,:), allocatable :: X_j_l ! An intermediate, term 1 real ( dp ), dimension (:,:), allocatable :: X_cl_bj ! An intermediate, term 2 real ( dp ), dimension (:,:), allocatable :: X_c_b ! An intermediate, term 3 ! real ( dp ), dimension (:,:), allocatable :: sigma_aij_b ! sigma_ai_bj contribution real ( dp ), dimension (:,:), allocatable :: b_aij_c ! b_aicj ! integer ( i15 ) :: kd = 0 , kc = 0 , k = 0 , jd = 0 , jc = 0 , j = 0 , d = 0 integer ( i15 ) :: ckd = 0 , c = 0 , l = 0 , dk = 0 , cl = 0 , bjd = 0 , bj = 0 integer ( i15 ) :: b = 0 , ldk = 0 , i = 0 , dl = 0 , cj = 0 , bk = 0 , aij = 0 integer ( i15 ) :: a = 0 , ai = 0 , ck = 0 ! !     :: Term 1. - sum_ckdl b_aibl t_kl&#94;cd L_kcjd :: ! !     X_j_l = sum_kcd L_kcjd t_kl&#94;cd = sum_kcd L_j_ckd t_ck_dl ! !     Form g_kc_jd = g_kcjd ! ! call wf % mem % alloc ( g_kc_jd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_jd ) ! !     Form L_j_ckd = L_kcjd = 2 * g_kcjd - g_kdjc !                           = 2 * g_kc_jd(kc,jd) - g_kc_jd(kd,jc) ! call wf % mem % alloc ( L_j_ckd , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) L_j_ckd = zero ! do d = 1 , wf % n_v do k = 1 , wf % n_o ! kd = index_two ( k , d , wf % n_o ) ! do c = 1 , wf % n_v ! kc = index_two ( k , c , wf % n_o ) ! ckd = index_three ( c , k , d , wf % n_v , wf % n_o ) ! do j = 1 , wf % n_o ! jd = index_two ( j , d , wf % n_o ) jc = index_two ( j , c , wf % n_o ) ! L_j_ckd ( j , ckd ) = two * g_kc_jd ( kc , jd ) - g_kc_jd ( kd , jc ) ! L_kcjd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kc_jd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form t_ck_dl = t_kl&#94;cd ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_ck_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_ck_dl = zero ! call squareup ( wf % t2am , t_ck_dl , ( wf % n_o ) * ( wf % n_v )) ! call wf % destruct_amplitudes ! !     Form the intermediate X_j_l = sum_kcd L_kcjd t_kl&#94;cd !                                 = sum_kcd L_j_ckd t_ckd_l ! call wf % mem % alloc ( X_j_l , wf % n_o , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & L_j_ckd , & wf % n_o , & t_ck_dl , & ! \"t_ckd_l\" ( wf % n_o ) * ( wf % n_v ) ** 2 , & zero , & X_j_l , & wf % n_o ) ! ! !     Add - sum_ckdl b_aibl t_kl&#94;cd L_kcjd !         = - sum_l b_aib_l X_j_l&#94;T(l,j) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & wf % n_o , & wf % n_o , & - one , & b_ai_bj , & ! \"b_aib_l\" ( wf % n_o ) * ( wf % n_v ) ** 2 , & X_j_l , & wf % n_o , & one , & sigma_ai_bj , & ! \"sigma_aib_j\" ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( X_j_l , wf % n_o , wf % n_o ) ! !     :: Term 2. -sum_ckdl b_aicl t_kl&#94;cd L_jbkd :: ! !     X_cl_bj = sum_kd t_kl&#94;cd L_jbkd = sum_kd t_cl_dk L_dk_bj ! !     We have L_j_ckd = L_kcjd   => L_j_ckd(k, bjd) = L_jbkd !     We have t_ckd_l = t_kl&#94;cd ! !     Reorder to L_dk_bj(dk,bj) = L_jbkd = L_j_ckd(k, bjd) ! call wf % mem % alloc ( L_dk_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) L_dk_bj = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do k = 1 , wf % n_o do d = 1 , wf % n_v ! dk = index_two ( d , k , wf % n_v ) ! bjd = index_three ( b , j , d , wf % n_v , wf % n_o ) ! L_dk_bj ( dk , bj ) = L_j_ckd ( k , bjd ) ! L_jbkd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( L_j_ckd , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! !     Reorder to t_cl_dk = t_kl&#94;cd = t_ck_dl ! call wf % mem % alloc ( t_cl_dk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) t_cl_dk = zero ! do k = 1 , wf % n_o do d = 1 , wf % n_v ! dk = index_two ( d , k , wf % n_v ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) cl = index_two ( c , l , wf % n_v ) ! t_cl_dk ( cl , dk ) = t_ck_dl ( ck , dl ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( t_ck_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form the intermediate X_cl_bj = sum_kd t_kl&#94;cd L_jbkd !                                   = sum_kd t_cl_dk L_dk_bj ! call wf % mem % alloc ( X_cl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & t_cl_dk , & ( wf % n_o ) * ( wf % n_v ), & L_dk_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_cl_bj , & ( wf % n_o ) * ( wf % n_v )) ! !     Add - sum_ckdl b_aicl t_kl&#94;cd L_jbkd !           = - sum_cl b_ai_cl X_cl_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & b_ai_bj , & ! \"b_ai_cl\" ( wf % n_o ) * ( wf % n_v ), & X_cl_bj , & ( wf % n_o ) * ( wf % n_v ), & one , & sigma_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( X_cl_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     :: Term 3. - sum_ckdl b_aicj t_kl&#94;cd L_ldkb :: ! !     - sum_c b_aij_c X_c_b,   X_c_b = sum_kdl t_kl&#94;cd L_ldkb !                                    = sum_kdl t_cl_dk L_ldk_b ! !     We have L_dk_bj(dk,bj) = L_jbkd => L_dk_bj(bk,dl) = L_ldkb ! !     Reorder to L_ldk_b = L_ldkb = L_dk_bj(bk,dl) ! call wf % mem % alloc ( L_ldk_b , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) L_ldk_b = zero ! do b = 1 , wf % n_v do k = 1 , wf % n_o ! bk = index_two ( b , k , wf % n_v ) ! do d = 1 , wf % n_v do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! ldk = index_three ( l , d , k , wf % n_o , wf % n_v ) ! L_ldk_b ( ldk , b ) = L_dk_bj ( bk , dl ) ! L_ldkb ! enddo enddo enddo enddo ! call wf % mem % dealloc ( L_dk_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     Form the intermediate X_c_b = sum_kdl t_kl&#94;cd L_ldkb !                                 = sum_kdl t_cl_dk L_ldk_b ! call wf % mem % alloc ( X_c_b , wf % n_v , wf % n_v ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & t_cl_dk , & ! \"t_c_ldk\" wf % n_v , & L_ldk_b , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & zero , & X_c_b , & wf % n_v ) ! call wf % mem % dealloc ( t_cl_dk , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) call wf % mem % dealloc ( L_ldk_b , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! !     Reorder to b_aij_c = b_aicj ! call wf % mem % alloc ( b_aij_c , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) b_aij_c = zero ! do c = 1 , wf % n_v do j = 1 , wf % n_o ! cj = index_two ( c , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! b_aij_c ( aij , c ) = b_ai_bj ( ai , cj ) ! b_aicj ! enddo enddo enddo enddo ! !     Form and add - sum_ckdl b_aicj t_kl&#94;cd L_ldkb !                  = - sum_c b_aij_c X_c_b ! call wf % mem % alloc ( sigma_aij_b , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_v , & wf % n_v , & - one , & b_aij_c , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & X_c_b , & wf % n_v , & zero , & sigma_aij_b , & ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call wf % mem % dealloc ( X_c_b , wf % n_v , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ! sigma_ai_bj ( ai , bj ) = sigma_ai_bj ( ai , bj ) + sigma_aij_b ( aij , b ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_aij_b , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! end subroutine jacobian_transpose_ccsd_e2_ccsd ! ! module subroutine jacobian_transpose_ccsd_f2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!    Jacobian transpose CCSD F2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the F2 term, !! !!       - sum_ckdl (b_alck t_kl&#94;cd L_jbid + b_ajck t_kl&#94;cd L_ldib + b_djck t_kl&#94;cd L_ialb) !! !!    and adds it to the transformed vector sigma_ai_bj. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! real ( dp ), dimension (:,:), allocatable :: t_lck_d ! t_kl&#94;cd real ( dp ), dimension (:,:), allocatable :: t_l_ckd ! t_kl&#94;cd real ( dp ), dimension (:,:), allocatable :: t_ck_dl ! t_kl&#94;cd ! real ( dp ), dimension (:,:), allocatable :: L_jb_J ! real ( dp ), dimension (:,:), allocatable :: g_jb_id ! g_jbid real ( dp ), dimension (:,:), allocatable :: L_d_ibj ! L_jbid real ( dp ), dimension (:,:), allocatable :: L_aib_l ! L_ialb real ( dp ), dimension (:,:), allocatable :: L_dl_bi ! L_ldib ! real ( dp ), dimension (:,:), allocatable :: X_a_d ! An intermediate, term 1 real ( dp ), dimension (:,:), allocatable :: X_ck_bi ! An intermediate, term 2 real ( dp ), dimension (:,:), allocatable :: X_l_j ! An intermediate, term 3 ! real ( dp ), dimension (:,:), allocatable :: sigma_aj_bi ! sigma_ai_bj contriution ! integer ( i15 ) :: k = 0 , l = 0 , lck = 0 , d = 0 , c = 0 , jd = 0 , jb = 0 integer ( i15 ) :: id = 0 , j = 0 , i = 0 , ibj = 0 , ib = 0 , dl = 0 , ckdl = 0 integer ( i15 ) :: b = 0 , ck = 0 , idl = 0 , ckd = 0 , bl = 0 , bj = 0 , bi = 0 integer ( i15 ) :: aj = 0 , ai = 0 , aib = 0 , a = 0 ! !     :: Term 1. - sum_ckdl b_alck t_kl&#94;cd L_jbid :: ! !     X_a_d = b_a_lck t_lck_d ! !     Form t_lck_d = t_kl&#94;cd ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_lck_d , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) t_lck_d = zero ! do d = 1 , wf % n_v do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! lck = index_three ( l , c , k , wf % n_o , wf % n_v ) ! ckdl = index_packed ( ck , dl ) ! t_lck_d ( lck , d ) = wf % t2am ( ckdl , 1 ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !     Form the intermediate X_a_d = sum_lck b_a_lck t_lck_d ! call wf % mem % alloc ( X_a_d , wf % n_v , wf % n_v ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & b_ai_bj , & ! \"b_a_lck\" wf % n_v , & t_lck_d , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & zero , & X_a_d , & wf % n_v ) ! !     Form g_jb_id = g_jbid ! call wf % mem % alloc ( g_jb_id , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_jb_id ) ! !     Form L_d_ibj = L_jbid = 2 * g_jbid - g_jdib !                           = 2 * g_jb_id(jb,id) - g_jb_id(jd,ib) ! call wf % mem % alloc ( L_d_ibj , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) L_d_ibj = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! jb = index_two ( j , b , wf % n_o ) ! do i = 1 , wf % n_o ! ib = index_two ( i , b , wf % n_o ) ! ibj = index_three ( i , b , j , wf % n_o , wf % n_v ) ! do d = 1 , wf % n_v ! id = index_two ( i , d , wf % n_o ) jd = index_two ( j , d , wf % n_o ) ! L_d_ibj ( d , ibj ) = two * g_jb_id ( jb , id ) - g_jb_id ( jd , ib ) ! L_jbid ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_jb_id , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     Add - sum_ckdl b_alck t_kl&#94;cd L_jbid !         = - sum_d X_a_d L_d_ibj ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_v , & - one , & X_a_d , & wf % n_v , & L_d_ibj , & wf % n_v , & one , & sigma_ai_bj , & ! \"sigma_a_ibj\" wf % n_v ) ! call wf % mem % dealloc ( X_a_d , wf % n_v , wf % n_v ) ! !     :: Term 2. - sum_ckdl b_ajck t_kl&#94;cd L_ldib :: ! !     X_ck_bi = sum_dl t_ck_dl L_dl_bi ! !     Reorder to t_ck_dl = t_lck_d = t_kl&#94;cd ! call wf % mem % alloc ( t_ck_dl , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) t_ck_dl = zero ! do l = 1 , wf % n_o do d = 1 , wf % n_v ! dl = index_two ( d , l , wf % n_v ) ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! lck = index_three ( l , c , k , wf % n_o , wf % n_v ) ! t_ck_dl ( ck , dl ) = t_lck_d ( lck , d ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( t_lck_d , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! !     We have L_d_ibj = L_jbid => L_d_ibj(b,idl) = L_ldib ! !     Form L_dl_bi = L_ldib = L_d_ibj(b,idl) ! call wf % mem % alloc ( L_dl_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) L_dl_bi = zero ! do i = 1 , wf % n_o do b = 1 , wf % n_v ! bi = index_two ( b , i , wf % n_v ) ! do l = 1 , wf % n_o do d = 1 , wf % n_v ! dl = index_two ( d , l , wf % n_v ) ! idl = index_three ( i , d , l , wf % n_o , wf % n_v ) ! L_dl_bi ( dl , bi ) = L_d_ibj ( b , idl ) ! L_ldib ! enddo enddo enddo enddo ! call wf % mem % dealloc ( L_d_ibj , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !     Form the intermediate X_ck_bi = sum_dl t_ck_dl L_dl_bi ! call wf % mem % alloc ( X_ck_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & one , & t_ck_dl , & ( wf % n_v ) * ( wf % n_o ), & L_dl_bi , & ( wf % n_v ) * ( wf % n_o ), & zero , & X_ck_bi , & ( wf % n_v ) * ( wf % n_o )) ! !     Form and add - sum_ckdl b_ajck t_kl&#94;cd L_ldib = - sum_ck b_aj_ck X_ck_bi ! call wf % mem % alloc ( sigma_aj_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & - one , & b_ai_bj , & ! \"b_aj_ck\" ( wf % n_v ) * ( wf % n_o ), & X_ck_bi , & ( wf % n_v ) * ( wf % n_o ), & zero , & sigma_aj_bi , & ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( X_ck_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o ! bi = index_two ( b , i , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) aj = index_two ( a , j , wf % n_v ) ! sigma_ai_bj ( ai , bj ) = sigma_ai_bj ( ai , bj ) + sigma_aj_bi ( aj , bi ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_aj_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     :: Term 3. - sum_ckdl b_djck t_kl&#94;cd L_ialb = - sum_ckdl b_ckdj t_kl&#94;cd L_ialb :: ! !     X_l_j = sum_ckd t_l_ckd b_ckd_j ! !     Reorder to t_l_ckd = t_ck_dl = t_kl&#94;cd ! call wf % mem % alloc ( t_l_ckd , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) t_l_ckd = zero ! do d = 1 , wf % n_v do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! ckd = index_three ( c , k , d , wf % n_v , wf % n_o ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! t_l_ckd ( l , ckd ) = t_ck_dl ( ck , dl ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % mem % dealloc ( t_ck_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form the intermediate X_l_j = sum_ckd t_kl&#94;cd b_ckdj !                                 = sum_ckd t_l_ckd b_ckd_j ! call wf % mem % alloc ( X_l_j , wf % n_o , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & t_l_ckd , & wf % n_o , & b_ai_bj , & ! \"b_ckd_j\" ( wf % n_o ) * ( wf % n_v ) ** 2 , & zero , & X_l_j , & wf % n_o ) ! call wf % mem % dealloc ( t_l_ckd , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! !     - sum_ckdl b_ckdj t_kl&#94;cd L_ialb = - sum_l L_ialb X_l_j ! !     We have L_dl_bi = L_ldib ! !     Form L_aib_l = L_ialb = L_dl_bi(ai,bl) ! call wf % mem % alloc ( L_aib_l , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) L_aib_l = zero ! do l = 1 , wf % n_o do b = 1 , wf % n_v ! bl = index_two ( b , l , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aib = index_three ( a , i , b , wf % n_v , wf % n_o ) ! L_aib_l ( aib , l ) = L_dl_bi ( ai , bl ) ! L_ialb ! enddo enddo enddo enddo ! call wf % mem % dealloc ( L_dl_bi , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Add - sum_ckdl b_ckdj t_kl&#94;cd L_ialb = - sum_l L_aib_l X_l_j ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & wf % n_o , & wf % n_o , & - one , & L_aib_l , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & X_l_j , & wf % n_o , & one , & sigma_ai_bj , & ! \"sigma_aib_j\" ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( L_aib_l , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) call wf % mem % dealloc ( X_l_j , wf % n_o , wf % n_o ) ! end subroutine jacobian_transpose_ccsd_f2_ccsd ! ! module subroutine jacobian_transpose_ccsd_g2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!    Jacobian transpose CCSD G2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the G2 term, !! !!       sum_ckdl (b_alcj t_kl&#94;cd g_kbid + b_ajcl t_kl&#94;cd g_kdib) !! !!    and adds it to the transformed vector sigma_ai_bj. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! real ( dp ), dimension (:,:), allocatable :: t_cl_dk ! t_kl&#94;cd real ( dp ), dimension (:,:), allocatable :: t_cl_kd ! t_kl&#94;cd ! real ( dp ), dimension (:,:), allocatable :: g_kb_id ! g_kbid real ( dp ), dimension (:,:), allocatable :: g_dk_bi ! g_kbid real ( dp ), dimension (:,:), allocatable :: g_kd_ib ! g_kdib ! real ( dp ), dimension (:,:), allocatable :: b_aj_cl ! b_alcj real ( dp ), dimension (:,:), allocatable :: sigma_aj_bi ! sigma_ai_bj contribution real ( dp ), dimension (:,:), allocatable :: sigma_aj_ib ! sigma_ai_bj contribution ! real ( dp ), dimension (:,:), allocatable :: X_cl_bi ! An intermediate, term 1 real ( dp ), dimension (:,:), allocatable :: X_aj_kd ! An intermediate, term 2 ! integer ( i15 ) :: k = 0 , d = 0 , l = 0 , c = 0 , dk = 0 , dl = 0 , ck = 0 , cl = 0 integer ( i15 ) :: ckdl = 0 , i = 0 , b = 0 , bi = 0 , kb = 0 , id = 0 , aj = 0 integer ( i15 ) :: j = 0 , cj = 0 , bj = 0 , al = 0 , ai = 0 , a = 0 , kd = 0 , ib = 0 ! !     :: Term 1. sum_ckdl b_alcj t_kl&#94;cd g_kbid :: ! !     Form t_cl_dk = t_kl&#94;cd ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_cl_dk , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) t_cl_dk = zero ! do k = 1 , wf % n_o do d = 1 , wf % n_v ! dk = index_two ( d , k , wf % n_v ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) cl = index_two ( c , l , wf % n_v ) ! ckdl = index_packed ( ck , dl ) ! t_cl_dk ( cl , dk ) = wf % t2am ( ckdl , 1 ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !     Form g_kb_id = g_kbid ! call wf % mem % alloc ( g_kb_id , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kb_id ) ! !     Reorder to g_dk_bi = g_kb_id ! call wf % mem % alloc ( g_dk_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) g_dk_bi = zero ! do i = 1 , wf % n_o do b = 1 , wf % n_v ! bi = index_two ( b , i , wf % n_v ) ! do k = 1 , wf % n_o ! kb = index_two ( k , b , wf % n_o ) ! do d = 1 , wf % n_v ! id = index_two ( i , d , wf % n_o ) dk = index_two ( d , k , wf % n_v ) ! g_dk_bi ( dk , bi ) = g_kb_id ( kb , id ) ! g_kbid ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_kb_id , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     Form the intermediate X_cl_bi = sum_dk t_cl_dk g_dk_bi ! call wf % mem % alloc ( X_cl_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & one , & t_cl_dk , & ( wf % n_v ) * ( wf % n_o ), & g_dk_bi , & ( wf % n_v ) * ( wf % n_o ), & zero , & X_cl_bi , & ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( t_cl_dk , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) call wf % mem % dealloc ( g_dk_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     Reorder to b_aj_cl = b_alcj ! call wf % mem % alloc ( b_aj_cl , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) b_aj_cl = zero ! do l = 1 , wf % n_o do c = 1 , wf % n_v ! cl = index_two ( c , l , wf % n_v ) ! do j = 1 , wf % n_o ! cj = index_two ( c , j , wf % n_v ) ! do a = 1 , wf % n_v ! al = index_two ( a , l , wf % n_v ) aj = index_two ( a , j , wf % n_v ) ! b_aj_cl ( aj , cl ) = b_ai_bj ( al , cj ) ! b_alcj ! enddo enddo enddo enddo ! !     Calculate and add sum_ckdl b_alcj t_kl&#94;cd g_kbid !                       = sum_cl b_aj_cl X_cl_bi ! call wf % mem % alloc ( sigma_aj_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & one , & b_aj_cl , & ( wf % n_v ) * ( wf % n_o ), & X_cl_bi , & ( wf % n_v ) * ( wf % n_o ), & zero , & sigma_aj_bi , & ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( X_cl_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) call wf % mem % dealloc ( b_aj_cl , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o ! bi = index_two ( b , i , wf % n_v ) ! do a = 1 , wf % n_v ! aj = index_two ( a , j , wf % n_v ) ai = index_two ( a , i , wf % n_v ) ! sigma_ai_bj ( ai , bj ) = sigma_ai_bj ( ai , bj ) + sigma_aj_bi ( aj , bi ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_aj_bi , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     :: Term 2. sum_ckdl b_ajcl t_kl&#94;cd g_kdib :: ! !     Form t_cl_kd = t_kl&#94;cd ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_cl_kd , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) t_cl_kd = zero ! do d = 1 , wf % n_v do k = 1 , wf % n_o ! kd = index_two ( k , d , wf % n_o ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) cl = index_two ( c , l , wf % n_v ) ! ckdl = index_packed ( ck , dl ) ! t_cl_kd ( cl , kd ) = wf % t2am ( ckdl , 1 ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !     Form the intermediate X_aj_kd = sum_cl b_aj_cl t_cl_kd ! call wf % mem % alloc ( X_aj_kd , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & ( wf % n_v ) * ( wf % n_o ), & one , & b_ai_bj , & ! \"b_aj_cl\" ( wf % n_v ) * ( wf % n_o ), & t_cl_kd , & ( wf % n_v ) * ( wf % n_o ), & zero , & X_aj_kd , & ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( t_cl_kd , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     Form g_kd_ib = g_kdib ! call wf % mem % alloc ( g_kd_ib , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kd_ib ) ! !     Form and add sum_ckdl b_ajcl t_kl&#94;cd g_kdib !                  = sum_kd X_aj_kd g_kd_ib ! call wf % mem % alloc ( sigma_aj_ib , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & X_aj_kd , & ( wf % n_o ) * ( wf % n_v ), & g_kd_ib , & ( wf % n_o ) * ( wf % n_v ), & zero , & sigma_aj_ib , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( g_kd_ib , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( X_aj_kd , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o ! ib = index_two ( i , b , wf % n_o ) ! do a = 1 , wf % n_v ! aj = index_two ( a , j , wf % n_v ) ai = index_two ( a , i , wf % n_v ) ! sigma_ai_bj ( ai , bj ) = sigma_ai_bj ( ai , bj ) + sigma_aj_ib ( aj , ib ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_aj_ib , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_transpose_ccsd_g2_ccsd ! ! module subroutine jacobian_transpose_ccsd_h2_ccsd ( wf , sigma_ab_ij , b_ab_ij ) !! !!    Jacobian transpose CCSD H2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the H2 term, !! !!       sum_kl b_akbl g_ikjl + sum_cd b_cidj g_cadb !! !!    and adds it to the transformed vector sigma_ab_ij. !! !!    In this routine, the b and sigma vectors are ordered as !! !!       b_ab_ij = b_ai_bj !!       sigma_ab_ij = sigma_ab_ij !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: b_ab_ij real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: sigma_ab_ij ! real ( dp ), dimension (:,:), allocatable :: sigma_ab_ij_batch ! real ( dp ), dimension (:,:), allocatable :: g_ca_db ! g_cadb real ( dp ), dimension (:,:), allocatable :: g_ab_cd ! g_cadb ! real ( dp ), dimension (:,:), allocatable :: g_ik_jl ! g_ikjl real ( dp ), dimension (:,:), allocatable :: g_kl_ij ! g_ikjl ! integer ( i15 ) :: l = 0 , kl = 0 , k = 0 , jl = 0 , j = 0 , ik = 0 , ij = 0 integer ( i15 ) :: i = 0 , db = 0 , d = 0 , cd = 0 , ca = 0 , c = 0 , b = 0 , a = 0 ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 integer ( i15 ) :: batch_dimension = 0 ! integer ( i15 ) :: a_max_length = 0 , a_n_batch = 0 integer ( i15 ) :: b_max_length = 0 , b_n_batch = 0 ! integer ( i15 ) :: b_batch = 0 , b_length = 0 , b_first = 0 , b_last = 0 integer ( i15 ) :: a_batch = 0 , a_length = 0 , a_first = 0 , a_last = 0 ! integer ( i15 ) :: ab = 0 , ab_full = 0 ! !     :: Term 1. sum_kl b_akbl g_ikjl :: ! !     Form g_ik_jl ! call wf % mem % alloc ( g_ik_jl , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! integral_type = 'electronic_repulsion' call wf % get_oo_oo ( integral_type , g_ik_jl ) ! !     Reorder to g_kl_ij = g_ik_jl = g_ikjl ! call wf % mem % alloc ( g_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) g_kl_ij = zero ! do j = 1 , wf % n_o do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do l = 1 , wf % n_o ! jl = index_two ( j , l , wf % n_o ) ! do k = 1 , wf % n_o ! ik = index_two ( i , k , wf % n_o ) kl = index_two ( k , l , wf % n_o ) ! g_kl_ij ( kl , ij ) = g_ik_jl ( ik , jl ) ! g_ikjl ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ik_jl , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! !     Add sum_kl b_akbl g_ikjl = sum_kl b_ab_kl g_kl_ij ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & one , & b_ab_ij , & ! \"b_ab_kl\" ( wf % n_v ) ** 2 , & g_kl_ij , & ( wf % n_o ) ** 2 , & one , & sigma_ab_ij , & ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( g_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! !     :: Term 2. sum_cd b_cidj g_cadb :: ! !     sum_cd b_cidj g_cadb = sum_cd g_cadb b_cd_ij !                          = sum_cd g_ab_cd b_cd_ij ! !     Prepare batching over a and b ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual indices a,b a_max_length = 0 ! Initilization of unset variables ! a_n_batch = 0 b_n_batch = 0 ! call num_two_batch ( required , available , a_max_length , a_n_batch , batch_dimension ) b_n_batch = a_n_batch ! !     Loop over the number of a & b batches ! a_first = 0 a_last = 0 a_length = 0 ! do a_batch = 1 , a_n_batch ! !        For each a batch, get the limits for the a index ! call batch_limits ( a_first , a_last , a_batch , a_max_length , batch_dimension ) a_length = a_last - a_first + 1 ! b_first = 0 b_last = 0 b_length = 0 ! b_max_length = a_max_length ! do b_batch = 1 , b_n_batch ! !           For each b batch, get the limits for the b index ! call batch_limits ( b_first , b_last , b_batch , b_max_length , batch_dimension ) b_length = b_last - b_first + 1 ! !           Form g_ca_db = g_cadb ! call wf % mem % alloc ( g_ca_db , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) ! integral_type = 'electronic_repulsion' call wf % get_vv_vv ( integral_type , g_ca_db , & 1 , wf % n_v , & a_first , a_last , & 1 , wf % n_v , & b_first , b_last ) ! !           Reorder to g_ab_cd = g_ca_db = g_cadb ! call wf % mem % alloc ( g_ab_cd , a_length * b_length , ( wf % n_v ) ** 2 ) g_ab_cd = zero ! do d = 1 , wf % n_v do c = 1 , wf % n_v ! cd = index_two ( c , d , wf % n_v ) ! do b = 1 , b_length ! db = index_two ( d , b , wf % n_v ) ! do a = 1 , a_length ! ca = index_two ( c , a , wf % n_v ) ab = index_two ( a , b , a_length ) ! g_ab_cd ( ab , cd ) = g_ca_db ( ca , db ) ! g_cadb ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ca_db , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) ! !           Calculate sigma_ab_ij_batch = sum_cd g_ab_cd b_cd_ij !           and add it to the full space sigma vector ! call wf % mem % alloc ( sigma_ab_ij_batch , a_length * b_length , ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & a_length * b_length , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & g_ab_cd , & a_length * b_length , & b_ab_ij , & ! \"b_cd_ij\" ( wf % n_v ) ** 2 , & zero , & sigma_ab_ij_batch , & a_length * b_length ) ! call wf % mem % dealloc ( g_ab_cd , a_length * b_length , ( wf % n_v ) ** 2 ) ! do j = 1 , wf % n_o do i = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do b = 1 , b_length do a = 1 , a_length ! ab = index_two ( a , b , a_length ) ! ab_full = index_two ( a + a_first - 1 , b + b_first - 1 , wf % n_v ) ! sigma_ab_ij ( ab_full , ij ) = sigma_ab_ij ( ab_full , ij ) & + sigma_ab_ij_batch ( ab , ij ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( sigma_ab_ij_batch , a_length * b_length , ( wf % n_o ) ** 2 ) ! enddo ! End of batches over b enddo ! End of batches over a ! end subroutine jacobian_transpose_ccsd_h2_ccsd ! ! module subroutine jacobian_transpose_ccsd_i2_ccsd ( wf , sigma_ab_ij , b_ab_ij ) !! !!    Jacobian transpose CCSD I2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the I2 term, !! !!       sum_ckdl b_cidj t_kl&#94;cd g_kalb + sum_ckdl b_akbl t_kl&#94;cd g_icjd !! !!    and adds it to the transformed vector sigma_ab_ij. !! !!    In this routine, the b and sigma vectors are ordered as !! !!       b_ab_ij = b_ai_bj !!       sigma_ab_ij = sigma_ab_ij !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: b_ab_ij real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: sigma_ab_ij ! real ( dp ), dimension (:,:), allocatable :: t_kl_cd ! t_kl&#94;cd ! real ( dp ), dimension (:,:), allocatable :: g_ka_lb ! g_kalb real ( dp ), dimension (:,:), allocatable :: g_ab_kl ! g_kalb ! real ( dp ), dimension (:,:), allocatable :: X_kl_ij ! An intermediate, terms 1 & 2 ! integer ( i15 ) :: d = 0 , c = 0 , cd = 0 , l = 0 , dl = 0 , k = 0 , ck = 0 , kl = 0 integer ( i15 ) :: ckdl = 0 , lb = 0 , ka = 0 , b = 0 , ab = 0 , a = 0 ! !     :: Term 1. sum_ckdl b_cidj t_kl&#94;cd g_kalb :: ! !     sum_ckdl t_kl_cd b_cd_ij ! !     Form t_kl_cd = t_kl&#94;cd ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( t_kl_cd , ( wf % n_o ) ** 2 , ( wf % n_v ) ** 2 ) t_kl_cd = zero ! do d = 1 , wf % n_v do c = 1 , wf % n_v ! cd = index_two ( c , d , wf % n_v ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! do k = 1 , wf % n_o ! ck = index_two ( c , k , wf % n_v ) kl = index_two ( k , l , wf % n_o ) ! ckdl = index_packed ( ck , dl ) ! t_kl_cd ( kl , cd ) = wf % t2am ( ckdl , 1 ) ! t_kl&#94;cd ! enddo enddo enddo enddo ! call wf % destruct_amplitudes ! !     Form the intermediate X_kl_ij = sum_cd t_kl_cd b_cd_ij ! call wf % mem % alloc ( X_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & t_kl_cd , & ( wf % n_o ) ** 2 , & b_ab_ij , & ! \"b_cd_ij\" ( wf % n_v ) ** 2 , & zero , & X_kl_ij , & ( wf % n_o ) ** 2 ) ! !     Form g_ka_lb = g_kalb ! ! call wf % mem % alloc ( g_ka_lb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_ka_lb ) ! !     Reorder to g_ab_kl = g_ka_lb = g_kalb ! call wf % mem % alloc ( g_ab_kl , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) g_ab_kl = zero ! do l = 1 , wf % n_o do k = 1 , wf % n_o ! kl = index_two ( k , l , wf % n_o ) ! do b = 1 , wf % n_v ! lb = index_two ( l , b , wf % n_o ) ! do a = 1 , wf % n_v ! ka = index_two ( k , a , wf % n_o ) ab = index_two ( a , b , wf % n_v ) ! g_ab_kl ( ab , kl ) = g_ka_lb ( ka , lb ) ! g_kalb ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ka_lb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Add sum_ckdl b_cidj t_kl&#94;cd g_kalb !         = sum_kl g_ab_kl X_kl_ij ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & one , & g_ab_kl , & ( wf % n_v ) ** 2 , & X_kl_ij , & ( wf % n_o ) ** 2 , & one , & sigma_ab_ij , & ( wf % n_v ) ** 2 ) ! !     :: Term 2. sum_ckdl b_akbl t_kl&#94;cd g_icjd :: ! !     Repurpose X_kl_ij to make sum_cd t_kl&#94;cd g_icjd !                               = sum_cd t_kl_cd g_cd_ij !                               = sum_cd t_kl_cd g_ab_kl(cd,ij) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & t_kl_cd , & ( wf % n_o ) ** 2 , & g_ab_kl , & ! \"g_cd_ij\" ( wf % n_v ) ** 2 , & zero , & X_kl_ij , & ( wf % n_o ) ** 2 ) ! call wf % mem % dealloc ( g_ab_kl , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( t_kl_cd , ( wf % n_o ) ** 2 , ( wf % n_v ) ** 2 ) ! !     Add sum_ckdl b_akbl t_kl&#94;cd g_icjd !         = sum_kl b_ab_kl X_kl_ij ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & one , & b_ab_ij , & ! \"b_ab_kl\" ( wf % n_v ) ** 2 , & X_kl_ij , & ( wf % n_o ) ** 2 , & one , & sigma_ab_ij , & ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( X_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! end subroutine jacobian_transpose_ccsd_i2_ccsd ! ! end submodule jacobian_transpose","tags":"","loc":"sourcefile/jacobian_transpose_submodule.f90.html","title":"jacobian_transpose_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~omega_submodule.f90~4~~EfferentGraph sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~batching_index_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 var pansourcefileomega_submodulef904EfferentGraph = svgPanZoom('#sourcefileomega_submodulef904EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules omega Source Code omega_submodule.F90 Source Code submodule ( ccsd_class ) omega ! !! !!    Omega submodule (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !! !!    Contains the following family of procedures of the CCSD class: !! !!    initialize_omega: allocates the projection vector (omega1, omega2) !!                          and sets it to zero. !! !!    construct_omega:  constructs the projection vector (omega1, omega2) !!                          for the current amplitudes (t1am, t2am) for the !!                          wavefunction object wf. The routine assumes that !!                          the projection vector is allocated. !! !!    omega_ccsd_a1:         adds A1 term to omega1 !!    omega_ccsd_b1:         adds B1 term to omega1 !!    omega_ccsd_c1:         adds C1 term to omega1 !! !!    omega_ccsd_a2:         adds A2 term to omega2 !!    omega_ccsd_b2:         adds B2 term to omega2 !!    omega_ccsd_c2:         adds C2 term to omega2 !!    omega_ccsd_d2:         adds D2 term to omega2 !!    omega_ccsd_e2:         adds E2 term to omega2 !! ! use batching_index_class ! implicit none ! logical :: debug = . false . ! real ( dp ) :: begin_timer real ( dp ) :: end_timer ! character ( len = 40 ) :: integral_type ! Here: electronic repulsion, 1/r_ij, g_pqrs ! contains ! ! module subroutine initialize_omega_ccsd ( wf ) !! !!    Initialize Omega (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Allocates the projection vector (omega1, omega2) and sets it !!    to zero. !! implicit none ! class ( ccsd ) :: wf ! if (. not . allocated ( wf % omega1 )) call wf % mem % alloc ( wf % omega1 , wf % n_v , wf % n_o ) wf % omega1 = zero ! if (. not . allocated ( wf % omega2 )) call wf % mem % alloc ( wf % omega2 , wf % n_t2am , 1 ) wf % omega2 = zero ! end subroutine initialize_omega_ccsd ! ! module subroutine construct_omega_ccsd ( wf ) !! !!     Construct Omega (CCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Directs the construction of the projection vector < mu | exp(-T) H exp(T) | R > !!     for the current amplitudes of the object wfn !! implicit none ! class ( ccsd ) :: wf ! real ( dp ) :: begin_timer , end_timer ! real ( dp ) :: ccsd_a1_time real ( dp ) :: ccsd_b1_time real ( dp ) :: ccsd_c1_time real ( dp ) :: ccs_a1_time ! real ( dp ) :: ccsd_a2_time real ( dp ) :: ccsd_b2_time real ( dp ) :: ccsd_c2_time real ( dp ) :: ccsd_d2_time real ( dp ) :: ccsd_e2_time ! !     Set the omega vector to zero ! wf % omega1 = zero wf % omega2 = zero ! !     Construct singles contributions ! call cpu_time ( begin_timer ) call wf % omega_ccsd_a1 call cpu_time ( end_timer ) ccsd_a1_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % omega_ccsd_b1 call cpu_time ( end_timer ) ccsd_b1_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % omega_ccsd_c1 call cpu_time ( end_timer ) ccsd_c1_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % omega_ccs_a1 call cpu_time ( end_timer ) ccs_a1_time = end_timer - begin_timer ! !     Construct doubles contributions ! call cpu_time ( begin_timer ) call wf % omega_ccsd_a2 call cpu_time ( end_timer ) ccsd_a2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % omega_ccsd_b2 call cpu_time ( end_timer ) ccsd_b2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % omega_ccsd_c2 call cpu_time ( end_timer ) ccsd_c2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % omega_ccsd_d2 call cpu_time ( end_timer ) ccsd_d2_time = end_timer - begin_timer ! call cpu_time ( begin_timer ) call wf % omega_ccsd_e2 call cpu_time ( end_timer ) ccsd_e2_time = end_timer - begin_timer ! !     Print timings ! if ( wf % settings % print_level == 'developer' ) then ! write ( unit_output , '(/t3,a)' ) 'Breakdown of CCSD omega timings:' ! write ( unit_output , '(/t3,a27,f14.8)' ) 'Time in CCSD A1 (seconds):' , ccsd_a1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD B1 (seconds):' , ccsd_b1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD C1 (seconds):' , ccsd_c1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCS  A1 (seconds):' , ccs_a1_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD A2 (seconds):' , ccsd_a2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD B2 (seconds):' , ccsd_b2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD C2 (seconds):' , ccsd_c2_time write ( unit_output , '(t3,a27,f14.8)' ) 'Time in CCSD D2 (seconds):' , ccsd_d2_time write ( unit_output , '(t3,a27,f14.8/)' ) 'Time in CCSD E2 (seconds):' , ccsd_e2_time ! flush ( unit_output ) ! endif ! end subroutine construct_omega_ccsd ! ! module subroutine omega_ccsd_a1_ccsd ( wf ) !! !!    Omega A1 term !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Calculates the A1 term, !! !!       A1: sum_ckd g_adkc * u_ki&#94;cd, !! !!    and adds it to the singles projection vector (omega1) of !!    the wavefunction object wf. ! implicit none ! class ( ccsd ) :: wf ! !     Batching variables ! type ( batching_index ) :: batch_a ! integer ( i15 ) :: current_a_batch = 0 integer ( i15 ) :: required = 0 ! !     Indices ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , c = 0 , k = 0 , d = 0 integer ( i15 ) :: ad = 0 , ad_dim = 0 , ci = 0 , cidk = 0 , ck = 0 , da = 0 integer ( i15 ) :: dkc = 0 , ckdi = 0 , di = 0 , dk = 0 , kc = 0 ! real ( dp ), dimension (:,:), allocatable :: g_ad_kc ! g_adkc; a is being batched over real ( dp ), dimension (:,:), allocatable :: u_dkc_i ! u_ki&#94;cd ! !     Allocate u_dkc_i = u_ki&#94;cd ! call wf % mem % alloc ( u_dkc_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) u_dkc_i = zero ! !     Calculate u_dkc_i = u_ki&#94;cd ! do i = 1 , wf % n_o do c = 1 , wf % n_v ! ci = index_two ( c , i , wf % n_v ) ! do k = 1 , wf % n_o ! ck = index_two ( c , k , wf % n_v ) ! do d = 1 , wf % n_v ! dk = index_two ( d , k , wf % n_v ) di = index_two ( d , i , wf % n_v ) ! dkc = index_three ( d , k , c , wf % n_v , wf % n_o ) ! ckdi = index_packed ( ck , di ) cidk = index_packed ( ci , dk ) ! u_dkc_i ( dkc , i ) = two * ( wf % t2am ( ckdi , 1 )) - wf % t2am ( cidk , 1 ) ! enddo enddo enddo enddo ! !     Prepare for batching ! !     Estimated memory required to construct g_adkc !     (clearly an underestimate, see Cholesky routines when updating) ! required = ( wf % n_o ) * ( wf % n_v ) ** 3 & ! g_adkc + ( wf % n_J ) * ( wf % n_v ) ** 2 & ! L_ad&#94;J + ( wf % n_J ) * ( wf % n_v ) * ( wf % n_o ) & ! L_kc&#94;J + ( wf % n_J ) * ( wf % n_v ) ** 2 + 2 * ( wf % n_J ) * ( wf % n_o ) * ( wf % n_v ) ! To construct L_ad&#94;J ! !     Initialization of the batching variable ! call batch_a % init ( wf % n_v ) ! Initialize batching index a call wf % mem % num_batch ( batch_a , required ) ! Determine batching information ! !     Loop over the number of a batches ! do current_a_batch = 1 , batch_a % num_batches ! !        For each batch, get the limits for the a index ! call batch_a % determine_limits ( current_a_batch ) ! ad_dim = ( batch_a % length ) * ( wf % n_v ) ! !        Form g_ad_kc = g_adkc ! call wf % mem % alloc ( g_ad_kc , ad_dim , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , & g_ad_kc , & batch_a % first , & batch_a % last , & 1 , & wf % n_v , & 1 , & wf % n_o , & 1 , & wf % n_v ) ! !        Calculate the A1 term, ! !           sum_ckd g_adkc * u_ki&#94;cd = sum_ckd g_ad_kc u_dkc_i, ! !        and add it to the omega vector ! call dgemm ( 'N' , 'N' , & batch_a % length , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & g_ad_kc , & ! g_a_dkc batch_a % length , & u_dkc_i , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & wf % omega1 ( batch_a % first , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( g_ad_kc , ad_dim , ( wf % n_o ) * ( wf % n_v )) ! enddo ! End of batches of the index a ! !     Deallocate vectors ! call wf % mem % dealloc ( u_dkc_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! end subroutine omega_ccsd_a1_ccsd ! ! module subroutine omega_ccsd_b1_ccsd ( wf ) !! !!       Omega B1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Calculates the B1 term, !! !!        B1:  - sum_ckl u_kl&#94;ac * g_kilc, !! !!       and adds it to the singles projection vector (omeg1) of !!       the wavefunction object wf !! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ) :: a = 0 , c = 0 , k = 0 , l = 0 , ckl = 0 , ki = 0 integer ( i15 ) :: ak = 0 , akcl = 0 , al = 0 , alck = 0 , ck = 0 , ai = 0 integer ( i15 ) :: cl = 0 , lc = 0 , i = 0 , j = 0 ! real ( dp ), dimension (:,:), allocatable :: g_ki_lc ! g_kilc real ( dp ), dimension (:,:), allocatable :: g_ckl_i ! g_kilc real ( dp ), dimension (:,:), allocatable :: u_a_ckl ! u_kl&#94;ac = 2 t_kl&#94;ac - t_lk&#94;ac ! !     Get g_ki_lc = g_kilc ! call wf % mem % alloc ( g_ki_lc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_ki_lc ) ! !     Form the reordered integrals g_ckl_i = g_kilc ! call wf % mem % alloc ( g_ckl_i , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_o ) ! do i = 1 , wf % n_o do l = 1 , wf % n_o do k = 1 , wf % n_o ! ki = index_two ( k , i , wf % n_o ) ! do c = 1 , wf % n_v ! ckl = index_three ( c , k , l , wf % n_v , wf % n_o ) lc = index_two ( l , c , wf % n_o ) ! g_ckl_i ( ckl , i ) = g_ki_lc ( ki , lc ) ! enddo enddo enddo enddo ! !     Deallocate unordered integrals g_ki_lc ! call wf % mem % dealloc ( g_ki_lc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Form the redordered u_a_ckl = u_kl&#94;ac ! call wf % mem % alloc ( u_a_ckl , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! do l = 1 , wf % n_o do k = 1 , wf % n_o do c = 1 , wf % n_v ! cl = index_two ( c , l , wf % n_v ) ck = index_two ( c , k , wf % n_v ) ckl = index_three ( c , k , l , wf % n_v , wf % n_o ) ! do a = 1 , wf % n_v ! ak = index_two ( a , k , wf % n_v ) al = index_two ( a , l , wf % n_v ) ! akcl = index_packed ( ak , cl ) alck = index_packed ( al , ck ) ! !                 Set the value of u_a_ckl = u_kl&#94;ac = 2*t_kl&#94;ac - t_lk&#94;ac = 2*t_ak,cl - t_al,ck ! u_a_ckl ( a , ckl ) = two * ( wf % t2am ( akcl , 1 )) - wf % t2am ( alck , 1 ) ! enddo enddo enddo enddo ! !     Calculate the B1 term, - sum_ckl u_a_ckl g_ckl_i ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & ( wf % n_v ) * (( wf % n_o ) ** 2 ), & - one , & u_a_ckl , & wf % n_v , & g_ckl_i , & ( wf % n_v ) * (( wf % n_o ) ** 2 ), & one , & wf % omega1 , & wf % n_v ) ! !     Deallocate remaining vectors ! call wf % mem % dealloc ( u_a_ckl , wf % n_v , ( wf % n_v ) * (( wf % n_o ) ** 2 )) call wf % mem % dealloc ( g_ckl_i , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_o ) ! end subroutine omega_ccsd_b1_ccsd ! ! module subroutine omega_ccsd_c1_ccsd ( wf ) !! !!    Omega C1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Calculates the C1 term of omega, !! !!       C1: sum_ck F_kc*u_ai_ck, !! !!    and adds it to the projection vector (omega1) of !!    the wavefunction object wf !! !!    u_ai_kc = 2*t_ck_ai - t_ci_ak !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: u_ai_kc ! integer ( i15 ) :: i = 0 , k = 0 , c = 0 , a = 0 integer ( i15 ) :: ck = 0 , ai = 0 , ak = 0 , ci = 0 , kc = 0 integer ( i15 ) :: aick = 0 , akci = 0 ! !     Allocate u_ai_ck ! call wf % mem % alloc ( u_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Set up u_ai_kc ! do i = 1 , wf % n_o do c = 1 , wf % n_v ! ci = index_two ( c , i , wf % n_v ) ! do k = 1 , wf % n_o ! ck = index_two ( c , k , wf % n_v ) kc = index_two ( k , c , wf % n_o ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ak = index_two ( a , k , wf % n_v ) ! aick = index_packed ( ck , ai ) akci = index_packed ( ci , ak ) ! u_ai_kc ( ai , kc ) = two * ( wf % t2am ( aick , 1 )) - wf % t2am ( akci , 1 ) ! enddo enddo enddo enddo ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & u_ai_kc , & ( wf % n_o ) * ( wf % n_v ), & wf % fock_ia , & ! F_kc ( wf % n_o ) * ( wf % n_v ), & one , & wf % omega1 , & ( wf % n_o ) * ( wf % n_v )) ! ! call wf % mem % dealloc ( u_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine omega_ccsd_c1_ccsd ! ! module subroutine omega_ccsd_a2_ccsd ( wf ) !! !!    Omega A2 term: Omega A2 = g_ai_bj + sum_(cd)g_ac_bd * t_ci_dj = A2.1 + A.2.2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, 10 Mar 2017 !! !!    Structure: Batching over both a and b for A2.2. !!                t&#94;+_ci_dj = t_ci_dj + t_di_cj !!                t&#94;-_ci_dj = t_ci_dj - t_di_cj !!                g&#94;+_ac_bd = g_ac_bd + g_bc_ad !!                g&#94;-_ac_bd = g_ac_bd - g_bc_ad !! !!                omega_A2.2_ai_bj = 1/4*(g&#94;+_ac_bd*t&#94;+_ci_dj + g&#94;-_ac_bd*t&#94;-_ci_dj) = omega_A2.2_bj_ai !!                omega_A2.2_aj_bi = 1/4*(g&#94;+_ac_bd*t&#94;+_ci_dj - g&#94;-_ac_bd*t&#94;-_ci_dj) = omega_A2.2_bi_aj !! implicit none ! class ( ccsd ) :: wf ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: g_ai_bj real ( dp ), dimension (:,:), allocatable :: g_ac_bd real ( dp ), dimension (:,:), allocatable :: g_p_ab_cd real ( dp ), dimension (:,:), allocatable :: g_m_ab_cd ! !     Reordered T2 amplitudes ! real ( dp ), dimension (:,:), allocatable :: t_p_cd_ij real ( dp ), dimension (:,:), allocatable :: t_m_cd_ij ! !     Reordered omega 2 ! real ( dp ), dimension (:,:), allocatable :: omega2_p_ab_ij real ( dp ), dimension (:,:), allocatable :: omega2_m_ab_ij ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: ab = 0 , ca = 0 , bc = 0 , cd = 0 , ad = 0 , db = 0 , ac = 0 , bd = 0 integer ( i15 ) :: ai = 0 , aj = 0 , bj = 0 , bi = 0 , ci = 0 , cj = 0 , dj = 0 , di = 0 integer ( i15 ) :: ij = 0 ! integer ( i15 ) :: aibj = 0 , biaj = 0 , cidj = 0 , dicj = 0 ! !     Batching and memory handling variables ! integer ( i15 ) :: a_n_batch = 0 , a_first = 0 , a_last = 0 , a_length = 0 , a_max_length = 0 , a_batch = 0 integer ( i15 ) :: b_n_batch = 0 , b_first = 0 , b_last = 0 , b_length = 0 , b_max_length = 0 , b_batch = 0 integer ( i15 ) :: required = 0 , available = 0 , threads = 0 ! integer :: omp_get_num_threads ! !     Timing variables ! real ( dp ) :: time_non_integral_part real ( dp ) :: a2_begin_time , a2_end_time real ( dp ) :: a2_begin_time_1 , a2_end_time_1 ! !   write(unit_output,'(t3,a/)') 'Breakdown of A2 term:' ! time_non_integral_part = zero ! call cpu_time ( a2_begin_time ) ! !     ::  Calculate the A2.1 term of omega :: ! !     Create g_ai_bj ! call wf % mem % alloc ( g_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vo_vo ( integral_type , g_ai_bj ) ! !     Add A2.1 to Omega 2 ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! if ( ai . ge . bj ) then ! aibj = index_packed ( ai , bj ) ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + g_ai_bj ( ai , bj ) ! endif enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !    ::  Calculate the A2.2 term  of omega :: ! required = max ( 3 * ( wf % n_v ) ** 2 * ( wf % n_J ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & ! Needed to get  L_db_J ( wf % n_v ) ** 4 + 2 * ( wf % n_v ) ** 2 * ( wf % n_J ), & ! Needed to get g_ac_bd ( wf % n_v ) ** 4 + 2 * ( packed_size ( wf % n_v )) * ( packed_size ( wf % n_v )) & ! Needed to get g+- and t+- + 2 * ( packed_size ( wf % n_v )) * ( packed_size ( wf % n_o )), & ! 2 * ( packed_size ( wf % n_v )) * ( packed_size ( wf % n_v )) & ! Needed for g+- and t+- and Omega+- + 2 * ( packed_size ( wf % n_v )) * ( packed_size ( wf % n_o )) & ! + 2 * ( wf % n_v ) ** 2 * ( packed_size ( wf % n_v ))) ! ! required = required * 4 ! Words available = get_available () ! a_max_length = 0 call num_two_batch ( required , available , a_max_length , a_n_batch , wf % n_v ) ! !    Initialize some variables for batching ! a_first = 0 a_last = 0 a_length = 0 ! !    Start looping over a-batches ! do a_batch = 1 , a_n_batch ! call batch_limits ( a_first , a_last , a_batch , a_max_length , wf % n_v ) a_length = a_last - a_first + 1 ! !       Start looping over batches of b ! b_first = 0 b_last = 0 b_length = 0 ! b_max_length = a_max_length ! do b_batch = 1 , a_batch ! call batch_limits ( b_first , b_last , b_batch , b_max_length , wf % n_v ) b_length = b_last - b_first + 1 ! !           Allocate g_ca_db ! call wf % mem % alloc ( g_ac_bd , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) ! !           Get g_ac_bd ! call cpu_time ( a2_begin_time_1 ) ! integral_type = 'electronic_repulsion' call wf % get_vv_vv ( integral_type , & g_ac_bd , & a_first , & a_last , & 1 , & wf % n_v , & b_first , & b_last , & 1 , & wf % n_v ) ! call cpu_time ( a2_end_time_1 ) time_non_integral_part = time_non_integral_part & - a2_end_time_1 + a2_begin_time_1 ! if ( b_batch . eq . a_batch ) then ! ! !           Allocate for +-g, +-t ! call wf % mem % alloc ( g_p_ab_cd , packed_size ( a_length ), packed_size ( wf % n_v )) call wf % mem % alloc ( g_m_ab_cd , packed_size ( a_length ), packed_size ( wf % n_v )) call wf % mem % alloc ( t_p_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) call wf % mem % alloc ( t_m_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) ! g_p_ab_cd = zero g_m_ab_cd = zero t_p_cd_ij = zero t_m_cd_ij = zero ! !              Reorder g_ca_db to g_ab_cd and t_ci_dj to t_cd_ij ! !$omp parallel do schedule(static) private(d,b,a,ac,cd,bd,bc,ab,ad,i,j,ij,ci,dj,cj,di,cidj,dicj) do c = 1 , wf % n_v do d = 1 , c ! cd = index_packed ( c , d ) ! do a = 1 , a_length ! ac = index_two ( a , c , a_length ) ad = index_two ( a , d , a_length ) ! do b = 1 , b_length if (( a + a_first - 1 ) . ge . ( b + b_first - 1 )) then ! bd = index_two ( b , d , b_length ) bc = index_two ( b , c , b_length ) ! ab = index_packed ( a , b ) ! g_p_ab_cd ( ab , cd ) = g_ac_bd ( ac , bd ) + g_ac_bd ( ad , bc ) g_m_ab_cd ( ab , cd ) = g_ac_bd ( ac , bd ) - g_ac_bd ( ad , bc ) ! if ( c . ne . d ) then g_p_ab_cd ( ab , cd ) = two * g_p_ab_cd ( ab , cd ) g_m_ab_cd ( ab , cd ) = two * g_m_ab_cd ( ab , cd ) endif ! endif enddo enddo ! do i = 1 , wf % n_o do j = 1 , i ! ij = index_packed ( i , j ) ! ci = index_two ( c , i , wf % n_v ) dj = index_two ( d , j , wf % n_v ) cj = index_two ( c , j , wf % n_v ) di = index_two ( d , i , wf % n_v ) ! cidj = index_packed ( ci , dj ) dicj = index_packed ( cj , di ) ! t_p_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) + wf % t2am ( dicj , 1 ) t_m_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) - wf % t2am ( dicj , 1 ) ! enddo enddo enddo enddo !$omp end parallel do ! !              Dellocate g_ac_bd ! call wf % mem % dealloc ( g_ac_bd , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) ! !              Allocate omega +- ! call wf % mem % alloc ( omega2_p_ab_ij , packed_size ( a_length ), packed_size ( wf % n_o )) call wf % mem % alloc ( omega2_m_ab_ij , packed_size ( a_length ), packed_size ( wf % n_o )) ! !              omega2_ab_ij = sum_(cd) g_ab_cd*t_cd_ij ! call dgemm ( 'N' , 'N' , & packed_size ( a_length ), & packed_size ( wf % n_o ), & packed_size ( wf % n_v ), & one / four , & g_p_ab_cd , & packed_size ( a_length ), & t_p_cd_ij , & packed_size ( wf % n_v ), & zero , & omega2_p_ab_ij , & packed_size ( a_length )) ! call dgemm ( 'N' , 'N' , & packed_size ( a_length ), & packed_size ( wf % n_o ), & packed_size ( wf % n_v ), & one / four , & g_m_ab_cd , & packed_size ( a_length ), & t_m_cd_ij , & packed_size ( wf % n_v ), & zero , & omega2_m_ab_ij , & packed_size ( a_length ) ) ! !             Deallocate +-g, +-t ! call wf % mem % dealloc ( g_p_ab_cd , packed_size ( a_length ), packed_size ( wf % n_v )) call wf % mem % dealloc ( g_m_ab_cd , packed_size ( a_length ), packed_size ( wf % n_v )) call wf % mem % dealloc ( t_p_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) call wf % mem % dealloc ( t_m_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) ! do i = 1 , wf % n_o do j = 1 , i ! ij = index_packed ( i , j ) ! do a = 1 , a_length ! ai = index_two ( a + a_first - 1 , i , wf % n_v ) ! A is full-CCSD-space a index aj = index_two ( a + a_first - 1 , j , wf % n_v ) ! A is full-CCSD-space a index ! do b = 1 , b_length ! if (( a + a_first - 1 ) . ge . ( b + b_first - 1 )) then bj = index_two ( b + b_first - 1 , j , wf % n_v ) ! B is full-CCSD-space b index bi = index_two ( b + b_first - 1 , i , wf % n_v ) ! B is full-CCSD-space b index ! ! ab = index_packed ( a , b ) ! aibj = index_packed ( ai , bj ) biaj = index_packed ( bi , aj ) ! !                            Reorder into omega2_aibj ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) & + omega2_p_ab_ij ( ab , ij ) + omega2_m_ab_ij ( ab , ij ) ! if ( aibj . ne . biaj ) then wf % omega2 ( biaj , 1 ) = wf % omega2 ( biaj , 1 ) & + omega2_p_ab_ij ( ab , ij ) - omega2_m_ab_ij ( ab , ij ) endif endif ! enddo enddo enddo enddo ! !              Deallocate omega +- ! call wf % mem % dealloc ( omega2_p_ab_ij , packed_size ( a_length ), packed_size ( wf % n_o )) call wf % mem % dealloc ( omega2_m_ab_ij , packed_size ( a_length ), packed_size ( wf % n_o )) else ! !              Allocate for +-g, +-t ! call wf % mem % alloc ( g_p_ab_cd , a_length * b_length , packed_size ( wf % n_v )) call wf % mem % alloc ( g_m_ab_cd , a_length * b_length , packed_size ( wf % n_v )) call wf % mem % alloc ( t_p_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) call wf % mem % alloc ( t_m_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) ! g_p_ab_cd = zero g_m_ab_cd = zero t_p_cd_ij = zero t_m_cd_ij = zero ! !$omp parallel do schedule(static) private(d,b,a,ac,cd,bd,bc,ab,ad,i,j,ij,ci,dj,cj,di,cidj,dicj) do c = 1 , wf % n_v do d = 1 , c ! cd = index_packed ( c , d ) ! do a = 1 , a_length ! ac = index_two ( a , c , a_length ) ad = index_two ( a , d , a_length ) ! do b = 1 , b_length ! bd = index_two ( b , d , b_length ) bc = index_two ( b , c , b_length ) ! ab = index_two ( a , b , a_length ) ! g_p_ab_cd ( ab , cd ) = g_ac_bd ( ac , bd ) + g_ac_bd ( ad , bc ) g_m_ab_cd ( ab , cd ) = g_ac_bd ( ac , bd ) - g_ac_bd ( ad , bc ) ! if ( c . ne . d ) then g_p_ab_cd ( ab , cd ) = two * g_p_ab_cd ( ab , cd ) g_m_ab_cd ( ab , cd ) = two * g_m_ab_cd ( ab , cd ) endif ! enddo enddo ! do i = 1 , wf % n_o do j = 1 , i ! ij = index_packed ( i , j ) ! ci = index_two ( c , i , wf % n_v ) dj = index_two ( d , j , wf % n_v ) cj = index_two ( c , j , wf % n_v ) di = index_two ( d , i , wf % n_v ) ! cidj = index_packed ( ci , dj ) dicj = index_packed ( cj , di ) ! t_p_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) + wf % t2am ( dicj , 1 ) t_m_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) - wf % t2am ( dicj , 1 ) ! enddo enddo enddo enddo !$omp end parallel do ! !              Dellocate g_ac_bd ! call wf % mem % dealloc ( g_ac_bd , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) ! !              Allocate omega +- ! call wf % mem % alloc ( omega2_p_ab_ij , b_length * a_length , packed_size ( wf % n_o )) call wf % mem % alloc ( omega2_m_ab_ij , b_length * a_length , packed_size ( wf % n_o )) ! !               omega2_ab_ij = sum_(cd) g_ab_cd*t_cd_ij ! call dgemm ( 'N' , 'N' , & b_length * a_length , & packed_size ( wf % n_o ), & packed_size ( wf % n_v ), & one / four , & g_p_ab_cd , & b_length * a_length , & t_p_cd_ij , & packed_size ( wf % n_v ), & zero , & omega2_p_ab_ij , & b_length * a_length ) ! call dgemm ( 'N' , 'N' , & b_length * a_length , & packed_size ( wf % n_o ), & packed_size ( wf % n_v ), & one / four , & g_m_ab_cd , & b_length * a_length , & t_m_cd_ij , & packed_size ( wf % n_v ), & zero , & omega2_m_ab_ij , & b_length * a_length ) ! !          Deallocate +-g, +-t ! call wf % mem % dealloc ( g_p_ab_cd , b_length * a_length , packed_size ( wf % n_v )) call wf % mem % dealloc ( g_m_ab_cd , b_length * a_length , packed_size ( wf % n_v )) call wf % mem % dealloc ( t_p_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) call wf % mem % dealloc ( t_m_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) ! do i = 1 , wf % n_o do j = 1 , i ! ij = index_packed ( i , j ) ! do a = 1 , a_length ! ai = index_two ( a + a_first - 1 , i , wf % n_v ) ! A is full-space a index aj = index_two ( a + a_first - 1 , j , wf % n_v ) ! A is full-space a index ! do b = 1 , b_length ! bj = index_two ( b + b_first - 1 , j , wf % n_v ) ! B is full-space b index bi = index_two ( b + b_first - 1 , i , wf % n_v ) ! B is full-space b index ! ! ab = index_two ( a , b , a_length ) ! aibj = index_packed ( ai , bj ) biaj = index_packed ( bi , aj ) ! !                             Reorder into omega2_aibj ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) & + omega2_p_ab_ij ( ab , ij ) + omega2_m_ab_ij ( ab , ij ) ! if ( aibj . ne . biaj ) then wf % omega2 ( biaj , 1 ) = wf % omega2 ( biaj , 1 ) & + omega2_p_ab_ij ( ab , ij ) - omega2_m_ab_ij ( ab , ij ) endif ! enddo enddo enddo enddo ! !              Deallocate omega +- ! call wf % mem % dealloc ( omega2_p_ab_ij , b_length * a_length , packed_size ( wf % n_o )) call wf % mem % dealloc ( omega2_m_ab_ij , b_length * a_length , packed_size ( wf % n_o )) endif ! enddo ! End batching over b enddo ! End batching over a ! !   call cpu_time(a2_end_time) !   time_non_integral_part = time_non_integral_part + a2_end_time - a2_begin_time ! !   write(unit_output,'(t6,a27,f14.8/)') 'Non-integral part (seconds):', time_non_integral_part ! end subroutine omega_ccsd_a2_ccsd ! ! module subroutine omega_ccsd_b2_ccsd ( wf ) !! !!    Omega B2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, 11 Mar 2017 !! !!    Omega B2 = sum_(kl) t_ak_bl*(g_kilj + sum_(cd) t_ci_dj * g_kc_ld) !! !!    Structure: g_kilj is constructed first and reordered as g_kl_ij. !!    Then the contraction over cd is performed, and the results added to g_kl_ij. !!    t_ak_bl is then reordered as t_ab_kl and the contraction over kl is performed. !! implicit none ! class ( ccsd ) :: wf ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: g_kc_ld real ( dp ), dimension (:,:), allocatable :: g_kl_cd real ( dp ), dimension (:,:), allocatable :: g_kl_ij real ( dp ), dimension (:,:), allocatable :: g_ki_lj ! !     Reordered T2 apmlitudes ! real ( dp ), dimension (:,:), allocatable :: t_cd_ij real ( dp ), dimension (:,:), allocatable :: t_ab_kl ! !     Intermediate for matrix multiplication ! real ( dp ), dimension (:,:), allocatable :: X_kl_ij ! !     Reordered omega ! real ( dp ), dimension (:,:), allocatable :: omega_ab_ij ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ab = 0 , cd = 0 integer ( i15 ) :: ai = 0 , ak = 0 , bj = 0 , bl = 0 , ci = 0 , dj = 0 integer ( i15 ) :: kc = 0 , ld = 0 integer ( i15 ) :: ij = 0 , ki = 0 , kl = 0 , lj = 0 ! integer ( i15 ) :: aibj = 0 , akbl = 0 , cidj = 0 ! !     Allocate and construct g_ki_lj ! call wf % mem % alloc ( g_ki_lj , ( wf % n_o ) * ( wf % n_o ), ( wf % n_o ) * ( wf % n_o )) ! integral_type = 'electronic_repulsion' call wf % get_oo_oo ( integral_type , g_ki_lj ) ! call wf % mem % alloc ( g_kl_ij , ( wf % n_o ) * ( wf % n_o ),( wf % n_o ) * ( wf % n_o )) ! do k = 1 , wf % n_o do l = 1 , wf % n_o do i = 1 , wf % n_o do j = 1 , wf % n_o ! !                 Calculate compound indices ! ki = index_two ( k , i , wf % n_o ) lj = index_two ( l , j , wf % n_o ) kl = index_two ( k , l , wf % n_o ) ij = index_two ( i , j , wf % n_o ) ! !                 Reordering g_ki_lj to g_kl_ij ! g_kl_ij ( kl , ij ) = g_ki_lj ( ki , lj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ki_lj , ( wf % n_o ) * ( wf % n_o ), ( wf % n_o ) * ( wf % n_o )) ! !     Allocate and construct g_kc_ld ! call wf % mem % alloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kc_ld ) ! !     Reorder g_kc_ld as g_kl_cd, also reordering t_ci_dj as t_cd_ij ! call wf % mem % alloc ( t_cd_ij , ( wf % n_v ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_o )) call wf % mem % alloc ( g_kl_cd , ( wf % n_o ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_v )) ! do d = 1 , wf % n_v do c = 1 , wf % n_v ! cd = index_two ( c , d , wf % n_v ) ! do l = 1 , wf % n_o ! ld = index_two ( l , d , wf % n_o ) dj = index_two ( d , l , wf % n_v ) ! do k = 1 , wf % n_o ! kl = index_two ( k , l , wf % n_o ) kc = index_two ( k , c , wf % n_o ) ci = index_two ( c , k , wf % n_v ) ij = kl ! cidj = index_packed ( ci , dj ) ! g_kl_cd ( kl , cd ) = g_kc_ld ( kc , ld ) t_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) ! enddo enddo enddo enddo ! !     Deallocate g_kc_ld ! call wf % mem % dealloc ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & g_kl_cd , & ( wf % n_o ) ** 2 , & t_cd_ij , & ( wf % n_v ) ** 2 , & one , & g_kl_ij , & ( wf % n_o ) ** 2 ) ! !     Deallocate t_cd_ij and g_kl_cd ! call wf % mem % dealloc ( g_kl_cd , ( wf % n_o ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_v )) ! !     omega_ab_ij = sum_(kl) t_ab_kl*X_kl_ij ! call wf % mem % alloc ( omega_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & one , & t_cd_ij , & ! t_ab_kl ( wf % n_v ) ** 2 , & g_kl_ij , & ( wf % n_o ) ** 2 , & zero , & omega_ab_ij , & ( wf % n_v ) ** 2 ) ! call wf % mem % dealloc ( t_cd_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( g_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! !     Reorder into omega2 ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! if ( ai . ge . bj ) then ! ab = index_two ( a , b , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega_ab_ij ( ab , ij ) ! endif ! enddo enddo enddo enddo ! call wf % mem % dealloc ( omega_ab_ij ,( wf % n_v ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_o )) ! end subroutine omega_ccsd_b2_ccsd ! ! module subroutine omega_ccsd_c2_ccsd ( wf ) !! !!    Omega C2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017 !! !!    Omega C2 = -1/2 * sum_(ck) t_bk_cj*(g_ki_ac -1/2 sum_(dl)t_al_di * g_kd_lc) !!                    - sum_(ck) t_bk_ci*(g_kj_ac - sum_(dl)t_al_dj * g_kd_lc) !!                    - 1/2 * sum_ck u_jk&#94;bc g_acki !! implicit none ! class ( ccsd ) :: wf ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: g_kd_lc real ( dp ), dimension (:,:), allocatable :: g_dl_ck real ( dp ), dimension (:,:), allocatable :: g_ki_ac real ( dp ), dimension (:,:), allocatable :: g_ai_ck ! !     Reordered T2 amplitudes ! real ( dp ), dimension (:,:), allocatable :: t_ai_dl real ( dp ), dimension (:,:), allocatable :: t_ck_bj ! !     Intermediates for matrix multiplication ! real ( dp ), dimension (:,:), allocatable :: X_ai_ck real ( dp ), dimension (:,:), allocatable :: Y_ai_bj ! !     Reordered U2 amplitudes ! real ( dp ), dimension (:,:), allocatable :: u_ck_bj real ( dp ), dimension (:,:), allocatable :: omega2_ai_bj ! Holds term temporarily ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ai = 0 , aj = 0 , al = 0 , bi = 0 , bj = 0 , bk = 0 , cj = 0 , ck = 0 , cl = 0 , di = 0 , dk = 0 , dl = 0 integer ( i15 ) :: kd = 0 , lc = 0 , ca = 0 , ac = 0 integer ( i15 ) :: ki = 0 , ai_offset = 0 ! integer ( i15 ) :: aldi = 0 , aibj = 0 , cldk = 0 , bkcj = 0 , bjck = 0 ! !     Batching and memory handling ! integer ( i15 ) :: required = 0 , available = 0 ! integer ( i15 ) :: n_batch = 0 , max_batch_length = 0 integer ( i15 ) :: a_batch = 0 , a_start = 0 , a_end = 0 , a_length = 0 ! !     Allocate and construct g_kd_lc ! call wf % mem % alloc ( g_kd_lc ,( wf % n_o ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_kd_lc ) ! !     Reorder g_kd_lc as g_dl_ck and t_al_di as t_ai_dl ! call wf % mem % alloc ( g_dl_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % alloc ( t_ai_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do k = 1 , wf % n_o do d = 1 , wf % n_v ! kd = index_two ( k , d , wf % n_o ) dk = index_two ( d , k , wf % n_v ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! do c = 1 , wf % n_v ! lc = index_two ( l , c , wf % n_o ) ck = index_two ( c , k , wf % n_v ) cl = index_two ( c , l , wf % n_v ) ! cldk = index_packed ( cl , dk ) ! g_dl_ck ( dl , ck ) = g_kd_lc ( kd , lc ) t_ai_dl ( ck , dl ) = wf % t2am ( cldk , 1 ) ! enddo enddo enddo enddo call wf % mem % dealloc ( g_kd_lc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     -1/2*sum_(dl) t_ai_dl*g_dl_ck = X_ai_ck ! call wf % mem % alloc ( X_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - half , & t_ai_dl , & ( wf % n_o ) * ( wf % n_v ), & g_dl_ck , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_ai_ck , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate L_ia_J and g_dl_ck, ! call wf % mem % dealloc ( g_dl_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( t_ai_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Allocate the u_ck_bj = u_jk&#94;bc vector ! call wf % mem % alloc ( u_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) u_ck_bj = zero ! !     Form u_ck_bj = u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do k = 1 , wf % n_o ! bk = index_two ( b , k , wf % n_v ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) cj = index_two ( c , j , wf % n_v ) ! bjck = index_packed ( bj , ck ) bkcj = index_packed ( bk , cj ) ! u_ck_bj ( ck , bj ) = two * ( wf % t2am ( bjck , 1 )) - wf % t2am ( bkcj , 1 ) ! enddo enddo enddo enddo ! !     Allocate a holder for - 1/2 * sum_ck u_jk&#94;bc g_acki, !     constructed in batches over the a index below ! call wf % mem % alloc ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) omega2_ai_bj = zero ! !     Constructing g_ki_ac ! !     Setup of variables needed for batching ! available = get_available () required = 2 * ( wf % n_v ** 2 ) * ( wf % n_J ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ) & + ( wf % n_o ** 2 ) * ( wf % n_v ** 2 ) required = 4 * required call num_batch ( required , available , max_batch_length , n_batch , wf % n_v ) ! a_start = 1 a_end = 0 a_length = 0 ! !     Start looping over batches ! do a_batch = 1 , n_batch ! !        Get batch limits  and  length of batch ! call batch_limits ( a_start , a_end , a_batch , max_batch_length , wf % n_v ) a_length = a_end - a_start + 1 ! !        Allocate and construct g_ki_ac ! call wf % mem % alloc ( g_ki_ac , ( wf % n_o ) ** 2 , a_length * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_oo_vv ( integral_type , & g_ki_ac , & 1 , & wf % n_o , & 1 , & wf % n_o , & a_start , & a_end , & 1 , & wf % n_v ) ! !        X_ai_ck = X_ai_ck + g_ki_ac ! do i = 1 , wf % n_o do k = 1 , wf % n_o ! ki = index_two ( k , i , wf % n_o ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do a = 1 , a_length ! ai = index_two ( a + a_start - 1 , i , wf % n_v ) ac = index_two ( a , c , a_length ) ! X_ai_ck ( ai , ck ) = X_ai_ck ( ai , ck ) + g_ki_ac ( ki , ac ) ! enddo enddo enddo enddo ! !        Calculate the contribution to the term ! !           omega_ai_bj = - 1/2 * sum_ck u_jk&#94;bc g_acki ! !        Reorder g_ac_ki to g_ai_kc ! call wf % mem % alloc ( g_ai_ck , a_length * ( wf % n_o ), ( wf % n_o ) * ( wf % n_v )) g_ai_ck = zero ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do i = 1 , wf % n_o ! ki = index_two ( k , i , wf % n_o ) ! do a = 1 , a_length ! ac = index_two ( a , c , a_length ) ai = index_two ( a , i , a_length ) ! g_ai_ck ( ai , ck ) = g_ki_ac ( ki , ac ) ! g_acki ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ki_ac , ( wf % n_o ) ** 2 , a_length * ( wf % n_v )) ! !        - 1/2 * sum_ck u_jk&#94;bc g_acki = -1/2 * sum_ck g_ai_ck u_ck_bj ! ai_offset = index_two ( a_start , 1 , wf % n_v ) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * a_length , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one / two , & g_ai_ck , & ( wf % n_o ) * a_length , & u_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & omega2_ai_bj ( ai_offset , 1 ), & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( g_ki_ac , ( wf % n_o ) ** 2 , a_length * ( wf % n_v )) ! enddo ! End of batching ! !     Deallocate reordered u_ck_bj vector ! call wf % mem % dealloc ( u_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Add the - 1/2 * sum_ck u_jk&#94;bc g_acki term to omega ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_ai_bj ( ai , bj ) & + omega2_ai_bj ( bj , ai ) ! endif ! enddo enddo enddo enddo ! call wf % mem % dealloc ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Reorder t_bkcj_1 as t_ck_bj ! call wf % mem % alloc ( t_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do j = 1 , wf % n_o do k = 1 , wf % n_o do b = 1 , wf % n_v ! bk = index_two ( b , k , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! do c = 1 , wf % n_v ! cj = index_two ( c , j , wf % n_v ) ck = index_two ( c , k , wf % n_v ) ! bkcj = index_packed ( bk , cj ) ! t_ck_bj ( ck , bj ) = wf % t2am ( bkcj , 1 ) ! enddo enddo enddo enddo ! !     Allocate intermediate Y_ai_bj ! call wf % mem % alloc ( Y_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Y_ai_bj = - sum_(ck) X_ai_ck*t_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & X_ai_ck , & ( wf % n_o ) * ( wf % n_v ), & t_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & Y_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate the X intermediate ! call wf % mem % dealloc ( X_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate t_ck_bj ! call wf % mem % dealloc ( t_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Omega_aibj,1 = P_ai_bj ( 1/2*Y_ai_bj + Y_aj_bi ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! if ( ai . ge . bj ) then ! aj = index_two ( a , j , wf % n_v ) bi = index_two ( b , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + half * Y_ai_bj ( ai , bj ) + Y_ai_bj ( aj , bi ) & + half * Y_ai_bj ( bj , ai ) + Y_ai_bj ( bi , aj ) ! endif ! enddo enddo enddo enddo ! !     Deallocate intermediate Y_ai_bj ! call wf % mem % dealloc ( Y_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine omega_ccsd_c2_ccsd ! ! module subroutine omega_ccsd_d2_ccsd ( wf ) !! !!    Omega D2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Calculates the D2 term, !! !!      D2: sum_ck u_jk&#94;bc g_aikc !!        + 1/4 * sum_ck u_jk&#94;bc sum_dl L_ldkc u_il&#94;ad, !! !!    where !! !!        u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc, !!        L_ldkc  = 2 * g_ldkc  - g_lckd. !! !!    The first and second terms are referred to as D2.1 and D2.2. !!    All terms are added to the omega vector of the wavefunction object wf. !! !!    The routine adds the terms in the following order: D2.2, D2.1 !! implicit none ! class ( ccsd ) :: wf ! !     Indices ! integer ( i15 ) :: ai = 0 , aidl = 0 , al = 0 , aldi = 0 , a = 0 , i = 0 , b = 0 , ca = 0 , ac = 0 integer ( i15 ) :: j = 0 , c = 0 , d = 0 , di = 0 , dl = 0 , k = 0 , kc = 0 , kd = 0 , l = 0 , ki = 0 integer ( i15 ) :: lc = 0 , ld = 0 , aibj = 0 , bj = 0 , bjck = 0 , bk = 0 , bkcj = 0 , cj = 0 , ck = 0 ! real ( dp ), dimension (:,:), allocatable :: omega2_ai_bj ! For storing D2.3, D2.2 & D2.1 ! !     Vectors for D2.2 term ! real ( dp ), dimension (:,:), allocatable :: g_ld_kc ! g_ldkc real ( dp ), dimension (:,:), allocatable :: L_ld_kc ! L_ldkc = 2 * g_ldkc - g_lckd real ( dp ), dimension (:,:), allocatable :: u_ai_ld ! u_il&#94;ad = 2 * t_il&#94;ad - t_li&#94;ad real ( dp ), dimension (:,:), allocatable :: Z_ai_kc ! An intermediate, see below ! real ( dp ), dimension (:,:), allocatable :: g_ai_kc ! g_aikc real ( dp ), dimension (:,:), allocatable :: u_kc_bj ! u_jk&#94;bc ! !     Vectors for D2.1 term ! real ( dp ), dimension (:,:), allocatable :: g_ai_ck ! g_acki real ( dp ), dimension (:,:), allocatable :: g_ac_ki ! g_acki; a is batched over real ( dp ), dimension (:,:), allocatable :: u_ck_bj ! u_jk&#94;bc ! !     :: Calculate the D2.2 term of omega :: ! !     Get g_ld_kc = g_ldkc ! call wf % mem % alloc ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_ld_kc ) ! !     Form L_ld_kc = L_ldkc ! call wf % mem % alloc ( L_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do c = 1 , wf % n_v do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) ! do d = 1 , wf % n_v ! kd = index_two ( k , d , wf % n_o ) ! do l = 1 , wf % n_o ! lc = index_two ( l , c , wf % n_o ) ld = index_two ( l , d , wf % n_o ) ! L_ld_kc ( ld , kc ) = two * g_ld_kc ( ld , kc ) - g_ld_kc ( lc , kd ) ! enddo enddo enddo enddo ! !     Deallocate g_ld_kc and L_kc_J ! call wf % mem % dealloc ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form u_ai_ld = u_il&#94;ad = 2 * t_il&#94;ad - t_li&#94;ad ! call wf % mem % alloc ( u_ai_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do d = 1 , wf % n_v do l = 1 , wf % n_o ! ld = index_two ( l , d , wf % n_o ) dl = index_two ( d , l , wf % n_v ) ! do i = 1 , wf % n_o ! di = index_two ( d , i , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) al = index_two ( a , l , wf % n_v ) ! aidl = index_packed ( ai , dl ) aldi = index_packed ( al , di ) ! u_ai_ld ( ai , ld ) = two * ( wf % t2am ( aidl , 1 )) - wf % t2am ( aldi , 1 ) ! enddo enddo enddo enddo ! !     Allocate the intermediate Z_ai_kc = sum_dl u_ai_ld L_ld_kc and set it to zero ! call wf % mem % alloc ( Z_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form the intermediate Z_ai_kc = sum_dl u_ai_ld L_ld_kc ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & u_ai_ld , & ( wf % n_o ) * ( wf % n_v ), & L_ld_kc , & ( wf % n_o ) * ( wf % n_v ), & zero , & Z_ai_kc , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate L_ld_kc ! call wf % mem % dealloc ( L_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form the D2.2 term, 1/4 sum_kc Z_ai_kc u_kc_bj = 1/4 sum_kc Z_ai_kc(ai,kc) u_ai_ld(bj,kc) ! call wf % mem % alloc ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one / four , & Z_ai_kc , & ( wf % n_o ) * ( wf % n_v ), & u_ai_ld , & ( wf % n_o ) * ( wf % n_v ), & zero , & omega2_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! !     Some mathematical justification for the above matrix multiplication. We have ! !           1/4 * sum_ck (sum_dl u_il&#94;ad L_ldkc) u_jk&#94;bc = 1/4 * sum_ck Z_ai,kc u_kc,bj, ! !     where Z_ai,kc = sum_dl u_ai,ld L_ld,kc. Note that u_ai_ld(ai,ld) = u_il&#94;ad, !     which means that u_ai_ld(bj,kc)&#94;T = u_ai_ld(kc,bj) = u_kj&#94;cb = u_jk&#94;bc. ! !     Deallocate the Z_ai_kc intermediate ! call wf % mem % dealloc ( Z_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     :: Calculate the D2.1 term of omega :: ! !     Form g_ai_kc = g_aikc ! call wf % mem % alloc ( g_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vo_ov ( integral_type , g_ai_kc ) ! !     Calculate the D2.1 term, sum_ck u_jk&#94;bc g_aikc = sum_ck g_ai_kc(ai,kc) u_ai_ld(bj,kc) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & g_ai_kc , & ( wf % n_o ) * ( wf % n_v ), & u_ai_ld , & ( wf % n_o ) * ( wf % n_v ), & one , & omega2_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( u_ai_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Add the D2.1 term to the omega vector ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_ai_bj ( ai , bj ) & + omega2_ai_bj ( bj , ai ) ! endif ! enddo enddo enddo enddo ! !     Deallocate g_ai_kc, u_kc_bj, and the omega2_ai_bj vectors ! call wf % mem % dealloc ( g_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine omega_ccsd_d2_ccsd ! ! module subroutine omega_ccsd_e2_ccsd ( wf ) ! !     Omega E2 !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 ! !     Calculates the E2 term, ! !      E2: sum_c t_ij&#94;ac (F_bc - sum_dkl g_ldkc u_kl&#94;bd) !        - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc), ! !     where ! !        u_kl&#94;bc = 2 * t_kl&#94;bc - t_lk&#94;bc. ! !     The first term is referred to as the E2.1 term, and comes out ordered as (b,jai). !     The second term is referred to as the E2.2 term, and comes out ordered as (aib,j). ! !     Both are permuted added to the projection vector element omega2(ai,bj) of !     the wavefunction object wf. ! implicit none ! class ( ccsd ) :: wf ! !     Indices ! integer ( i15 ) :: aib = 0 , aibk = 0 , bk = 0 , bja = 0 , ibj = 0 , aibj = 0 , dlck = 0 integer ( i15 ) :: b = 0 , c = 0 , k = 0 , d = 0 , ck = 0 , ckdl = 0 , cl = 0 , cldk = 0 integer ( i15 ) :: dk = 0 , dl = 0 , kc = 0 , ldk = 0 , l = 0 , ld = 0 , a = 0 , ai = 0 integer ( i15 ) :: bj = 0 , aicj = 0 , cj = 0 , i = 0 , j = 0 , jai = 0 , cld = 0 , dkcl = 0 ! !     Vectors for E2.1 term ! real ( dp ), dimension (:,:), allocatable :: omega2_bj_ai ! For storing the E2.1 term temporarily real ( dp ), dimension (:,:), allocatable :: g_ld_kc ! g_ldkc real ( dp ), dimension (:,:), allocatable :: u_b_ldk ! u_kl&#94;bd real ( dp ), dimension (:,:), allocatable :: X_b_c ! An intermediate, see below for definition real ( dp ), dimension (:,:), allocatable :: t_cj_ai ! t_ij&#94;ac ! !     Vectors for E2.2 term ! real ( dp ), dimension (:,:), allocatable :: omega2_ai_bj ! For storing the E2.2 term temporarily real ( dp ), dimension (:,:), allocatable :: Y_k_j ! An intermediate, see below for definition ! !     :: Calculate the E2.1 term of omega :: ! !     Form g_ld_kc = g_ldkc ! call wf % mem % alloc ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_ld_kc ) ! !     Form u_b_ldk = u_kl&#94;bd ! call wf % mem % alloc ( u_b_ldk , wf % n_v , ( wf % n_v ) * (( wf % n_o ) ** 2 )) ! do k = 1 , wf % n_o do d = 1 , wf % n_v ! dk = index_two ( d , k , wf % n_v ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! ldk = index_three ( l , d , k , wf % n_o , wf % n_v ) ! do c = 1 , wf % n_v ! Pretend that c is b below ! cl = index_two ( c , l , wf % n_v ) ck = index_two ( c , k , wf % n_v ) ! ckdl = index_packed ( ck , dl ) cldk = index_packed ( cl , dk ) ! u_b_ldk ( c , ldk ) = two * ( wf % t2am ( ckdl , 1 )) - wf % t2am ( cldk , 1 ) ! enddo enddo enddo enddo ! !     Allocate the intermediate X_b_c = F_bc - sum_dkl g_ldkc u_kl&#94;bd and set to zero ! call wf % mem % alloc ( X_b_c , wf % n_v , wf % n_v ) ! !     Copy the virtual-virtual Fock matrix into the intermediate ! call dcopy (( wf % n_v ) ** 2 , wf % fock_ab , 1 , X_b_c , 1 ) ! X_b_c = F_bc ! !     Add the second contribution, !     - sum_dkl g_ldkc u_kl&#94;bd = - sum_dkl u_b_kdl * g_kdl_c, to X_b_c ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & - one , & u_b_ldk , & wf % n_v , & g_ld_kc , & ! g_ldk_c ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & X_b_c , & wf % n_v ) ! !     Form t_cj_ai = t_ij&#94;ac = t_ji&#94;ca ! call wf % mem % alloc ( t_cj_ai , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) call squareup ( wf % t2am , t_cj_ai , ( wf % n_v ) * ( wf % n_o )) ! !     Form the E2.1 term ! call wf % mem % alloc ( omega2_bj_ai , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_v , & one , & X_b_c , & wf % n_v , & t_cj_ai , & ! t_c_jai wf % n_v , & zero , & omega2_bj_ai , & ! omega2_b_jai wf % n_v ) ! !     Add the E2.1 term to the omega vector ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_bj_ai ( ai , bj ) & + omega2_bj_ai ( bj , ai ) ! endif ! enddo enddo enddo enddo ! !     Deallocate the E2.1 term, the X intermediate, keep the amplitudes ! call wf % mem % dealloc ( omega2_bj_ai , ( wf % n_o ) * ( wf % n_v ), ( wf % n_v ) * ( wf % n_o )) call wf % mem % dealloc ( X_b_c , wf % n_v , wf % n_v ) ! !     :: Calculate E2.2 term of omega :: ! !     Allocate the intermediate Y_k_j = F_kj  + sum_cdl u_lj&#94;dc g_ldkc !                                     = F_kj  + sum_cdl u_lj&#94;dc g_kcld !                                     = F_k_j + sum_cdl g_k_cld * u_cld_j ! call wf % mem % alloc ( Y_k_j , wf % n_o , wf % n_o ) ! !     Copy the occupied-occupied Fock matrix, such that Y_k_j = F_kj ! call dcopy (( wf % n_o ) ** 2 , wf % fock_ij , 1 , Y_k_j , 1 ) ! !     Add sum_cdl g_k_dlc u_dlc_j to Y_k_j, such that !     Y_k_j = F_k_j + sum_cdl g_k_cld u_cld_j ! !     Note: ! !     g_ld_kc(kc,ld) = g_kcld              -> pretend that this is g_k_cld !     u_b_ldk(c,ldj) = u_jl&#94;cd (= u_lj&#94;dc) -> pretend that this is u_cld_j ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & g_ld_kc , & ! g_k_cld wf % n_o , & u_b_ldk , & ! u_cld_j ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & Y_k_j , & wf % n_o ) ! !     Deallocate u_b_ldk and g_ld_kc ! call wf % mem % dealloc ( u_b_ldk , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !    Allocate the E2.2 term and set to zero ! call wf % mem % alloc ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !    Calculate the E2.2 term, !    - sum_k t_aib_k Y_k_j = - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc) ! !    Note: t_cj_ai = t_ji&#94;ca => t_cj_ai(ai,bk) = t_ik&#94;ab; !    thus, we can treat t_cj_ai as t_aib_k = t_ik&#94;ab. ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & wf % n_o , & wf % n_o , & - one , & t_cj_ai , & ! t_aib_k ( wf % n_o ) * ( wf % n_v ) ** 2 , & Y_k_j , & wf % n_o , & zero , & omega2_ai_bj , & ! omega2_aib_j ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! !    Deallocate Y_k_j and the amplitudes ! call wf % mem % dealloc ( Y_k_j , wf % n_o , wf % n_o ) call wf % mem % dealloc ( t_cj_ai , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !    Add the E2.2 term to the omega vector ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_ai_bj ( ai , bj ) & + omega2_ai_bj ( bj , ai ) ! endif ! enddo enddo enddo enddo ! !    Deallocate the E2.2 term ! call wf % mem % dealloc ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine omega_ccsd_e2_ccsd ! ! end submodule omega","tags":"","loc":"sourcefile/omega_submodule.f90~4.html","title":"omega_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ground_state_submodule.f90~2~~EfferentGraph sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileground_state_submodulef902EfferentGraph = svgPanZoom('#sourcefileground_state_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules ground_state Source Code ground_state_submodule.F90 Source Code submodule ( ccsd_class ) ground_state ! !! !!     Ground state submodule (CCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !! !!     Consists of the following module subroutines of the CCSD module: !! !!     new_amplitudes:             Calculates the quasi-Newton estimate and passes the !!                                 information needed by the DIIS routine. !!     calc_ampeqs_norm:           Calculates the norm of the amplitude equations. !!     calc_quasi_Newton_doubles:  Calculates the doubles part of the quasi-Newton estimate. !!     initialize_ground_state:    Initializes the amplitudes (MP2 estimate) and the amplitude !!                                 equations. !! !!     Can be inherited by models of the same level (e.g. CC3) without modification. !! !!     When inherited by higher level models (e.g. CCSDT), the new_amplitudes and calc_ampeqs_norm !!     routines should be overridden to account for the triples quasi-Newton estimate, amplitudes, !!     and projection vector. !! ! implicit none ! ! contains ! ! module subroutine calc_ampeqs_norm_ccsd ( wf , ampeqs_norm ) ! !     Calculate Amplitude Equations Norm (CCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! implicit none ! class ( ccsd ) :: wf ! real ( dp ) :: ampeqs_norm ! real ( dp ) :: ddot ! For dot product ! ampeqs_norm = zero ampeqs_norm = ddot ( wf % n_t1am , wf % omega1 , 1 , wf % omega1 , 1 ) ampeqs_norm = ddot ( wf % n_t2am , wf % omega2 , 1 , wf % omega2 , 1 ) + ampeqs_norm ampeqs_norm = sqrt ( ampeqs_norm ) ! end subroutine calc_ampeqs_norm_ccsd ! ! module subroutine new_amplitudes_ccsd ( wf ) ! !     New Amplitudes (CCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !     Directs the calculation of the quasi-Newton estimate Δ t_i, !     and t_i + Δ t_i, and calls the DIIS routine to save & get !     the amplitudes for the next iteration. ! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ) :: i = 0 ! for debug purposes ! real ( dp ), dimension (:,:), allocatable :: dt ! Δ t_i real ( dp ), dimension (:,:), allocatable :: t_dt ! t_i + Δ t_i ! !     Allocate Δ t_i and t_i + Δ t_i vectors ! call wf % mem % alloc ( dt , wf % n_parameters , 1 ) call wf % mem % alloc ( t_dt , wf % n_parameters , 1 ) ! dt = zero t_dt = zero ! !     Calculate Δ t_i ! call wf % calc_quasi_Newton_singles ( dt ) call wf % calc_quasi_Newton_doubles ( dt ) ! !     Set t_i + Δ t_i ! call dcopy ( wf % n_parameters , dt , 1 , t_dt , 1 ) ! t_dt = Δ t_i ! call daxpy ( wf % n_t1am , one , wf % t1am , 1 , t_dt , 1 ) ! t_dt = t_i + Δ t_i singles call daxpy ( wf % n_t2am , one , wf % t2am , 1 , t_dt ( wf % n_t1am + 1 , 1 ), 1 ) ! t_dt = t_i + Δ t_i doubles ! !     Save estimates to file and get the next amplitudes !     (they are placed in dt on exit from diis) ! call wf % diis ( dt , t_dt ) ! !     Set the new amplitudes ! call dcopy ( wf % n_t1am , dt , 1 , wf % t1am , 1 ) call dcopy ( wf % n_t2am , dt ( wf % n_t1am + 1 , 1 ), 1 , wf % t2am , 1 ) ! !     Deallocate vectors ! call wf % mem % dealloc ( dt , wf % n_parameters , 1 ) call wf % mem % dealloc ( t_dt , wf % n_parameters , 1 ) ! end subroutine new_amplitudes_ccsd ! ! module subroutine calc_quasi_Newton_doubles_ccsd ( wf , dt ) ! !     Calculate quasi-Newtoni doubles estimate (CCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !     Calculates the quasi-Newton estimate Δ t_i (doubbles part) !     and places the contribution in the dt vector (of length n_parameters, !     with singles first, then doubles, etc. if inherited) ! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: dt ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 integer ( i15 ) :: ai = 0 , bj = 0 , aibj = 0 , offset = 0 ! !     Calculate the doubles Δ t_i contribution ! do a = 1 , wf % n_v do i = 1 , wf % n_o do b = 1 , wf % n_v do j = 1 , wf % n_o ! !                 Calculate the necessary indices ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! offset = wf % n_t1am + aibj ! dt has singles first, then doubles ! dt ( offset , 1 ) = - wf % omega2 ( aibj , 1 ) / ( wf % fock_diagonal ( wf % n_o + a , 1 ) + & wf % fock_diagonal ( wf % n_o + b , 1 ) - & wf % fock_diagonal ( i , 1 ) - & wf % fock_diagonal ( j , 1 )) ! enddo enddo enddo enddo ! end subroutine calc_quasi_Newton_doubles_ccsd ! ! module subroutine initialize_ground_state_ccsd ( wf ) !! !!    Initialize Ground State (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Initializes the amplitudes and the projection vector for the ground !!    state solver. !! implicit none ! class ( ccsd ) :: wf ! if (. not . allocated ( wf % t1am )) call wf % mem % alloc ( wf % t1am , wf % n_v , wf % n_o ) wf % t1am = zero ! call wf % initialize_amplitudes ! Allocate amplitudes call wf % construct_perturbative_doubles ! Set doubles amplitudes to MP2 guess call wf % initialize_omega ! Allocate projection vector ! end subroutine initialize_ground_state_ccsd ! ! module subroutine ground_state_preparations_ccsd ( wf ) !! !!    Ground State Preparations (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    A routine for preparation tasks (if any). Can be overwritten !!    in descendants if other preparations prove necessary. !! class ( ccsd ) :: wf ! !     Test for the possibility of storing vir-vir-vir-vir !     electronic repulsion integrals (g_abcd), storing the !     integrals if possible ! call wf % store_vv_vv_electronic_repulsion ! end subroutine ground_state_preparations_ccsd end submodule ground_state","tags":"","loc":"sourcefile/ground_state_submodule.f90~2.html","title":"ground_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~excited_state_submodule.f90~3~~EfferentGraph sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileexcited_state_submodulef903EfferentGraph = svgPanZoom('#sourcefileexcited_state_submodulef903EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules excited_state Source Code excited_state_submodule.F90 Source Code submodule ( ccsd_class ) excited_state ! !! !!    Excited state  submodule (CCSD) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017 !! !!    Contains the following family of procedures of the CCSD class: !! !!    calculate_orbital_differences: calculates the orbital energy differences. !!    transform_trial_vectors:       transform trial vectors by the Jacobian (or Jacobian&#94;T). !! ! contains ! ! module subroutine calculate_orbital_differences_ccsd ( wf , orbital_diff ) !! !!       Calculate Orbital Differences (CCSD) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       Calculates orbital differences !! !!          1) ε_i&#94;a = ε_a - ε_i !!          2) ε_ij&#94;ab = ε_a + ε_b - ε_i - ε_j !! !!       and puts them in orbital_diff, which is a vector of length n_parameters. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: orbital_diff ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 integer ( i15 ) :: ai = 0 , bj = 0 integer ( i15 ) :: aibj = 0 ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! orbital_diff ( ai , 1 ) = wf % fock_diagonal ( a + wf % n_o , 1 ) - wf % fock_diagonal ( i , 1 ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! orbital_diff (( wf % n_o ) * ( wf % n_v ) + aibj , 1 ) = wf % fock_diagonal ( a + wf % n_o , 1 ) - wf % fock_diagonal ( i , 1 ) & + wf % fock_diagonal ( b + wf % n_o , 1 ) - wf % fock_diagonal ( j , 1 ) ! enddo enddo enddo enddo ! end subroutine calculate_orbital_differences_ccsd ! ! module subroutine transform_trial_vectors_ccsd ( wf , first_trial , last_trial ) !! !!    Transformation Trial Vectors (CCSD) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Each trial vector in first_trial to last_trial is read from file and !!    transformed before the transformed vector is written to file. !! !!    Singles and doubles part of the transformed vectors are written to !!    the same record in file transformed_vec, record length is n_parameters long. !! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ), intent ( in ) :: first_trial , last_trial ! Which trial_vectors we are to transform ! real ( dp ), dimension (:,:), allocatable :: c_a_i real ( dp ), dimension (:,:), allocatable :: c_aibj ! integer ( i15 ) :: unit_trial_vecs = 0 , unit_rho = 0 , ioerror = 0 integer ( i15 ) :: trial = 0 ! !     Allocate c_a_i and c_aibj ! call wf % mem % alloc ( c_a_i , wf % n_v , wf % n_o ) c_a_i = zero ! call wf % mem % alloc ( c_aibj , wf % n_t2am , 1 ) c_aibj = zero ! !     Open trial vector- and transformed vector files ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * wf % n_parameters , iostat = ioerror ) ! call generate_unit_identifier ( unit_rho ) open ( unit = unit_rho , file = 'transformed_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * wf % n_parameters , iostat = ioerror ) ! !     For each trial vector: read, transform and write ! do trial = first_trial , last_trial ! read ( unit_trial_vecs , rec = trial , iostat = ioerror ) c_a_i , c_aibj !        Test for left or right transformation ! if ( wf % tasks % current == 'excited_state' ) then ! if ( wf % excited_state_specifications % right ) then ! call wf % jacobian_ccsd_transformation ( c_a_i , c_aibj ) ! elseif ( wf % excited_state_specifications % left ) then ! call wf % jacobian_transpose_ccsd_transformation ( c_a_i , c_aibj ) ! else ! write ( unit_output , * ) 'Error: Excited state task not recognized' stop ! endif ! elseif ( wf % tasks % current == 'multipliers' ) then ! call wf % jacobian_transpose_ccsd_transformation ( c_a_i , c_aibj ) ! else ! write ( unit_output , * ) 'Error: Current task not recognized' stop ! endif ! !        -::- Projections -::- ! !        Test for core calculation ! if ( wf % tasks % core_excited_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from valence contributions ! call wf % cvs_rho_a_i_projection ( c_a_i ) call wf % cvs_rho_aibj_projection ( c_aibj ) ! endif ! !        Test for ionization calculation ! if ( wf % tasks % ionized_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from regular excitations ! call wf % ionization_rho_a_i_projection ( c_a_i ) call wf % ionization_rho_aibj_projection ( c_aibj ) ! endif ! !        Write transformed vector to file ! write ( unit_rho , rec = trial , iostat = ioerror ) c_a_i , c_aibj ! enddo ! !     Close files ! close ( unit_trial_vecs ) close ( unit_rho ) ! !     Deallocate c_a_i and c_aibj ! call wf % mem % dealloc ( c_a_i , wf % n_v , wf % n_o ) call wf % mem % dealloc ( c_aibj , wf % n_t2am , 1 ) ! end subroutine transform_trial_vectors_ccsd ! ! module subroutine print_excitation_vector_ccsd ( wf , vec , unit_id ) !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: vec ! integer ( i15 ) :: unit_id ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 ! !     Print singles part ! write ( unit_id , '(2a6,a12)' ) 'a' , 'i' , 'coeff' write ( unit_id , '(t3,a)' ) '-------------------------' ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) if ( abs ( vec ( ai , 1 )) . gt . 1.0D-03 ) then write ( unit_id , '(2i6,f12.4)' ) a , i , vec ( ai , 1 ) endif ! enddo enddo flush ( unit_id ) ! !     Print doubles part ! write ( unit_id , '(/4a6, a11)' ) 'a' , 'i' , 'b' , 'j' , 'coeff' write ( unit_id , '(t3,a)' ) '---------------------------------' ! do a = 1 , wf % n_v do i = 1 , wf % n_o do b = 1 , wf % n_v do j = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) aibj = index_packed ( ai , bj ) ! if ( abs ( vec (( wf % n_o ) * ( wf % n_v ) + aibj , 1 )) . gt . 1.0D-03 . and . ai . ge . bj ) then write ( unit_id , '(4i6,f12.4)' ) a , i , b , j , vec (( wf % n_o ) * ( wf % n_v ) + aibj , 1 ) endif ! enddo enddo enddo enddo ! end subroutine print_excitation_vector_ccsd ! ! module subroutine excited_state_preparations_ccsd ( wf ) !! !!    Excited State Preparations (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    A routine for preparation tasks (if any). Can be overwritten !!    in descendants if other preparations prove necessary. !! class ( ccsd ) :: wf ! if ( wf % settings % print_level == 'developer' ) write ( unit_output , '(/t3,a/)' ) 'Preparing for excited state calculation:' ! !     Store vvvv-electronic repulsion integrals to file if there is space ! call wf % store_t1_vv_vv_electronic_repulsion ! !     Store voov-electronic repulsion integrals to file if there is space ! call wf % store_t1_vo_ov_electronic_repulsion ! !     Store vvvo and vvov-electronic repulsion integrals to file if there is space ! call wf % store_t1_vv_vo_electronic_repulsion call wf % store_t1_vv_ov_electronic_repulsion ! !     Set current task to excited state calculation ! wf % tasks % current = 'excited_state' ! ! !     Set current task to excited state calculation ! wf % tasks % current = 'excited_state' ! !     Set filename for solution vectors ! if ( wf % tasks % core_excited_state . or . wf % tasks % core_ionized_state ) then ! Core excitation ! if ( wf % excited_state_specifications % right ) then ! Right vectors wf % excited_state_specifications % solution_file = 'right_core' else ! Left vectors wf % excited_state_specifications % solution_file = 'left_core' endif ! else ! Valence excitation ! if ( wf % excited_state_specifications % left ) then ! Right vectors wf % excited_state_specifications % solution_file = 'left_valence' else ! Left vectors wf % excited_state_specifications % solution_file = 'right_valence' endif ! endif ! end subroutine excited_state_preparations_ccsd ! ! module subroutine analyze_double_excitation_vector_ccsd ( wf , vec , n , sorted_short_vec , index_list ) !! !! !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_t2am , 1 ) :: vec ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 , k = 0 ! integer ( i15 ) :: n ! Number of elements wanted ! real ( dp ), dimension ( n , 1 ) :: sorted_short_vec ! integer ( i15 ), dimension ( n , 4 ) :: index_list ! !     Variables for sorting ! real ( dp ) :: min integer ( i15 ) :: min_pos ! real ( dp ) :: swap = zero integer ( i15 ) :: swap_i = 0 , swap_a = 0 , swap_j = 0 , swap_b = 0 ! !     Placing the n first elements of vec into sorted_short_vec ! index_list = 0 sorted_short_vec ( 1 , 1 ) = vec ( 1 , 1 ) index_list ( 1 , 1 ) = 1 index_list ( 1 , 2 ) = 1 index_list ( 1 , 3 ) = 1 index_list ( 1 , 4 ) = 1 ! min = abs ( sorted_short_vec ( 1 , 1 )) min_pos = 1 ! do i = 1 , wf % n_o do a = 1 , wf % n_v do j = 1 , wf % n_o do b = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! if ( ai . ge . bj ) then ! aibj = index_packed ( ai , bj ) ! if ( aibj . le . n ) then sorted_short_vec ( aibj , 1 ) = vec ( aibj , 1 ) index_list ( min_pos , 1 ) = a index_list ( min_pos , 2 ) = i index_list ( min_pos , 3 ) = b index_list ( min_pos , 4 ) = j ! if ( abs ( sorted_short_vec ( i , 1 )) . le . min ) then ! min = abs ( sorted_short_vec ( i , 1 )) min_pos = i ! endif else ! if ( abs ( vec ( aibj , 1 )) . ge . min ) then ! sorted_short_vec ( min_pos , 1 ) = vec ( aibj , 1 ) index_list ( min_pos , 1 ) = a index_list ( min_pos , 2 ) = i index_list ( min_pos , 3 ) = b index_list ( min_pos , 4 ) = j min = abs ( vec ( aibj , 1 )) ! endif endif ! do k = 1 , n if ( abs ( sorted_short_vec ( k , 1 )) . lt . min ) then ! min = abs ( sorted_short_vec ( k , 1 )) min_pos = k ! endif enddo endif ! enddo enddo enddo enddo ! !      Sorting sorted_short_vec ! do i = 1 , n do j = 1 , n - 1 if ( abs ( sorted_short_vec ( j , 1 )) . lt . abs ( sorted_short_vec ( j + 1 , 1 ))) then ! swap = sorted_short_vec ( j , 1 ) sorted_short_vec ( j , 1 ) = sorted_short_vec ( j + 1 , 1 ) sorted_short_vec ( j + 1 , 1 ) = swap ! swap_a = index_list ( j , 1 ) swap_i = index_list ( j , 2 ) swap_b = index_list ( j , 3 ) swap_j = index_list ( j , 4 ) ! index_list ( j , 1 ) = index_list ( j + 1 , 1 ) index_list ( j , 2 ) = index_list ( j + 1 , 2 ) index_list ( j , 3 ) = index_list ( j + 1 , 3 ) index_list ( j , 4 ) = index_list ( j + 1 , 4 ) index_list ( j + 1 , 1 ) = swap_a index_list ( j + 1 , 2 ) = swap_i index_list ( j + 1 , 3 ) = swap_b index_list ( j + 1 , 4 ) = swap_j ! endif enddo enddo ! ! end subroutine analyze_double_excitation_vector_ccsd ! ! module subroutine summary_excited_state_info_ccsd ( wf , energies ) !! !! !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! integer ( i15 ) :: unit_solution = - 1 , ioerror = 0 integer ( i15 ) :: state = 0 , i = 0 real ( dp ), dimension (:,:), allocatable :: solution_ai , solution_aibj real ( dp ), dimension (:,:), allocatable :: sorted_max_vec_singles , sorted_max_vec_doubles integer ( i15 ), dimension (:,:), allocatable :: index_list_singles , index_list_doubles real ( dp ) :: norm , ddot ! !     Open solution vector file ! call generate_unit_identifier ( unit_solution ) ! open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file , & action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening solution file' ! !     Allocations ! call wf % mem % alloc ( solution_ai , wf % n_t1am , 1 ) call wf % mem % alloc ( solution_aibj , wf % n_t2am , 1 ) ! call wf % mem % alloc ( sorted_max_vec_singles , 20 , 1 ) call wf % mem % alloc ( sorted_max_vec_doubles , 20 , 1 ) ! call wf % mem % alloc_int ( index_list_singles , 20 , 2 ) call wf % mem % alloc_int ( index_list_doubles , 20 , 4 ) ! do state = 1 , wf % excited_state_specifications % n_singlet_states ! write ( unit_output , '(/t3,a30,i3,a1/)' ) 'Analysis of excitation vector ' , state , ':' write ( unit_output , '(t6, a, f14.8)' ) 'Excitation energy [a.u.]:   ' , energies ( state , 1 ) write ( unit_output , '(t6, a, f14.8)' ) 'Excited state energy [a.u.]:' , wf % energy + energies ( state , 1 ) ! !        Read the solution ! solution_ai = zero solution_aibj = zero read ( unit_solution , rec = state ) solution_ai , solution_aibj ! !        Calculate the contribution from single excitations ! norm = sqrt ( ddot ( wf % n_t1am , solution_ai , 1 , solution_ai , 1 )) write ( unit_output , '(/t6,a,f6.4)' ) 'Single excitation contribution to excitation vector: ' , norm ! !        Analysis of excitation vectors ! write ( unit_output , '(/t6,a)' ) 'Largest contributions to excitation vector:' ! write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' write ( unit_output , '(t6,a3, 8x, a3, 8x, a10)' ) 'a' , 'i' , 'amplitude' write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' ! !        Get 20 highest amplitudes ! call wf % analyze_single_excitation_vector ( solution_ai , 20 , sorted_max_vec_singles , index_list_singles ) call wf % analyze_double_excitation_vector ( solution_aibj , 20 , sorted_max_vec_doubles , index_list_doubles ) ! !        And print them ! do i = 1 , 20 ! if ( abs ( sorted_max_vec_singles ( i , 1 )) . lt . 1.0D-03 ) then ! exit ! else ! write ( unit_output , '(t6,i3, 8x,i3, 10x, f8.5)' ) & index_list_singles ( i , 1 ),& index_list_singles ( i , 2 ),& sorted_max_vec_singles ( i , 1 ) endif enddo ! write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' write ( unit_output , '(t6,a3, 8x, a3, 8x, a3, 8x, a3, 8x, a10)' ) 'a' , 'i' , 'b' , 'j' , 'amplitude' write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' ! do i = 1 , 20 ! if ( abs ( sorted_max_vec_doubles ( i , 1 )) . lt . 1.0D-03 ) then ! exit ! else ! write ( unit_output , '(t6,i3, 8x,i3, 8x,i3, 8x, i3, 10x, f8.5)' )& index_list_doubles ( i , 1 ),& index_list_doubles ( i , 2 ),& index_list_doubles ( i , 3 ),& index_list_doubles ( i , 4 ),& sorted_max_vec_doubles ( i , 1 ) endif enddo write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' ! enddo ! !     Deallocations ! call wf % mem % dealloc ( solution_ai , wf % n_t1am , 1 ) call wf % mem % dealloc ( solution_aibj , wf % n_t2am , 1 ) ! call wf % mem % dealloc ( sorted_max_vec_singles , 20 , 1 ) call wf % mem % dealloc ( sorted_max_vec_doubles , 20 , 1 ) ! call wf % mem % dealloc_int ( index_list_singles , 20 , 2 ) call wf % mem % dealloc_int ( index_list_doubles , 20 , 4 ) ! close ( unit_solution ) ! end subroutine summary_excited_state_info_ccsd ! ! end submodule excited_state","tags":"","loc":"sourcefile/excited_state_submodule.f90~3.html","title":"excited_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~cvs_submodule.f90~~EfferentGraph sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilecvs_submodulef90EfferentGraph = svgPanZoom('#sourcefilecvs_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules cvs Source Code cvs_submodule.F90 Source Code submodule ( ccsd_class ) cvs ! !! !!    CVS submodule(CCSD) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017 !! !!    Contains the CVS routines for the CCSD class. !!    Note that this submodule contains both excited state routines and jacobian transformation routines. ! ! contains ! ! module subroutine cvs_residual_projection_ccsd ( wf , residual ) !! !!    Residual projection (CCSD), !!    Written by Sarai D. Folkestad Aug. 2017 !! implicit none ! class ( ccsd ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! integer ( i15 ) :: i = 0 , a = 0 , j = 0 , b = 0 , core = 0 , ai = 0 , bj = 0 , aibj = 0 ! logical :: core_orbital ! do i = 1 , wf % n_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if ( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) residual ( ai , 1 ) = zero enddo endif ! enddo ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if (( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) . or . & ( j . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 ))) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , wf % n_v do b = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) aibj = index_packed ( ai , bj ) residual ( wf % n_t1am + aibj , 1 ) = zero enddo enddo endif enddo enddo ! end subroutine cvs_residual_projection_ccsd ! ! module subroutine cvs_rho_aibj_projection_ccsd ( wf , vec_aibj ) !! !!    Rho projection for CVS (CCSD), !!    Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( ccsd ) :: wf real ( dp ), dimension (:, :) :: vec_aibj ! integer ( i15 ) :: i = 0 , a = 0 , j = 0 , b = 0 , core = 0 , ai = 0 , bj = 0 , aibj = 0 ! logical :: core_orbital ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if (( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) . or . & ( j . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 ))) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , wf % n_v do b = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! if ( ai . ge . bj ) then aibj = index_packed ( ai , bj ) ! vec_aibj ( aibj , 1 ) = zero ! endif enddo enddo endif enddo enddo ! end subroutine cvs_rho_aibj_projection_ccsd ! ! end submodule cvs","tags":"","loc":"sourcefile/cvs_submodule.f90.html","title":"cvs_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~jacobian_submodule.f90~4~~EfferentGraph sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~cc2_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~cc2_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~cc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~cc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilejacobian_submodulef904EfferentGraph = svgPanZoom('#sourcefilejacobian_submodulef904EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules jacobian Source Code jacobian_submodule.F90 Source Code submodule ( cc2_class ) jacobian ! !! !!    jacobian transformation submodule (cc2)) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, September 2017 !! !!    contains the following family of procedures of the cc2 class: !! !!    jacobian_transformation: Directs the transformation by a. !! !!    cc2 contributions to jacobi transformation !! !!    jacobian_cc2_a1 !!    jacobian_cc2_b1 !!    jacobian_cc2_a2 !!    jacobian_cc2_b2 !! !!    Upper case indices are general indices, lower case indices are restricted !!    to the cc2 orbital space. !! ! implicit none ! logical :: debug = . false . logical :: timings = . false . ! character ( len = 40 ) :: integral_type ! ! contains ! ! module subroutine jacobian_cc2_transformation_cc2 ( wf , c_a_i , c_aibj ) !! !!    Jacobian transformation (cc2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Directs the transformation by the ccSD Jacobi matrix, !! !!       A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >, !! !!    where the basis employed for the brackets is biorthonormal. !!    The transformation is rho = A c, i.e., !! !!       rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck !!                  + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl). !! !!    On exit, c is overwritten by rho. That is, c_a_i = rho_a_i, !!    and c_aibj = rho_aibj. !! implicit none ! class ( cc2 ) :: wf ! !     Incoming vector c ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_s2am , 1 ) :: c_aibj ! c_aibj ! !     Local unpacked and reordered vectors ! real ( dp ), dimension (:,:), allocatable :: rho_a_i ! rho_ai   = (A c)_ai real ( dp ), dimension (:,:), allocatable :: rho_ai_bj ! rho_ai   = (A c)_aibj real ( dp ), dimension (:,:), allocatable :: rho_ai_bj_sym ! rho_ai   = (A c)_aibj real ( dp ), dimension (:,:), allocatable :: c_ai_bj ! rho_ai   = (A c)_aibj ! !     Indices ! integer ( i15 ) :: a = 0 , ab = 0 , ai = 0 , b = 0 integer ( i15 ) :: bj = 0 , i = 0 , ij = 0 , j = 0 , aibj = 0 ! !     Allocate and zero the transformed vector (singles part) ! call wf % mem % alloc ( rho_a_i , wf % n_v , wf % n_o ) rho_a_i = zero ! !     :: ccS contributions to the singles c vector :: ! call wf % initialize_amplitudes call wf % read_amplitudes ! ! call wf % jacobian_ccs_a1 ( rho_a_i , c_a_i ) call wf % jacobian_ccs_b1 ( rho_a_i , c_a_i ) ! !     :: cc2 contributions to transformed vector :: ! call wf % jacobian_cc2_a1 ( rho_a_i , c_a_i ) ! !     Allocate the incoming unpacked doubles vector ! call wf % mem % alloc ( c_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) c_ai_bj = zero ! call squareup ( c_aibj , c_ai_bj , ( wf % n_o ) * ( wf % n_v )) ! Pack out vector ! !     Scale the doubles vector by 1 + delta_ai,bj, i.e. !     redefine to c_ckdl = c_ckdl (1 + delta_ck,dl) ! do i = 1 , ( wf % n_o ) * ( wf % n_v ) ! c_ai_bj ( i , i ) = two * c_ai_bj ( i , i ) ! enddo ! !     - B1 term - ! call wf % jacobian_cc2_b1 ( rho_a_i , c_ai_bj ) ! ! !     Allocate unpacked transformed vector ! call wf % mem % alloc ( rho_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) rho_ai_bj = zero ! !     - A2 term - ! call wf % jacobian_cc2_a2 ( rho_ai_bj , c_a_i ) ! !     Last term is already symmetric (B2). Perform the symmetrization !     rho_ai_bj = P_ij&#94;ab rho_ai_bj now, for convenience ! !     Allocate temporary symmetric transformed vector ! call wf % mem % alloc ( rho_ai_bj_sym , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) rho_ai_bj_sym = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! rho_ai_bj_sym ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_ai_bj ( bj , ai ) ! enddo enddo enddo enddo ! rho_ai_bj = rho_ai_bj_sym ! !     Done with temporary vector; deallocate ! call wf % mem % dealloc ( rho_ai_bj_sym , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     - B2 term - ! call wf % jacobian_cc2_b2 ( rho_ai_bj , c_ai_bj ) ! !     Divide rho_ai_bj by biorthonormal, and save to c_aibj ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) ! do b = 1 , wf % n_v do j = 1 , wf % n_o ! bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai == bj ) rho_ai_bj ( ai , bj ) = half * rho_ai_bj ( ai , bj ) ! c_aibj ( aibj , 1 ) = rho_ai_bj ( ai , bj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( rho_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( c_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! c_a_i = rho_a_i ! call wf % mem % dealloc ( rho_a_i , wf % n_v , wf % n_o ) ! end subroutine jacobian_cc2_transformation_cc2 ! ! module subroutine jacobian_cc2_a1_cc2 ( wf , rho_a_i , c_a_i ) !! !!    jacobian tem a1 (cc2)) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, june 2017 !! !!    calculates the a1 contribution to the jacobi transformation, !! !!      rho_ai&#94;a1 = sum_ckbj  (L_kc,jb u_ki&#94;ca c_bj  - g_kc,jb u_ki&#94;cb c_aj - g_kc,jb u_kj&#94;ab c_ci) !! !!     with, !! !!    u_ik&#94;ac = 2*s_ik&#94;ac - 2*s_ik&#94;ca, !! !!    which is constructed while batching over c !! implicit none ! class ( cc2 ) :: wf ! !     incoming vectors c and rho ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! !     allocatables ! real ( dp ), dimension (:,:), allocatable :: u_a_jbk real ( dp ), dimension (:,:), allocatable :: u_bkc_i real ( dp ), dimension (:,:), allocatable :: u_ai_ck real ( dp ), dimension (:,:), allocatable :: L_ck_bj real ( dp ), dimension (:,:), allocatable :: g_jb_kc real ( dp ), dimension (:,:), allocatable :: X_a_c real ( dp ), dimension (:,:), allocatable :: X_j_i real ( dp ), dimension (:,:), allocatable :: X_ai_bj ! !     indices ! integer ( i15 ) :: k = 0 , c = 0 , j = 0 , a = 0 , i = 0 , b = 0 integer ( i15 ) :: kc = 0 , ck = 0 , ai = 0 , ak = 0 , ic = 0 , jb = 0 , bj = 0 , jc = 0 , aj = 0 integer ( i15 ) :: bi = 0 , kb = 0 , ci = 0 , bk = 0 integer ( i15 ) :: jkc = 0 , bkc = 0 , jbk = 0 integer ( i15 ) :: ajbk = 0 , akbj = 0 , ciak = 0 , ckai = 0 , ckbi = 0 , cibk = 0 ! call wf % read_amplitudes ! !     :: Term a1.3 :: !     - sum_(bjck) g_kc,jb u_kj&#94;ab c_ci ! call wf % mem % alloc ( u_a_jbk , ( wf % n_v ), ( wf % n_o ** 2 ) * ( wf % n_v )) ! u_ak_bj ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do a = 1 , wf % n_v ! aj = index_two ( a , j , wf % n_v ) ! do k = 1 , wf % n_o ! ak = index_two ( a , k , wf % n_v ) bk = index_two ( b , k , wf % n_v ) ! akbj = index_packed ( ak , bj ) ajbk = index_packed ( aj , bk ) jbk = index_three ( j , b , k , wf % n_o , wf % n_v ) ! u_a_jbk ( a , jbk ) = two * wf % s2am ( akbj , 1 ) - wf % s2am ( ajbk , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_s2am ! !     g_jb_kc = g_jb,kc ! call wf % mem % alloc ( g_jb_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_ov_ov ( integral_type , g_jb_kc ) ! !     X_a_c = - sum_(bjk)u_a_jbk * g_jbk_c ! call wf % mem % alloc ( X_a_c , wf % n_v , wf % n_v ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ** 2 ), & - one , & u_a_jbk , & wf % n_v , & g_jb_kc , & ( wf % n_v ) * ( wf % n_o ** 2 ), & zero , & X_a_c , & wf % n_v ) ! call wf % mem % dealloc ( u_a_jbk , ( wf % n_v ), ( wf % n_o ** 2 ) * ( wf % n_v )) ! !     rho_a_i =+ sum_(c) X_a_c * c_c_i ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & wf % n_v , & one , & X_a_c , & wf % n_v , & c_a_i , & ! c_c_i wf % n_v , & one , & rho_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_a_c , wf % n_v , wf % n_v ) ! !     :: Term a.2 :: !     - sum_(bjck) g_jb,kc u_ki&#94;cb c_aj ! !     construct u_ck,bi ordered as u_bkc_i ! ! call wf % read_amplitudes ! call wf % mem % alloc ( u_bkc_i , ( wf % n_v ** 2 ) * ( wf % n_o ), ( wf % n_o )) ! u_ak_bj ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do b = 1 , wf % n_v ! bk = index_two ( b , k , wf % n_v ) ! do i = 1 , wf % n_o ! ci = index_two ( c , i , wf % n_v ) bi = index_two ( b , i , wf % n_v ) ! ckbi = index_packed ( ck , bi ) cibk = index_packed ( ci , bk ) bkc = index_three ( b , k , c , wf % n_v , wf % n_o ) ! u_bkc_i ( bkc , i ) = two * wf % s2am ( ckbi , 1 ) - wf % s2am ( cibk , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_s2am ! !     X_j_i = -sum_(bkc) g_j_bkc * u_bkc_i ! call wf % mem % alloc ( X_j_i , wf % n_o , wf % n_o ) ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & wf % n_o * ( wf % n_v ** 2 ), & - one , & g_jb_kc , & wf % n_o , & u_bkc_i , & wf % n_o * ( wf % n_v ** 2 ), & zero , & X_j_i , & wf % n_o ) ! call wf % mem % alloc ( u_bkc_i , ( wf % n_v ** 2 ) * ( wf % n_o ), ( wf % n_o )) ! u_ak_bj ! !     rho_a_i =+ sum_(c) X_j_i * c_a_j ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & wf % n_o , & one , & c_a_i , & ! c_a_j wf % n_v , & X_j_i , & wf % n_o , & one , & rho_a_i , & wf % n_v ) ! call wf % mem % dealloc ( X_j_i , wf % n_o , wf % n_o ) ! !     :: Term a1.1 :: !     sum_(ckbj) L_jb,kc u_ki&#94;ca c_bj ! !     construct L_kc,bj ordered as L_kc_bj ! call wf % mem % alloc ( L_ck_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! kc = index_two ( k , c , wf % n_o ) ck = index_two ( c , k , wf % n_v ) ! do j = 1 , wf % n_o ! jc = index_two ( j , c , wf % n_o ) ! do b = 1 , wf % n_v ! kb = index_two ( k , b , wf % n_o ) jb = index_two ( j , b , wf % n_o ) bj = index_two ( b , j , wf % n_v ) ! L_ck_bj ( ck , bj ) = two * g_jb_kc ( kc , jb ) - g_jb_kc ( jc , kb ) ! enddo enddo enddo enddo ! !     construct u_ai,ck ordered as u_ai_ck ! call wf % read_amplitudes ! call wf % mem % alloc ( u_ai_ck , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do a = 1 , wf % n_v ! ak = index_two ( a , k , wf % n_v ) ! do i = 1 , wf % n_o ! ci = index_two ( c , i , wf % n_v ) ai = index_two ( a , i , wf % n_v ) ! ckai = index_packed ( ck , ai ) ciak = index_packed ( ci , ak ) ! u_ai_ck ( ai , ck ) = two * wf % s2am ( ckai , 1 ) - wf % s2am ( ciak , 1 ) ! enddo enddo enddo enddo ! call wf % destruct_s2am ! !     X_ai_bj = sum_(ck) u_ai_ck * L_ck_bj ! call wf % mem % alloc ( X_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & u_ai_ck , & ( wf % n_o ) * ( wf % n_v ), & L_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( u_ai_ck , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) call wf % mem % dealloc ( L_ck_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & X_ai_bj , & ( wf % n_o ) * ( wf % n_v ), & c_a_i , & ! c_bj ( wf % n_o ) * ( wf % n_v ), & one , & rho_a_i , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( X_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_cc2_a1_cc2 ! ! module subroutine jacobian_cc2_b1_cc2 ( wf , rho_a_i , c_ai_bj ) !! !!    jacobian tem b1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, june 2017 !! !!    calculates the b1 contribution to the jacobi transformation, !! !!       b1:   sum_ck F_kc*(2c_ai,ck - c_ak,ci) !!           - sum_ckj L_jikc * c_aj,ck + sum_cbk L_abkc * c_bi,ck !! !! !!    L_abkc is constructed while batching over a. !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension (:,:) :: c_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! !     batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , offset = 0 integer ( i15 ) :: a_n_batch = 0 , a_first = 0 , a_last = 0 , a_batch = 0 , a_length = 0 ! !     allocatables ! real ( dp ), dimension (:,:), allocatable :: d_ai_kc real ( dp ), dimension (:,:), allocatable :: c_bkc_i real ( dp ), dimension (:,:), allocatable :: g_ji_kc real ( dp ), dimension (:,:), allocatable :: g_ab_kc real ( dp ), dimension (:,:), allocatable :: L_jck_i real ( dp ), dimension (:,:), allocatable :: L_ab_kc ! integer ( i15 ) :: k = 0 , c = 0 , a = 0 , i = 0 , j = 0 , b = 0 integer ( i15 ) :: ak = 0 , ck = 0 , ai = 0 , ci = 0 , ji = 0 , ki = 0 , kc = 0 , jc = 0 , ac = 0 , ab = 0 , bi = 0 , kb = 0 integer ( i15 ) :: jck = 0 , bkc ! !     :: Term 1 :: !     sum_ck F_kc*(2c_ai,ck - c_ak,ci) ! call wf % mem % alloc ( d_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     construct 2c_ai,ck - c_ak,ci = d_ai_kc ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do k = 1 , wf % n_o ! ak = index_two ( a , k , wf % n_v ) ! do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) kc = index_two ( k , c , wf % n_o ) ci = index_two ( c , i , wf % n_v ) ! d_ai_kc ( ai , kc ) = two * c_ai_bj ( ai , ck ) - c_ai_bj ( ak , ci ) ! enddo enddo enddo enddo ! ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & d_ai_kc , & ( wf % n_o ) * ( wf % n_v ), & wf % fock_ia , & !f_kc ( wf % n_o ) * ( wf % n_v ), & one , & rho_a_i , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( d_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     :: Term 2 :: !     - sum_ckj L_ji,kc * c_aj,ck = - sum_ckj (2*g_jikc - g_kijc) * c_aj,ck (L_ji,kc ordered as L_jck_i) ! call wf % mem % alloc ( g_ji_kc , ( wf % n_o ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! integral_type = 'electronic_repulsion' call wf % get_oo_ov ( integral_type , g_ji_kc ) ! !     construct L_jikc ( = two*g_ji_kc - g_ki_jc ) ! call wf % mem % alloc ( L_jck_i , ( wf % n_o ** 2 ) * ( wf % n_v ), wf % n_o ) ! do j = 1 , wf % n_o do i = 1 , wf % n_o do c = 1 , wf % n_v do k = 1 , wf % n_o kc = index_two ( k , c , wf % n_o ) ki = index_two ( k , i , wf % n_o ) jc = index_two ( j , c , wf % n_o ) ji = index_two ( j , i , wf % n_o ) jck = index_three ( j , c , k , wf % n_o , wf % n_v ) ! L_jck_i ( jck , i ) = two * g_ji_kc ( ji , kc ) - g_ji_kc ( ki , jc ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ji_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     add term to rho_a_i ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & wf % n_v * wf % n_o ** 2 , & - one , & c_ai_bj , & wf % n_v , & L_jck_i , & wf % n_v * wf % n_o ** 2 , & one , & rho_a_i , & wf % n_v ) ! call wf % mem % dealloc ( L_jck_i , ( wf % n_o ** 2 ) * wf % n_v , wf % n_o ) ! !    :: Term 3 :: !    sum_cbk L_abkc * c_bi,ck ! !    Prepare for batching over a ! required = max ( 2 * ( wf % n_v ** 3 ) * ( wf % n_o ), & ( wf % n_v ** 3 ) * ( wf % n_o ) + wf % n_o * wf % n_v * ( wf % n_j ) + ( wf % n_v ** 2 ) * ( wf % n_j )) ! required = required * 4 ! Words available = get_available () max_length = 0 call num_batch ( required , available , max_length , a_n_batch , wf % n_v ) ! !    initialize some variables for batching ! a_first = 0 a_last = 0 a_length = 0 ! !    Start looping over a-batches ! do a_batch = 1 , a_n_batch ! call batch_limits ( a_first , a_last , a_batch , max_length , wf % n_v ) ! a_length = a_last - a_first + 1 ! call wf % mem % alloc ( g_ab_kc , wf % n_v * a_length , ( wf % n_v ) * ( wf % n_o )) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , g_ab_kc , a_first , a_last , 1 , wf % n_v , 1 , wf % n_o , 1 , wf % n_v ) ! !       construct L_ab_kc = 2*g_ab_kc - g_ac_kb ! call wf % mem % alloc ( L_ab_kc , ( wf % n_v ) * a_length , ( wf % n_o ) * ( wf % n_v )) do a = 1 , a_length do b = 1 , wf % n_v do c = 1 , wf % n_v do k = 1 , wf % n_o ! ab = index_two ( a , b , a_length ) kc = index_two ( k , c , wf % n_o ) kb = index_two ( k , b , wf % n_o ) ac = index_two ( a , c , a_length ) ! L_ab_kc ( ab , kc ) = two * g_ab_kc ( ab , kc ) - g_ab_kc ( ac , kb ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ab_kc , ( wf % n_v ) * a_length , ( wf % n_o ) * ( wf % n_v )) ! !       Reorder c_bi_ck to c_bkc_i ! call wf % mem % alloc ( c_bkc_i , ( wf % n_v ** 2 ) * ( wf % n_o ), wf % n_o ) do i = 1 , wf % n_o do b = 1 , wf % n_v do c = 1 , wf % n_v do k = 1 , wf % n_o ! bi = index_two ( b , i , wf % n_v ) ck = index_two ( c , k , wf % n_v ) bkc = index_three ( b , k , c , wf % n_v , wf % n_o ) ! c_bkc_i ( bkc , i ) = c_ai_bj ( bi , ck ) ! enddo enddo enddo enddo ! !       add contribution for current batch to rho ! call dgemm ( 'N' , 'N' , & a_length , & wf % n_o , & ( wf % n_v ** 2 ) * wf % n_o , & one , & L_ab_kc , & a_length , & c_bkc_i , & ( wf % n_v ** 2 ) * wf % n_o , & one , & rho_a_i ( a_first , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( L_ab_kc , ( wf % n_v ) * a_length , ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( c_bkc_i , ( wf % n_v ** 2 ) * wf % n_o , wf % n_o ) ! enddo ! batching over a ! ! end subroutine jacobian_cc2_b1_cc2 ! ! module subroutine jacobian_cc2_a2_cc2 ( wf , rho_ai_bj , c_a_i ) !! !!    jacobian tem a2 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, june 2017 !! !!    calculates the a2 contribution to the jacobi transformation, !! !!       a2:   sum_c g_ai,bc * c_cj - sum_K g_ai,kj * c_bk. !! !!    g_ai,bc is constructed in batches of c. !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension (: , :) :: rho_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! !     batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , batch_dimension = 0 , offset = 0 integer ( i15 ) :: c_n_batch = 0 , c_first = 0 , c_last = 0 , c_batch = 0 , c_length = 0 ! !     allocatables ! real ( dp ), dimension (:,:), allocatable :: g_ai_bc real ( dp ), dimension (:,:), allocatable :: g_ai_Kj real ( dp ), dimension (:,:), allocatable :: g_aij_K real ( dp ), dimension (:,:), allocatable :: rho_aij_b real ( dp ), dimension (:,:), allocatable :: rho_aib_j ! !     indices ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 , K = 0 integer ( i15 ) :: Kj = 0 , ai = 0 , aij = 0 , bj = 0 ! !     :: Term 1 :: !     sum_c g_aib_c * c_c_j(= sum_c g_ai,bc * c_cj) ! required = max ( 2 * wf % n_v * ( wf % n_v ) * ( wf % n_J ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & wf % n_v * ( wf % n_v ) * ( wf % n_J ) + ( wf % n_v ** 2 ) * ( wf % n_v ) * wf % n_o ) ! ! required = required * 4 ! Words available = get_available () max_length = 0 call num_batch ( required , available , max_length , c_n_batch , wf % n_v ) ! !     Initialize some variables for batching ! c_first = 0 c_last = 0 c_length = 0 ! !     Start looping over batches of c ! do c_batch = 1 , c_n_batch ! call batch_limits ( c_first , c_last , c_batch , max_length , wf % n_v ) ! !        construct g_ai,bc ordered as g_ai_bc batching over c ! c_length = c_last - c_first + 1 ! call wf % mem % alloc ( g_ai_bc , wf % n_v * wf % n_o , wf % n_v * c_length ) ! integral_type = 'electronic_repulsion' call wf % get_vo_vv ( integral_type , g_ai_bc , 1 , wf % n_v , 1 , wf % n_o , 1 , wf % n_v , c_first , c_last ) ! !        Add contribution tho rho ! call dgemm ( 'N' , 'N' , & ( wf % n_v ** 2 ) * wf % n_o , & wf % n_o , & c_length , & one , & g_ai_bc , & (( wf % n_v ) ** 2 ) * wf % n_o , & c_a_i ( c_first , 1 ), & wf % n_v , & one , & rho_ai_bj , & ( wf % n_v ** 2 ) * wf % n_o ) ! call wf % mem % dealloc ( g_ai_bc , wf % n_v * wf % n_o , wf % n_v * c_length ) ! enddo ! batching over c ! !     :: Term 2 :: !     - sum_K g_aij_K * c_K_b(= - sum_K g_ai,Kj * c_bK) ! !     construct g_ai,Kj ordered as g_aij_K ! call wf % mem % alloc ( g_ai_kj , wf % n_v * wf % n_o , wf % n_o ** 2 ) ! integral_type = 'electronic_repulsion' call wf % get_vo_oo ( integral_type , g_ai_kj ) ! !     Reorder g_ai_Kj to g_aij_K ! call wf % mem % alloc ( g_aij_K , wf % n_v * wf % n_o ** 2 , wf % n_o ) g_aij_K = zero do a = 1 , wf % n_v do j = 1 , wf % n_o do i = 1 , wf % n_o aij = index_three ( a , i , j , wf % n_v , wf % n_o ) ai = index_two ( a , i , wf % n_v ) do K = 1 , wf % n_o Kj = index_two ( K , j , wf % n_o ) g_aij_K ( aij , K ) = g_ai_Kj ( ai , Kj ) enddo enddo enddo enddo call wf % mem % dealloc ( g_ai_Kj , wf % n_v * wf % n_o , wf % n_o * ( wf % n_o )) ! call wf % mem % alloc ( rho_aij_b , wf % n_v * wf % n_o ** 2 , wf % n_v ) ! !      Add term to rho_ai_bj ! call dgemm ( 'N' , 'T' , & wf % n_v * wf % n_o ** 2 , & wf % n_v , & wf % n_o , & - one , & g_aij_K , & wf % n_v * wf % n_o ** 2 , & c_a_i , & wf % n_v , & zero , & rho_aij_b , & wf % n_v * wf % n_o ** 2 ) ! call wf % mem % dealloc ( g_aij_K , wf % n_v * wf % n_o ** 2 , wf % n_o ) ! ! !     Reorder into rho_ai_bj ! do a = 1 , wf % n_v do b = 1 , wf % n_v do i = 1 , wf % n_o do j = 1 , wf % n_o ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) aij = index_three ( a , i , j , wf % n_v , wf % n_o ) rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + rho_aij_b ( aij , b ) enddo enddo enddo enddo call wf % mem % dealloc ( rho_aij_b , wf % n_v * wf % n_o ** 2 , wf % n_v ) ! ! end subroutine jacobian_cc2_a2_cc2 ! ! module subroutine jacobian_cc2_b2_cc2 ( wf , rho_ai_bj , c_ai_bj ) !! !!    jacobian tem b2 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, june 2017 !! !!    calculates the b2 contribution to the jacobi transformation, !! !!       b2:   ε_ij&#94;ab*c_ai,bj. !! !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension (:,:) :: c_ai_bj real ( dp ), dimension (:,:) :: rho_ai_bj ! !     Local routine variables ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 integer ( i15 ) :: ai = 0 , bj = 0 ! do i = 1 , wf % n_o ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! rho_ai_bj ( ai , bj ) = rho_ai_bj ( ai , bj ) + c_ai_bj ( ai , bj ) * ( wf % fock_diagonal ( wf % n_o + a , 1 ) & - wf % fock_diagonal ( i , 1 ) & + wf % fock_diagonal ( wf % n_o + b , 1 ) & - wf % fock_diagonal ( j , 1 )) ! enddo enddo enddo enddo ! end subroutine jacobian_cc2_b2_cc2 ! ! module subroutine cvs_rho_aibj_projection_cc2 ( wf , vec_aibj ) !! !!    Rho projection for cVS (cc2), !!    Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( cc2 ) :: wf real ( dp ), dimension (:, :) :: vec_aibj ! integer ( i15 ) :: i = 0 , a = 0 , j = 0 , b = 0 , core = 0 , ai = 0 , bj = 0 , aibj = 0 ! logical :: core_orbital ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if (( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) . or . & ( j . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 ))) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , wf % n_v do b = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) aibj = index_packed ( ai , bj ) vec_aibj ( aibj , 1 ) = zero ! enddo enddo endif enddo enddo ! end subroutine cvs_rho_aibj_projection_cc2 ! ! ! end submodule jacobian","tags":"","loc":"sourcefile/jacobian_submodule.f90~4.html","title":"jacobian_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~omega_submodule.f90~5~~EfferentGraph sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~cc2_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~cc2_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~cc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~cc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileomega_submodulef905EfferentGraph = svgPanZoom('#sourcefileomega_submodulef905EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules omega Source Code omega_submodule.F90 Source Code submodule ( cc2_class ) omega ! !! !!    Omega submodule (CC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Apr 2017 !! !!    Contains the following family of procedures of the CC2 class: !! !!    initialize_omega: allocates the projection vector omega1 !!                      and sets it to zero. !! !!    construct_omega: constructs the projection vector omega1 !!                     for the current amplitudes t1am for the !!                     wavefunction object wf. !!                     The routine assumes that the projection !!                     vector is allocated. !! !!    omega_a1:  adds A1 term to omega1 !!    omega_b1:  adds B1 term to omega1 !!    omega_c1:  adds C1 term to omega1 !! ! implicit none ! logical :: debug = . false . logical :: timings = . false . ! character ( len = 40 ) :: integral_type ! ! contains ! module subroutine construct_omega_cc2 ( wf ) ! !     Construct Omega (CC2) !     Written by Eirik F. Kjønstad and Sarai Folkestad, Apr 2017 ! !     The routine also sets up timing variables. ! implicit none ! class ( cc2 ) :: wf ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: g_ia_bj ! Reordered g_aibj ! !     Batching variables ! integer ( i15 ) :: a_batch , a_first , a_last , a_length integer ( i15 ) :: required , available , n_batch , batch_dimension , max_batch_length ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: bj = 0 , ai = 0 , ia = 0 ! !     Timing variables ! real ( dp ) :: omega_start = zero real ( dp ) :: omega_end = zero ! !     Start timing of omega ! call cpu_time ( omega_start ) ! !     Set the omega vector to zero ! wf % omega1 = zero ! !     :: Calculate CCS omega contributions :: ! call wf % omega_ccs_a1 ! !     :: Calculate CC2 omega contributions :: ! call wf % omega_cc2_a1 ! call wf % omega_cc2_b1 ! !     Timings ! call cpu_time ( omega_end ) if ( timings ) write ( unit_output , * ) 'Time in omega:' , omega_end - omega_start ! end subroutine construct_omega_cc2 ! ! module subroutine omega_cc2_a1_cc2 ( wf ) !! !!     Omega A1 !!     Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!     Calculates the A1 term of omega for the active space, !! !!     A1: sum_bcj g_ab,jc * u_ij&#94;bc, !! !!     and adds it to the projection vector (omega1) of !!     the wavefunction object wf !! !!     u_ij&#94;bc = 2*s_ij&#94;bc - s_ij&#94;cb !! !!    Batching over A and c !! !! implicit none ! class ( cc2 ) :: wf ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , batch_dimension = 0 , offset = 0 integer ( i15 ) :: A_n_batch = 0 , A_first = 0 , A_last = 0 , A_batch = 0 , A_length = 0 integer ( i15 ) :: c_n_batch = 0 , c_first = 0 , c_last = 0 , c_batch = 0 , c_length = 0 ! !     Indices ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , c = 0 , b = 0 ! integer ( i15 ) :: ba = 0 , ab = 0 , bi = 0 integer ( i15 ) :: ic = 0 , ib = 0 , jc = 0 , jb = 0 integer ( i15 ) :: bjc = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: g_ib_jc real ( dp ), dimension (:,:), allocatable :: s_ib_jc real ( dp ), dimension (:,:), allocatable :: u_bjc_i real ( dp ), dimension (:,:), allocatable :: g_Ab_jc real ( dp ), dimension (:,:), allocatable :: L_Ab_J ! L_Ab&#94;J; A is batched over ! logical :: reorder ! To get L_ab_J reordered, for batching over a ! !     Prepare for batching ocer c and A ! required = wf % n_v * ( wf % n_v ) * ( wf % n_J ) & + wf % n_v * ( wf % n_o ) * ( wf % n_J ) & + ( wf % n_v ** 2 ) * ( wf % n_o ) * wf % n_o & + (( wf % n_o ) ** 2 ) * (( wf % n_v ) ** 2 ) ! ! required = required * 4 ! Words available = get_available () max_length = 0 ! call num_two_batch ( required , available , max_length , c_n_batch , wf % n_v ) ! !     Initialize some variables for batching ! c_first = 0 c_last = 0 c_length = 0 ! !     Start looping over batches of c ! do c_batch = 1 , c_n_batch ! call batch_limits ( c_first , c_last , c_batch , max_length , wf % n_v ) ! !        Length of batch ! c_length = c_last - c_first + 1 ! !        :: Construct u_ib_jc :: ! !        u_ij&#94;bc = 2*s_ij&#94;bc - s_ij&#94;cb =  (2*g_ij&#94;bc - g_ij&#94;cb)/ε_ij&#94;cb ! call wf % mem % alloc ( s_ib_jc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * c_length ) call wf % get_s2am ( s_ib_jc , c_first , c_length ) ! call wf % mem % alloc ( u_bjc_i , wf % n_v * wf % n_o * c_length , wf % n_o ) ! do b = 1 , wf % n_v do i = 1 , wf % n_o ! ib = index_two ( i , b , wf % n_o ) ! do c = 1 , c_length do j = 1 , wf % n_o ! jc = index_two ( j , c , wf % n_o ) jb = index_two ( j , b , wf % n_o ) ic = index_two ( i , c , wf % n_o ) ! bjc = index_three ( b , j , c , wf % n_v , wf % n_o ) ! u_bjc_i ( bjc , i ) = ( two * s_ib_jc ( ib , jc ) - s_ib_jc ( jb , ic )) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( s_ib_jc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * c_length ) ! !        Prepare for batching over A ! A_first = 0 A_last = 0 A_length = 0 A_n_batch = c_n_batch ! !        Start looping over a-batches ! do A_batch = 1 , A_n_batch ! call batch_limits ( A_first , A_last , A_batch , max_length , wf % n_v ) A_length = A_last - A_first + 1 ! !           :: Construct integral g_ab,jc :: ! call wf % mem % alloc ( g_ab_jc , wf % n_v * a_length , wf % n_o * c_length ) ! integral_type = 'electronic_repulsion' call wf % get_vv_ov ( integral_type , g_ab_jc , a_first , a_last , 1 , wf % n_v , 1 , wf % n_o , c_first , c_last ) ! ! !           :: Add contributions to omega :: ! call dgemm ( 'N' , 'N' , & A_length , & wf % n_o , & ( wf % n_v ) * ( wf % n_o ) * c_length , & one , & g_ab_jc , & A_length , & u_bjc_i , & ( wf % n_v ) * ( wf % n_o ) * c_length , & one , & wf % omega1 ( A_first , 1 ), & wf % n_v ) ! call wf % mem % dealloc ( g_ab_jc , ( wf % n_v ) * a_length , wf % n_o * c_length ) ! enddo ! Batching over a ! call wf % mem % dealloc ( u_bjc_i , ( wf % n_v ) * ( wf % n_o ) * c_length , wf % n_o ) ! enddo ! Batching over c ! end subroutine omega_cc2_a1_cc2 ! ! module subroutine omega_cc2_b1_cc2 ( wf ) !! !!    Omega B1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Calculates the B1 term of omega, !! !!    B1: - sum_bjk u_jk&#94;ab*g_kbjI + sum_bj u_ij&#94;ab F_jb, !! !!    with u_ij&#94;ab = 2*s_ij&#94;ab - s_ij&#94;ba. !! !!    Batching over b. !! implicit none ! class ( cc2 ) :: wf ! !     Batching ! integer ( i15 ) :: required = 0 , available = 0 , max_length = 0 , batch_dimension = 0 , offset = 0 integer ( i15 ) :: b_n_batch = 0 , b_first = 0 , b_last = 0 , b_batch = 0 , b_length = 0 ! !     Allocatables ! real ( dp ), dimension (:,:), allocatable :: s_ja_kb real ( dp ), dimension (:,:), allocatable :: u_a_kbj real ( dp ), dimension (:,:), allocatable :: g_kb_ji ! !     looping indices ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 , a = 0 , b = 0 integer ( i15 ) :: I_full = 0 , J_full = 0 , A_full = 0 , B_full = 0 integer ( i15 ) :: ja = 0 , kb = 0 , ka = 0 , jb = 0 , aj = 0 integer ( i15 ) :: kbj = 0 , jbi = 0 ! !     Prepare for batching ! required = (( wf % n_o ) ** 3 ) * ( wf % n_v ) + (( wf % n_o ) ** 2 ) * ( wf % n_J ) & + ( wf % n_o ) * ( wf % n_v ) * ( wf % n_J ) + (( wf % n_o ) ** 2 ) * (( wf % n_v ) ** 2 ) ! ! required = required * 4 ! Words available = get_available () max_length = 0 call num_batch ( required , available , max_length , b_n_batch , wf % n_v ) ! !     Initialize some variables for batching ! b_first = 0 b_last = 0 b_length = 0 ! !     Start looping over a-batches ! do b_batch = 1 , b_n_batch ! call batch_limits ( b_first , b_last , b_batch , max_length , wf % n_v ) ! !        b is active index, and thus b_first and b_last must be displaced ! b_length = b_last - b_first + 1 ! !        :: Construct u_jk&#94;ab :: ! !        u_jk&#94;ab = 2*s_jk&#94;ab - s_jk&#94;ba  (place in u_a_jkb) ! call wf % mem % alloc ( s_ja_kb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * b_length ) call wf % get_s2am ( s_ja_kb , b_first , b_length ) ! call wf % mem % alloc ( u_a_kbj , wf % n_v , ( wf % n_o ** 2 ) * b_length ) do k = 1 , wf % n_o do b = 1 , b_length ! kb = index_two ( k , b , wf % n_o ) ! do j = 1 , wf % n_o ! jb = index_two ( j , b , wf % n_o ) kbj = index_three ( k , b , j , wf % n_o , b_length ) ! do a = 1 , wf % n_v ! ja = index_two ( j , a , wf % n_o ) ka = index_two ( k , a , wf % n_o ) ! u_a_kbj ( a , kbj ) = ( two * s_ja_kb ( ja , kb ) - s_ja_kb ( ka , jb )) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( s_ja_kb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( b_length )) ! !        :: - sum_bjk u_ja_kb * g_kb_jI :: ! call wf % mem % alloc ( g_kb_ji , ( wf % n_o ) * b_length , ( wf % n_o ) ** 2 ) ! integral_type = 'electronic_repulsion' call wf % get_ov_oo ( integral_type , g_kb_ji , 1 , wf % n_o , b_first , b_last , 1 , wf % n_o , 1 , wf % n_o ) ! !        Add contributions to omega ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_o ), & b_length * (( wf % n_o ) ** 2 ), & - one , & u_a_kbj , & wf % n_v , & g_kb_ji , & b_length * (( wf % n_o ) ** 2 ), & one , & wf % omega1 , & ( wf % n_v )) ! call wf % mem % dealloc ( g_kb_ji , wf % n_o * b_length , wf % n_o * ( wf % n_o )) ! !        :: sum_jb F_jb u_ij&#94;ab :: ! do i = 1 , wf % n_o ! do a = 1 , wf % n_v ! do j = 1 , wf % n_o ! do b = 1 , b_length ! B_full = b + b_first - 1 ! jbi = index_three ( j , b , i , wf % n_o , b_length ) wf % omega1 ( a , i ) = wf % omega1 ( a , i ) + u_a_kbj ( a , jbi ) * wf % fock_ia ( j , B_full ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( u_a_kbj , wf % n_v , ( wf % n_o ** 2 ) * b_length ) ! enddo ! end subroutine omega_cc2_b1_cc2 ! module subroutine get_s2am_cc2 ( wf , s_ia_jb , b_first , b_length ) !! !!    Get S_2 amplitudes, !!    Written by Sarai D. Folkestad, July 2017 !! !!    Construct !! !!       s_ai_bj = - 1/ε_ij&#94;ab * g_aibj, !! !!    while batching over b. !! implicit none ! class ( cc2 ) :: wf ! integer ( i15 ) :: b_first , b_length real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), b_length * ( wf % n_o )) :: s_ia_jb ! real ( dp ), dimension (:,:), allocatable :: g_ai_bj ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 , ia = 0 , jb = 0 , ai = 0 , bj = 0 ! ! call wf % mem % alloc ( g_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * b_length ) ! integral_type = 'electronic_repulsion' call wf % get_vo_vo ( integral_type , g_ai_bj , 1 , wf % n_v , 1 , wf % n_o , b_first , b_first + b_length - 1 , 1 , wf % n_o ) ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ia = index_two ( i , a , wf % n_o ) ai = index_two ( a , i , wf % n_v ) ! do b = 1 , b_length do j = 1 , wf % n_o ! jb = index_two ( j , b , wf % n_o ) bj = index_two ( b , j , wf % n_v ) ! s_ia_jb ( ia , jb ) = g_ai_bj ( ai , bj ) / ( wf % fock_diagonal ( i , 1 )& + wf % fock_diagonal ( j , 1 ) & - wf % fock_diagonal ( wf % n_o + b + b_first - 1 , 1 ) & - wf % fock_diagonal ( wf % n_o + a , 1 )) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * b_length ) ! end subroutine get_s2am_cc2 ! ! end submodule","tags":"","loc":"sourcefile/omega_submodule.f90~5.html","title":"omega_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~excited_state_submodule.f90~4~~EfferentGraph sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~cc2_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~cc2_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~cc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~cc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileexcited_state_submodulef904EfferentGraph = svgPanZoom('#sourcefileexcited_state_submodulef904EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules excited_state Source Code excited_state_submodule.F90 Source Code submodule ( cc2_class ) excited_state ! !! !!    Excited state submodule (CC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Contains the following family of procedures of the CC2 class: !! !!    inititialize_excited_states: Initializes number of s2 amplitudes (n_s2am), and adds it n_parameters !!    calculate_orbital_differences: Calculates the orbital differences, including the double excitation differences !!                                   in the active CC2 spaces !!    transform_trial_vectors: Transforms the new trial vectors. rho = Ac !! !!    Upper case indices are general indices, lower case indices are restricted !!    to the CC2 orbital space. !! ! implicit none ! logical :: debug = . false . logical :: timings = . false . ! ! contains ! ! module subroutine initialize_excited_states_cc2 ( wf ) !! !!    Initialize excited states !!    Written by Sarai D. Folkestad, June 2017 !! !!    Calculates and sets n_s2am, and updates n_parameters !!    for excited state calculation !! implicit none ! class ( cc2 ) :: wf ! wf % n_s2am = (( wf % n_v ) * ( wf % n_o )) * (( wf % n_v ) * ( wf % n_o ) + 1 ) / 2 ! wf % n_parameters = wf % n_parameters + wf % n_s2am ! end subroutine initialize_excited_states_cc2 ! ! module subroutine calculate_orbital_differences_cc2 ( wf , orbital_diff ) !! !!    Calculate Orbital Differences (CC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad May 2017 !! !!    Calculates orbital differences !! !!       1) ε_I&#94;A = ε_A - ε_I !!       2) ε_ij&#94;ab = ε_a + ε_b - ε_i - ε_j (for active spaces only) !! !!    and puts them in orbital_diff, which is a vector of length n_parameters. !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: orbital_diff ! ! integer ( i15 ) :: A = 0 , I = 0 , b = 0 , j = 0 integer ( i15 ) :: AI = 0 , bj = 0 integer ( i15 ) :: aibj = 0 ! do I = 1 , wf % n_o do A = 1 , wf % n_v ! AI = index_two ( A , I , wf % n_v ) ! orbital_diff ( AI , 1 ) = wf % fock_diagonal ( A + wf % n_o , 1 ) - wf % fock_diagonal ( I , 1 ) ! enddo enddo ! do i = 1 , wf % n_o ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! orbital_diff (( wf % n_o ) * ( wf % n_v ) + aibj , 1 ) & = wf % fock_diagonal ( wf % n_o + a , 1 ) & - wf % fock_diagonal ( i , 1 ) & + wf % fock_diagonal ( wf % n_o + b , 1 ) & - wf % fock_diagonal ( j , 1 ) ! enddo enddo enddo enddo ! end subroutine calculate_orbital_differences_cc2 ! ! module subroutine transform_trial_vectors_cc2 ( wf , first_trial , last_trial ) !! !!    Transformation of Trial Vectors (CC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Each trial vector in first_trial to last_trial is read from file and !!    transformed before the transformed vector is written to file. !! !!    Singles and doubles part of the transformed vectors are written to !!    the same record in file transformed_vec, record length is n_parameters long. !! implicit none ! class ( cc2 ) :: wf ! integer ( i15 ), intent ( in ) :: first_trial , last_trial ! Which trial_vectors we are to transform ! real ( dp ), dimension (:,:), allocatable :: c_a_i real ( dp ), dimension (:,:), allocatable :: c_aibj ! integer ( i15 ) :: unit_trial_vecs = 0 , unit_rho = 0 , ioerror = 0 integer ( i15 ) :: trial = 0 ! ! !     Allocate c_a_i and c_aibj ! call wf % mem % alloc ( c_a_i , wf % n_v , wf % n_o ) c_a_i = zero ! call wf % mem % alloc ( c_aibj , wf % n_s2am , 1 ) c_aibj = zero ! !     Open trial vector- and transformed vector files ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * wf % n_parameters , iostat = ioerror ) ! call generate_unit_identifier ( unit_rho ) open ( unit = unit_rho , file = 'transformed_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * wf % n_parameters , iostat = ioerror ) ! !     For each trial vector: read, transform and write ! do trial = first_trial , last_trial ! read ( unit_trial_vecs , rec = trial , iostat = ioerror ) c_a_i , c_aibj ! if ( wf % tasks % current == 'excited_state' ) then ! if ( wf % excited_state_specifications % right ) then ! call wf % jacobian_cc2_transformation ( c_a_i , c_aibj ) ! elseif ( wf % excited_state_specifications % left ) then ! write ( unit_output , * ) 'Error: Jacobian transpose transformation not implemented for CC2' stop ! else ! write ( unit_output , * ) 'Error: Excited state task not recognized' stop ! endif ! elseif ( wf % tasks % current == 'multipliers' ) then ! write ( unit_output , * ) 'Error: multipliers not implemented for CC2' stop ! else ! write ( unit_output , * ) 'Error: Current task not recognized' stop ! endif ! !        -::- Projections -::- ! !        Test for core calculation ! if ( wf % tasks % core_excited_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from valence contributions ! call wf % cvs_rho_a_i_projection ( c_a_i ) call wf % cvs_rho_aibj_projection ( c_aibj ) ! endif ! !        Test for ionization calculation ! if ( wf % tasks % ionized_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from regular excitations ! write ( unit_output , * ) 'Error: Ionized state not implemented for CC2' stop ! endif ! ! write ( unit_rho , rec = trial , iostat = ioerror ) c_a_i , c_aibj ! enddo ! !     Close files ! close ( unit_trial_vecs ) close ( unit_rho ) ! !     Deallocate c_a_i and c_aibj ! call wf % mem % dealloc ( c_a_i , wf % n_v , wf % n_o ) call wf % mem % dealloc ( c_aibj , wf % n_s2am , 1 ) ! end subroutine transform_trial_vectors_cc2 ! ! module subroutine cvs_residual_projection_cc2 ( wf , residual ) !! !!    Residual projection (CC2), !!    Written by Sarai D. Folkestad Aug. 2017 !! implicit none ! class ( cc2 ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! integer ( i15 ) :: i = 0 , a = 0 , j = 0 , b = 0 , core = 0 , ai = 0 , bj = 0 , aibj = 0 ! logical :: core_orbital do i = 1 , wf % n_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if ( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) residual ( ai , 1 ) = zero enddo endif ! enddo ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if (( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) . or . & ( j . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 ))) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , wf % n_v do b = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) aibj = index_packed ( ai , bj ) residual ( wf % n_t1am + aibj , 1 ) = zero enddo enddo endif enddo enddo ! end subroutine cvs_residual_projection_cc2 ! ! module subroutine excited_state_preparations_cc2 ( wf ) !! !!    Excited State Preparations (CC2) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    A routine for preparation tasks (if any). Can be overwritten !!    in descendants if other preparations prove necessary. !! class ( cc2 ) :: wf ! !     Store vvov-electronic repulsion integrals to file if there is space ! call wf % mem % alloc ( wf % t1am , wf % n_v , wf % n_o ) call wf % read_single_amplitudes ! call wf % store_t1_vv_ov_electronic_repulsion ! !     Set current task to excited state calculation ! wf % tasks % current = 'excited_state' ! !     Set filename for solution vectors ! if ( wf % tasks % core_excited_state . or . wf % tasks % core_ionized_state ) then ! Core excitation ! if ( wf % excited_state_specifications % right ) then ! Right vectors wf % excited_state_specifications % solution_file = 'right_core' else ! Left vectors write ( unit_output , * ) 'Error: Jacobian transpose transformation not implemented for core excitations' ! S: should be able to get these with the same projections however so... stop endif ! else ! Valence excitation ! if ( wf % excited_state_specifications % left ) then ! Right vectors wf % excited_state_specifications % solution_file = 'left_valence' else ! Left vectors wf % excited_state_specifications % solution_file = 'right_valence' endif ! endif ! call deallocator ( wf % t1am , wf % n_v , wf % n_o ) ! end subroutine excited_state_preparations_cc2 ! ! module subroutine analyze_double_excitation_vector_cc2 ( wf , vec , n , sorted_short_vec , index_list ) !! !! !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension ( wf % n_s2am , 1 ) :: vec ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 , k = 0 ! integer ( i15 ) :: n ! Number of elements wanted ! real ( dp ), dimension ( n , 1 ) :: sorted_short_vec ! integer ( i15 ), dimension ( n , 4 ) :: index_list ! !     Variables for sorting ! real ( dp ) :: min integer ( i15 ) :: min_pos ! real ( dp ) :: swap = zero integer ( i15 ) :: swap_i = 0 , swap_a = 0 , swap_j = 0 , swap_b = 0 ! !     Placing the n first elements of vec into sorted_short_vec ! index_list = 0 sorted_short_vec ( 1 , 1 ) = vec ( 1 , 1 ) index_list ( 1 , 1 ) = 1 index_list ( 1 , 2 ) = 1 index_list ( 1 , 3 ) = 1 index_list ( 1 , 4 ) = 1 ! min = abs ( sorted_short_vec ( 1 , 1 )) min_pos = 1 ! do i = 1 , wf % n_o do a = 1 , wf % n_v do j = 1 , wf % n_o do b = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! if ( ai . ge . bj ) then ! aibj = index_packed ( ai , bj ) ! if ( aibj . le . n ) then sorted_short_vec ( aibj , 1 ) = vec ( aibj , 1 ) index_list ( min_pos , 1 ) = a index_list ( min_pos , 2 ) = i index_list ( min_pos , 3 ) = b index_list ( min_pos , 4 ) = j ! if ( abs ( sorted_short_vec ( i , 1 )) . le . min ) then ! min = abs ( sorted_short_vec ( i , 1 )) min_pos = i ! endif else ! if ( abs ( vec ( aibj , 1 )) . ge . min ) then ! sorted_short_vec ( min_pos , 1 ) = vec ( aibj , 1 ) index_list ( min_pos , 1 ) = a index_list ( min_pos , 2 ) = i index_list ( min_pos , 3 ) = b index_list ( min_pos , 4 ) = j min = abs ( vec ( aibj , 1 )) ! endif endif ! do k = 1 , n if ( abs ( sorted_short_vec ( k , 1 )) . lt . min ) then ! min = abs ( sorted_short_vec ( k , 1 )) min_pos = k ! endif enddo endif ! enddo enddo enddo enddo ! !      Sorting sorted_short_vec ! do i = 1 , n do j = 1 , n - 1 if ( abs ( sorted_short_vec ( j , 1 )) . lt . abs ( sorted_short_vec ( j + 1 , 1 ))) then ! swap = sorted_short_vec ( j , 1 ) sorted_short_vec ( j , 1 ) = sorted_short_vec ( j + 1 , 1 ) sorted_short_vec ( j + 1 , 1 ) = swap ! swap_a = index_list ( j , 1 ) swap_i = index_list ( j , 2 ) swap_b = index_list ( j , 3 ) swap_j = index_list ( j , 4 ) ! index_list ( j , 1 ) = index_list ( j + 1 , 1 ) index_list ( j , 2 ) = index_list ( j + 1 , 2 ) index_list ( j , 3 ) = index_list ( j + 1 , 3 ) index_list ( j , 4 ) = index_list ( j + 1 , 4 ) index_list ( j + 1 , 1 ) = swap_a index_list ( j + 1 , 2 ) = swap_i index_list ( j + 1 , 3 ) = swap_b index_list ( j + 1 , 4 ) = swap_j ! endif enddo enddo ! ! end subroutine analyze_double_excitation_vector_cc2 ! ! module subroutine summary_excited_state_info_cc2 ( wf , energies ) !! !! !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! integer ( i15 ) :: unit_solution = - 1 , ioerror = 0 integer ( i15 ) :: state = 0 , i = 0 real ( dp ), dimension (:,:), allocatable :: solution_ai , solution_aibj real ( dp ), dimension (:,:), allocatable :: sorted_max_vec_singles , sorted_max_vec_doubles integer ( i15 ), dimension (:,:), allocatable :: index_list_singles , index_list_doubles real ( dp ) :: norm , ddot ! !     Open solution vector file ! call generate_unit_identifier ( unit_solution ) ! open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file , & action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening solution file' ! !     Allocations ! call wf % mem % alloc ( solution_ai , wf % n_t1am , 1 ) call wf % mem % alloc ( solution_aibj , wf % n_s2am , 1 ) ! call wf % mem % alloc ( sorted_max_vec_singles , 20 , 1 ) call wf % mem % alloc ( sorted_max_vec_doubles , 20 , 1 ) ! call wf % mem % alloc_int ( index_list_singles , 20 , 2 ) call wf % mem % alloc_int ( index_list_doubles , 20 , 4 ) ! do state = 1 , wf % excited_state_specifications % n_singlet_states ! write ( unit_output , '(/t3,a30,i3,a1/)' ) 'Analysis of excitation vector ' , state , ':' write ( unit_output , '(t6, a, f14.8)' ) 'Excitation energy [a.u.]:   ' , energies ( state , 1 ) write ( unit_output , '(t6, a, f14.8)' ) 'Excited state energy [a.u.]:' , wf % energy + energies ( state , 1 ) ! !        Read the solution ! solution_ai = zero solution_aibj = zero read ( unit_solution , rec = state ) solution_ai , solution_aibj ! !        Calculate the contribution from single excitations ! norm = sqrt ( ddot ( wf % n_t1am , solution_ai , 1 , solution_ai , 1 )) write ( unit_output , '(/t6,a,f6.4)' ) 'Single excitation contribution to excitation vector: ' , norm ! !        Analysis of excitation vectors ! write ( unit_output , '(/t6,a)' ) 'Largest contributions to excitation vector:' ! write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' write ( unit_output , '(t6,a3, 8x, a3, 8x, a10)' ) 'a' , 'i' , 'amplitude' write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' ! !        Get 20 highest amplitudes ! call wf % analyze_single_excitation_vector ( solution_ai , 20 , sorted_max_vec_singles , index_list_singles ) call wf % analyze_double_excitation_vector ( solution_aibj , 20 , sorted_max_vec_doubles , index_list_doubles ) ! !        And print them ! do i = 1 , 20 ! if ( abs ( sorted_max_vec_singles ( i , 1 )) . lt . 1.0D-03 ) then ! exit ! else ! write ( unit_output , '(t6,i3, 8x,i3, 10x, f8.5)' ) & index_list_singles ( i , 1 ),& index_list_singles ( i , 2 ),& sorted_max_vec_singles ( i , 1 ) endif enddo ! write ( unit_output , '(t6,a32)' ) '------------------------------------------------------' write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' write ( unit_output , '(t6,a3, 8x, a3, 8x, a3, 8x, a3, 8x, a10)' ) 'a' , 'i' , 'b' , 'j' , 'amplitude' write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' ! do i = 1 , 20 ! if ( abs ( sorted_max_vec_doubles ( i , 1 )) . lt . 1.0D-03 ) then ! exit ! else ! write ( unit_output , '(t6,i3, 8x,i3, 8x,i3, 8x, i3, 10x, f8.5)' )& index_list_doubles ( i , 1 ),& index_list_doubles ( i , 2 ),& index_list_doubles ( i , 3 ),& index_list_doubles ( i , 4 ),& sorted_max_vec_doubles ( i , 1 ) endif enddo write ( unit_output , '(t6,a54)' ) '------------------------------------------------------' ! enddo ! !     Deallocations ! call wf % mem % dealloc ( solution_ai , wf % n_t1am , 1 ) call wf % mem % dealloc ( solution_aibj , wf % n_s2am , 1 ) ! call wf % mem % dealloc ( sorted_max_vec_singles , 20 , 1 ) call wf % mem % dealloc ( sorted_max_vec_doubles , 20 , 1 ) ! call wf % mem % dealloc_int ( index_list_singles , 20 , 2 ) call wf % mem % dealloc_int ( index_list_doubles , 20 , 4 ) ! close ( unit_solution ) ! end subroutine summary_excited_state_info_cc2 ! ! ! end submodule","tags":"","loc":"sourcefile/excited_state_submodule.f90~4.html","title":"excited_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~omega_submodule.f90~6~~EfferentGraph sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsdpt_class.f90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~types.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~input_output.f90->sourcefile~ccsdpt_class.f90 sourcefile~input_output.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsdpt_class.f90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsdpt_class.f90 sourcefile~workspace.f90->sourcefile~cc3_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileomega_submodulef906EfferentGraph = svgPanZoom('#sourcefileomega_submodulef906EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules omega Source Code omega_submodule.F90 Source Code submodule ( ccsdpt_class ) omega ! !! !!    Omega submodule (CCSD(T)) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !! !!    Contains the following procedures of the CCSD(T) class: !! !!    construct_omega:  constructs the projection vector (omega1, omega2). !!                      Calls the CCSD construction of omega (not CC3, its !!                      immediate parent). !! ! implicit none ! ! contains ! ! module subroutine construct_omega_ccsdpt ( wf ) ! !     Construct Omega (CCSD(T)) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 ! !     Directs the construction of the projection vector < mu | exp(-T) H exp(T) | R > !     for the current amplitudes of the object wfn. ! class ( ccsdpt ) :: wf ! call construct_omega_ccsd ( wf ) ! end subroutine construct_omega_ccsdpt ! ! end submodule omega","tags":"","loc":"sourcefile/omega_submodule.f90~6.html","title":"omega_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ground_state_submodule.f90~3~~EfferentGraph sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsdpt_class.f90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~types.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~input_output.f90->sourcefile~ccsdpt_class.f90 sourcefile~input_output.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsdpt_class.f90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsdpt_class.f90 sourcefile~workspace.f90->sourcefile~cc3_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileground_state_submodulef903EfferentGraph = svgPanZoom('#sourcefileground_state_submodulef903EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules ground_state Source Code ground_state_submodule.F90 Source Code submodule ( ccsdpt_class ) ground_state ! !! !!     Ground state submodule (CCSD(T)) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !! !!     Consists of the following subroutines of the CCSD(T) module: !! !!     destruct_ground_state: before destroying the converged CCSD amplitudes, !!                            the non-iterative CCSD(T) correction is to be added !!                            to the energy (call wf%calc_energy_correction). !! ! implicit none ! ! contains ! ! module subroutine destruct_ground_state_ccsdpt ( wf ) !! !!    Destruct Ground State (CCSD(T)) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Calculates the CCSD(T) energy correction to the CCSD !!    energy, thereafter deallocating the amplitudes and the !!    projection vector. !! implicit none ! class ( ccsdpt ) :: wf ! call wf % calc_energy_correction ! Add CCSD(T) energy correction call wf % destruct_amplitudes call wf % destruct_omega ! end subroutine destruct_ground_state_ccsdpt ! ! end submodule ground_state","tags":"","loc":"sourcefile/ground_state_submodule.f90~3.html","title":"ground_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ionized_state_submodule.f90~2~~EfferentGraph sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileionized_state_submodulef902EfferentGraph = svgPanZoom('#sourcefileionized_state_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules ionized_state Source Code ionized_state_submodule.F90 Source Code submodule ( ccs_class ) ionized_state ! !! !!    Ionized state submodule(CCS) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, October 2017 !! !!    Contains the CCS class routines for ionization, both core and valence. !!    Note that this submodule contains both excited state routines and jacobian transformation routines. !! !!    -::- Subroutines in this submodule -::- !! !!    ionized_state_driver                         - Driver for ionized state calculation !!    initialize_trial_vectors_valence_ionization  - Initializes trial vectors for valence ionization calculation !!    initialize_trial_vectors_core_ionization     - Initializes trial vectors for core ionization calculation !!    precondition_residual_valence_ionization     - Projects out contamination (regular excitations) !!                                                   and preconditions uncontaminated residual !!    ionization_residual_projection               - Projects out contamination (regular excitations) from residual !!    ionization_rho_a_i_projection                - Projection routine for rho_a_i !!                                                   (valence contributions and regular excitations) are projected out !!    precondition_residual_core_ionization        - Projects out contaminations (valence contributiona and regular excitations) !!                                                   and preconditions uncontaminated residual !! ! implicit none ! ! contains ! ! module subroutine ionized_state_driver_ccs ( wf ) !! !!    Ionizedstate driver (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Directs the solution of the ionizedstate problem for CCS. The !!    routine is inherited is to be inherited unaltered in the CC hierarchy. !! !!    Note: it is only necessary to alter this routine if the ionized states are !!    solved for by a different algorithm (such as in similarity constrained CC, !!    where the excited states and ground state are determined simultaneously). !! implicit none ! class ( ccs ) :: wf ! !     Let the user know the excited state driver is running ! write ( unit_output , '(t3,a)' ) ':: Ionized state solver (Davidson)' write ( unit_output , '(t3,a/)' ) ':: E. F. Kjønstad, S. D. Folkestad, May 2017' write ( unit_output , '(t3,a,i2,a,a,a)' ) & 'Requested ' , wf % excited_state_specifications % n_singlet_states ,& ' ' , trim ( wf % name ), ' singlet states.' ! !     Run the general solver routine (file names are given !     by the task, i.e., the file 'right_valence' contains !     the right eigenvectors) ! call wf % excited_state_solver ! end subroutine ionized_state_driver_ccs ! ! module subroutine initialize_trial_vectors_valence_ionization_ccs ( wf ) !! !!    Initialize trial vectors for valence ionized state !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad !! !!    Initializes start trial vectors for the calculation of !!    singlet excited states and writes them to file 'trial_vecs'. !! !!    n start vectors are constructed by finding the n lowest orbital differences, !!    where n = n_singlet_states. Vector i has a 1.0D0 at the element corresponding to the i'th lowest !!    orbital difference and 0.0d0 everywhere else !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: mo = 0 , i = 0 , j = 0 , diffuse_mo = 0 ! integer ( i15 ), dimension (:,:), allocatable :: index_lowest_obital_diff ! real ( dp ), dimension (:,:), allocatable :: c ! integer ( i15 ) :: unit_trial_vecs = 0 , ioerror = 0 ! !\t\tFind MO corresponding to super diffuse orbital ! !     Super diffuse AO is the last AO (for dalton integrals and HF this corresponds to !     the ghost atom being declared at the end of the MOLECULE.INP file). Must locate the MO !     with weight 1.0D0 on this AO. ! do mo = 1 , wf % n_mo ! i = index_two ( wf % n_ao , mo , wf % n_ao ) if ( abs ( wf % mo_coef ( i , 1 ) - 1.0D0 ) . lt . 1.0D-7 ) diffuse_mo = mo ! enddo ! !     Sanity check - Did we find diffuse mo? ! if ( diffuse_mo . eq . 0 ) then write ( unit_output , * ) 'Error: Super diffuse mo not found.' stop endif ! !     Allocate array for the indices of the lowest orbital differences ! call wf % mem % alloc_int ( index_lowest_obital_diff , wf % excited_state_specifications % n_singlet_states , 1 ) index_lowest_obital_diff = zero ! !     Select start vectors corresponding to excitation from HOMO, HOMO - 1, ..., (HOMO - n_singlet_states + 1) !     to super diffuse MO ! do i = 1 , wf % excited_state_specifications % n_singlet_states j = index_two ( diffuse_mo - wf % n_o , wf % n_o + 1 - i , wf % n_v ) index_lowest_obital_diff ( i , 1 ) = j enddo do i = 1 , wf % excited_state_specifications % n_singlet_states write ( unit_output , * ) index_lowest_obital_diff ( i , 1 ) write ( unit_output , * ) index_two ( 1 , 8 , wf % n_v ), index_two ( 1 , 7 , wf % n_v ) enddo ! !     Generate start trial vectors c and write to file ! call wf % mem % alloc ( c , wf % n_parameters , 1 ) ! !     Prepare for writing trial vectors to file ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! do i = 1 , ( wf % excited_state_specifications % n_singlet_states ) c = zero c ( index_lowest_obital_diff ( i , 1 ), 1 ) = one write ( unit_trial_vecs , rec = i , iostat = ioerror ) ( c ( j , 1 ), j = 1 , wf % n_parameters ) enddo ! !     Close file ! close ( unit_trial_vecs ) ! !     Deallocate c ! call wf % mem % dealloc ( c , wf % n_parameters , 1 ) ! !     Deallocate index_lowest_obital_diff ! call wf % mem % dealloc_int ( index_lowest_obital_diff , wf % excited_state_specifications % n_singlet_states , 1 ) ! end subroutine initialize_trial_vectors_valence_ionization_ccs ! ! module subroutine initialize_trial_vectors_core_ionization_ccs ( wf ) !! !!    Initialize trial vectors for core ionized state !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad !! !!    Initializes start trial vectors for the calculation of !!    singlet excited states and writes them to file 'trial_vecs'. !! !!    n start vectors are constructed by finding the n lowest orbital differences, !!    where n = n_singlet_states. Vector i has a 1.0D0 at the element corresponding to the i'th lowest !!    orbital difference and 0.0d0 everywhere else !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: mo = 0 , i = 0 , j = 0 , k = 0 , diffuse_mo = 0 ! real ( dp ), dimension (:,:), allocatable :: c ! integer ( i15 ) :: unit_trial_vecs = 0 , ioerror = 0 ! !     Sanity check - does number of states correspond to number of equivalent cores ? ! if ( wf % core_excited_state_specifications % n_equivalent_cores . ne . wf % excited_state_specifications % n_singlet_states ) then write ( unit_output , * ) 'Error: Using super diffuse orbital for XPS calc only allows for one root per equivalent core.' stop endif ! !     Find MO corresponding to super diffuse orbital ! !     Super diffuse AO is the last AO (for dalton integrals and HF this corresponds to !     the ghost atom being declared at the end of the MOLECULE.INP file). Must locate the MO !     with weight 1.0D0 on this AO. ! do mo = 1 , wf % n_mo ! i = index_two ( wf % n_ao , mo , wf % n_ao ) if ( abs ( wf % mo_coef ( i , 1 ) - 1.0D0 ) . lt . 1.0D-7 ) diffuse_mo = mo ! enddo ! !     Sanity check - Did we find diffuse mo? ! if ( diffuse_mo . eq . 0 ) then write ( unit_output , * ) 'Error: Super diffuse mo not found.' stop endif ! !     Generate start trial vectors c and write to file ! call wf % mem % alloc ( c , wf % n_parameters , 1 ) ! !     Prepare for writing trial vectors to file ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! !     Find core mo(s) ! call wf % mem % alloc_int ( wf % core_excited_state_specifications % index_core_mo ,& wf % core_excited_state_specifications % n_equivalent_cores , 1 ) ! call wf % find_core_mo ! !     Select start vectors corresponding to excitation from CORE to super diffuse MO ! do i = 1 , wf % core_excited_state_specifications % n_equivalent_cores c = zero k = index_two ( diffuse_mo - wf % n_o , wf % core_excited_state_specifications % index_core_mo ( i , 1 ), wf % n_v ) c ( k , 1 ) = one write ( unit_trial_vecs , rec = i , iostat = ioerror ) ( c ( j , 1 ), j = 1 , wf % n_parameters ) enddo ! !     Close file ! close ( unit_trial_vecs ) ! !     Deallocate c ! call wf % mem % dealloc ( c , wf % n_parameters , 1 ) ! end subroutine initialize_trial_vectors_core_ionization_ccs ! ! module subroutine precondition_residual_valence_ionization_ccs ( wf , residual ) !! !!    Precondition residual valence !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Projects out contamination from regular excitations !!    Divide elements of residual by orbital difference !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! integer ( i15 ) :: i = 0 ! real ( dp ), dimension (:,:), allocatable :: orbital_diff ! call wf % ionization_residual_projection ( residual ) ! call wf % mem % alloc ( orbital_diff , wf % n_parameters , 1 ) orbital_diff = zero ! call wf % calculate_orbital_differences ( orbital_diff ) ! do i = 1 , wf % n_parameters ! residual ( i , 1 ) = residual ( i , 1 ) / orbital_diff ( i , 1 ) ! enddo ! call wf % mem % dealloc ( orbital_diff , wf % n_parameters , 1 ) ! end subroutine precondition_residual_valence_ionization_ccs ! ! module subroutine ionization_residual_projection_ccs ( wf , residual ) !! !!    Residual projection for core ionization (CCS) !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Projects out contaminations from regular excitations !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! integer ( i15 ) :: i = 0 , a = 0 , diffuse_mo = 0 , ai = 0 , mo = 0 ! !     Find MO corresponding to super diffuse orbital ! !     Super diffuse AO is the last AO (for dalton integrals and HF this corresponds to !     the ghost atom being declared at the end of the MOLECULE.INP file). Must locate the MO !     with weight 1.0D0 on this AO. ! do mo = 1 , wf % n_mo ! i = index_two ( wf % n_ao , mo , wf % n_ao ) if ( abs ( wf % mo_coef ( i , 1 ) - 1.0D0 ) . lt . 1.0D-7 ) diffuse_mo = mo ! enddo ! !     Project out elements not corresponding to ionization ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! if ( a . ne . ( diffuse_mo - wf % n_o )) then ai = index_two ( a , i , wf % n_v ) residual ( ai , 1 ) = 0.0d0 ! endif ! enddo enddo ! end subroutine ionization_residual_projection_ccs ! ! module subroutine ionization_rho_a_i_projection_ccs ( wf , rho_a_i ) !! !!    Ionization rho_a_i projection (CCS). !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Transformed vector projection for ionization, contamination from !!    regular excitations are projected out. !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! integer ( i15 ) :: i = 0 , a = 0 , diffuse_mo = 0 , ai = 0 , mo = 0 ! !     Find MO corresponding to super diffuse orbital ! !     Super diffuse AO is the last AO (for dalton integrals and HF this corresponds to !     the ghost atom being declared at the end of the MOLECULE.INP file). Must locate the MO !     with weight 1.0D0 on this AO. ! do mo = 1 , wf % n_mo ! i = index_two ( wf % n_ao , mo , wf % n_ao ) if ( abs ( wf % mo_coef ( i , 1 ) - 1.0D0 ) . lt . 1.0D-7 ) diffuse_mo = mo ! enddo ! !     Project out elements not corresponding to ionization ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! if ( a . ne . ( diffuse_mo - wf % n_o )) then rho_a_i ( a , i ) = 0.0d0 ! endif ! enddo enddo ! end subroutine ionization_rho_a_i_projection_ccs ! ! module subroutine precondition_residual_core_ionization_ccs ( wf , residual ) ! !     Precondition residual core ionization !     Written by Sarai D. Folkestad, Aug. 2017 ! !     Projects out contaminations from valence contributions and all regular. excitations. !     Divide elements of residual by corresponding orbital difference. ! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! integer ( i15 ) :: i = 0 ! real ( dp ), dimension (:,:), allocatable :: orbital_diff ! !     :: Projection :: ! !     Project out valence ! call wf % cvs_residual_projection ( residual ) ! !     Project out excitations ! call wf % ionization_residual_projection ( residual ) ! !     Preconditioning by dividing with orbital differences ! call wf % mem % alloc ( orbital_diff , wf % n_parameters , 1 ) orbital_diff = zero ! call wf % calculate_orbital_differences ( orbital_diff ) ! do i = 1 , wf % n_parameters ! residual ( i , 1 ) = residual ( i , 1 ) / orbital_diff ( i , 1 ) ! enddo ! call wf % mem % dealloc ( orbital_diff , wf % n_parameters , 1 ) ! end subroutine precondition_residual_core_ionization_ccs ! ! end submodule ionized_state","tags":"","loc":"sourcefile/ionized_state_submodule.f90~2.html","title":"ionized_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~jacobian_submodule.f90~5~~EfferentGraph sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilejacobian_submodulef905EfferentGraph = svgPanZoom('#sourcefilejacobian_submodulef905EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules jacobian Source Code jacobian_submodule.F90 Source Code submodule ( ccs_class ) jacobian ! !! !!    Jacobian submodule (CCS) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017 !! !!    Contains the following family of procedures of the CCS class: !! !!    jacobian_ccs_transformation: directs the transformation by A. !!    jacobian_ccs_a1:             adds the A1 term to the transformed vector. !!    jacobian_ccs_b1:             adds the B1 term to the transformed vector. !! implicit none ! character ( len = 40 ) :: integral_type ! contains ! ! module subroutine jacobian_ccs_transformation_ccs ( wf , c_a_i ) !! !!    Jacobian CCS transformation !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Directs the transformation by the CCSD Jacobi matrix, !! !!       A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >. !! !!    In particular, !! !!       rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck. !! !!    On exit, c is overwritten by rho. !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! real ( dp ), dimension (:,:), allocatable :: rho_a_i ! call wf % mem % alloc ( rho_a_i , wf % n_v , wf % n_o ) rho_a_i = zero ! !     A1-term ! call wf % jacobian_ccs_a1 ( rho_a_i , c_a_i ) ! !     B1-term ! call wf % jacobian_ccs_b1 ( rho_a_i , c_a_i ) ! !     Place rho_a_i in c_a_i ! c_a_i = zero ! call dcopy (( wf % n_o ) * ( wf % n_v ), rho_a_i , 1 , c_a_i , 1 ) ! call wf % mem % dealloc ( rho_a_i , wf % n_v , wf % n_o ) ! end subroutine jacobian_ccs_transformation_ccs ! ! module subroutine jacobian_ccs_a1_ccs ( wf , rho , c1 ) !! !!    Jacobian CCS A1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad !! !!    Calculates the A1 term, !! !!       sum_b F_ab*c_bi - sum_j F_ji*c_aj !! !!    and adds it to the rho vector. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c1 real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho ! !     sum_b F_a_b * c_b_i ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & wf % n_v , & one , & wf % fock_ab , & wf % n_v , & c1 , & wf % n_v , & one , & rho , & wf % n_v ) ! !     - sum_j c_a_j * F_j_i ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & wf % n_o , & - one , & c1 , & wf % n_v , & wf % fock_ij , & wf % n_o , & one , & rho , & wf % n_v ) ! ! end subroutine jacobian_ccs_a1_ccs ! ! module subroutine jacobian_ccs_b1_ccs ( wf , rho , c1 ) !! !!    Jacobian CCS B1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Calculates the B1 term, !! !!       sum_bj L_aijb*c_bj = sum_bj (2*g_aijb-g_abji)c_bj, !! !!    and adds it to the rho vector. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c1 real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: L_jb_J real ( dp ), dimension (:,:), allocatable :: L_ji_J real ( dp ), dimension (:,:), allocatable :: L_ab_J ! real ( dp ), dimension (:,:), allocatable :: g_ai_jb real ( dp ), dimension (:,:), allocatable :: g_ab_ji real ( dp ), dimension (:,:), allocatable :: L_ai_jb ! !     Reorderings of c and rho ! real ( dp ), dimension (:,:), allocatable :: c_jb ! !     Batching variables ! integer ( i15 ) :: b_batch = 0 , b_first = 0 , b_last = 0 , b_length = 0 integer ( i15 ) :: required = 0 , available = 0 , n_batch = 0 , batch_dimension = 0 integer ( i15 ) :: max_batch_length = 0 ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: ab = 0 integer ( i15 ) :: ai = 0 , jb = 0 , jb_full = 0 integer ( i15 ) :: ji = 0 ! logical :: reorder ! !     Allocate and construct g_ai_jb ! call wf % mem % alloc ( g_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vo_ov ( integral_type , g_ai_jb ) ! !     Preparing for batching over b ! required = max ((( wf % n_o ) ** 2 ) * (( wf % n_v ) ** 2 ) & ! + 2 * ( wf % n_J ) * ( wf % n_v ) ** 2 + 2 * ( wf % n_J ) * ( wf % n_v ) * ( wf % n_o ), & ! Needed to get L_ab_J 2 * (( wf % n_o ) ** 2 ) * (( wf % n_v ) ** 2 ) & ! + ( wf % n_J ) * ( wf % n_v ) ** 2 + ( wf % n_J ) * ( wf % n_o ) ** 2 , & ! Needed to get g_ab_ij 3 * (( wf % n_o ) ** 2 ) * (( wf % n_v ) ** 2 )) ! Needed to get L_ai_jb ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index b max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do b_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( b_first , b_last , b_batch , max_batch_length , batch_dimension ) b_length = b_last - b_first + 1 ! !        Allocate and construct g_ab_ji ! call wf % mem % alloc ( g_ab_ji , ( wf % n_v ) * b_length , ( wf % n_o ) ** 2 ) ! integral_type = 'electronic_repulsion' call wf % get_vv_oo ( integral_type , & g_ab_ji , & 1 , & wf % n_v , & b_first , & b_last , & 1 , & wf % n_o , & 1 , & wf % n_o ) ! !        Allocate L_ai_jb ! call wf % mem % alloc ( L_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * b_length ) L_ai_jb = zero ! !        Construct L_ai_jb = 2*g_ai_jb - g_ab_ij ! do i = 1 , wf % n_o do b = 1 , b_length do j = 1 , wf % n_o ! ji = index_two ( j , i , wf % n_o ) jb = index_two ( j , b , wf % n_o ) jb_full = index_two ( j , b + b_first - 1 , wf % n_o ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ab = index_two ( a , b , wf % n_v ) ! L_ai_jb ( ai , jb ) = two * g_ai_jb ( ai , jb_full ) - g_ab_ji ( ab , ji ) ! enddo enddo enddo enddo ! !        Deallocate g_ai_jb and g_ab_ji ! call wf % mem % dealloc ( g_ab_ji , ( wf % n_v ) * b_length , ( wf % n_o ) ** 2 ) ! !        Allocate reordering of c and rho ! call wf % mem % alloc ( c_jb , ( wf % n_o ) * b_length , 1 ) ! !        reordered c amplitudes ! c_jb = zero do j = 1 , wf % n_o do b = 1 , b_length ! jb = index_two ( j , b , wf % n_o ) ! c_jb ( jb , 1 ) = c1 ( b + b_first - 1 , j ) ! enddo enddo ! !        Create rho contribution from the batch ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & 1 , & b_length * ( wf % n_o ), & one , & L_ai_jb , & ( wf % n_v ) * ( wf % n_o ), & c_jb , & b_length * ( wf % n_o ), & one , & rho , & ( wf % n_v ) * ( wf % n_o )) ! !        Deallocate L_ai_jb ! call wf % mem % dealloc ( L_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * b_length ) ! !        Deallocate c reordered ! call wf % mem % dealloc ( c_jb , ( wf % n_o ) * b_length , 1 ) ! enddo ! Looping over batches ! call wf % mem % dealloc ( g_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * b_length ) ! end subroutine jacobian_ccs_b1_ccs ! ! end submodule jacobian","tags":"","loc":"sourcefile/jacobian_submodule.f90~5.html","title":"jacobian_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~jacobian_transpose_submodule.f90~2~~EfferentGraph sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilejacobian_transpose_submodulef902EfferentGraph = svgPanZoom('#sourcefilejacobian_transpose_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules jacobian_transpose Source Code jacobian_transpose_submodule.F90 Source Code submodule ( ccs_class ) jacobian_transpose ! !! !!    Jacobian transpose submodule (CCS) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Contains the following family of procedures of the CCS class: !! !!    jacobian_transpose_ccs_transformation: performs the transposed Jacobian transformation (A&#94;T) !!    jacobian_transpose_ccs_a1:             adds the CCS A1 term for the A&#94;T transformation !!    jacobian_transpose_ccs_b1:             adds the CCS B1 term for the A&#94;T transformation !! ! implicit none ! character ( len = 40 ) :: integral_type ! contains ! ! module subroutine jacobian_transpose_ccs_transformation_ccs ( wf , b_a_i ) !! !!    Jacobian transpose transformation (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the transpose Jacobian transformation, i.e., the transformation !!    by the transpose of the Jacobian matrix !! !!       A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | R >. !! !!    The transformation is performed as sigma&#94;T = b&#94;T A, where b is the vector !!    sent to the routine. On exit, the vector b is equal to sigma (the transformed !!    vector). !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i ! real ( dp ), dimension (:,:), allocatable :: sigma_a_i ! !     Allocate the transformed vector ! call wf % mem % alloc ( sigma_a_i , wf % n_v , wf % n_o ) sigma_a_i = zero ! !     Calculate and add the CCS contributions ! call wf % jacobian_transpose_ccs_a1 ( sigma_a_i , b_a_i ) call wf % jacobian_transpose_ccs_b1 ( sigma_a_i , b_a_i ) ! !     Copy the result into the incoming vector ! call dcopy (( wf % n_o ) * ( wf % n_v ), sigma_a_i , 1 , b_a_i , 1 ) ! !     Deallocate the transformed vector ! call wf % mem % dealloc ( sigma_a_i , wf % n_v , wf % n_o ) ! end subroutine jacobian_transpose_ccs_transformation_ccs ! ! module subroutine jacobian_transpose_ccs_a1_ccs ( wf , sigma_a_i , b_a_i ) !! !!    Jacobian transpose A1 (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the A1 term, !! !!       sum_c b_ci F_ca - sum_k b_ak F_ik, !! !!    and adds it to the sigma-vector (b&#94;T -> sigma&#94;T = b&#94;T A). !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i ! !     Add sum_c F_ca b_ci = sum_c F_ac&#94;T b_ci ! call dgemm ( 'T' , 'N' , & wf % n_v , & wf % n_o , & wf % n_v , & one , & wf % fock_ab , & wf % n_v , & b_a_i , & wf % n_v , & one , & sigma_a_i , & wf % n_v ) ! !     Add - sum_k b_ak F_ik = - sum_k b_ak F_ki&#94;T ! call dgemm ( 'N' , 'T' , & wf % n_v , & wf % n_o , & wf % n_o , & - one , & b_a_i , & wf % n_v , & wf % fock_ij , & wf % n_o , & one , & sigma_a_i , & wf % n_v ) ! end subroutine jacobian_transpose_ccs_a1_ccs ! ! module subroutine jacobian_transpose_ccs_b1_ccs ( wf , sigma_a_i , b_a_i ) !! !!    Jacobian transpose B1 (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Calculates the B1 term, !! !!       sum_ck L_ckia b_ck !! !!    and adds it to the sigma-vector (b&#94;T -> sigma&#94;T = b&#94;T A). !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i ! real ( dp ), dimension (:,:), allocatable :: g_ck_ia ! g_ckia real ( dp ), dimension (:,:), allocatable :: g_ca_ik ! g_caik ! real ( dp ), dimension (:,:), allocatable :: L_ai_ck ! L_ckia = 2 * g_ckia - g_caik ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 integer ( i15 ) :: batch_dimension = 0 , max_batch_length = 0 , n_batch = 0 ! integer ( i15 ) :: a_batch = 0 , a_length = 0 , a_first = 0 , a_last = 0 ! !     Indices ! integer ( i15 ) :: a = 0 , i = 0 , c = 0 , k = 0 , ck = 0 , ik = 0 , ai = 0 integer ( i15 ) :: ia = 0 , ca = 0 ! !     Form the integral g_ck_ia = g_ckia ! call wf % mem % alloc ( g_ck_ia , ( wf % n_v ) * ( wf % n_o ), ( wf % n_o ) * ( wf % n_v )) ! integral_type = 'electronic_repulsion' call wf % get_vo_ov ( integral_type , g_ck_ia ) ! !     :: Form L_ai_ck = L_ckia in batches over a :: ! call wf % mem % alloc ( L_ai_ck , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) L_ai_ck = zero ! !     Prepare for batching over index a ! required = 1 ! Not a correct estimate - needs to be set! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_first , a_last , a_batch , max_batch_length , batch_dimension ) a_length = a_last - a_first + 1 ! !        Form g_ca_ik ! call wf % mem % alloc ( g_ca_ik , ( wf % n_v ) * a_length , ( wf % n_o ) ** 2 ) ! integral_type = 'electronic_repulsion' call wf % get_vv_oo ( integral_type , & g_ca_ik , & 1 , & wf % n_v , & a_first , & a_last , & 1 , & wf % n_o , & 1 , & wf % n_o ) ! !        Set L_ai_ck = L_ckia = 2 * g_ckia - g_caik !        for the current batch over a ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do i = 1 , wf % n_o ! ik = index_two ( i , k , wf % n_o ) ! do a = 1 , a_length ! Ai = index_two ( a + a_first - 1 , i , wf % n_v ) ! Full space a iA = index_two ( i , a + a_first - 1 , wf % n_o ) ! Full space a ca = index_two ( c , a , wf % n_v ) ! L_ai_ck ( Ai , ck ) = two * g_ck_ia ( ck , iA ) - g_ca_ik ( ca , ik ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ca_ik , ( wf % n_v ) * a_length , ( wf % n_o ) ** 2 ) ! enddo ! End of batches over a ! call wf % mem % dealloc ( g_ck_ia , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Add sum_ck L_ckia b_ck = sum_ck L_ai_ck b_ck ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) * ( wf % n_o ), & 1 , & ( wf % n_v ) * ( wf % n_o ), & one , & L_ai_ck , & ( wf % n_v ) * ( wf % n_o ), & b_a_i , & ! \"b_ai\" ( wf % n_v ) * ( wf % n_o ), & one , & sigma_a_i , & ! \"sigma_ai\" ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( L_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine jacobian_transpose_ccs_b1_ccs ! ! end submodule jacobian_transpose","tags":"","loc":"sourcefile/jacobian_transpose_submodule.f90~2.html","title":"jacobian_transpose_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ground_state_submodule.f90~4~~EfferentGraph sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileground_state_submodulef904EfferentGraph = svgPanZoom('#sourcefileground_state_submodulef904EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules ground_state Source Code ground_state_submodule.F90 Source Code submodule ( ccs_class ) ground_state ! !! !!    Ground state submodule (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Consists of the following module subroutines of the CCS: !! !!    ground_state_solver:        Controls the iterative loop, calling in turn !!                                the calculation of the energy, the amplitude equations !!                                (and its norm), and the new_amplitudes routine. !! !!    new_amplitudes:             Calculates the quasi-Newton estimate and passes the !!                                information needed by the DIIS routine. !! !!    diis_ccs:                   This routine saves the quasi-Newton estimate Δ t and !!                                t + Δ t to file. It uses the previous estimates to !!                                select the amplitudes t for the next iteration. !! !! !!    calc_ampeqs:                Updates the amplitude equations for the current amplitudes. !!    calc_ampeqs_norm:           Calculates the norm of the amplitude equations. !!    calc_quasi_Newton_singles:  Calculates the singles part of the quasi-Newton estimate. !!    initialize_ground_state:    Initializes the amplitudes and the amplitude equations. !!    destruct_ground_state:      Deallocates the amplitudes and the amplitude equations. !! !!    Can be inherited by models of the same level (e.g. CC2) without modification. !! !!    When inherited by higher level models (e.g. CCSD), the new_amplitudes and calc_ampeqs_norm !!    routines should be overridden to account for the doubles quasi-Newton estimate, amplitudes, !!    and projection vector. Non-standard CC methods may need to override the initialize_ground_state !!    and destruct_ground_state. !! ! implicit none ! !  Some variables available to all routines of the module ! integer ( i15 ) :: iteration = - 1 ! integer ( i15 ) :: unit_dt = - 1 ! Unit identifier for Δ t_i file integer ( i15 ) :: unit_t_dt = - 1 ! Unit identifier for t_i + Δ t_i file integer ( i15 ) :: unit_diis_matrix = - 1 ! Unit identifier for DIIS matrix file ! integer ( i15 ), parameter :: diis_dim = 9 ! The maximum dimension of the DIIS matrix, plus 1 ! ! contains ! ! module subroutine ground_state_driver_ccs ( wf ) !! !!    Ground state driver (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Directs the solution of the ground state problem for CCS. The !!    routine is written so as to be inherited unaltered in the CC hierarchy. !! implicit none ! class ( ccs ) :: wf ! !     Preparations for ground state solver ! call wf % ground_state_preparations ! !     Run the solver routine ! call wf % ground_state_solver ! !     Final work and preparations for other tasks (such as excited state calculations) ! call wf % ground_state_cleanup ! end subroutine ground_state_driver_ccs ! ! module subroutine ground_state_preparations_ccs ( wf ) !! !!    Ground State Preparations (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    A routine for preparation tasks (if any). Can be overwritten !!    in descendants if other preparations prove necessary. !! class ( ccs ) :: wf ! wf % tasks % current = 'ground_state' ! end subroutine ground_state_preparations_ccs ! ! module subroutine ground_state_cleanup_ccs ( wf ) !! !!    Ground State Cleanup (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    A routine for cleanup tasks (if any). Can be overwritten !!    in descendants if other cleanups prove necessary. !! class ( ccs ) :: wf ! !     Nothing yet! ! end subroutine ground_state_cleanup_ccs ! ! module subroutine ground_state_solver_ccs ( wf ) !! !!    Ground State Solver !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Directs the solution of the ground state amplitude equations !!    using a DIIS algorithm. The problem the routine solves is !! !!       X_mu(t) = 0, where t = { t_mu }_mu !! !!    For standard coupled cluster theories, the vector X is the !!    projection vector (omega). !! implicit none ! class ( ccs ) :: wf ! real ( dp ) :: prev_energy real ( dp ) :: ampeqs_norm ! real ( dp ) :: start_gs_solver , end_gs_solver ! logical :: converged_energy = . false . logical :: converged_ampeqs = . false . ! logical :: converged = . false . ! True iff both the energy and the equations have converged ! !     Let the user know the ground state solver is running ! write ( unit_output , '(//t3,a)' ) ':: Ground state solver (DIIS)' write ( unit_output , '(t3,a/)' ) ':: S. D. Folkestad, E. F. Kjønstad, May 2017' ! write ( unit_output , '(t3,a,a,a/)' ) 'Settings for ' , trim ( wf % name ), ' ground state calculation:' ! write ( unit_output , '(t6,a20,e9.2)' ) 'Energy threshold:   ' , wf % ground_state_specifications % energy_threshold write ( unit_output , '(t6,a20,e9.2)' ) 'Residual threshold: ' , wf % ground_state_specifications % residual_threshold flush ( unit_output ) ! !     Initialize amplitudes & amplitude equations ! call wf % initialize_ground_state ! !     If restart, read amplitudes from disk ! if ( wf % ground_state_specifications % restart ) then ! write ( unit_output , '(/t3,a)' ) 'Requested restart. Reading amplitudes from file.' call wf % read_amplitudes ! endif ! !     Open DIIS files ! call generate_unit_identifier ( unit_dt ) open ( unit = unit_dt , file = 'diis_dt' , status = 'unknown' , form = 'unformatted' ) ! call generate_unit_identifier ( unit_t_dt ) open ( unit = unit_t_dt , file = 'diis_t_dt' , status = 'unknown' , form = 'unformatted' ) ! call generate_unit_identifier ( unit_diis_matrix ) open ( unit = unit_diis_matrix , file = 'diis_matrix' , status = 'unknown' , form = 'unformatted' ) ! !     Enter iterative loop ! write ( unit_output , '(/t3,a)' ) 'Iter.      Energy             Norm of amplitude eq.' write ( unit_output , '(t3,a)' ) '---------------------------------------------------' flush ( unit_output ) ! !     Make sure the initial energy is up to date for first iteration ! call wf % calc_energy ! iteration = 1 converged_energy = . false . converged_ampeqs = . false . converged = . false . ! call cpu_time ( start_gs_solver ) ! do while ((. not . converged ) . and . ( iteration . le . wf % ground_state_specifications % max_iterations )) ! !        Save the previous energy ! prev_energy = wf % energy ! !        Update the energy ! call wf % calc_energy ! !        Update the Fock matrix ! call wf % construct_fock ! !        Construct the current amplitude equations vector, !        and calculate the norm of the amplitude equations ! call wf % calc_ampeqs call wf % calc_ampeqs_norm ( ampeqs_norm ) ! !        Check for convergence of the energy and the amplitude equations ! converged_energy = abs ( wf % energy - prev_energy ) . lt . wf % ground_state_specifications % energy_threshold converged_ampeqs = ampeqs_norm . lt . wf % ground_state_specifications % residual_threshold ! !        Print information to output ! write ( unit_output , '(T3,i2,5x,f19.12,4x,e10.4)' ) iteration , wf % energy , ampeqs_norm flush ( unit_output ) ! Flush so that the user can follow each iteration in real-time ! !        Perform DIIS update if convergence hasn't been reached ! if ( converged_energy . and . converged_ampeqs ) then ! converged = . true . ! write ( unit_output , '(/t3,a,i2,a/)' ) 'Converged in ' , iteration , ' iterations!' ! else ! !           Update the amplitudes for the next iteration ! call wf % new_amplitudes iteration = iteration + 1 ! endif ! enddo ! !     Close the DIIS files ! close ( unit_dt ) close ( unit_t_dt ) close ( unit_diis_matrix ) ! call cpu_time ( end_gs_solver ) ! !     Print summary ! write ( unit_output , '(t3,a,a,a/)' ) 'Summary of ' , trim ( wf % name ), ' ground state calculation:' write ( unit_output , '(t6,a25,f14.8)' ) 'Total energy (hartrees):  ' , wf % energy write ( unit_output , '(t6,a25,f14.8/)' ) 'Total time CPU (seconds): ' , end_gs_solver - start_gs_solver flush ( unit_output ) ! !     Save the amplitudes ! call wf % save_amplitudes ! !     Destroy amplitudes and amplitude equations ! call wf % destruct_ground_state ! end subroutine ground_state_solver_ccs ! ! module subroutine calc_ampeqs_ccs ( wf ) !! !!    Calculate Amplitude Equations (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Constructs the amplitude equations vector (the projection vector !!    in CCS) for the amplitudes of the current iteration of the ground !!    state solver. It also calculates the norm of the amplitude equations, !!    which is zero when the equations are exactly solved. !! implicit none ! class ( ccs ) :: wf ! !     Update the projection vector ! call wf % construct_omega ! end subroutine calc_ampeqs_ccs ! ! module subroutine calc_ampeqs_norm_ccs ( wf , ampeqs_norm ) !! !!     Calculate Amplitude Equations Norm (CCS) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ) :: ampeqs_norm ! real ( dp ) :: ddot ! For dot product ! ampeqs_norm = zero ampeqs_norm = ddot ( wf % n_t1am , wf % omega1 , 1 , wf % omega1 , 1 ) ampeqs_norm = sqrt ( ampeqs_norm ) ! end subroutine calc_ampeqs_norm_ccs ! ! module subroutine new_amplitudes_ccs ( wf ) !! !!    New Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Directs the calculation of the quasi-Newton estimate Δ t_i, !!    and t_i + Δ t_i, and calls the DIIS routine to save & get !!    the amplitudes for the next iteration. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:), allocatable :: dt ! Δ t_i real ( dp ), dimension (:,:), allocatable :: t_dt ! t_i + Δ t_i ! !     Allocate Δ t_i and t_i + Δ t_i vectors ! call wf % mem % alloc ( dt , wf % n_parameters , 1 ) call wf % mem % alloc ( t_dt , wf % n_parameters , 1 ) ! dt = zero t_dt = zero ! !     Calculate Δ t_i ! call wf % calc_quasi_Newton_singles ( dt ) ! !     Set t_i + Δ t_i ! call dcopy ( wf % n_t1am , dt , 1 , t_dt , 1 ) ! t_dt = Δ t_i call daxpy ( wf % n_t1am , one , wf % t1am , 1 , t_dt , 1 ) ! t_dt = t_i + Δ t_i ! !     Save estimates to file and get the next amplitudes !     (they are placed in dt on exit from diis) ! call wf % diis ( dt , t_dt ) ! !     Set the new amplitudes ! call dcopy ( wf % n_t1am , dt , 1 , wf % t1am , 1 ) ! !     Deallocate vectors ! call wf % mem % dealloc ( dt , wf % n_parameters , 1 ) call wf % mem % dealloc ( t_dt , wf % n_parameters , 1 ) ! end subroutine new_amplitudes_ccs ! ! module subroutine calc_quasi_Newton_singles_ccs ( wf , dt ) !! !!    Calculate quasi-Newton estimate (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Calculates the quasi-Newton estimate Δ t_i (singles part) !!    and places the contribution in the dt vector (of length n_parameters, !!    with singles first, then doubles, etc. if inherited) !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: dt ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 ! !     Calculate the singles Δ t_i contribbution ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) ! dt ( ai , 1 ) = - wf % omega1 ( a , i ) / ( wf % fock_diagonal ( wf % n_o + a , 1 ) - & wf % fock_diagonal ( i , 1 )) ! enddo enddo ! end subroutine calc_quasi_Newton_singles_ccs ! ! module subroutine diis_ccs ( wf , dt , t_dt ) !! !!    DIIS routine !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    The next amplitudes are !! !!       t_n+1 = sum_k w_k (t_k + dt_k), !! !!    where the weights w_k in front of the quasi-Newton estimate dt_k !!    are determined so as to minimize !! !!       f(w_k) = sum_k w_k dt_k, !! !!    with the constraint that g(w_k) = sum_k w_k - 1 = 0. !! implicit none ! class ( ccs ), intent ( in ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: dt real ( dp ), dimension ( wf % n_parameters , 1 ) :: t_dt ! real ( dp ), dimension (:,:), allocatable :: dt_i ! To hold previous Δ t_i temporarily ! real ( dp ) :: ddot ! integer ( i15 ) :: i = 0 , j = 0 ! integer :: info = - 1 ! Error integer for dgesv routine (LU factorization) integer ( i15 ) :: current_index = 0 ! Progressing as follows: 1,2,...,7,8,1,2,... ! real ( dp ), dimension (:,:), allocatable :: diis_vector real ( dp ), dimension (:,:), allocatable :: diis_matrix ! integer ( i15 ), dimension ( diis_dim ) :: ipiv = 0 ! Pivot integers (see dgesv routine) ! !     Set the current index ! current_index = iteration - ( diis_dim - 1 ) * (( iteration - 1 ) / ( diis_dim - 1 )) ! 1,2,...,7,8,1,2,... ! !     :: Save (Δ t_i) and (t_i + Δ t_i) to files :: ! if ( current_index . eq . 1 ) then rewind ( unit_dt ) rewind ( unit_t_dt ) endif ! write ( unit_dt ) ( dt ( i , 1 ), i = 1 , wf % n_parameters ) write ( unit_t_dt ) ( t_dt ( i , 1 ), i = 1 , wf % n_parameters ) ! !     :: Solve the least squares problem, G * w = H :: ! !        G : DIIS matrix, G_ij = Δ t_i Δ t_j, !        H : DIIS vector,  H_i = 0, ! !     where i, j = 1, 2, ..., current_index. To enforce normality !     of the solution, G is extended with a row & column of -1's !     and H with a -1 at the end. ! !     First set the DIIS vector to one ! call wf % mem % alloc ( diis_vector , current_index + 1 , 1 ) diis_vector = zero ! !     Allocate the DIIS matrix and read in previous matrix elements ! call wf % mem % alloc ( diis_matrix , current_index + 1 , current_index + 1 ) diis_matrix = zero ! if ( current_index . gt . 1 ) then ! rewind ( unit_diis_matrix ) ! do j = 1 , current_index - 1 do i = 1 , current_index - 1 ! read ( unit_diis_matrix ) diis_matrix ( i , j ) ! enddo enddo ! endif ! !     Get the parts of the DIIS matrix G not constructed in !     the previous iterations ! call wf % mem % alloc ( dt_i , wf % n_parameters , 1 ) ! Allocate temporary holder of quasi-Newton estimates dt_i = zero ! rewind ( unit_dt ) ! do i = 1 , current_index ! read ( unit_dt ) ( dt_i ( j , 1 ), j = 1 , wf % n_parameters ) ! diis_matrix ( current_index , i ) = ddot ( wf % n_parameters , dt , 1 , dt_i , 1 ) diis_matrix ( i , current_index ) = diis_matrix ( current_index , i ) ! diis_matrix ( current_index + 1 , i ) = - one diis_matrix ( i , current_index + 1 ) = - one ! enddo ! diis_vector ( current_index + 1 , 1 ) = - one ! !     Write the current DIIS matrix to file ! rewind ( unit_diis_matrix ) ! do j = 1 , current_index do i = 1 , current_index ! write ( unit_diis_matrix ) diis_matrix ( i , j ) ! enddo enddo ! !     Solve the DIIS equation ! !     Note: on exit, the solution is in the diis_vector, !     provided info = 0 (see LAPACK documentation for more) ! call dgesv ( current_index + 1 , & 1 , & diis_matrix , & current_index + 1 , & ipiv , & diis_vector , & current_index + 1 , & info ) ! !     :: Update the amplitudes (placed in dt on exit) :: ! dt = zero ! rewind ( unit_t_dt ) ! do i = 1 , current_index ! !        Read the t_i + Δ t_i vector ! t_dt = zero read ( unit_t_dt ) ( t_dt ( j , 1 ), j = 1 , wf % n_parameters ) ! !        Add w_i (t_i + Δ t_i) to the amplitudes ! call daxpy ( wf % n_parameters , diis_vector ( i , 1 ), t_dt , 1 , dt , 1 ) ! enddo ! !     Deallocations ! call wf % mem % dealloc ( dt_i , wf % n_parameters , 1 ) call wf % mem % dealloc ( diis_vector , current_index + 1 , 1 ) call wf % mem % dealloc ( diis_matrix , current_index + 1 , current_index + 1 ) ! end subroutine diis_ccs ! ! module subroutine initialize_ground_state_ccs ( wf ) !! !!    Initialize Ground State (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Initializes the amplitudes and the projection vector for the !!    ground state solver. !! implicit none ! class ( ccs ) :: wf ! call wf % initialize_amplitudes ! Allocate amplitudes call wf % initialize_omega ! Allocate projection vector ! end subroutine initialize_ground_state_ccs ! ! module subroutine destruct_ground_state_ccs ( wf ) !! !!    Destruct Ground State (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Deallocates the amplitudes and the projection vector. This routine !!    can be inherited unaltered by standard CC methods. !! implicit none ! class ( ccs ) :: wf ! call wf % destruct_amplitudes call wf % destruct_omega ! end subroutine destruct_ground_state_ccs ! ! end submodule ground_state","tags":"","loc":"sourcefile/ground_state_submodule.f90~4.html","title":"ground_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~cholesky_submodule.f90~2~~EfferentGraph sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilecholesky_submodulef902EfferentGraph = svgPanZoom('#sourcefilecholesky_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules cholesky Source Code cholesky_submodule.F90 Source Code submodule ( ccs_class ) cholesky ! !! !!    Cholesky sub(CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Contains the following family of procedures of the CCS class: !! !!    get_cholesky_ij(L_ij_J):         returns the T1-transformed Cholesky vector L_ij&#94;J !!    get_cholesky_ia(L_ia_J):         returns the T1-transformed Cholesky vector L_ia&#94;J !!    get_cholesky_ai(L_ai_J):         returns the T1-transformed Cholesky vector L_ai&#94;J !!    get_cholesky_ab(L_ab_J, ...):    returns the T1-transformed Cholesky vector L_ab&#94;J, !!                                     but has options (...) for batching over the two !!                                     indices a and b !! ! implicit none ! ! contains ! ! module subroutine get_cholesky_ij_ccs ( wf , L_ij_J , i_first , i_last , j_first , j_last ) !! !!    Get Cholesky IJ !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads and T1-transforms the IA Cholesky vectors: !! !!       L_ij_J_T1 = L_ij_J + sum_a t_aj * L_ia_J !! !!    Memory required in routine: !! !!       2*n_J*(i_length)*n_v     -> for reading L_ia_J contribution and reordering !!       i_length = i_last - i_first + 1 !! !!    Optional arguments: i_first, i_last, j_first, j_last can be used in order to restrict indices !! implicit none ! class ( ccs ) :: wf integer ( i15 ), optional :: i_first , j_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), optional :: i_last , j_last ! Last index (can differ from n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ij_J ! !     Local routine variables ! real ( dp ), dimension (:,:), allocatable :: L_ia_J ! L_ia&#94;J real ( dp ), dimension (:,:), allocatable :: L_iJ_a ! L_ia&#94;J reordered real ( dp ), dimension (:,:), allocatable :: L_iJ_k ! L_ik&#94;J reordered ! integer ( i15 ) :: i = 0 , J = 0 , a = 0 , ij = 0 , ia = 0 , ik = 0 , k = 0 integer ( i15 ) :: i_length , j_length ! if ( present ( i_first ) . and . present ( i_last ) . and . present ( j_first ) . and . present ( j_last )) then i_length = i_last - i_first + 1 j_length = j_last - j_first + 1 ! !        Allocate ! call wf % mem % alloc ( L_ia_J , i_length * ( wf % n_v ), wf % n_J ) call wf % mem % alloc ( L_iJ_a , i_length * ( wf % n_J ), wf % n_v ) ! !        Read the untransformed Cholesky vectors ! call wf % read_cholesky_ij ( L_ij_J , i_first , i_last , j_first , j_last ) call wf % read_cholesky_ia ( L_ia_J , i_first , i_last , 1 , wf % n_v ) ! !        Reorder L_ia_J to L_iJ_a ! do i = 1 , i_length do J = 1 , wf % n_J do a = 1 , wf % n_v ! iJ = index_two ( i , J , i_length ) ia = index_two ( i , a , i_length ) ! L_iJ_a ( iJ , a ) = L_ia_J ( ia , J ) ! enddo enddo enddo ! !        Deallocate L_ia_J ! call wf % mem % dealloc ( L_ia_J , i_length * ( wf % n_v ), wf % n_J ) ! !        Allocate L_iJ_k (L_ij&#94;J reordered as L_iJ_j) ! call wf % mem % alloc ( L_iJ_k , i_length * ( wf % n_J ), j_length ) ! !        T1-transformation ! call dgemm ( 'N' , 'N' , & i_length * ( wf % n_J ), & j_length , & wf % n_v , & one , & L_iJ_a , & i_length * ( wf % n_J ), & wf % t1am ( 1 , j_first ),& wf % n_v , & zero , & L_iJ_k , & i_length * ( wf % n_J )) ! !        Place terms from L_iJ_k into L_ij_J ! do i = 1 , i_length do k = 1 , j_length do J = 1 , wf % n_J ! !                 Needed indices ! iJ = index_two ( i , J , i_length ) ik = index_two ( i , k , i_length ) ! L_ij_J ( ik , J ) = L_ij_J ( ik , J ) + L_iJ_k ( iJ , k ) ! enddo enddo enddo ! !        Deallocate L_iJ_k and L_iJ_a ! call wf % mem % dealloc ( L_iJ_k , i_length * ( wf % n_J ), j_length ) call wf % mem % dealloc ( L_iJ_a , i_length * ( wf % n_J ), wf % n_v ) ! elseif (. not . ( present ( i_first ) . and . present ( i_last ) . and . present ( j_first ) . and . present ( j_last ))) then !    Allocate ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % mem % alloc ( L_iJ_a , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) ! !    Read the untransformed Cholesky vectors ! call wf % read_cholesky_ij ( L_ij_J ) call wf % read_cholesky_ia ( L_ia_J ) ! !    Reorder L_ia_J to L_iJ_a ! do i = 1 , wf % n_o do J = 1 , wf % n_J do a = 1 , wf % n_v ! iJ = index_two ( i , J , wf % n_o ) ia = index_two ( i , a , wf % n_o ) ! L_iJ_a ( iJ , a ) = L_ia_J ( ia , J ) ! enddo enddo enddo ! !    Deallocate L_ia_J ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !    Allocate L_iJ_k ! call wf % mem % alloc ( L_iJ_k , ( wf % n_o ) * ( wf % n_J ), wf % n_o ) ! !    T1-transformation ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_J ), & wf % n_o , & wf % n_v , & one , & L_iJ_a , & ( wf % n_o ) * ( wf % n_J ), & wf % t1am , & wf % n_v , & zero , & L_iJ_k , & ( wf % n_o ) * ( wf % n_J )) ! !    Place terms from L_iJ_k into L_ij_J ! do i = 1 , wf % n_o do k = 1 , wf % n_o do J = 1 , wf % n_J ! !             Needed indices ! iJ = index_two ( i , J , wf % n_o ) ik = index_two ( i , k , wf % n_o ) ! L_ij_J ( ik , J ) = L_ij_J ( ik , J ) + L_iJ_k ( iJ , k ) ! enddo enddo enddo ! !    Deallocate L_iJ_k and L_iJ_a ! call wf % mem % dealloc ( L_iJ_k , ( wf % n_o ) * ( wf % n_J ), wf % n_o ) call wf % mem % dealloc ( L_iJ_a , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) else write ( unit_output , * ) 'WARNING: Error in call to get_cholesky_ij' stop endif ! end subroutine get_cholesky_ij_ccs ! ! module subroutine get_cholesky_ia_ccs ( wf , L_ia_J , i_first , i_last , a_first , a_last ) !! !!    Get Cholesky IA !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads and T1-transforms IA Cholesky vectors !! !!       L_ia_J_T1 = L_ia_J (only reading necessary) !! !!    Memory required in routine: !! !!       No additional memory !! !!    Optional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( ccs ) :: wf integer ( i15 ), optional :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), optional :: i_last , a_last ! Last index (can differ from n_v/n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ia_J ! call wf % read_cholesky_ia ( L_ia_J , i_first , i_last , a_first , a_last ) ! end subroutine get_cholesky_ia_ccs ! ! module subroutine get_cholesky_ai_ccs ( wf , L_ai_J , a_first , a_last , i_first , i_last ) !! !!    Get Cholesky AI !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Read and T1-transform Cholesky AI vectors: !! !!       L_ai_J_T1 = L_ia_J - sum_j  t_aj*L_ji_J !!                          + sum_b  t_bi*L_ab_J !!                          - sum_bj t_aj*t_bi*L_jb_J !! !!    Allocations in routine: !! !!      (1) n_J*(i_length)*(a_length) + 2*n_J*(a_length)*batch_length  ->  for L_ab_J contribution (batches of b) !!      (2) n_J*(i_length)*n_v + 2*n_J*n_o*(i_length)                  ->  for L_ij_J contribution !!      (3) 2*n_J*n_o*n_v                                              ->  for L_jb_J contribution !! !!      i_length = i_last - i_first + 1 !!      a_length = a_last - a_first + 1 !! !!      (1) determines memory requirement. !! !!    Optional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( ccs ) :: wf integer ( i15 ), optional :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), optional :: i_last , a_last ! Last index (can differ from n_o/n_v when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ai_J ! !     Local routine variables ! logical :: reorder ! Reorder or not, when reading Cholesky AB ! !     Batch variables ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , n_batch = 0 , L_off = 0 integer ( i15 ) :: a_batch = 0 , batch_start = 0 , batch_end = 0 , batch_length = 0 ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , J = 0 , i = 0 , ai = 0 , Ja = 0 integer ( i15 ) :: ba = 0 , k = 0 , ik = 0 , iJ = 0 , kb = 0 , kJ = 0 , ab = 0 integer ( i15 ) :: a_length , i_length ! !     Cholesky vectors (in many different orderings) ! real ( dp ), dimension (:,:), allocatable :: L_ba_J real ( dp ), dimension (:,:), allocatable :: L_ab_J real ( dp ), dimension (:,:), allocatable :: L_Ja_b real ( dp ), dimension (:,:), allocatable :: L_Ja_i real ( dp ), dimension (:,:), allocatable :: L_ik_J real ( dp ), dimension (:,:), allocatable :: L_k_iJ real ( dp ), dimension (:,:), allocatable :: L_a_iJ real ( dp ), dimension (:,:), allocatable :: L_kJ_b real ( dp ), dimension (:,:), allocatable :: L_kJ_i real ( dp ), dimension (:,:), allocatable :: L_kb_J ! if ( present ( i_first ) . and . present ( i_last ) . and . present ( a_first ) . and . present ( a_last )) then a_length = a_last - a_first + 1 i_length = i_last - i_first + 1 ! !        Read L_ai&#94;J from file ! call wf % read_cholesky_ai ( L_ai_J , a_first , a_last , i_first , i_last ) ! !        :: L_ab_J contributions :: ! !        Allocate L_Ja_i ! call wf % mem % alloc ( L_Ja_i , ( wf % n_J ) * a_length , i_length ) L_Ja_i = zero ! !        Set batching variables ! required = 2 * ( wf % n_v ) * ( a_last - a_first + 1 ) * ( wf % n_J ) * 4 available = get_available () max_batch_length = 0 ! n_batch = 0 a_batch = 0 ! batch_length = 0 batch_start = 0 batch_end = 0 ! !        Calculate the number of batches ! call num_batch ( required , available , max_batch_length , n_batch , a_length ) ! do a_batch = 1 , n_batch ! !           Get start, end, and length of batch ! call batch_limits ( batch_start , batch_end , a_batch , max_batch_length , a_length ) batch_start = batch_start + ( a_first - 1 ) batch_end = batch_end + ( a_first - 1 ) ! if ( batch_end . gt . a_last ) batch_end = a_last batch_length = batch_end - batch_start + 1 ! !           Allocate L_ab_J and L_Ja_b ! call wf % mem % alloc ( L_ab_J , ( wf % n_v ) * batch_length , wf % n_J ) ! L_ab&#94;J L_ab_J = zero call wf % read_cholesky_ab ( L_ab_J , batch_start , batch_end , 1 , wf % n_v ) ! !           Read Cholesky AB vectors, batching over a ! call wf % mem % alloc ( L_ba_J , ( wf % n_v ) * batch_length , wf % n_J ) ! L_ab&#94;J = L_ba_J(ba,J) L_ba_J = zero ! do b = 1 , wf % n_v do a = 1 , batch_length ba = index_two ( b , a , wf % n_v ) ab = index_two ( a , b , batch_length ) do J = 1 , wf % n_J L_ba_J ( ba , J ) = L_ab_J ( ab , J ) enddo enddo enddo ! call wf % mem % dealloc ( L_ab_J , ( wf % n_v ) * batch_length , wf % n_J ) call wf % mem % alloc ( L_Ja_b , batch_length * ( wf % n_J ), wf % n_v ) L_Ja_b = zero ! !           Reorder the Cholesky array L_ba_J ! do a = 1 , batch_length do b = 1 , wf % n_v do J = 1 , wf % n_J ! !                    Needed indices ! ba = index_two ( b , a , wf % n_v ) Ja = index_two ( J , a , wf % n_J ) ! L_Ja_b ( Ja , b ) = L_ba_J ( ba , J ) ! L_ab&#94;J ! enddo enddo enddo ! !           Calculate sum_b L_Ja_b*t_b_i = L_Ja_i ! L_off = index_two ( 1 , batch_start , wf % n_J ) ! call dgemm ( 'N' , 'N' , & batch_length * ( wf % n_J ), & i_length , & wf % n_v , & one , & L_Ja_b , & batch_length * ( wf % n_J ), & wf % t1am ( 1 , i_first ), & wf % n_v , & one , & L_Ja_i ( L_off , 1 ), & a_length * ( wf % n_J )) ! !           Deallocate L_ab_J and L_Ja_b ! call wf % mem % dealloc ( L_ba_J , ( wf % n_v ) * batch_length , wf % n_J ) call wf % mem % dealloc ( L_Ja_b , batch_length * ( wf % n_J ), wf % n_v ) ! enddo ! batching over a ! !        Add terms to T1-transformed Cholesky AI vector ! do i = 1 , i_length do a = 1 , a_length do J = 1 , wf % n_J ! !                 Needed indices ! Ja = index_two ( J , a , wf % n_J ) ai = index_two ( a , i , a_length ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_Ja_i ( Ja , i ) ! enddo enddo enddo ! !        Deallocate L_Ja_i ! call wf % mem % dealloc ( L_Ja_i , ( wf % n_J ) * a_length , i_length ) ! ! !        :: L_ij_J contributions :: ! ! !        Allocate L_a_iJ, L_ik_J, L_k_iJ ! call wf % mem % alloc ( L_a_iJ , a_length , ( wf % n_J ) * i_length ) call wf % mem % alloc ( L_k_iJ , wf % n_o , i_length * ( wf % n_J )) ! call wf % mem % alloc ( L_ik_J , ( wf % n_o ) * i_length , wf % n_J ) ! !        Read Cholesky IJ vectors ! call wf % read_cholesky_ij ( L_ik_J , i_first , i_last , 1 , wf % n_o ) ! L_ik_J(ik,J) = L_ik&#94;J ! !        Reorder IJ Cholesky vectors ! do i = 1 , i_length do k = 1 , wf % n_o do J = 1 , wf % n_J ! !                 Needed indices ! ik = index_two ( i , k , i_length ) iJ = index_two ( i , J , i_length ) ! L_k_iJ ( k , iJ ) = L_ik_J ( ik , J ) ! L_k_iJ(k,iJ) = L_ik&#94;J ! enddo enddo enddo ! !        Calculate -sum_k t_a_k*L_k_iJ = L_a_iJ  ! Here we assume L_ik&#94;J = L_ki&#94;J ! call dgemm ( 'N' , 'N' , & a_length , & i_length * ( wf % n_J ), & wf % n_o , & - one , & wf % t1am ( a_first , 1 ),& wf % n_v , & L_k_iJ , & wf % n_o , & zero , & L_a_iJ , & a_length ) ! !        Add terms to T1-transformation of L_ai_J ! do i = 1 , i_length do a = 1 , a_length do J = 1 , wf % n_J ! !                 Needed indices ! ai = index_two ( a , i , a_length ) iJ = index_two ( i , J , i_length ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_a_iJ ( a , iJ ) ! enddo enddo enddo ! !        Deallocate L_a_iJ, L_ik_J, L_k_iJ ! call wf % mem % dealloc ( L_a_iJ , a_length , ( wf % n_J ) * i_length ) call wf % mem % dealloc ( L_k_iJ , wf % n_o , i_length * ( wf % n_J )) ! call wf % mem % dealloc ( L_ik_J , ( wf % n_o ) * i_length , wf % n_J ) ! ! !        :: L_jb_J contributions :: ! ! call wf % mem % alloc ( L_kJ_b , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) call wf % mem % alloc ( L_kb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Read the Cholesky vector L_kb_J ! call wf % read_cholesky_ia ( L_kb_J ) ! !        Reorder L_kb_J to L_kJ_b ! do k = 1 , wf % n_o do b = 1 , wf % n_v do J = 1 , wf % n_J ! kb = index_two ( k , b , wf % n_o ) kJ = index_two ( k , J , wf % n_o ) ! L_kJ_b ( kJ , b ) = L_kb_J ( kb , J ) ! enddo enddo enddo ! !        Deallocate L_kb_J ! call wf % mem % dealloc ( L_kb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Allocate L_kJ_i ! call wf % mem % alloc ( L_kJ_i , ( wf % n_o ) * ( wf % n_J ), i_length ) ! !        Calculate sum_b L_kJ_b*t_b_i = L_kJ_i ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_J ), & i_length , & wf % n_v , & one , & L_kJ_b , & ( wf % n_o ) * ( wf % n_J ), & wf % t1am ( 1 , i_first ),& wf % n_v , & zero , & L_kJ_i , & ( wf % n_o ) * ( wf % n_J )) ! !        Deallocate L_kJ_b ! call wf % mem % dealloc ( L_kJ_b , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) ! !        Allocate L_k_iJ ! call wf % mem % alloc ( L_k_iJ , ( wf % n_o ), i_length * ( wf % n_J )) ! !        Reorder L_kJ_i to L_k_iJ ! do i = 1 , i_length do k = 1 , wf % n_o do J = 1 , wf % n_J ! kJ = index_two ( k , J , wf % n_o ) iJ = index_two ( i , J , i_length ) ! L_k_iJ ( k , iJ ) = L_kJ_i ( kJ , i ) ! enddo enddo enddo ! !        Deallocate L_kJ_i ! call wf % mem % dealloc ( L_kJ_i , ( wf % n_o ) * ( wf % n_J ), i_length ) ! !        Allocate L_a_iJ ! call wf % mem % alloc ( L_a_iJ , a_length , i_length * ( wf % n_J )) ! !        Calculate sum_k t_a_k*L_k_iJ = L_a_iJ ! call dgemm ( 'N' , 'N' , & a_length , & i_length * ( wf % n_J ), & wf % n_o , & - one , & wf % t1am ( a_first , 1 ),& wf % n_v , & L_k_iJ , & wf % n_o , & zero , & L_a_iJ , & a_length ) ! !        Add contribution to L ai_J ! do a = 1 , a_length do i = 1 , i_length do J = 1 , wf % n_J ! iJ = index_two ( i , J , i_length ) ai = index_two ( a , i , a_length ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_a_iJ ( a , iJ ) ! enddo enddo enddo ! !        Deallocations ! call wf % mem % dealloc ( L_a_iJ , a_length , i_length * ( wf % n_J )) call wf % mem % dealloc ( L_k_iJ , wf % n_o , i_length * ( wf % n_J )) ! elseif (. not .( present ( i_first ) . and . present ( i_last ) . and . present ( a_first ) . and . present ( a_last ))) then ! !        Read L_ai&#94;J from file ! call wf % read_cholesky_ai ( L_ai_J ) ! !        :: L_ab_J contributions :: ! !        Allocate L_Ja_i ! call wf % mem % alloc ( L_Ja_i , ( wf % n_J ) * ( wf % n_v ), wf % n_o ) L_Ja_i = zero ! !        Set batching variables ! required = 2 * ( wf % n_v ) ** 2 * ( wf % n_J ) * 4 available = get_available () max_batch_length = 0 ! n_batch = 0 a_batch = 0 ! batch_length = 0 batch_start = 0 batch_end = 0 ! !        Calculate the number of batches ! call num_batch ( required , available , max_batch_length , n_batch , wf % n_v ) ! do a_batch = 1 , n_batch ! !           Get start, end, and length of batch ! call batch_limits ( batch_start , batch_end , a_batch , max_batch_length , wf % n_v ) batch_length = batch_end - batch_start + 1 ! call wf % mem % alloc ( L_ab_J , batch_length * ( wf % n_v ), wf % n_J ) ! L_ab&#94;J L_ab_J = zero ! !           Read Cholesky AB vectors, batching over a ! call wf % read_cholesky_ab ( L_ab_J , batch_start , batch_end , 1 , wf % n_v ) ! call wf % mem % alloc ( L_ba_J , ( wf % n_v ) * batch_length , wf % n_J ) ! L_ab&#94;J = L_ba_J(ba,J) L_ba_J = zero do b = 1 , wf % n_v do a = 1 , batch_length ba = index_two ( b , a , wf % n_v ) ab = index_two ( a , b , batch_length ) do J = 1 , wf % n_J L_ba_J ( ba , J ) = L_ab_J ( ab , J ) enddo enddo enddo call wf % mem % dealloc ( L_ab_J , batch_length * ( wf % n_v ), wf % n_J ) ! call wf % mem % alloc ( L_Ja_b , batch_length * ( wf % n_J ), wf % n_v ) L_Ja_b = zero ! !           Reorder the Cholesky array L_ba_J ! do a = 1 , batch_length do b = 1 , wf % n_v do J = 1 , wf % n_J ! !                    Needed indices ! ba = index_two ( b , a , wf % n_v ) Ja = index_two ( J , a , wf % n_J ) ! L_Ja_b ( Ja , b ) = L_ba_J ( ba , J ) ! L_ab&#94;J ! enddo enddo enddo call wf % mem % dealloc ( L_ba_J , ( wf % n_v ) * batch_length , wf % n_J ) ! !           Calculate sum_b L_Ja_b*t_b_i = L_Ja_i ! L_off = index_two ( 1 , batch_start , wf % n_J ) ! ! call dgemm ( 'N' , 'N' , & batch_length * ( wf % n_J ), & wf % n_o , & wf % n_v , & one , & L_Ja_b , & batch_length * ( wf % n_J ), & wf % t1am , & wf % n_v , & one , & L_Ja_i ( L_off , 1 ), & ( wf % n_v ) * ( wf % n_J )) ! ! !           Deallocate  L_Ja_b ! call wf % mem % dealloc ( L_Ja_b , batch_length * ( wf % n_J ), wf % n_v ) ! enddo ! batching over a ! !        Add terms to T1-transformed Cholesky AI vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v do J = 1 , wf % n_J ! !                 Needed indices ! Ja = index_two ( J , a , wf % n_J ) ai = index_two ( a , i , wf % n_v ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_Ja_i ( Ja , i ) ! enddo enddo enddo ! !        Deallocate L_Ja_i ! call wf % mem % dealloc ( L_Ja_i , ( wf % n_J ) * ( wf % n_v ), wf % n_o ) ! ! !        :: L_ij_J contributions :: ! ! !        Allocate L_a_iJ, L_ik_J, L_k_iJ ! call wf % mem % alloc ( L_a_iJ , wf % n_v , ( wf % n_J ) * ( wf % n_o )) call wf % mem % alloc ( L_k_iJ , wf % n_o , ( wf % n_o ) * ( wf % n_J )) ! call wf % mem % alloc ( L_ik_J , ( wf % n_o ) ** 2 , wf % n_J ) ! !        Read Cholesky IJ vectors ! call wf % read_cholesky_ij ( L_ik_J ) ! L_ik_J(ik,J) = L_ik&#94;J ! !        Reorder IJ Cholesky vectors ! do i = 1 , wf % n_o do k = 1 , wf % n_o do J = 1 , wf % n_J ! !                 Needed indices ! ik = index_two ( i , k , wf % n_o ) iJ = index_two ( i , J , wf % n_o ) ! L_k_iJ ( k , iJ ) = L_ik_J ( ik , J ) ! L_k_iJ(k,iJ) = L_ik&#94;J ! enddo enddo enddo ! !        Calculate -sum_k t_a_k*L_k_iJ = L_a_iJ  ! Here we assume L_ik&#94;J = L_ki&#94;J ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_o ) * ( wf % n_J ), & wf % n_o , & - one , & wf % t1am , & wf % n_v , & L_k_iJ , & wf % n_o , & zero , & L_a_iJ , & wf % n_v ) ! !        Add terms to T1-transformation of L_ai_J ! do i = 1 , wf % n_o do a = 1 , wf % n_v do J = 1 , wf % n_J ! !                 Needed indices ! ai = index_two ( a , i , wf % n_v ) iJ = index_two ( i , J , wf % n_o ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_a_iJ ( a , iJ ) ! enddo enddo enddo ! !        Deallocate L_a_iJ, L_ik_J, L_k_iJ ! call wf % mem % dealloc ( L_a_iJ , wf % n_v , ( wf % n_J ) * ( wf % n_o )) call wf % mem % dealloc ( L_k_iJ , wf % n_o , ( wf % n_o ) * ( wf % n_J )) ! call wf % mem % dealloc ( L_ik_J , ( wf % n_o ) ** 2 , wf % n_J ) ! ! !        :: L_jb_J contributions :: ! ! call wf % mem % alloc ( L_kJ_b , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) call wf % mem % alloc ( L_kb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Read the Cholesky vector L_kb_J ! call wf % read_cholesky_ia ( L_kb_J ) ! !        Reorder L_kb_J to L_kJ_b ! do k = 1 , wf % n_o do b = 1 , wf % n_v do J = 1 , wf % n_J ! kb = index_two ( k , b , wf % n_o ) kJ = index_two ( k , J , wf % n_o ) ! L_kJ_b ( kJ , b ) = L_kb_J ( kb , J ) ! enddo enddo enddo ! !        Deallocate L_kb_J ! call wf % mem % dealloc ( L_kb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Allocate L_kJ_i ! call wf % mem % alloc ( L_kJ_i , ( wf % n_o ) * ( wf % n_J ), wf % n_o ) ! !        Calculate sum_b L_kJ_b*t_b_i = L_kJ_i ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_J ), & wf % n_o , & wf % n_v , & one , & L_kJ_b , & ( wf % n_o ) * ( wf % n_J ), & wf % t1am , & wf % n_v , & zero , & L_kJ_i , & ( wf % n_o ) * ( wf % n_J )) ! !        Deallocate L_kJ_b ! call wf % mem % dealloc ( L_kJ_b , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) ! !        Allocate L_k_iJ ! call wf % mem % alloc ( L_k_iJ , ( wf % n_o ), ( wf % n_o ) * ( wf % n_J )) ! !        Reorder L_kJ_i to L_k_iJ ! do i = 1 , wf % n_o do k = 1 , wf % n_o do J = 1 , wf % n_J ! kJ = index_two ( k , J , wf % n_o ) iJ = index_two ( i , J , wf % n_o ) ! L_k_iJ ( k , iJ ) = L_kJ_i ( kJ , i ) ! enddo enddo enddo ! !        Deallocate L_kJ_i ! call wf % mem % dealloc ( L_kJ_i , ( wf % n_o ) * ( wf % n_J ), wf % n_o ) ! !        Allocate L_a_iJ ! call wf % mem % alloc ( L_a_iJ , wf % n_v , ( wf % n_o ) * ( wf % n_J )) ! !        Calculate sum_k t_a_k*L_k_iJ = L_a_iJ ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_o ) * ( wf % n_J ), & wf % n_o , & - one , & wf % t1am , & wf % n_v , & L_k_iJ , & wf % n_o , & zero , & L_a_iJ , & wf % n_v ) ! !        Add contribution to L ai_J ! do a = 1 , wf % n_v do i = 1 , wf % n_o do J = 1 , wf % n_J ! iJ = index_two ( i , J , wf % n_o ) ai = index_two ( a , i , wf % n_v ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_a_iJ ( a , iJ ) ! enddo enddo enddo ! !        Deallocations ! call wf % mem % dealloc ( L_a_iJ , wf % n_v , ( wf % n_o ) * ( wf % n_J )) call wf % mem % dealloc ( L_k_iJ , wf % n_o , ( wf % n_o ) * ( wf % n_J )) ! else write ( unit_output , * ) 'WARNING: Error in call to read_cholesky_ia' stop endif ! end subroutine get_cholesky_ai_ccs ! ! module subroutine get_cholesky_ab_ccs ( wf , L_ab_J , a_first , a_last , b_first , b_last ) !! !!    Get Cholesky AB !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads and T1-transforms the IA Cholesky vectors: !! !!       L_ab_J_T1 = L_ab_J - sum_i t_ai*L_ib_J !! !! !!    Required memory: !! !!       n_J*b_length*a_length       ->   For reordering of L_ab_J / L_ba_J !!       2*b_length*n_o*n_J          ->   For L_ib_J contribution !! !!      a_length = a_last - a_first + 1 !!      b_length = b_last - b_first + 1 !! implicit none ! class ( ccs ) :: wf integer ( i15 ), intent ( in ) :: a_first , b_first ! First index (can differ from 1 when batching) integer ( i15 ), intent ( in ) :: a_last , b_last ! Last index  (can differ from n_v when batching) real ( dp ), dimension ((( b_last - b_first + 1 ) * ( a_last - a_first + 1 )), wf % n_J ) :: L_ab_J ! L_ab&#94;J ! !     Local routine variables ! integer ( i15 ) :: memory_lef = 0 ! integer :: unit_chol_ab = - 1 ! Unit identifier for cholesky_ab file ! integer :: a = 0 , b = 0 , J = 0 , i = 0 , ia = 0 , aJ = 0 , ib = 0 , Jb = 0 , ab = 0 , ba = 0 ! real ( dp ), dimension (:,:), allocatable :: L_ib_J real ( dp ), dimension (:,:), allocatable :: L_Jb_i real ( dp ), dimension (:,:), allocatable :: L_Jb_a real ( dp ), dimension (:,:), allocatable :: L_a_Jb real ( dp ), dimension (:,:), allocatable :: L_i_Jb ! integer ( i15 ) :: b_length , a_length ! a_length = a_last - a_first + 1 b_length = b_last - b_first + 1 ! !        Allocate L_ib_J ! call wf % mem % alloc ( L_ib_J , ( wf % n_o ) * b_length , wf % n_J ) ! !        Read L_ia_J ! !        Note: using L_ia_J instead of L_ai_J, here, to avoid two reorderings. !              This is possible because of the symmetry L_ai_J(ai,J) == L_ia_J(ia,J). ! call wf % read_cholesky_ia ( L_ib_J , 1 , wf % n_o , b_first , b_last ) ! !        Read L_ab_J for batch of b ! call wf % read_cholesky_ab ( L_ab_J , a_first , a_last , b_first , b_last ) ! !        Allocate L_Jb,i for batch of b ! call wf % mem % alloc ( L_Jb_i , ( wf % n_J ) * b_length , wf % n_o ) ! !        Reorder L_ib_J to L_Jb_i ! do i = 1 , wf % n_o do b = 1 , b_length do J = 1 , wf % n_J ! ib = index_two ( i , b , wf % n_o ) Jb = index_two ( J , b , wf % n_J ) ! L_Jb_i ( Jb , i ) = L_ib_J ( ib , J ) ! enddo enddo enddo ! !        Dellocate L_ib_J ! call wf % mem % dealloc ( L_ib_J , ( wf % n_o ) * b_length , wf % n_J ) ! !        Allocate L_Jb_a for batch of b ! call wf % mem % alloc ( L_Jb_a , ( wf % n_J ) * b_length , a_length ) ! !        T1-transformation ! call dgemm ( 'N' , 'T' , & ( wf % n_J ) * b_length , & a_length , & wf % n_o , & - one , & L_Jb_i , & ( wf % n_J ) * b_length , & wf % t1am ( a_first , 1 ), & wf % n_v , & zero , & L_Jb_a , & b_length * ( wf % n_J )) ! !        Add terms of L_Jb_a to L_ab_J ! do a = 1 , a_length do b = 1 , b_length do J = 1 , wf % n_J ! Jb = index_two ( J , b , wf % n_J ) ab = index_two ( a , b , a_length ) ! L_ab_J ( ab , J ) = L_ab_J ( ab , J ) + L_Jb_a ( Jb , a ) ! enddo enddo enddo ! !        Dellocate L_Jb,i and L_Jb_a for batch of b ! call wf % mem % dealloc ( L_Jb_a , ( wf % n_J ) * b_length , a_length ) call wf % mem % dealloc ( L_Jb_i , ( wf % n_J ) * b_length , wf % n_o ) ! end subroutine get_cholesky_ab_ccs ! end submodule cholesky","tags":"","loc":"sourcefile/cholesky_submodule.f90~2.html","title":"cholesky_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~excited_state_submodule.f90~5~~EfferentGraph sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileexcited_state_submodulef905EfferentGraph = svgPanZoom('#sourcefileexcited_state_submodulef905EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules excited_state Source Code excited_state_submodule.F90 Source Code submodule ( ccs_class ) excited_state ! !! !!    Excited state sub(CCS) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017 !! !!    Contains the following family of procedures of the CCS class: !! !!    excited_state_driver:                directs the solution of excited state problems. !!    excited_state_solver:                solves the excited state problem. !!    solve_reduced_eigenvalue_equation:   solves the excited state problem in the projected/reduced space !!                                         of trial vectors (in a given iteration). !!    construct_next_trial_vectors:        finds the new trial vectors resulting from the residuals found !!                                         by solving the reduced eigenvalue equation. !!    calculate_orbital_differences:       calculates the orbital differences (used for preconditioning and !!                                         start vector guess). !!    transform_trial_vectors:             transforms (by A) the new trial vectors and saves them to disk. !!    find_start_trial_indices:            find the indices corresponding to the lowest orbital differences. !!    trial_vectors_from_stored_solutions: finds suitable start trial vectors from stored solutions (for restart). !! ! implicit none ! !  Some variables available to all routines of the module ! integer ( i15 ) :: iteration = 1 ! !  Variables to handle convergence criterea ! logical :: converged = . false . ! True iff both the energy and the equations have converged ! logical :: converged_energy = . false . logical :: converged_residual = . false . ! logical :: print_vectors = . true . ! ! contains ! ! module subroutine excited_state_driver_ccs ( wf ) !! !!    Excited state driver (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Directs the solution of the excited state problem for CCS. The !!    routine is inherited is to be inherited unaltered in the CC hierarchy. !! !!    Note: it is only necessary to alter this routine if the excited states are !!    solved for by a different algorithm (such as in similarity constrained CC, !!    where the excited states and ground state are determined simultaneously). !! implicit none ! class ( ccs ) :: wf ! !     Let the user know the excited state driver is running ! write ( unit_output , '(/t3,a)' ) ':: Excited state solver (Davidson)' write ( unit_output , '(t3,a/)' ) ':: E. F. Kjønstad, S. D. Folkestad, May 2017' write ( unit_output , '(t3,a,i2,a,a,a)' ) & 'Requested' , wf % excited_state_specifications % n_singlet_states ,& ' ' , trim ( wf % name ), ' singlet states.' write ( unit_output , '(t3,a,i2,a,a,a)' ) & 'Requested' , wf % excited_state_specifications % n_triplet_states ,& ' ' , trim ( wf % name ), ' triplet states.' flush ( unit_output ) ! !     Preparations for excited state solver ! call wf % excited_state_preparations ! !     Run the general solver routine (file names are given !     by the task, i.e., the file 'right_valence' contains !     the right eigenvectors) ! call wf % excited_state_solver ! !     Final work and preparations for other tasks (such as property calculations) ! call wf % excited_state_cleanup ! end subroutine excited_state_driver_ccs ! ! module subroutine excited_state_preparations_ccs ( wf ) !! !!    Excited State Preparations (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    A routine for preparation tasks (if any). Can be overwritten !!    in descendants if other preparations prove necessary. !! class ( ccs ) :: wf ! !     Store electronic repulsion integrals to file if there is space ! call wf % mem % alloc ( wf % t1am , wf % n_v , wf % n_o ) call wf % read_single_amplitudes ! call wf % store_t1_vo_ov_electronic_repulsion call wf % store_t1_vv_ov_electronic_repulsion ! !     Set current task to excited state calculation ! wf % tasks % current = 'excited_state' ! !     Set filename for solution vectors ! if ( wf % tasks % core_excited_state . or . wf % tasks % core_ionized_state ) then ! Core excitation ! if ( wf % excited_state_specifications % right ) then ! Right vectors wf % excited_state_specifications % solution_file = 'right_core' else ! Left vectors wf % excited_state_specifications % solution_file = 'left_core' endif ! else ! Valence excitation ! if ( wf % excited_state_specifications % left ) then ! Right vectors wf % excited_state_specifications % solution_file = 'left_valence' else ! Left vectors wf % excited_state_specifications % solution_file = 'right_valence' endif ! endif ! call deallocator ( wf % t1am , wf % n_v , wf % n_o ) ! end subroutine excited_state_preparations_ccs ! ! module subroutine excited_state_cleanup_ccs ( wf ) !! !!    Excited State Cleanup (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    A routine for cleanup tasks (if any). Can be overwritten !!    in descendants if other cleanups prove necessary. !! class ( ccs ) :: wf ! !     Nothing yet! ! end subroutine excited_state_cleanup_ccs ! ! module subroutine excited_state_solver_ccs ( wf ) !! !!    Excited State Solver !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Directs the solution of the excited states using a Davidson algorithm. !!    The routine aims to find the right eigenvectors of the matrix A: !! !!       A X = e X, !! !!    and the eigenvalues which corresponds to the excitation energies. !! !!    The matrix A above can be the Jacobian (the usual A) or the transposed Jacobian (A&#94;T), or, !!    in principle, any matrix. The transformation used is determined by the value of the wavefunction's !!    \"response_task\" variable (if \"right_eigenvectors\", use A; if \"left_eigenvectors\", use A&#94;T; and so on). !!    The selection of A is done in the routine transform_trial_vectors. !! !!    The problem is solved in a reduced space. To find n roots, n start trial vectors {c_i}_i=1, !!    n are generated according to the lowest orbital differences. Then a reduced space Jacobian !!    is constructed, !! !!       A_red_ij = c_i&#94;T * A c_j, !! !!    and the eigenvalues e and eigenvectors x of this matrix are found. !!    The full space vectors {X_j}_j=1,n are then given by !! !!       X_j = sum_i x_j_i*c_i, !! !!    and the j'th residual vector is given by !! !!       R_j = (A*X_j - e*X_j)/|X_j|. !! !!    If the norm of this residual is sufficiently small (and the excitation energies !!    are converged within a given threshold), convergence is reached. If not, new trial !!    vectors will be generated by orthogonalizing the residual vector against the previous !!    trial vectors and then normalizing them, thereby expanding the dimension !!    of the reduced space for the next iteration. !! !!    The linear system (equivalently, the residual) is preconditioned with a diagonal !!    matrix with elements equal to the inverse orbital differences. !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim = 0 ! Current dimension of the reduced space (i.e., the number of trial vectors) integer ( i15 ) :: n_new_trials = 0 ! Number of new trial vectors for the current iteration ! !     Solution for the reduced eigenvalue problem ! real ( dp ), dimension (:,:), allocatable :: eigenvalues_Re_new ! Eigenvalues of current iteration real ( dp ), dimension (:,:), allocatable :: eigenvalues_Im_new ! real ( dp ), dimension (:,:), allocatable :: eigenvalues_Re_old ! Eigenvalues of previous iteration real ( dp ), dimension (:,:), allocatable :: eigenvalues_Im_old ! real ( dp ), dimension (:,:), allocatable :: solution_vectors_reduced real ( dp ), dimension (:,:), allocatable :: solution ! integer ( i15 ) :: state = 0 , unit_solution = 0 , ioerror = 0 , i = 0 ! For looping over the states ! real ( dp ) :: start_excited_state_solver , end_excited_state_solver real ( dp ) :: start_excited_state_iter , end_excited_state_iter ! !     Start timings ! call cpu_time ( start_excited_state_solver ) ! !     Test for triplet calculation, and stop if so - not yet implemented ! if (. not . wf % excited_state_specifications % n_triplet_states . eq . 0 ) then write ( unit_output , '(/t3,a/)' ) 'Triplet excitations not implemented.' endif flush ( unit_output ) ! converged = . false . ! converged_energy = . false . converged_residual = . false . ! iteration = 1 ! !     Initialize for excited state calculation ! reduced_dim = wf % excited_state_specifications % n_singlet_states n_new_trials = wf % excited_state_specifications % n_singlet_states ! ! call wf % initialize_excited_states ! !     Find start trial vectors and store them to the trial_vec file ! call wf % initialize_trial_vectors ! !     Allocate and initialize eigenvalue arrays ! call wf % mem % alloc ( eigenvalues_Im_old , wf % excited_state_specifications % n_singlet_states , 1 ) call wf % mem % alloc ( eigenvalues_Re_old , wf % excited_state_specifications % n_singlet_states , 1 ) call wf % mem % alloc ( eigenvalues_Im_new , wf % excited_state_specifications % n_singlet_states , 1 ) call wf % mem % alloc ( eigenvalues_Re_new , wf % excited_state_specifications % n_singlet_states , 1 ) ! eigenvalues_Im_old = zero eigenvalues_Re_old = zero eigenvalues_Im_new = zero eigenvalues_Re_new = zero ! !     Enter iterative loop ! do while (. not . converged . and . iteration . le . wf % excited_state_specifications % max_iterations ) call cpu_time ( start_excited_state_iter ) ! !        Prints ! write ( unit_output , '(/t3,a,i3)' ) 'Iteration:' , iteration write ( unit_output , '(t3,a,i3/)' ) 'Reduced space dimension:' , reduced_dim flush ( unit_output ) ! !        Transform new trial vectors !        rho_i = A * c_i ! call wf % transform_trial_vectors ( reduced_dim - n_new_trials + 1 , reduced_dim ) ! !        Allocate solution vectors for reduced problem ! call wf % mem % alloc ( solution_vectors_reduced , reduced_dim , wf % excited_state_specifications % n_singlet_states ) solution_vectors_reduced = zero ! !        Solve the reduced eigenvalue problem ! call wf % solve_reduced_eigenvalue_equation ( eigenvalues_Re_new , eigenvalues_Im_new , & solution_vectors_reduced , reduced_dim , n_new_trials ) ! !        Test for energy convergence of all states ! converged_energy = . true . ! do state = 1 , wf % excited_state_specifications % n_singlet_states ! if ( abs ( eigenvalues_Re_new ( state , 1 ) - eigenvalues_Re_old ( state , 1 )) & . gt . wf % excited_state_specifications % energy_threshold ) then ! converged_energy = . false . ! endif ! enddo ! !        Save excitation energies for next iteration ! call dcopy ( wf % excited_state_specifications % n_singlet_states , eigenvalues_Im_new , 1 , eigenvalues_Im_old , 1 ) call dcopy ( wf % excited_state_specifications % n_singlet_states , eigenvalues_Re_new , 1 , eigenvalues_Re_old , 1 ) ! !        Get next trial vectors and test for convergence of residuals ! call wf % construct_next_trial_vectors ( eigenvalues_Re_new , eigenvalues_Im_new , & solution_vectors_reduced , reduced_dim , n_new_trials ) ! !        Test for convergence of the energies and residuals ! if ( converged_energy . and . converged_residual ) then converged = . true . call cpu_time ( end_excited_state_iter ) if ( wf % settings % print_level == 'developer' ) & write ( unit_output , '(t3,a35,i5,a5,f14.8/)' ) 'Total CPU time (seconds) of iteration ' ,& iteration , ' : ' , end_excited_state_iter - start_excited_state_iter flush ( unit_output ) ! else iteration = iteration + 1 endif ! call wf % mem % dealloc ( solution_vectors_reduced , reduced_dim , wf % excited_state_specifications % n_singlet_states ) ! enddo ! End of iterative loop ! !     Prints ! if ( converged ) then write ( unit_output , '(/t3,a,i2,a/)' ) 'Converged in ' , iteration , ' iterations!' ! if ( print_vectors ) then ! call wf % print_excited_state_info ! endif ! else write ( unit_output , '(/t3,a/)' ) 'Max number of iterations performed without convergence!' endif ! !     End and print timings ! call cpu_time ( end_excited_state_solver ) ! ! call wf % summary_excited_state_info ( eigenvalues_Re_new ) ! !     Print summary ! write ( unit_output , '(//t3,a,a,a/)' ) 'Summary of ' , trim ( wf % name ), ' excited state calculation:' write ( unit_output , '(t6,a25,f14.8/)' ) 'Total CPU time (seconds):    ' , end_excited_state_solver - start_excited_state_solver flush ( unit_output ) write ( unit_output , '(t6,a10,a18,a17,a20)' ) 'Excitation' , 'energy [a.u.]' , 'energy [eV]' , 'energy [cm&#94;-1]' write ( unit_output , '(t6,a)' ) '--------------------------------------------------------------------' do i = 1 , wf % excited_state_specifications % n_singlet_states ! !     Print energy of excitation in eV, hartree and cm&#94;-1 ! write ( unit_output , '(t6,i3,12x,f12.8,7x,f12.8,5x,f16.8)' ) i , eigenvalues_Re_new ( i , 1 ),& eigenvalues_Re_new ( i , 1 ) * 2 7.211399 , & eigenvalues_Re_new ( i , 1 ) * 21947 4.63 enddo write ( unit_output , '(t6,a)' ) '--------------------------------------------------------------------' write ( unit_output , '(t6,a)' ) '1 a.u. = 27.211399 eV' write ( unit_output , '(t6,a)' ) '1 a.u. = 219474.63 cm&#94;-1' ! !     Final deallocations ! call wf % mem % dealloc ( eigenvalues_Im_old , reduced_dim , 1 ) call wf % mem % dealloc ( eigenvalues_Re_old , reduced_dim , 1 ) call wf % mem % dealloc ( eigenvalues_Im_new , reduced_dim , 1 ) call wf % mem % dealloc ( eigenvalues_Re_new , reduced_dim , 1 ) ! end subroutine excited_state_solver_ccs ! ! module subroutine solve_reduced_eigenvalue_equation_ccs ( wf , eigenvalues_Re , eigenvalues_Im , & solution_vectors_reduced , reduced_dim , n_new_trials ) !! !!    Solve Reduced Eigenvalue Equation !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Constructs the reduced A matrix, solves its eigenvalue equation, !!    and returns its first n eigenvalues and eigenvectors (reduced space !!    solution vectors). !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: eigenvalues_Re real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: eigenvalues_Im ! real ( dp ), dimension ( reduced_dim , wf % excited_state_specifications % n_singlet_states ) :: solution_vectors_reduced ! real ( dp ), dimension (:,:), allocatable :: A_red real ( dp ), dimension (:,:), allocatable :: c_i real ( dp ), dimension (:,:), allocatable :: rho_j real ( dp ), dimension (:,:), allocatable :: solution_vectors_reduced_all real ( dp ), dimension (:,:), allocatable :: eigenvalues_Re_all real ( dp ), dimension (:,:), allocatable :: eigenvalues_Im_all real ( dp ), dimension (:,:), allocatable :: work ! real ( dp ) :: ddot , dummy ! integer ( i15 ), dimension (:,:), allocatable :: index_list ! integer ( i15 ) :: unit_trial_vecs = 0 , unit_rho = 0 , unit_reduced_jacobi = 0 , ioerror = 0 ! integer ( i15 ) :: i = 0 , j = 0 ! integer :: info = - 1 ! call wf % mem % alloc ( A_red , reduced_dim , reduced_dim ) A_red = zero ! !     -::- Prepare to solve the eigenvalue problem -::- ! !     Prepare files ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! call generate_unit_identifier ( unit_rho ) open ( unit = unit_rho , file = 'transformed_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! if ( iteration . eq . 1 ) then ! call generate_unit_identifier ( unit_reduced_jacobi ) open ( unit = unit_reduced_jacobi , file = 'reduced_jacobi' , action = 'readwrite' , status = 'unknown' ,& form = 'unformatted' , iostat = ioerror ) ! else ! call generate_unit_identifier ( unit_reduced_jacobi ) open ( unit = unit_reduced_jacobi , file = 'reduced_jacobi' , action = 'readwrite' , status = 'old' ,& form = 'unformatted' , iostat = ioerror ) ! rewind ( unit_reduced_jacobi ) read ( unit_reduced_jacobi ) (( A_red ( i , j ), i = 1 , reduced_dim - n_new_trials ), j = 1 , reduced_dim - n_new_trials ) ! endif ! !     Allocate c and rho ! call wf % mem % alloc ( c_i , wf % n_parameters , 1 ) call wf % mem % alloc ( rho_j , wf % n_parameters , 1 ) c_i = zero rho_j = zero ! !     Construct reduced Jacobi matrix !     A_red_ij = c_i&#94;T * A * c_j = c_i&#94;T * rho_i ! if ( iteration . eq . 1 ) then ! !        If first iteration, make the entire reduced matrix ! do i = 1 , reduced_dim read ( unit_trial_vecs , rec = i , iostat = ioerror ) c_i do j = 1 , reduced_dim read ( unit_rho , rec = j , iostat = ioerror ) rho_j A_red ( i , j ) = ddot ( wf % n_parameters , c_i , 1 , rho_j , 1 ) enddo enddo ! else ! !        If not, make the elements of the reduced matrix not constructed !        in previous iterations ! do i = 1 , reduced_dim ! read ( unit_trial_vecs , rec = i , iostat = ioerror ) c_i ! do j = reduced_dim - n_new_trials + 1 , reduced_dim read ( unit_rho , rec = j , iostat = ioerror ) rho_j A_red ( i , j ) = ddot ( wf % n_parameters , c_i , 1 , rho_j , 1 ) enddo ! enddo ! do j = 1 , reduced_dim - n_new_trials ! read ( unit_rho , rec = j , iostat = ioerror ) rho_j ! do i = reduced_dim - n_new_trials + 1 , reduced_dim read ( unit_trial_vecs , rec = i , iostat = ioerror ) c_i A_red ( i , j ) = ddot ( wf % n_parameters , c_i , 1 , rho_j , 1 ) enddo ! enddo ! endif ! call wf % mem % dealloc ( c_i , wf % n_parameters , 1 ) call wf % mem % dealloc ( rho_j , wf % n_parameters , 1 ) ! !     Close files for trial vectors and transformed vectors ! close ( unit_trial_vecs ) close ( unit_rho ) ! !     Write current reduced Jacobi matrix to file ! rewind ( unit_reduced_jacobi ) write ( unit_reduced_jacobi ) (( A_red ( i , j ), i = 1 , reduced_dim ), j = 1 , reduced_dim ) ! !     Close reduced Jacobi file ! close ( unit_reduced_jacobi ) ! !     -::- Solve reduced eigenvalue problem -::- ! !     Allocate arrays for eigenvalues and eigenvectors ! call wf % mem % alloc ( solution_vectors_reduced_all , reduced_dim , reduced_dim ) solution_vectors_reduced_all = zero ! call wf % mem % alloc ( eigenvalues_Re_all , reduced_dim , 1 ) call wf % mem % alloc ( eigenvalues_Im_all , reduced_dim , 1 ) eigenvalues_Re_all = zero eigenvalues_Im_all = zero ! call wf % mem % alloc ( work , 4 * reduced_dim , 1 ) work = zero ! !     Solve reduced eigenvalue problem ! info = 0 call dgeev ( 'N' , 'V' , & reduced_dim , & A_red , & reduced_dim , & eigenvalues_Re_all , & eigenvalues_Im_all , & dummy , & 1 , & solution_vectors_reduced_all , & reduced_dim , & work , & 4 * reduced_dim , & info ) ! if ( info . ne . 0 ) then write ( unit_output , * ) 'WARNING: Error while finding solution' , info stop endif ! call wf % mem % dealloc ( work , 4 * reduced_dim , 1 ) ! !     Deallocate reduced Jacobi matrix ! call wf % mem % dealloc ( A_red , reduced_dim , reduced_dim ) ! !     Find lowest eigenvalues and sort them (the corresponding indices !     are placed in the integer array index_list) ! call wf % mem % alloc_int ( index_list , wf % excited_state_specifications % n_singlet_states , 1 ) index_list = 0 ! call get_n_lowest ( wf % excited_state_specifications % n_singlet_states ,& reduced_dim , eigenvalues_Re_all , eigenvalues_Re , index_list ) ! !     Pick out solution vectors and imaginary parts of eigenvalues according to index_list ! do i = 1 , reduced_dim do j = 1 , wf % excited_state_specifications % n_singlet_states ! solution_vectors_reduced ( i , j ) = solution_vectors_reduced_all ( i , index_list ( j , 1 )) eigenvalues_Im = eigenvalues_Im_all ( index_list ( j , 1 ), 1 ) ! enddo enddo ! !     Final deallocatons ! call wf % mem % dealloc ( solution_vectors_reduced_all , reduced_dim , reduced_dim ) call wf % mem % dealloc ( eigenvalues_Im_all , reduced_dim , 1 ) call wf % mem % dealloc ( eigenvalues_Re_all , reduced_dim , 1 ) ! call wf % mem % dealloc_int ( index_list , wf % excited_state_specifications % n_singlet_states , 1 ) ! end subroutine solve_reduced_eigenvalue_equation_ccs ! ! module subroutine construct_next_trial_vectors_ccs ( wf , eigenvalues_Re , eigenvalues_Im , & solution_vectors_reduced , & reduced_dim , n_new_trials ) !! !!    Construct Next Trial Vectors !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Constructs the next eigenvectors by constructing the residual vectors !! !!       R_j = (A*X_j - e*X_j)/|X_j|, !! !!    orthogonalizing them against the other trial vectors. !! !!    Residual vectors are preconditioned before orthogonalization. !!    This is done by dividing by the orbital differences. !! !!    If norm of orthogonal vector is very small !!    (i.e. high degree of linear dependence on previous trial vectors) !!    it is scrapped. If norm sufficiently large, vector is normalized and !!    stored in trial_vec file, to be used in the next iteration. !! !!    Routine also constructs full space solution vectors and stores them !!    in file solution_vectors !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: eigenvalues_Re real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: eigenvalues_Im ! integer ( i15 ) :: reduced_dim integer ( i15 ) :: n_new_trials ! real ( dp ), dimension ( reduced_dim , wf % excited_state_specifications % n_singlet_states ) :: solution_vectors_reduced ! !     Local variables ! integer ( i15 ) :: root = 0 , trial = 0 , i = 0 , j = 0 ! real ( dp ), dimension (:,:), allocatable :: solution_vector real ( dp ), dimension (:,:), allocatable :: residual real ( dp ), dimension (:,:), allocatable :: orbital_diff ! real ( dp ), dimension (:,:), allocatable :: c_i real ( dp ), dimension (:,:), allocatable :: c_j real ( dp ), dimension (:,:), allocatable :: rho_i ! real ( dp ) :: norm_new_trial = zero real ( dp ) :: norm_residual = zero real ( dp ) :: norm_solution_vector = zero ! real ( dp ) :: conv_test = zero real ( dp ) :: dot_prod = zero ! integer ( i15 ) :: ioerror = 0 integer ( i15 ) :: unit_trial_vecs = 0 , unit_rho = 0 , unit_solution = 0 ! Unit identifiers for files ! real ( dp ) :: ddot character ( 100 ) :: iostring ! !     Prepare necessary files ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'readwrite' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening trial vecs file' ! call generate_unit_identifier ( unit_rho ) open ( unit = unit_rho , file = 'transformed_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening transformed vecs file' ! call generate_unit_identifier ( unit_solution ) open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file ,& action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening solution file' ! call wf % mem % alloc ( residual , wf % n_parameters , 1 ) ! n_new_trials = 0 converged_residual = . true . ! write ( unit_output , '(t3,a)' ) 'Root       Eigenvalue (Re)      Eigenvalue (Im)      Residual norm' write ( unit_output , '(t3,a)' ) '-------------------------------------------------------------------' ! !     For each of the roots ! do root = 1 , wf % excited_state_specifications % n_singlet_states ! residual = zero ! !        :: Create fullspace vector X and calculate norm ||X|| :: ! call wf % mem % alloc ( solution_vector , wf % n_parameters , 1 ) solution_vector = zero ! call wf % mem % alloc ( c_i , wf % n_parameters , 1 ) ! !        Calculate X_j = sum_i x_j_i * c_i (for the root j) ! do trial = 1 , reduced_dim ! c_i = zero read ( unit_trial_vecs , rec = trial , iostat = ioerror , iomsg = iostring ) c_i call daxpy ( wf % n_parameters , solution_vectors_reduced ( trial , root ), c_i , 1 , solution_vector , 1 ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error reading trial vecs in get_next_trial_vectors' , ioerror , iostring ! enddo ! call wf % mem % dealloc ( c_i , wf % n_parameters , 1 ) ! !        Calculate norm of solution vector ! norm_solution_vector = sqrt ( ddot ( wf % n_parameters , solution_vector , 1 , solution_vector , 1 )) ! !        Normalize and write full space solution vectors to file ! call dscal ( wf % n_parameters , one / norm_solution_vector , solution_vector , 1 ) write ( unit_solution , rec = root , iostat = ioerror ) solution_vector ! !        :: Calculate residual :: ! call dcopy ( wf % n_parameters , solution_vector , 1 , residual , 1 ) ! R = X ! call wf % mem % dealloc ( solution_vector , wf % n_parameters , 1 ) ! !        Residual = AX - eX ! !        - eX : ! call dscal ( wf % n_parameters , - eigenvalues_Re ( root , 1 ), residual , 1 ) ! !        + AX : ! call wf % mem % alloc ( rho_i , wf % n_parameters , 1 ) ! do trial = 1 , reduced_dim ! rho_i = zero read ( unit_rho , rec = trial , iostat = ioerror ) rho_i call daxpy ( wf % n_parameters , solution_vectors_reduced ( trial , root ), rho_i , 1 , residual , 1 ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error reading tranf vecs in get_next_trial_vectors' , ioerror ! enddo ! call wf % mem % dealloc ( rho_i , wf % n_parameters , 1 ) ! !        Calculate norm of residual || AX - eX || ! norm_residual = sqrt ( ddot ( wf % n_parameters , residual , 1 , residual , 1 )) ! !        Calculate residual norm and check convergence criteria on residual norms !        ||AX-eX||/||X|| ! conv_test = norm_residual / norm_solution_vector ! if ( conv_test . gt . wf % excited_state_specifications % residual_threshold ) converged_residual = . false . ! !        Prints ! write ( unit_output , '(t3,i2,5x,f14.8,7x,f14.8,11x,e10.4)' ) root , eigenvalues_Re ( root , 1 ), & eigenvalues_Im ( root , 1 ), norm_residual / norm_solution_vector flush ( unit_output ) ! !        :: Precondition the residual by inverse orbital energy differences :: ! call wf % precondition_residual ( residual ) ! !        :: Orthogonalize the residual to the other trial vectors :: ! !        Calculate norm of the residual ! norm_residual = sqrt ( ddot ( wf % n_parameters , residual , 1 , residual , 1 )) ! !        Normalize the residual ! call dscal ( wf % n_parameters , one / norm_residual , residual , 1 ) ! !        Orthogonalize new trial vector (the residual) against old trial vectors ! call wf % mem % alloc ( c_i , wf % n_parameters , 1 ) ! !        prod_i (I - c_i*c_i&#94;T)*Res = prod_i (Res - c_i*c_i&#94;T*Res) ! do trial = 1 , reduced_dim + n_new_trials ! c_i = zero read ( unit_trial_vecs , rec = trial , iostat = ioerror ) c_i if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error reading trial vecs in get_next_trial_vectors' ! dot_prod = ddot ( wf % n_parameters , c_i , 1 , residual , 1 ) call daxpy ( wf % n_parameters , - dot_prod , c_i , 1 , residual , 1 ) ! enddo ! call wf % mem % dealloc ( c_i , wf % n_parameters , 1 ) ! !        Calculate norm of residual ! norm_new_trial = sqrt ( ddot ( wf % n_parameters , residual , 1 , residual , 1 )) ! !        Test for linear dependency on old trial vectors !        If norm sufficiently high new vector is normalized and written to file ! if (( norm_new_trial . gt . wf % excited_state_specifications % residual_threshold ) & . and . ( conv_test . gt . wf % excited_state_specifications % residual_threshold )) then ! n_new_trials = n_new_trials + 1 call dscal ( wf % n_parameters , one / norm_new_trial , residual , 1 ) write ( unit_trial_vecs , rec = n_new_trials + reduced_dim , iostat = ioerror ) residual ! endif ! enddo ! !     Close all files ! close ( unit_trial_vecs ) close ( unit_rho ) close ( unit_solution ) ! !     Update dimension of reduced space ! reduced_dim = reduced_dim + n_new_trials ! call wf % mem % dealloc ( residual , wf % n_parameters , 1 ) ! write ( unit_output , '(t3,a)' ) '-------------------------------------------------------------------' ! end subroutine construct_next_trial_vectors_ccs ! ! module subroutine initialize_trial_vectors_ccs ( wf ) !! !!    Initialize trial vectors (CCS) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Wrapper for initialization of trial vectors: !! !!    If restart, then checks if old solution file exists, !!    then uses old solutions as new trial vectors !! !!    If not restart: !!    initialize_trial_vectors_valence is called for regular excited state calculation !!    initialize_trial_vectors_core is called for cvs calculation !! !! implicit none ! class ( ccs ) :: wf ! ! !     If restart use old solution vectors for first start vectors ! if ( wf % excited_state_specifications % restart ) then ! write ( unit_output , '(/t3,a)' ) 'Requested restart. Using old solution vectors as trial vectors.' call wf % trial_vectors_from_stored_solutions return ! endif ! !     Test for ionization or excitation, core or valence ! if ( wf % tasks % excited_state ) then ! call wf % initialize_trial_vectors_valence ! elseif ( wf % tasks % core_excited_state ) then ! call wf % initialize_trial_vectors_core ! elseif ( wf % tasks % ionized_state ) then ! call wf % initialize_trial_vectors_valence_ionization ! elseif ( wf % tasks % core_ionized_state ) then ! call wf % initialize_trial_vectors_core_ionization ! endif ! end subroutine initialize_trial_vectors_ccs ! ! module subroutine initialize_trial_vectors_valence_ccs ( wf ) !! !!    Initialize trial vectors valence !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad !! !!    Initializes start trial vectors for the calculation of !!    singlet excited states and writes them to file 'trial_vecs'. !!    Initializes start trial vectors for the calculation of !!    singlet excited states and writes them to file 'trial_vecs'. !! !!    n start vectors are constructed by finding the n lowest orbital differences, !!    where n = n_singlet_states. Vector i has a 1.0D0 at the element corresponding to the i'th lowest !!    orbital difference and 0.0d0 everywhere else !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ), dimension (:,:), allocatable :: index_lowest_obital_diff ! real ( dp ), dimension (:,:), allocatable :: c ! integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: unit_trial_vecs = 0 , unit_rho = 0 , ioerror = 0 ! !     Allocate array for the indices of the lowest orbital differences ! call wf % mem % alloc_int ( index_lowest_obital_diff , wf % excited_state_specifications % n_singlet_states , 1 ) index_lowest_obital_diff = zero ! !     Find indecies of lowest orbital differences ! call wf % find_start_trial_indices ( index_lowest_obital_diff ) ! !     Generate start trial vectors c and write to file ! call wf % mem % alloc ( c , wf % n_parameters , 1 ) ! !     Prepare for writing trial vectors to file ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! do i = 1 , ( wf % excited_state_specifications % n_singlet_states ) c = zero c ( index_lowest_obital_diff ( i , 1 ), 1 ) = one write ( unit_trial_vecs , rec = i , iostat = ioerror ) ( c ( j , 1 ), j = 1 , wf % n_parameters ) enddo ! !     Close file ! close ( unit_trial_vecs ) ! !     Deallocate c ! call wf % mem % dealloc ( c , wf % n_parameters , 1 ) ! !     Deallocate index_lowest_obital_diff ! call wf % mem % dealloc_int ( index_lowest_obital_diff , wf % excited_state_specifications % n_singlet_states , 1 ) ! end subroutine initialize_trial_vectors_valence_ccs ! ! module subroutine trial_vectors_from_stored_solutions_ccs ( wf ) !! !!    Trial vectors from old solutions, !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Restart: Use old solutions as trial vectors !!    Trial Vectors from Stored Solutions (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Reads the solutions from file and uses them as the first trial !!    vectors in the iterative loop. !! implicit none ! class ( ccs ) :: wf ! logical :: solution_exists = . false . logical :: more_trials = . true . ! integer ( i15 ) :: ioerror = 0 , unit_solution = 0 , unit_trial_vecs = 0 integer ( i15 ) :: number_of_solutions = 0 ! integer ( i15 ) :: i = 0 , j = 0 ! real ( dp ), dimension (:,:), allocatable :: c_i , c_j ! real ( dp ) :: ddot , dot_prod = zero , norm = zero ! !     Open solution vector file - if it does not exist return ! inquire ( file = wf % excited_state_specifications % solution_file , exist = solution_exists ) ! !     If no solution vector file, return and use orbital differences. ! if (. not . solution_exists ) return ! !     Open files ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'readwrite' , status = 'old' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! call generate_unit_identifier ( unit_solution ) ! open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file ,& action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! !     Allocate c_i ! call wf % mem % alloc ( c_i , wf % n_parameters , 1 ) c_i = zero ! i = 1 ! do while (( i . le . wf % excited_state_specifications % n_singlet_states ) . and . more_trials ) ! !        Read old solutions and count them ! read ( unit_solution , rec = i , iostat = ioerror ) c_i if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error reading solution vecs' ! if ( ioerror . eq . 0 ) then ! write ( unit_trial_vecs , rec = i ) c_i ! else ! more_trials = . false . ! endif ! i = i + 1 ! enddo ! !     Deallocate c_i ! call wf % mem % dealloc ( c_i , wf % n_parameters , 1 ) ! !     Close solution file ! close ( unit_solution ) ! !     Allocate c_i and c_j ! call wf % mem % alloc ( c_i , wf % n_parameters , 1 ) call wf % mem % alloc ( c_j , wf % n_parameters , 1 ) c_i = zero c_j = zero ! !     Reorthonormalize trial vectors ! do i = 1 , wf % excited_state_specifications % n_singlet_states ! read ( unit_trial_vecs , rec = i , iostat = ioerror ) c_i ! do j = 1 , i - 1 ! read ( unit_trial_vecs , rec = j , iostat = ioerror ) c_j dot_prod = ddot ( wf % n_parameters , c_j , 1 , c_i , 1 ) call daxpy ( wf % n_parameters , - dot_prod , c_j , 1 , c_i , 1 ) ! norm = sqrt ( ddot ( wf % n_parameters , c_i , 1 , c_i , 1 )) call dscal ( wf % n_parameters , one / norm , c_i , 1 ) ! enddo write ( unit_trial_vecs , rec = i ) c_i enddo ! call wf % mem % dealloc ( c_i , wf % n_parameters , 1 ) call wf % mem % dealloc ( c_j , wf % n_parameters , 1 ) ! !     Close trial vector file ! close ( unit_trial_vecs ) ! end subroutine trial_vectors_from_stored_solutions_ccs ! ! module subroutine find_start_trial_indices_ccs ( wf , index_list ) !! !!    Find Start Trial Indices (CCS) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf integer ( i15 ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ), intent ( inout ) :: index_list ! real ( dp ), dimension (:,:), allocatable :: orbital_diff real ( dp ), dimension (:,:), allocatable :: lowest_orbital_diff ! integer ( i15 ) :: a = 0 , i = 0 , j = 0 ! integer ( i15 ) :: ai = 0 ! real ( dp ) :: max integer ( i15 ) :: max_pos ! real ( dp ) :: swap = zero integer ( i15 ) :: swap_int = 0 ! !     Test if there are user specified trial vectors ! if ( wf % excited_state_specifications % user_specified_start_vector ) then index_list = wf % excited_state_specifications % start_vectors else ! !        Allocate orbital_diff ! call wf % mem % alloc ( orbital_diff , wf % n_parameters , 1 ) orbital_diff = zero ! !        Calculate orbital differences ! call wf % calculate_orbital_differences ( orbital_diff ) ! !        Finding lowest orbital differences ! call wf % mem % alloc ( lowest_orbital_diff , wf % excited_state_specifications % n_singlet_states , 1 ) ! lowest_orbital_diff = zero ! call get_n_lowest ( wf % excited_state_specifications % n_singlet_states ,& wf % n_parameters , orbital_diff , lowest_orbital_diff , index_list ) ! call wf % mem % dealloc ( orbital_diff , wf % n_parameters , 1 ) ! call wf % mem % dealloc ( lowest_orbital_diff , wf % excited_state_specifications % n_singlet_states , 1 ) ! endif ! end subroutine find_start_trial_indices_ccs ! ! module subroutine calculate_orbital_differences_ccs ( wf , orbital_diff ) !! !!    Calculate Orbital Differences (CCS) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad May 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: orbital_diff ! integer ( i15 ) :: a = 0 , i = 0 integer ( i15 ) :: ai = 0 ! do i = 1 , wf % n_o do a = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) orbital_diff ( ai , 1 ) = wf % fock_diagonal ( a + wf % n_o , 1 ) - wf % fock_diagonal ( i , 1 ) enddo enddo ! end subroutine calculate_orbital_differences_ccs ! ! module subroutine transform_trial_vectors_ccs ( wf , first_trial , last_trial ) !! !!    Transform trial vectors (CCS) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Each trial vector in first_trial to last_trial is read from file and !!    transformed before the transformed vector is written to file. !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ), intent ( in ) :: first_trial , last_trial ! Which trial_vectors we are to transform ! real ( dp ), dimension (:,:), allocatable :: c_a_i ! integer ( i15 ) :: unit_trial_vecs = 0 , unit_rho = 0 , ioerror = 0 integer ( i15 ) :: trial = 0 ! !     Allocate c_a_i ! call wf % mem % alloc ( c_a_i , wf % n_v , wf % n_o ) c_a_i = zero ! !     Open trial vector and transformed vector files ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) * ( wf % n_o ), iostat = ioerror ) ! call generate_unit_identifier ( unit_rho ) open ( unit = unit_rho , file = 'transformed_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) * ( wf % n_o ), iostat = ioerror ) ! !     For each trial vector: Read, transform and write ! do trial = first_trial , last_trial ! read ( unit_trial_vecs , rec = trial , iostat = ioerror ) c_a_i ! if ( wf % tasks % current == 'excited_state' ) then ! if ( wf % excited_state_specifications % right ) then ! call wf % jacobian_ccs_transformation ( c_a_i ) ! elseif ( wf % excited_state_specifications % left ) then ! call wf % jacobian_transpose_ccs_transformation ( c_a_i ) ! else ! write ( unit_output , * ) 'Error: Excited state task not recognized' stop ! endif ! elseif ( wf % tasks % current == 'multipliers' ) then ! call wf % jacobian_transpose_ccs_transformation ( c_a_i ) ! else ! write ( unit_output , * ) 'Error: Current task not recognized' stop ! endif ! !        -::- Projections -::- ! !        Test for core calculation ! if ( wf % tasks % core_excited_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from valence contributions ! call wf % cvs_rho_a_i_projection ( c_a_i ) ! endif ! !        Test for ionization calculation ! if ( wf % tasks % ionized_state . or . wf % tasks % core_ionized_state ) then ! !           Project out contamination from regular excitations ! call wf % ionization_rho_a_i_projection ( c_a_i ) ! endif ! !        Write transformed vector to file ! write ( unit_rho , rec = trial , iostat = ioerror ) c_a_i enddo ! close ( unit_trial_vecs ) close ( unit_rho ) ! !     Deallocate c_a_i ! call wf % mem % dealloc ( c_a_i , wf % n_v , wf % n_o ) ! end subroutine transform_trial_vectors_ccs ! ! module subroutine initialize_excited_states_ccs ( wf ) !! implicit none ! class ( ccs ) :: wf ! call wf % initialize_amplitudes ! end subroutine initialize_excited_states_ccs ! ! module subroutine precondition_residual_ccs ( wf , residual ) !! !!       Precondition residual !!       Written by Sarai D. Folkestad, Aug. 2017 !! !!       Calls precondition_residual_valence for normal excited state calculation !!       Calls precondition_residual_core for cvs calculation !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! if ( wf % tasks % excited_state ) then ! call wf % precondition_residual_valence ( residual ) ! elseif ( wf % tasks % core_excited_state ) then ! call wf % precondition_residual_core ( residual ) ! elseif ( wf % tasks % ionized_state ) then ! call wf % precondition_residual_valence_ionization ( residual ) ! elseif ( wf % tasks % core_ionized_state ) then ! call wf % precondition_residual_core_ionization ( residual ) ! endif ! end subroutine precondition_residual_ccs ! ! module subroutine precondition_residual_valence_ccs ( wf , residual ) !! !!       Precondition residual valence !!       Written by Sarai D. Folkestad, Aug. 2017 !! !!       Divide elements of residual by orbital difference !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! integer ( i15 ) :: i = 0 ! real ( dp ), dimension (:,:), allocatable :: orbital_diff ! call wf % mem % alloc ( orbital_diff , wf % n_parameters , 1 ) orbital_diff = zero ! call wf % calculate_orbital_differences ( orbital_diff ) ! do i = 1 , wf % n_parameters ! residual ( i , 1 ) = residual ( i , 1 ) / orbital_diff ( i , 1 ) ! enddo ! call wf % mem % dealloc ( orbital_diff , wf % n_parameters , 1 ) ! end subroutine precondition_residual_valence_ccs ! ! module subroutine print_excited_state_info_ccs ( wf ) !! !! !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: unit_solution = - 1 , unit_es_info = - 1 , ioerror = 0 integer ( i15 ) :: state = 0 ! real ( dp ), dimension (:,:), allocatable :: solution ! !        Read solution vectors ! call generate_unit_identifier ( unit_solution ) ! open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file , & action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening solution file' ! !        Open info file ! call generate_unit_identifier ( unit_es_info ) ! open ( unit = unit_es_info , file = 'excited_state_information' , action = 'write' , status = 'unknown' , & access = 'sequential' , form = 'formatted' , iostat = ioerror ) rewind ( unit_es_info ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening excited_state_information file' call wf % mem % alloc ( solution , wf % n_parameters , 1 ) do state = 1 , wf % excited_state_specifications % n_singlet_states ! solution = zero read ( unit_solution , rec = state ) solution ! write ( unit_es_info , '(/a33)' ) '----------------------------------' write ( unit_es_info , '(a30,i2, a1)' ) 'Components of solution vector' , state , ':' write ( unit_es_info , '(a33/)' ) '----------------------------------' call wf % print_excitation_vector ( solution , unit_es_info ) ! enddo ! call wf % mem % dealloc ( solution , wf % n_parameters , 1 ) ! close ( unit_solution ) close ( unit_es_info ) ! end subroutine print_excited_state_info_ccs ! ! module subroutine print_excitation_vector_ccs ( wf , vec , unit_id ) !! !! !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: vec ! integer ( i15 ) :: unit_id ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 ! write ( unit_id , '(2a6,a12)' ) 'a' , 'i' , 'coeff' write ( unit_id , '(t3,a)' ) '-------------------------' ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) if ( abs ( vec ( ai , 1 )) . gt . 1.0D-03 ) then write ( unit_id , '(2i6,f12.4)' ) a , i , vec ( ai , 1 ) endif ! enddo enddo ! end subroutine print_excitation_vector_ccs ! ! module subroutine analyze_single_excitation_vector_ccs ( wf , vec , n , sorted_short_vec , index_list ) !! !! !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_o * wf % n_v , 1 ) :: vec ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 ! integer ( i15 ) :: n ! Number of elements wanted ! real ( dp ), dimension ( n , 1 ) :: sorted_short_vec ! integer ( i15 ), dimension ( n , 2 ) :: index_list ! !        Variables for sorting ! real ( dp ) :: min integer ( i15 ) :: min_pos ! real ( dp ) :: swap = zero integer ( i15 ) :: swap_i = 0 , swap_a = 0 ! integer ( i15 ) :: i = 0 , j = 0 ! !        Placing the n first elements of vec into sorted_short_vec ! sorted_short_vec ( 1 , 1 ) = vec ( 1 , 1 ) index_list ( 1 , 1 ) = 1 index_list ( 1 , 2 ) = 1 ! min = abs ( sorted_short_vec ( 1 , 1 )) min_pos = 1 ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! if ( ai . le . n ) then sorted_short_vec ( ai , 1 ) = vec ( ai , 1 ) index_list ( ai , 1 ) = a index_list ( ai , 2 ) = i ! if ( abs ( sorted_short_vec ( i , 1 )) . le . min ) then ! min = abs ( sorted_short_vec ( i , 1 )) min_pos = i ! endif else if ( abs ( vec ( ai , 1 )) . ge . min ) then ! sorted_short_vec ( min_pos , 1 ) = vec ( ai , 1 ) index_list ( min_pos , 1 ) = a index_list ( min_pos , 2 ) = i min = abs ( vec ( ai , 1 )) ! endif ! do j = 1 , n if ( abs ( sorted_short_vec ( j , 1 )) . lt . min ) then ! min = abs ( sorted_short_vec ( j , 1 )) min_pos = j ! endif enddo endif enddo enddo ! !         Sorting sorted_short_vec ! do i = 1 , n do j = 1 , n - 1 if ( abs ( sorted_short_vec ( j , 1 )) . lt . abs ( sorted_short_vec ( j + 1 , 1 ))) then ! swap = sorted_short_vec ( j , 1 ) sorted_short_vec ( j , 1 ) = sorted_short_vec ( j + 1 , 1 ) sorted_short_vec ( j + 1 , 1 ) = swap ! swap_a = index_list ( j , 1 ) swap_i = index_list ( j , 2 ) ! index_list ( j , 1 ) = index_list ( j + 1 , 1 ) index_list ( j , 2 ) = index_list ( j + 1 , 2 ) index_list ( j + 1 , 1 ) = swap_a index_list ( j + 1 , 2 ) = swap_i ! endif enddo enddo ! ! end subroutine analyze_single_excitation_vector_ccs ! ! module subroutine summary_excited_state_info_ccs ( wf , energies ) !! !! !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! integer ( i15 ) :: unit_solution = - 1 , ioerror = 0 integer ( i15 ) :: state = 0 , i = 0 real ( dp ), dimension (:,:), allocatable :: solution , sorted_max_vec integer ( i15 ), dimension (:,:), allocatable :: index_list real ( dp ) :: ddot , norm ! !        Read solution vectors ! call generate_unit_identifier ( unit_solution ) ! open ( unit = unit_solution , file = wf % excited_state_specifications % solution_file , & action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) 'Error while opening solution file' call wf % mem % alloc ( solution , wf % n_parameters , 1 ) call wf % mem % alloc_int ( index_list , 20 , 2 ) call wf % mem % alloc ( sorted_max_vec , 20 , 1 ) ! do state = 1 , wf % excited_state_specifications % n_singlet_states ! write ( unit_output , '(/t3,a30,i3,a1/)' ) 'Analysis of excitation vector ' , state , ':' write ( unit_output , '(t6, a, f14.8)' ) 'Excitation energy [a.u.]:   ' , energies ( state , 1 ) write ( unit_output , '(t6, a, f14.8)' ) 'Excited state energy [a.u.]:' , wf % energy + energies ( state , 1 ) ! solution = zero read ( unit_solution , rec = state ) solution ! norm = sqrt ( ddot ( wf % n_t1am , solution , 1 , solution , 1 )) write ( unit_output , '(/t6,a,f6.4)' ) 'Single excitation contribution to excitation vector: ' , norm ! write ( unit_output , '(/t6,a)' ) 'Largest contributions to excitation vector:' ! write ( unit_output , '(t6,a32)' ) '--------------------------------' write ( unit_output , '(t6,a3, 8x, a3, 8x, a10)' ) 'a' , 'i' , 'amplitude' write ( unit_output , '(t6,a32)' ) '--------------------------------' ! !           Get 20 highest amplitudes ! call wf % analyze_single_excitation_vector ( solution , 20 , sorted_max_vec , index_list ) do i = 1 , 20 if ( abs ( sorted_max_vec ( i , 1 )) . lt . 1.0D-03 ) then exit else write ( unit_output , '(t6,i3, 8x, i3, 10x, f8.5)' ) index_list ( i , 1 ),& index_list ( i , 2 ),& sorted_max_vec ( i , 1 ) endif enddo write ( unit_output , '(t6,a32/)' ) '--------------------------------' ! enddo ! call wf % mem % dealloc ( solution , wf % n_parameters , 1 ) call wf % mem % dealloc_int ( index_list , 20 , 2 ) call wf % mem % dealloc ( sorted_max_vec , 20 , 1 ) ! close ( unit_solution ) ! end subroutine summary_excited_state_info_ccs ! end submodule excited_state","tags":"","loc":"sourcefile/excited_state_submodule.f90~5.html","title":"excited_state_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~fock_submodule.f90~~EfferentGraph sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilefock_submodulef90EfferentGraph = svgPanZoom('#sourcefilefock_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules fock Source Code fock_submodule.F90 Source Code submodule ( ccs_class ) fock ! !! !!    Fock submodule !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Contains the following family of procedures of the CCS class: !! !!    initialize_fock_matrix_ccs(wf):     Allocates and sets Fock matrix to 0. !!    construct_fock_ccs(wf):             Constructs T1_transformed mo Fock matrix. !!    one_electron_t1_ccs(wf, h1 ,h1_T1): T1-transformation of one-electron mo integrals. !! ! implicit none ! ! contains ! ! module subroutine initialize_fock_matrix_ccs ( wf ) !! !!     Initialize Fock Matrix !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Allocates and sets Fock matrix blocks (ij, ia, ai, ab) to zero !!     before calling the Fock matrix constructor. !! implicit none ! class ( ccs ) :: wf ! if (. not . allocated ( wf % fock_ij )) call wf % mem % alloc ( wf % fock_ij , wf % n_o , wf % n_o ) if (. not . allocated ( wf % fock_ia )) call wf % mem % alloc ( wf % fock_ia , wf % n_o , wf % n_v ) if (. not . allocated ( wf % fock_ai )) call wf % mem % alloc ( wf % fock_ai , wf % n_v , wf % n_o ) if (. not . allocated ( wf % fock_ab )) call wf % mem % alloc ( wf % fock_ab , wf % n_v , wf % n_v ) ! wf % fock_ij = zero wf % fock_ia = zero wf % fock_ai = zero wf % fock_ab = zero ! call wf % construct_fock ! end subroutine initialize_fock_matrix_ccs ! ! module subroutine construct_fock_ccs ( wf ) !! !!    Construct Fock !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Constructs the T1-transformed Fock matrix blocks (occ/vir-occ/vir), !!    and saves the result in the class variables fock_pq. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:), allocatable :: fock_ao real ( dp ), dimension (:,:), allocatable :: fock_matrix ! real ( dp ), dimension (:,:), allocatable :: h1ao ! AO basis matrix h_αβ real ( dp ), dimension (:,:), allocatable :: h1mo ! MO basis matrix h_pq real ( dp ), dimension (:,:), allocatable :: X ! An intermediate ! integer ( i15 ) :: unit_identifier_ao_integrals = - 1 ! Unit identifier for file mlcc_aoint ! !     Indices ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 , a = 0 , b = 0 integer ( i15 ) :: kj = 0 , ii = 0 , ij = 0 , kk = 0 , ik = 0 , jj = 0 , ji = 0 , ai = 0 , ib = 0 , bi = 0 , ia = 0 integer ( i15 ) :: aj = 0 , ja = 0 , ab = 0 ! !     Useful orbital information ! integer ( i15 ) :: n_ao_sq_packed = 0 ! Dimension of packed (n_ao x n_ao) matrix ! !     Two electron integrals ! real ( dp ), dimension (:,:), allocatable :: g_ij_kl real ( dp ), dimension (:,:), allocatable :: g_ab_ij real ( dp ), dimension (:,:), allocatable :: g_ai_jb real ( dp ), dimension (:,:), allocatable :: g_ia_jk real ( dp ), dimension (:,:), allocatable :: g_ai_jk ! !     Cholesky vectors ! real ( dp ), dimension (:,:), allocatable :: L_ij_J real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: L_ab_J ! !     Batch settings ! integer ( i15 ) :: available = 0 , required = 0 , max_batch_length = 0 integer ( i15 ) :: batch_end = 0 , batch_length = 0 , g_off = 0 , n_batches = 0 integer ( i15 ) :: b_batch = 0 , batch_start = 0 ! !     Allocate one-electron MO integrals ! call wf % mem % alloc ( h1mo , wf % n_mo , wf % n_mo ) h1mo = zero ! call wf % mem % alloc ( fock_matrix , wf % n_mo , wf % n_mo ) fock_matrix = zero ! ! !     :: One-electron contribution :: ! ! !     Allocate for one-electron ao integrals ! n_ao_sq_packed = packed_size ( wf % n_ao ) ! call wf % mem % alloc ( h1ao , n_ao_sq_packed , 1 ) h1ao = zero ! !     Open mlcc_aoint file ! call generate_unit_identifier ( unit_identifier_ao_integrals ) open ( unit = unit_identifier_ao_integrals , file = 'MLCC_AOINT' , status = 'old' , form = 'formatted' ) rewind ( unit_identifier_ao_integrals ) ! !     Read in one-electron AO integrals ! read ( unit_identifier_ao_integrals , * ) ( h1ao ( i , 1 ), i = 1 , n_ao_sq_packed ) ! !     Close mlcc_aoint ! close ( unit_identifier_ao_integrals ) ! !     Allocate the AO Fock matrix and add the one-electron contributions ! call wf % mem % alloc ( fock_ao , wf % n_ao , wf % n_ao ) fock_ao = zero ! call squareup ( h1ao , fock_ao , wf % n_ao ) ! !     Deallocation of one-electron AO integrals ! call wf % mem % dealloc ( h1ao , n_ao_sq_packed , 1 ) ! !     Transform to one-electron part to MO basis and save it !     in the fock_matrix ! call wf % mem % alloc ( X , wf % n_ao , wf % n_mo ) ! call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_mo , & wf % n_ao , & one , & fock_ao , & wf % n_ao , & wf % mo_coef , & wf % n_ao , & zero , & X , & wf % n_ao ) ! call dgemm ( 'T' , 'N' , & wf % n_mo , & wf % n_mo , & wf % n_ao , & one , & wf % mo_coef , & wf % n_ao , & X , & wf % n_ao , & zero , & h1mo , & wf % n_mo ) ! !     T1-transformation of one-electron integrals in MO basis ! call wf % one_electron_t1 ( h1mo , fock_matrix ) call wf % mem % dealloc ( h1mo , wf % n_mo , wf % n_mo ) ! !     Deallocate intermediate X and fock_ao ! call wf % mem % dealloc ( X , wf % n_ao , wf % n_mo ) call wf % mem % dealloc ( fock_ao , wf % n_ao , wf % n_ao ) ! ! !     :: Two-electron occupied-occupied block: F_ij = h_ij + sum_k (2*g_ijkk - g_ikkj) :: ! ! !     Allocation for L_ij_J ! call wf % mem % alloc ( L_ij_J , ( wf % n_o ) ** 2 , wf % n_J ) call wf % mem % alloc ( g_ij_kl , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! L_ij_J = zero g_ij_kl = zero ! !     Read Cholesky IJ vector ! call wf % get_cholesky_ij ( L_ij_J ) ! !     Calculate g_ij_kl ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & wf % n_J , & one , & L_ij_J , & ( wf % n_o ) ** 2 , & L_ij_J , & ( wf % n_o ) ** 2 , & zero , & g_ij_kl , & ( wf % n_o ) ** 2 ) ! !     Add two-electron contributions to occupied-occupied block ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do k = 1 , wf % n_o ! kk = index_two ( k , k , wf % n_o ) ik = index_two ( i , k , wf % n_o ) kj = index_two ( k , j , wf % n_o ) ! fock_matrix ( i , j ) = fock_matrix ( i , j ) + & two * g_ij_kl ( ij , kk ) - & g_ij_kl ( ik , kj ) ! enddo ! enddo ! enddo ! !     Deallocate g_ij_kl ! call wf % mem % dealloc ( g_ij_kl , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! ! !     :: Two-electron occupied-virtual blocks :: ! ! !     Allocation for g_ia_jk ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % mem % alloc ( g_ia_jk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) L_ia_J = zero g_ia_jk = zero ! !     Read Cholesky vector L_ia_J ! call wf % get_cholesky_ia ( L_ia_J ) ! !     Calculate g_ia_jk ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) ** 2 , & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ij_J , & ( wf % n_o ) ** 2 , & zero , & g_ia_jk , & ( wf % n_o ) * ( wf % n_v )) ! !     Dealllocate L_ia_J ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Allocation for g_ai_jk ! call wf % mem % alloc ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % mem % alloc ( g_ai_jk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) L_ai_J = zero g_ai_jk = zero ! !     Get Cholesky AI vector ! call wf % get_cholesky_ai ( L_ai_J ) ! !     Calculate g_ai_jk ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) ** 2 , & wf % n_J , & one , & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & L_ij_J , & ( wf % n_o ) ** 2 , & zero , & g_ai_jk , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate L_ai_J ! call wf % mem % dealloc ( L_ai_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) ! !     Add terms to Fock matrix ! do i = 1 , wf % n_o do a = 1 , wf % n_v do j = 1 , wf % n_o ! !              Needed indices ! ia = index_two ( i , a , wf % n_o ) ja = index_two ( j , a , wf % n_o ) ! ai = index_two ( a , i , wf % n_v ) aj = index_two ( a , j , wf % n_v ) ! jj = index_two ( j , j , wf % n_o ) ji = index_two ( j , i , wf % n_o ) ij = index_two ( i , j , wf % n_o ) ! !              Set the blocks of the Fock matrix ! fock_matrix ( i , a + wf % n_o ) = fock_matrix ( i , a + wf % n_o ) + & two * g_ia_jk ( ia , jj ) - g_ia_jk ( ja , ij ) ! g_ia_jk(ja,ij) = g_jaij = g_ijja ! fock_matrix ( a + wf % n_o , i ) = fock_matrix ( a + wf % n_o , i ) + & two * g_ai_jk ( ai , jj ) - g_ai_jk ( aj , ji ) ! enddo enddo enddo ! call wf % mem % dealloc ( g_ia_jk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( g_ai_jk , ( wf % n_v ) * ( wf % n_o ), ( wf % n_o ) ** 2 ) ! ! !     :: Two-electron virtual-virtual block F_ab = h_ab + sum_k (2*g_abkk - g_akkb) :: ! ! call wf % mem % alloc ( g_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) g_ab_ij = zero ! !     Batch over index b ! available = get_available () ! required = 2 * ( wf % n_v ) * ( wf % n_v ) * ( wf % n_J ) * 4 + & 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ) * 4 ! call num_batch ( required , available , max_batch_length , n_batches , wf % n_v ) ! batch_start = 1 batch_end = 0 batch_length = 0 ! !     Loop over the batches ! do b_batch = 1 , n_batches ! !        Get batch limits and length of batch ! call batch_limits ( batch_start , batch_end , b_batch , max_batch_length , wf % n_v ) batch_length = batch_end - batch_start + 1 ! !        Allocate L_ab_J ! call wf % mem % alloc ( L_ab_J , ( wf % n_v ) * batch_length , wf % n_J ) L_ab_J = zero ! !        Read Cholesky vectors ! call wf % get_cholesky_ab ( L_ab_J , 1 , wf % n_v , batch_start , batch_end ) ! !        Calculate g_ab_ij = sum_J L_ab_J*L_ij_J ! g_off = index_two ( 1 , batch_start , wf % n_v ) ! call dgemm ( 'N' , 'T' , & ( wf % n_v ) * batch_length , & ( wf % n_o ) ** 2 , & wf % n_J , & one , & L_ab_J , & ( wf % n_v ) * batch_length , & L_ij_J , & ( wf % n_o ) ** 2 , & one , & g_ab_ij ( g_off , 1 ), & ( wf % n_v ) ** 2 ) ! !        Deallocate L_ab_J ! call wf % mem % dealloc ( L_ab_J , batch_length * ( wf % n_v ), wf % n_J ) ! enddo ! batching done ! !     Deallocate L_ij_J ! call wf % mem % dealloc ( L_ij_J , ( wf % n_o ) ** 2 , wf % n_J ) ! !     Allocate for g_ai_jb ! call wf % mem % alloc ( g_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ai_jb = 0 ! call wf % mem % alloc ( L_ai_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_ai_J = 0 L_ia_J = 0 ! !     Read Cholesky vectors L_ia_J and L_ai_J ! call wf % get_cholesky_ia ( L_ia_J ) call wf % get_cholesky_ai ( L_ai_J ) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ai_jb , & ( wf % n_o ) * ( wf % n_v )) ! !     Calculate two-electron terms for virtual-virtual blocks ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ai_jb , & ( wf % n_o ) * ( wf % n_v )) ! !    Deallocate L_ia_J ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % mem % dealloc ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! do a = 1 , wf % n_v do b = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) ! do i = 1 , wf % n_o ! ii = index_two ( i , i , wf % n_o ) ai = index_two ( a , i , wf % n_v ) bi = index_two ( b , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ib = index_two ( i , b , wf % n_o ) ! fock_matrix ( wf % n_o + a , wf % n_o + b ) = fock_matrix ( wf % n_o + a , wf % n_o + b ) & + two * g_ab_ij ( ab , ii ) & - g_ai_jb ( ai , ib ) ! enddo ! enddo enddo ! call wf % mem % dealloc ( g_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) call wf % mem % dealloc ( g_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Save the blocks of the Fock matrix in memory (ij,ia,ai,ab) ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! wf % fock_ij ( i , j ) = fock_matrix ( i , j ) ! enddo enddo ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! wf % fock_ia ( i , a ) = fock_matrix ( i , wf % n_o + a ) wf % fock_ai ( a , i ) = fock_matrix ( wf % n_o + a , i ) ! enddo enddo ! do a = 1 , wf % n_v do b = 1 , wf % n_v ! wf % fock_ab ( a , b ) = fock_matrix ( wf % n_o + a , wf % n_o + b ) ! enddo enddo ! call wf % mem % dealloc ( fock_matrix , wf % n_mo , wf % n_mo ) ! end subroutine construct_fock_ccs ! ! module subroutine one_electron_t1_ccs ( wf , h1 , h1_T1 ) !! !!    One-electron T1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    T1-transforms the one-electron MO integrals h_pq !! !!       h_p_q_T1 = sum_st x_p_s * y_q_t * h_s_t, !! !!    where !! !!       x = I - t1, !!       y = I - t1&#94;T. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_mo , wf % n_mo ) :: h1 real ( dp ), dimension ( wf % n_mo , wf % n_mo ) :: h1_T1 ! real ( dp ), dimension (:,:), allocatable :: x real ( dp ), dimension (:,:), allocatable :: y real ( dp ), dimension (:,:), allocatable :: t1 ! real ( dp ), dimension (:,:), allocatable :: Z ! Intermediate for matrix multiplication ! integer ( i15 ) :: p = 0 , q = 0 , a = 0 , i = 0 ! !     Allocate the arrays t1, x, and y ! call wf % mem % alloc ( t1 , wf % n_mo , wf % n_mo ) t1 = zero ! call wf % mem % alloc ( y , wf % n_mo , wf % n_mo ) call wf % mem % alloc ( x , wf % n_mo , wf % n_mo ) ! y = zero x = zero ! !     Set t1_p_q = t1am_p_q for p virtual and q occupied, 0 otherwise ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! t1 ( wf % n_o + a , i ) = wf % t1am ( a , i ) ! enddo enddo ! !     Form the x and y arrays ! do p = 1 , wf % n_mo do q = 1 , wf % n_mo ! if ( p . eq . q ) then ! x ( p , q ) = 1 y ( p , q ) = 1 ! else ! x ( p , q ) = x ( p , q ) - t1 ( p , q ) y ( p , q ) = y ( p , q ) + t1 ( q , p ) ! endif ! enddo enddo ! !     Deallocate t1 (only x and y are needed below) ! call wf % mem % dealloc ( t1 , wf % n_mo , wf % n_mo ) ! !     Allocate Z intermediate ! call wf % mem % alloc ( Z , wf % n_mo , wf % n_mo ) ! !     Calculate h1_T1 = x*h1*y&#94;T = x*Z ! call dgemm ( 'N' , 'T' , & wf % n_mo , & wf % n_mo , & wf % n_mo , & one , & h1 , & wf % n_mo , & y , & wf % n_mo , & zero , & Z , & wf % n_mo ) ! call dgemm ( 'N' , 'N' , & wf % n_mo , & wf % n_mo , & wf % n_mo , & one , & x , & wf % n_mo , & Z , & wf % n_mo , & zero , & h1_T1 , & wf % n_mo ) ! !     Deallocate x and y, and the intermediate Z ! call wf % mem % dealloc ( Z , wf % n_mo , wf % n_mo ) call wf % mem % dealloc ( y , wf % n_mo , wf % n_mo ) call wf % mem % dealloc ( x , wf % n_mo , wf % n_mo ) ! end subroutine one_electron_t1_ccs ! ! end submodule","tags":"","loc":"sourcefile/fock_submodule.f90.html","title":"fock_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~response_submodule.f90~~EfferentGraph sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileresponse_submodulef90EfferentGraph = svgPanZoom('#sourcefileresponse_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules response Source Code response_submodule.F90 Source Code submodule ( ccs_class ) response ! !! !!    Response submodule (CCS) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, June 2017 !! !!    Contains the following family of procedures of the CCS class: !! !!    response_driver:                       directs the solution of molecular properties. !!    response_solver:                       solves for a particular molecular property. !!    initialize_response:                   finds a suitable start trial vector & requests the construction !!                                           of the so-called response gradient vector (F). !!    solve_reduced_response_equation:       solves the response equation in the reduced space !!                                           of trial vectors (in the given iteration). !!    construct_gradient_vector:             constructs the gradient vector (F) & saves it to disk. !!    construct_next_response_trial_vectors: finds the next trial vectors from the residual resulting !!                                           from the reduced space solution. !!    construct_reduced_matrix:              constructs the reduced matrix (the reduced Jacobian, or Jacobian&#94;T). !!    construct_reduced_gradient:            constructs the reduced gradient vector. !! !!    Note: in order to implement new properties, changes needs to be made in the \"transform_trial_vectors\" !!    and \"construct_gradient_vector\" routines. The behavior of these routines are governed by the value of !!    the \"response_task\" string, which must be set in the response driver. !! ! implicit none ! !  Some variables available to all routines of the module ! integer ( i15 ) :: iteration = 1 integer ( i15 ) :: max_iterations = 75 ! !  Variables to handle convergence criterea ! logical :: converged = . false . ! True if the residual has converged ! contains ! ! module subroutine response_driver_ccs ( wf ) !! !!    Response driver (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Directs the solution of molculear properties for CCS. The !!    routine is inherited is to be inherited unaltered in the CC hierarchy. !! implicit none ! class ( ccs ) :: wf ! !     Let the user know the response driver is running ! write ( unit_output , '(/t3,a)' ) ':: Response solver (Davidson)' write ( unit_output , '(t3,a/)' ) ':: E. F. Kjønstad, S. D. Folkestad, June 2017' flush ( unit_output ) ! call wf % response_preparations !     Run the general solver routine (file names are given !     by the task, i.e., the file 'right_eigenvectors' contains !     the right eigenvectors) ! call wf % response_solver ! end subroutine response_driver_ccs ! ! module subroutine response_preparations_ccs ( wf ) !! !! !! implicit none ! class ( ccs ) :: wf ! if ( wf % tasks % multipliers ) then ! wf % tasks % current = 'multipliers' ! wf % excited_state_specifications % right = . false . wf % excited_state_specifications % left = . true . ! if ( wf % tasks % core_excited_state ) then ! wf % excited_state_specifications % solution_file = 'left_core' ! else ! wf % excited_state_specifications % solution_file = 'left_valence' ! endif ! endif ! end subroutine response_preparations_ccs ! ! module subroutine response_solver_ccs ( wf ) !! !!    Response Solver (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Solves the response equation !! !!       A X = F, !! !!    where F is the gradient vector and A is either the Jacobian (A) or !!    the transposed Jacobian (A&#94;T) matrix. !! !!    The equation is solved by constructing a set of trial vectors, c_i, and !!    solving the projected/reduced equations associated with the reduced A and !!    reduced F vectors: !! !!       A_ij = c_i&#94;T A c_j,    F_i = c_i&#94;T F !! !!    The equation is precondition with the orbital energy differences, and the space !!    of trial vectors is expanded according to a Davidson algorithm. !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim = 0 ! Current dimension of the reduced space (i.e., the number of trial vectors) integer ( i15 ) :: n_new_trials = 0 ! Number of new trial vectors for the current iteration ! !     Solution for the reduced eigenvalue problem ! real ( dp ), dimension (:,:), allocatable :: solution_vector_reduced ! real ( dp ) :: start_property_solver = 0 , end_property_solver = 0 ! call cpu_time ( start_property_solver ) ! !     Initialize variables ! reduced_dim = 1 n_new_trials = 1 ! !     Initialization: - construct the gradient vector and save to file !                     - use the gradient vector and the orbital differences !                       to get the first trial vector ! call wf % initialize_response ! write ( unit_output , '(/t3,a)' ) 'Iteration      Residual norm' write ( unit_output , '(t3,a)' ) '----------------------------' flush ( unit_output ) ! do while (. not . converged . and . iteration . le . max_iterations ) ! !        Allocate solution vector ! call wf % mem % alloc ( solution_vector_reduced , reduced_dim , 1 ) solution_vector_reduced = zero ! !        Transform new trial vector (rho_i = A c_i for new trials i) ! call wf % transform_trial_vectors ( reduced_dim - n_new_trials + 1 , reduced_dim ) ! !        Solve the reduced linear equation (A X = F) ! call wf % solve_reduced_response_equation ( solution_vector_reduced , reduced_dim , n_new_trials ) ! !        Construct next trial vectors (& test for convergence) ! call wf % construct_next_response_trial_vectors ( solution_vector_reduced , reduced_dim , n_new_trials ) ! call wf % mem % dealloc ( solution_vector_reduced , reduced_dim , 1 ) ! if ( converged ) then ! write ( unit_output , '(/t3,a,i2,a)' ) 'Converged in ' , iteration , ' iterations!' ! else ! iteration = iteration + 1 ! endif ! enddo call cpu_time ( end_property_solver ) write ( unit_output , '(//t3,a,a,a,a,a/)' ) 'Summary of ' , trim ( wf % name ), ' ' , trim ( wf % tasks % current ), ' calculation:' write ( unit_output , '(t6,a25,f14.8/)' ) 'Total CPU time (seconds):    ' , end_property_solver - start_property_solver flush ( unit_output ) ! end subroutine response_solver_ccs ! ! module subroutine initialize_response_ccs ( wf ) !! !!    Initialize response (CCS) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Performs two tasks: !! !!    1. Initializes start trial vector for response solver. We use the !!    the diagonal approximation D of A (and A&#94;T) to form the trial vector: !! !!      A X = F => X ~ D&#94;-1 F !! !!    The diagonal approximation of A consists of the orbital energy differences. !! !!    2. Constructs the vector F and saves it to file. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:), allocatable :: orbital_diff real ( dp ), dimension (:,:), allocatable :: gradient_vector ! F ! integer :: I = 0 ! integer ( i15 ) :: ioerror = 0 integer ( i15 ) :: unit_resp_trial_vecs = 0 integer ( i15 ) :: unit_grad_vec = 0 ! !     Open response trial vectors file ! call generate_unit_identifier ( unit_resp_trial_vecs ) open ( unit = unit_resp_trial_vecs , file = 'trial_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! !     Construct the gradient vector ! call wf % construct_gradient_vector ! !     Read gradient vector ! call generate_unit_identifier ( unit_grad_vec ) open ( unit = unit_grad_vec , file = 'gradient_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! call wf % mem % alloc ( gradient_vector , wf % n_parameters , 1 ) gradient_vector = zero ! read ( unit_grad_vec , rec = 1 , iostat = ioerror ) gradient_vector if ( ioerror . ne . 0 ) write ( unit_output , * ) 'WARNING!!' ! close ( unit_grad_vec ) ! !     Calculate the orbital differences ! call wf % mem % alloc ( orbital_diff , wf % n_parameters , 1 ) orbital_diff = zero ! call wf % calculate_orbital_differences ( orbital_diff ) ! !     Transform by D&#94;-1 - i.e., scale by orbital differences (F <- D&#94;-1 F) ! do I = 1 , wf % n_parameters ! gradient_vector ( I , 1 ) = gradient_vector ( I , 1 ) / orbital_diff ( I , 1 ) ! enddo ! !     Write the trial vector to file ! write ( unit_resp_trial_vecs , rec = 1 , iostat = ioerror ) & ( gradient_vector ( I , 1 ), I = 1 , wf % n_parameters ) ! call wf % mem % dealloc ( gradient_vector , wf % n_parameters , 1 ) call wf % mem % dealloc ( orbital_diff , wf % n_parameters , 1 ) ! !     Close response trial vectors file ! close ( unit_resp_trial_vecs ) ! end subroutine initialize_response_ccs ! ! module subroutine solve_reduced_response_equation_ccs ( wf , solution_vector_reduced , reduced_dim , n_new_trials ) !! !!    Solve Reduced Response Equation !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Constructs the reduced A matrix and the reduced F vector, !!    and solves the (reduced space) linear equation A X = F for X. !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension ( reduced_dim , 1 ) :: solution_vector_reduced ! real ( dp ), dimension (:,:), allocatable :: A_reduced ! Reduced Jacobi (or Jacobi&#94;T) real ( dp ), dimension (:,:), allocatable :: F_reduced ! Reduced gradient vector ! integer ( i15 ), dimension (:,:), allocatable :: ipiv ! Pivot integers (see dgesv routine) ! integer :: info = - 1 ! Error integer for dgesv routine (LU factorization) ! !     Allocate the reduced Jacobi matrix & the reduced gradient vector ! call wf % mem % alloc ( A_reduced , reduced_dim , reduced_dim ) call wf % mem % alloc ( F_reduced , reduced_dim , 1 ) ! A_reduced = zero F_reduced = zero ! !     Construct the reduced Jacobi and reduced gradient vectors ! call wf % construct_reduced_matrix ( A_reduced , reduced_dim , n_new_trials ) call wf % construct_reduced_gradient ( F_reduced , reduced_dim , n_new_trials ) ! !     Solve the eigenvalue problem ! !     Note: on exit, the solution is in the F_reduced vector, !     provided info = 0 (see LAPACK documentation for more) ! call wf % mem % alloc_int ( ipiv , reduced_dim , 1 ) ipiv = 0 ! info = 0 ! call dgesv ( reduced_dim , & 1 , & A_reduced , & reduced_dim , & ipiv , & F_reduced , & reduced_dim , & info ) ! if ( info . ne . 0 ) then ! write ( unit_output , * ) 'Error: could not solve reduced response equation.' , info stop ! endif ! !     Save the solution in the solution vector ! solution_vector_reduced = F_reduced ! !     Deallocations the reduced Jacobi matrix & the reduced gradient vector ! call wf % mem % dealloc ( A_reduced , reduced_dim , reduced_dim ) call wf % mem % dealloc ( F_reduced , reduced_dim , 1 ) ! end subroutine solve_reduced_response_equation_ccs ! ! module subroutine construct_gradient_vector_ccs ( wf ) !! !!    Construct Gradient Vector (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Constructs the gradient vector, given the current value of \"response_task\", !!    and stores the vector on disk for use by the solver. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:), allocatable :: gradient_vector ! F ! integer ( i15 ) :: unit_grad_vec = 0 integer ( i15 ) :: ioerror = 0 ! !     Allocate and construct the gradient vector ! call wf % mem % alloc ( gradient_vector , wf % n_parameters , 1 ) gradient_vector = zero ! if ( wf % tasks % multipliers ) then ! write ( unit_output , '(/t3,a)' ) 'Requested the solution of the multiplier equation (t-bar).' call wf % construct_eta ( gradient_vector ) ! else ! write ( unit_output , * ) 'Error: Requested gradient vector not recognized.' stop ! endif ! !     Open gradient vector file ! call generate_unit_identifier ( unit_grad_vec ) open ( unit = unit_grad_vec , file = 'gradient_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! !     Write gradient vector to file and deallocate ! write ( unit_grad_vec , rec = 1 , iostat = ioerror ) gradient_vector call wf % mem % dealloc ( gradient_vector , wf % n_parameters , 1 ) ! !     Close file ! close ( unit_grad_vec ) ! end subroutine construct_gradient_vector_ccs ! ! module subroutine construct_reduced_matrix_ccs ( wf , A_reduced , reduced_dim , n_new_trials ) !! !!    Construct Reduced Matrix (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Constructs A_ij = c_i&#94;T A c_j by reading from file and constructing the missing elements. !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension ( reduced_dim , reduced_dim ) :: A_reduced ! real ( dp ), dimension (:,:), allocatable :: c_i ! Trial vector i real ( dp ), dimension (:,:), allocatable :: rho_j ! Transformed trial vector j ! integer ( i15 ) :: i = 0 , j = 0 ! real ( dp ) :: ddot ! integer ( i15 ) :: unit_reduced_jacobi = 0 integer ( i15 ) :: unit_trial_vecs = 0 integer ( i15 ) :: unit_rho = 0 ! integer ( i15 ) :: ioerror = 0 ! !     Open files with trial vectors, transformed and nontransformed ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'read' , status = 'old' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! call generate_unit_identifier ( unit_rho ) open ( unit = unit_rho , file = 'transformed_vec' , action = 'read' , status = 'old' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! !     If first iteration, create reduced matrix file. Otherwise, !     read the part of the reduced matrix already stored on file. ! if ( iteration . eq . 1 ) then ! call generate_unit_identifier ( unit_reduced_jacobi ) open ( unit = unit_reduced_jacobi , file = 'reduced_jacobi' , action = 'readwrite' , status = 'unknown' ,& form = 'unformatted' , iostat = ioerror ) ! else ! call generate_unit_identifier ( unit_reduced_jacobi ) open ( unit = unit_reduced_jacobi , file = 'reduced_jacobi' , action = 'readwrite' , status = 'old' ,& form = 'unformatted' , iostat = ioerror ) ! rewind ( unit_reduced_jacobi ) read ( unit_reduced_jacobi ) & (( A_reduced ( i , j ), i = 1 , reduced_dim - n_new_trials ), j = 1 , reduced_dim - n_new_trials ) ! endif ! !     Allocate trial (c) and transformed trial (rho) vectors ! call wf % mem % alloc ( c_i , wf % n_parameters , 1 ) call wf % mem % alloc ( rho_j , wf % n_parameters , 1 ) ! c_i = zero rho_j = zero ! !     If first iteration, form the first block of the reduced matrix. Otherwise, !     form the three new square blocks. ! if ( iteration . eq . 1 ) then ! do i = 1 , reduced_dim ! read ( unit_trial_vecs , rec = i , iostat = ioerror ) c_i ! do j = 1 , reduced_dim ! read ( unit_rho , rec = j , iostat = ioerror ) rho_j A_reduced ( i , j ) = ddot ( wf % n_parameters , c_i , 1 , rho_j , 1 ) ! enddo ! enddo ! else ! iteration ≠ 1 ! do i = 1 , reduced_dim ! read ( unit_trial_vecs , rec = i , iostat = ioerror ) c_i ! do j = reduced_dim - n_new_trials + 1 , reduced_dim ! read ( unit_rho , rec = j , iostat = ioerror ) rho_j A_reduced ( i , j ) = ddot ( wf % n_parameters , c_i , 1 , rho_j , 1 ) ! enddo ! enddo ! do j = 1 , reduced_dim - n_new_trials ! read ( unit_rho , rec = j , iostat = ioerror ) rho_j ! do i = reduced_dim - n_new_trials + 1 , reduced_dim ! read ( unit_trial_vecs , rec = i , iostat = ioerror ) c_i A_reduced ( i , j ) = ddot ( wf % n_parameters , c_i , 1 , rho_j , 1 ) ! enddo ! enddo ! endif ! !     Close files for trial vectors and transformed vectors ! close ( unit_trial_vecs ) close ( unit_rho ) ! !     Write current reduced Jacobi matrix to file ! rewind ( unit_reduced_jacobi ) write ( unit_reduced_jacobi ) (( A_reduced ( i , j ), i = 1 , reduced_dim ), j = 1 , reduced_dim ) ! !     Close reduced Jacobi file ! close ( unit_reduced_jacobi ) ! end subroutine construct_reduced_matrix_ccs ! ! module subroutine construct_reduced_gradient_ccs ( wf , F_reduced , reduced_dim , n_new_trials ) !! !!    Construct Reduced Gradient (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Constructs F_i = c_i&#94;T F by reading from file and constructing the missing elements. !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension (:,:), allocatable :: F ! Gradient vector real ( dp ), dimension ( reduced_dim , 1 ) :: F_reduced ! Reduced gradient vector ! real ( dp ), dimension (:,:), allocatable :: c_i ! Trial vector i ! integer ( i15 ) :: i = 0 ! integer ( i15 ) :: unit_trial_vecs = 0 integer ( i15 ) :: unit_reduced_gradient = 0 integer ( i15 ) :: unit_grad_vec = 0 ! integer ( i15 ) :: ioerror = 0 ! real ( dp ) :: ddot ! !     Open file with trial vectors ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'read' , status = 'old' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! !     If first iteration, create reduced gradient file. Otherwise, !     read the part of the reduced gradient already stored on file. ! if ( iteration . eq . 1 ) then ! call generate_unit_identifier ( unit_reduced_gradient ) open ( unit = unit_reduced_gradient , file = 'reduced_gradient' , action = 'readwrite' , status = 'unknown' ,& form = 'unformatted' , iostat = ioerror ) ! else ! call generate_unit_identifier ( unit_reduced_gradient ) open ( unit = unit_reduced_gradient , file = 'reduced_gradient' , action = 'readwrite' , status = 'old' ,& form = 'unformatted' , iostat = ioerror ) ! rewind ( unit_reduced_gradient ) read ( unit_reduced_gradient ) & ( F_reduced ( i , 1 ), i = 1 , reduced_dim - n_new_trials ) ! endif ! !     Allocate trial (c) vector ! call wf % mem % alloc ( c_i , wf % n_parameters , 1 ) c_i = zero ! !     Allocate and read gradient vector (F) ! call wf % mem % alloc ( F , wf % n_parameters , 1 ) F = zero ! !     Read gradient vector ! call generate_unit_identifier ( unit_grad_vec ) open ( unit = unit_grad_vec , file = 'gradient_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! read ( unit_grad_vec , rec = 1 , iostat = ioerror ) F ! close ( unit_grad_vec ) ! !     Form the new elements of the reduced gradient vector ! do i = reduced_dim - n_new_trials + 1 , reduced_dim ! read ( unit_trial_vecs , rec = i , iostat = ioerror ) c_i F_reduced ( i , 1 ) = ddot ( wf % n_parameters , c_i , 1 , F , 1 ) ! enddo ! !     Close files for trial vectors ! close ( unit_trial_vecs ) ! !     Write current reduced gradient vector to file ! rewind ( unit_reduced_gradient ) write ( unit_reduced_gradient ) ( F_reduced ( i , 1 ), i = 1 , reduced_dim ) ! !     Close reduced gradient file ! close ( unit_reduced_gradient ) ! end subroutine construct_reduced_gradient_ccs ! ! module subroutine construct_next_response_trial_vectors_ccs ( wf , solution_vector_reduced , reduced_dim , n_new_trials ) !! !!    Construct Next Response Trial Vectors (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Constructs the next trial vector by constructing the residual vector !! !!       R = (A*X - F)/|X|, !! !!    and orthogonalizing it against the previous trial vectors. !! !!    Residual vectors are preconditioned before orthogonalization. !!    This is done by dividing by the orbital differences. !! !!    If the norm of orthogonal vector is very small !!    (i.e. high degree of linear dependence on previous trial vectors) !!    it is scrapped. If norm sufficiently large, the vector is normalized and !!    stored in trial_vec file, to be used in the next iteration. !! !!    The routine also constructs full space solution vectors and stores them !!    in file solution_vectors when the residuals are converged. !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension ( reduced_dim , 1 ) :: solution_vector_reduced ! X_reduced ! integer ( i15 ) :: unit_rho = 0 integer ( i15 ) :: unit_trial_vecs = 0 integer ( i15 ) :: unit_solution = 0 integer ( i15 ) :: unit_grad_vec = 0 ! integer ( i15 ) :: ioerror = 0 ! integer ( i15 ) :: trial = 0 ! Loops over the trial vectors ! real ( dp ) :: norm_solution_vector = zero real ( dp ) :: norm_new_trial = zero real ( dp ) :: norm_residual = zero real ( dp ) :: conv_test ! Norm to test for convergence ! real ( dp ), parameter :: linear_dependence_threshold = 1.0D-18 ! real ( dp ), dimension (:,:), allocatable :: solution_vector ! X real ( dp ), dimension (:,:), allocatable :: gradient_vector ! F real ( dp ), dimension (:,:), allocatable :: residual ! R real ( dp ), dimension (:,:), allocatable :: orbital_diff ! Orbital differences ! real ( dp ), dimension (:,:), allocatable :: c_i real ( dp ), dimension (:,:), allocatable :: rho_i ! integer ( i15 ) :: i = 0 , a = 0 , ai = 0 ! real ( dp ) :: ddot , dot_prod ! !     Open trial vector files, transformed and untransformed (rho_i = A c_i), !     and the solution vector file ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'readwrite' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! call generate_unit_identifier ( unit_rho ) open ( unit = unit_rho , file = 'transformed_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! call generate_unit_identifier ( unit_solution ) open ( unit = unit_solution , file = wf % tasks % current , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! !     Construct full space solution vector X ! call wf % mem % alloc ( solution_vector , wf % n_parameters , 1 ) solution_vector = zero ! call wf % mem % alloc ( c_i , wf % n_parameters , 1 ) ! do trial = 1 , reduced_dim ! !        X = X + solution_vector_reduced_i * c_i ! c_i = zero read ( unit_trial_vecs , rec = trial , iostat = ioerror ) c_i call daxpy ( wf % n_parameters , solution_vector_reduced ( trial , 1 ), c_i , 1 , solution_vector , 1 ) ! enddo ! call wf % mem % dealloc ( c_i , wf % n_parameters , 1 ) ! !     Calculate the norm of the solution vector & deallocate ! norm_solution_vector = sqrt ( ddot ( wf % n_parameters , solution_vector , 1 , solution_vector , 1 )) ! !     Construct A X and place into residual R ! call wf % mem % alloc ( residual , wf % n_parameters , 1 ) residual = zero ! call wf % mem % alloc ( rho_i , wf % n_parameters , 1 ) ! do trial = 1 , reduced_dim ! !        R = R + solution_vector_reduced_i * rho_i ! rho_i = zero read ( unit_rho , rec = trial , iostat = ioerror ) rho_i call daxpy ( wf % n_parameters , solution_vector_reduced ( trial , 1 ), rho_i , 1 , residual , 1 ) ! enddo ! !     Read the gradient vector from disk ! call wf % mem % alloc ( gradient_vector , wf % n_parameters , 1 ) gradient_vector = zero ! call generate_unit_identifier ( unit_grad_vec ) open ( unit = unit_grad_vec , file = 'gradient_vec' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! read ( unit_grad_vec , rec = 1 , iostat = ioerror ) gradient_vector ! close ( unit_grad_vec ) ! !     Subtract it from the residual (R = A X - F) ! call daxpy ( wf % n_parameters , - one , gradient_vector , 1 , residual , 1 ) ! call wf % mem % dealloc ( gradient_vector , wf % n_parameters , 1 ) ! !     Calculate the norm of the residual (|| A X - F || / || X ||) !     and print to output ! norm_residual = sqrt ( ddot ( wf % n_parameters , residual , 1 , residual , 1 )) ! conv_test = norm_residual / norm_solution_vector ! if ( conv_test . le . wf % response_specifications % residual_threshold ) then ! converged = . true . ! !        Write solution vector to disk ! write ( unit_solution , rec = 1 , iostat = ioerror ) solution_vector ! endif ! !     Print information to output ! write ( unit_output , '(t3,i2,13x,e10.4)' ) iteration , conv_test flush ( unit_output ) ! !     Precondition the residual by inverse orbital energy differences ! call wf % mem % alloc ( orbital_diff , wf % n_parameters , 1 ) orbital_diff = zero ! call wf % calculate_orbital_differences ( orbital_diff ) ! do i = 1 , wf % n_parameters ! residual ( i , 1 ) = residual ( i , 1 ) / orbital_diff ( i , 1 ) ! enddo ! call wf % mem % dealloc ( orbital_diff , wf % n_parameters , 1 ) ! !     Orthogonalize the residual against other trials vectors ! call dscal ( wf % n_parameters , one / norm_residual , residual , 1 ) ! Normalize residual ! call wf % mem % alloc ( c_i , wf % n_parameters , 1 ) ! !     prod_i (I - c_i*c_i&#94;T)*Res = prod_i (Res - c_i*c_i&#94;T*Res) ! do trial = 1 , reduced_dim ! c_i = zero read ( unit_trial_vecs , rec = trial , iostat = ioerror ) c_i ! dot_prod = ddot ( wf % n_parameters , c_i , 1 , residual , 1 ) call daxpy ( wf % n_parameters , - dot_prod , c_i , 1 , residual , 1 ) ! enddo ! call wf % mem % dealloc ( c_i , wf % n_parameters , 1 ) ! n_new_trials = 0 ! norm_new_trial = sqrt ( ddot ( wf % n_parameters , residual , 1 , residual , 1 )) ! if (( norm_new_trial . gt . linear_dependence_threshold ) . and . . not . converged ) then ! n_new_trials = n_new_trials + 1 call dscal ( wf % n_parameters , one / norm_new_trial , residual , 1 ) write ( unit_trial_vecs , rec = n_new_trials + reduced_dim , iostat = ioerror ) residual ! endif ! if ( n_new_trials . eq . 0 . and . . not . converged ) then ! write ( unit_output , * ) 'Error: linear dependency resulted in no new trial vectors.' stop ! endif ! !     Close all files ! close ( unit_trial_vecs ) close ( unit_rho ) close ( unit_solution ) ! !     Update dimension of reduced space ! reduced_dim = reduced_dim + n_new_trials ! call wf % mem % dealloc ( residual , wf % n_parameters , 1 ) call wf % mem % dealloc ( solution_vector , wf % n_parameters , 1 ) ! end subroutine construct_next_response_trial_vectors_ccs ! ! end submodule response","tags":"","loc":"sourcefile/response_submodule.f90.html","title":"response_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~cvs_submodule.f90~2~~EfferentGraph sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilecvs_submodulef902EfferentGraph = svgPanZoom('#sourcefilecvs_submodulef902EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules cvs Source Code cvs_submodule.F90 Source Code submodule ( ccs_class ) cvs ! !! !!    CVS submodule(CCS) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017 !! !!    Contains the CVS routines for the CCS class and routines for core excitations. !!    Note that this submodule contains both excited state routines and jacobian transformation routines. !! !!    -::- Subroutines in this submodule -::- !! !!    initialize_trial_vectors_core    - Driver for initialization of trial vectors !!    find_start_trial_indices_core    - Finds indices of single core excitations of lowest energy to be used for start vectors !!    precondition_residual_core       - Projects out contamination (valence contributions) and preconditions uncontaminated residual !!    cvs_residual_projection          - Projection routine for residual !!    core_jacobian_ccs_transformation - Jacobian transformation where contamination (valence contributions) is projected out !!    cvs_rho_a_i_projection           - Projection routine for rho_a_i !! !!    Helper subroutines: !! !!    find_core_mo - identifies the mo-index of the core orbital of interest. !! !! ! ! contains ! ! module subroutine initialize_trial_vectors_core_ccs ( wf ) !! !!    Initialize trial vectors, for core excitation calculation !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Finds correct core MO, and selects the n_singlet_state lowest !!    orbital differences where one of the occupied indices corresponds to the !!    core MO !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ), dimension (:,:), allocatable :: index_core_obital ! real ( dp ), dimension (:,:), allocatable :: c ! integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: unit_trial_vecs = 0 , unit_rho = 0 , ioerror = 0 ! !     Allocate array for the indices of the lowest orbital differences ! call wf % mem % alloc_int ( index_core_obital , wf % excited_state_specifications % n_singlet_states , 1 ) index_core_obital = zero ! !     Find indecies of lowest orbital differences ! call wf % find_start_trial_indices_core ( index_core_obital ) ! !     Generate start trial vectors c and write to file ! call wf % mem % alloc ( c , wf % n_parameters , 1 ) ! !     Prepare for writing trial vectors to file ! call generate_unit_identifier ( unit_trial_vecs ) open ( unit = unit_trial_vecs , file = 'trial_vec' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_parameters ), iostat = ioerror ) ! do i = 1 , ( wf % excited_state_specifications % n_singlet_states ) c = zero c ( index_core_obital ( i , 1 ), 1 ) = one write ( unit_trial_vecs , rec = i , iostat = ioerror ) ( c ( j , 1 ), j = 1 , wf % n_parameters ) enddo ! !     Close file ! close ( unit_trial_vecs ) ! !     Deallocate c ! call wf % mem % dealloc ( c , wf % n_parameters , 1 ) ! !     Deallocate index_lowest_obital_diff ! call wf % mem % dealloc_int ( index_core_obital , wf % excited_state_specifications % n_singlet_states , 1 ) ! end subroutine initialize_trial_vectors_core_ccs ! ! module subroutine find_start_trial_indices_core_ccs ( wf , index_list ) !! !!    Find indices for lowest orbital differences !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad !! !! implicit none ! class ( ccs ) :: wf integer ( i15 ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ), intent ( inout ) :: index_list ! real ( dp ), dimension (:,:), allocatable :: sorted_short_vec ! integer ( i15 ) :: a , i , counter ! !     Find core mo(s) ! call wf % mem % alloc_int ( wf % core_excited_state_specifications % index_core_mo , & wf % core_excited_state_specifications % n_equivalent_cores , 1 ) ! call wf % find_core_mo ! counter = 1 do a = 1 , wf % n_v if ( counter . le . wf % excited_state_specifications % n_singlet_states ) then do i = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! index_list ( counter , 1 ) = index_two ( a , wf % core_excited_state_specifications % index_core_mo ( i , 1 ), wf % n_v ) ! counter = counter + 1 ! if ( counter . gt . wf % excited_state_specifications % n_singlet_states ) exit ! enddo endif enddo ! end subroutine find_start_trial_indices_core_ccs ! module subroutine find_core_mo_ccs ( wf ) !! !!    Find which mo are core mos !!    Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: n_nuclei = 0 , core = 0 , ao = 0 , mo = 0 , ao_mo_index = 0 integer ( i15 ) :: first_ao_on_core = 0 , counter = 0 , n_aos_on_atoms = 0 , i = 0 , j = 0 integer ( i15 ), dimension (:,:), allocatable :: n_ao_on_center , ao_center_info , aos_on_atoms ! !     :: Get center info :: ! call read_atom_info ( n_nuclei , wf % n_ao ) ! !     n_ao_on_center contains number of aos on each atom !     ao_center_info contains ao index (first column) belonging to each of the aos (second column) ! call wf % mem % alloc_int ( n_ao_on_center , n_nuclei , 1 ) call wf % mem % alloc_int ( ao_center_info , wf % n_ao , 2 ) ! call read_center_info ( n_nuclei , wf % n_ao , n_ao_on_center , ao_center_info ) ! !     Find number of aos on atoms that we are interested in ! n_aos_on_atoms = 0 do i = 1 , wf % core_excited_state_specifications % n_equivalent_cores n_aos_on_atoms = n_aos_on_atoms + n_ao_on_center ( wf % core_excited_state_specifications % cores ( i , 1 ), 1 ) enddo ! call wf % mem % alloc_int ( aos_on_atoms , n_aos_on_atoms , 1 ) ! write ( unit_output , * ) wf % core_excited_state_specifications % n_equivalent_cores , wf % core_excited_state_specifications % cores ( 1 , 1 ) flush ( unit_output ) ! counter = 1 do i = 1 , wf % core_excited_state_specifications % n_equivalent_cores do j = 1 , wf % n_ao if ( ao_center_info ( j , 1 ) == wf % core_excited_state_specifications % cores ( i , 1 )) then ! aos_on_atoms ( counter , 1 ) = ao_center_info ( j , 2 ) counter = counter + 1 ! endif enddo enddo ! call wf % mem % dealloc_int ( ao_center_info , wf % n_ao , 2 ) ! !     :: Find core mo that has large ao component on the atom in question :: ! wf % core_excited_state_specifications % index_core_mo = zero counter = 0 ! do ao = 1 , n_aos_on_atoms ! do mo = 1 , wf % n_o ! !           Determine wether orbital in core mo ! if ( wf % fock_diagonal ( mo , 1 ) . lt . - 5.0d0 ) then ! !              Determine wether the core orbital sits on the corect atom(s) ! ao_mo_index = index_two ( aos_on_atoms ( ao , 1 ), mo , wf % n_ao ) ! if ( abs ( wf % mo_coef ( ao_mo_index , 1 )) . gt . 0.5d0 ) then counter = counter + 1 ! if ( counter . le . wf % core_excited_state_specifications % n_equivalent_cores ) then wf % core_excited_state_specifications % index_core_mo ( counter , 1 ) = mo endif ! endif ! endif ! enddo ! enddo ! ! call wf % mem % dealloc_int ( n_ao_on_center , n_nuclei , 1 ) call wf % mem % dealloc_int ( aos_on_atoms , n_aos_on_atoms , 1 ) ! !     Sanity check ! do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores if ( wf % core_excited_state_specifications % index_core_mo ( core , 1 ) . eq . 0 ) then write ( unit_output , * ) 'WARNING: Found no core orbitals for core' , wf % core_excited_state_specifications % cores ( core , 1 ) stop endif enddo ! end subroutine find_core_mo_ccs ! ! module subroutine precondition_residual_core_ccs ( wf , residual ) !! !!    Precondition residual for core excited state calculation !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Project out elements not corresponding to the core excitation !!    Divide elements of residual by orbital difference !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! real ( dp ), dimension (:,:), allocatable :: orbital_diff ! integer ( i15 ) :: i = 0 , a = 0 , ai = 0 ! call wf % cvs_residual_projection ( residual ) ! call wf % mem % alloc ( orbital_diff , wf % n_parameters , 1 ) orbital_diff = zero ! call wf % calculate_orbital_differences ( orbital_diff ) ! do i = 1 , wf % n_parameters ! residual ( i , 1 ) = residual ( i , 1 ) / orbital_diff ( i , 1 ) ! enddo ! call wf % mem % dealloc ( orbital_diff , wf % n_parameters , 1 ) ! end subroutine precondition_residual_core_ccs ! ! module subroutine cvs_residual_projection_ccs ( wf , residual ) !! !!    Residual projection for core excited state calculation (CCS) !!    Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! integer ( i15 ) :: i = 0 , a = 0 , core = 0 , ai = 0 ! logical :: core_orbital ! do i = 1 , wf % n_o ! core_orbital = . false . do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if ( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then do a = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) residual ( ai , 1 ) = zero enddo endif ! enddo ! end subroutine cvs_residual_projection_ccs ! ! module subroutine cvs_rho_a_i_projection_ccs ( wf , vec_a_i ) !! !!    CVS projection of rho_a_i, !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Projects out elements of rho that do not correspond to the core excitation. !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_v , wf % n_o ) :: vec_a_i ! integer ( i15 ) :: i = 0 , a = 0 , core = 0 ! logical :: core_orbital ! do i = 1 , wf % n_o ! core_orbital = . false . ! do core = 1 , wf % core_excited_state_specifications % n_equivalent_cores ! if ( i . eq . wf % core_excited_state_specifications % index_core_mo ( core , 1 )) core_orbital = . true . ! enddo ! if (. not . core_orbital ) then vec_a_i (:, i ) = zero endif ! enddo ! end subroutine cvs_rho_a_i_projection_ccs ! ! end submodule cvs","tags":"","loc":"sourcefile/cvs_submodule.f90~2.html","title":"cvs_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~input_reader_submodule.f90~3~~EfferentGraph sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~input_reader.f90 input_reader.F90 sourcefile~input_reader.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileinput_reader_submodulef903EfferentGraph = svgPanZoom('#sourcefileinput_reader_submodulef903EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules input_reader Source Code input_reader_submodule.F90 Source Code submodule ( ccs_class ) input_reader ! !! !!    Input reader submodule (CCS) !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017 !! !!    Contains the following family of procedures of the CCS class: !! !! use input_reader ! contains ! ! module subroutine general_specs_reader_ccs ( wf , unit_input ) !! !!    General Specifications Reader !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017 !! !!    Reads general settings !!       - memory !!       - disk space !!    from the eT.inp file. !! !!    Both variables are given in gb in the input file and must be converted to words. !! implicit none ! class ( ccs ) :: wf integer ( i15 ) :: unit_input ! integer :: memory = 0 , disk_space = 0 ! character ( len = 40 ) :: line ! !     Start at the beginning of eT.inp ! rewind ( unit_input ) ! do ! General do loop - ends when it reaches 'exit'. Either when method is specified or if no method is given. ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! !        Find general input section ! if ( trim ( line ) == 'CC' . or . trim ( line ) == 'MLCC' . or . trim ( line ) == 'SCC' ) then ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! do ! General do loop - ends when it reaches 'exit'. ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'disk_space:' ) then ! read ( unit_input , * ) disk_space ! !                    Converting from gb to words ! wf % settings % disk_space = disk_space * 134500000 ! cycle ! elseif ( trim ( line ) == 'memory:' ) then ! read ( unit_input , * ) memory ! !                    Initialize memory object for the specified memory ! call wf % mem % init ( memory ) ! cycle ! elseif ( trim ( line ) == 'print_level:' ) then ! read ( unit_input , * ) wf % settings % print_level ! cycle ! elseif ( trim ( line ) == 'end of eT input' ) then ! Use defaults for memory and disk_space ! exit ! endif ! enddo ! End general do loop ! exit ! else ! write ( unit_output , * ) 'Error: no general input section found.' stop endif ! elseif ( trim ( line ) == 'end of eT input' ) then ! write ( unit_output , * ) 'Error: no general input section found.' stop ! endif ! enddo write ( unit_output , '(t3,a,i4,a)' ) 'Memory available for calculation:     ' , memory , ' gb' write ( unit_output , '(t3,a,i4,a/)' ) 'Disk space available for calculation: ' , disk_space , ' gb' flush ( unit_output ) ! end subroutine general_specs_reader_ccs ! ! module subroutine calculation_reader_ccs ( wf , unit_input ) !! !!    Calculation reader, !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017 !! !!    Reads eT.inp to determine which calculation tasks !! !!       - ground state !!       - excited state !!       - ionized state !!       - property calculation !! !!     to do, and then calls specific readers for each of these tasks to set task specific settings. !! implicit none ! integer ( i15 ) :: unit_input ! class ( ccs ) :: wf ! character ( len = 40 ) :: line ! !     Prints ! write ( unit_output , '(t3,a/)' ) 'Calculations requested:' ! !     Always do ground state calculation ! wf % tasks % ground_state = . true . ! !     Start at the begining of eT.inp ! rewind ( unit_input ) ! do ! General do loop - ends when it reaches 'exit'. ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! !        Find ground state/excited state/ionized state/property input section ! if ( trim ( line ) == 'ground state' ) then ! Ground State ! !           Prints ! write ( unit_output , '(t6,a,a)' ) trim ( wf % name ), ' ground state' ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! Specifications given for ground state ! call wf % read_ground_state_specs ( unit_input ) ! cycle ! else ! Use defaults for ground state calculation ! cycle ! endif ! elseif ( trim ( line ) == 'excited state' ) then ! Excited state ! !           Prints ! write ( unit_output , '(t6,a,a)' ) trim ( wf % name ), ' excited state' ! wf % tasks % excited_state = . true . ! This will be set to false again in the case of core_excited_state = .true. ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! Specifications and calculation details given for excited state ! call wf % read_excited_state_specs ( unit_input ) ! cycle ! else ! No excited state calculation without any information in eT.inp ! write ( unit_output , * ) 'Error: excited state calculation section of eT.inp is missing.' stop ! endif ! elseif ( trim ( line ) == 'ionized state' ) then ! Ionized state ! !           Prints ! write ( unit_output , '(t6,a,a)' ) trim ( wf % name ), ' ionized state' ! wf % tasks % ionized_state = . true . ! This will be set to false again in the case of core_ionized_state = .true. ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! Specifications and calculation details given for ionized state ! call wf % read_excited_state_specs ( unit_input ) ! cycle ! else ! No ionized state calculation without any information in eT.inp ! write ( unit_output , * ) 'Error: ionized state calculation section of eT.inp missing.' stop ! endif ! elseif ( trim ( line ) == 'property' ) then ! Property calculation ! !           Prints ! write ( unit_output , '(t6,a)' ) '- Property' ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! Specifications and calculation details given for property calculation ! call wf % read_property_specs ( unit_input ) ! cycle ! else ! No property calculation without any information in eT.inp ! write ( unit_output , * ) 'Error: property calculation section of eT.inp missing.' stop ! endif elseif ( trim ( line ) == 'end of eT input' ) then backspace ( unit_input ) exit endif ! enddo ! end subroutine calculation_reader_ccs ! ! module subroutine read_ground_state_specs_ccs ( wf , unit_input ) !! !!    Read ground state specifications. !!    Written by Eirik F. Kjønstad and Sarai Dery Folkestad, Nov. 2017 !! !!    Reads settings !! !!       - restart !!       - energy and residual thresholds !!       - max number of iterations !! !!    for the ground state calculation !! implicit none ! integer :: unit_input ! class ( ccs ) :: wf ! character ( len = 40 ) :: line ! !     File is open, and positioned at the top of the ground state section !     thus we will NOT rewind. ! do ! General do loop - ends when it reaches 'exit'. ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'restart' ) then ! Restart ! wf % ground_state_specifications % restart = . true . cycle ! elseif ( trim ( line ) == 'energy_threshold:' ) then ! Energy threshold ! read ( unit_input , * ) wf % ground_state_specifications % energy_threshold cycle ! elseif ( trim ( line ) == 'residual_threshold:' ) then ! Residual threshold ! read ( unit_input , * ) wf % ground_state_specifications % residual_threshold cycle ! elseif ( trim ( line ) == 'max_iterations:' ) then ! Max number of iterations ! read ( unit_input , * ) wf % ground_state_specifications % max_iterations cycle ! elseif ( trim ( line ) == '}' ) then ! Done ! return ! elseif ( trim ( line ) == 'enf of eT input' ) then ! write ( unit_output , * ) 'Error: could not find the end of the ground state calculation section of eT.inp .' stop ! endif ! enddo ! end subroutine read_ground_state_specs_ccs ! module subroutine read_excited_state_specs_ccs ( wf , unit_input ) !! !!    Read excited state specifications, !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017 !! !!    Reads settings !! !!       - restart !!       - energy and residual thresholds !!       - max number of iterations !! !!    for the excited state calculation and specifications !! !!       - n_singlet_states !!       - n_triplet_states !!       - start_vectors !! !!    and for core excited states !! !!       - n_equivalent_cores !!       - cores !! !!     is also read. These MUST be present (in this order) in eT.inp if core excited/ionized state is requested. !! implicit none ! integer ( i15 ) :: unit_input ! class ( ccs ) :: wf ! character ( len = 40 ) :: line ! !     File is open, and positioned at the top of the ground state section !     thus we will NOT rewind. ! do ! General do loop - ends when it reaches 'exit'. ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'restart' ) then ! Restart ! wf % excited_state_specifications % restart = . true . cycle ! elseif ( trim ( line ) == 'energy_threshold:' ) then ! Energy threshold ! read ( unit_input , * ) wf % excited_state_specifications % energy_threshold cycle ! elseif ( trim ( line ) == 'residual_threshold:' ) then ! Residual threshold ! read ( unit_input , * ) wf % excited_state_specifications % residual_threshold cycle ! elseif ( trim ( line ) == 'max_iterations:' ) then ! Max number of iterations ! read ( unit_input , * ) wf % excited_state_specifications % max_iterations cycle ! elseif ( trim ( line ) == 'n_singlet_states:' ) then ! Number of singlets ! read ( unit_input , * ) wf % excited_state_specifications % n_singlet_states cycle ! elseif ( trim ( line ) == 'n_triplet_states:' ) then ! Number of triplets ! read ( unit_input , * ) wf % excited_state_specifications % n_triplet_states cycle ! elseif ( trim ( line ) == 'start_vectors:' ) then ! Start vector provided in eT.inp ! wf % excited_state_specifications % user_specified_start_vector = . true . ! if ( wf % excited_state_specifications % n_singlet_states == 0 ) then ! write ( unit_output , * ) 'Error: Number of singlet excited states must be specified before start vectors are given' stop ! endif ! call wf % mem % alloc_int ( wf % excited_state_specifications % start_vectors , & wf % excited_state_specifications % n_singlet_states , 1 ) ! read ( unit_input , * ) wf % excited_state_specifications % start_vectors cycle ! elseif ( trim ( line ) == 'core excited state' . or . trim ( line ) == 'core ionized state' ) then ! Requested core excitations ! !           Set calculation tasks ! if ( wf % tasks % excited_state ) then ! wf % tasks % excited_state = . false . wf % tasks % core_excited_state = . true . ! elseif ( wf % tasks % ionized_state ) then ! wf % tasks % ionized_state = . false . wf % tasks % core_ionized_state = . true . ! endif ! !           This input section har strict structure: !           E.g. a calculation of core excitations from the second atom given MOLECULE.INP !           when this atom is the only atom of the this type with exactly the same environment (no equivalent cores). ! !           n_equivalent_cores: !           1 !           cores: !           2 ! read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == '{' ) then ! do read ( unit_input , '(a40)' ) line line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'n_equivalent_cores:' ) then ! Number of equivalent cores ! read ( unit_input , * ) wf % core_excited_state_specifications % n_equivalent_cores cycle ! elseif ( trim ( line ) == 'cores:' ) then ! Cores (given by the order of which it appears in MOLECULE.INP) ! if ( wf % core_excited_state_specifications % n_equivalent_cores == 0 ) then write ( unit_output , * ) 'Number of equivalent cores should be selected before atoms are selected.' stop endif ! call wf % mem % alloc_int ( wf % core_excited_state_specifications % cores , & wf % core_excited_state_specifications % n_equivalent_cores , 1 ) ! read ( unit_input , * ) wf % core_excited_state_specifications % cores cycle ! elseif ( trim ( line ) == '}' ) then ! exit ! elseif ( trim ( line ) == 'enf of eT input' ) then backspace ( unit_input ) exit ! endif enddo ! !              Sanity check for core excited states ! if ( wf % core_excited_state_specifications % n_equivalent_cores == 0 & . or . . not . allocated ( wf % core_excited_state_specifications % cores )) then write ( unit_output , * ) 'Error: atoms for core excitation was not found in eT.inp' endif ! else ! write ( unit_output , * ) 'Error: core excited state input section is incomplete.' stop ! endif cycle ! ! elseif ( trim ( line ) == '}' ) then ! Done exit elseif ( trim ( line ) == 'enf of eT input' ) then ! Done ! backspace ( unit_input ) exit ! endif ! enddo ! !     Sanity check: ! if ( wf % excited_state_specifications % n_singlet_states == 0 . and . & wf % excited_state_specifications % n_triplet_states == 0 ) then ! write ( unit_output , * ) 'Error: please specify either n_singlet_states or n_triplet_states in eT.inp' stop ! endif ! end subroutine read_excited_state_specs_ccs ! ! module subroutine read_property_specs_ccs ( wf , unit_input ) !! !!    Read property specifications, !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017 !! !!    Reads which properties to calculate. !! implicit none ! integer ( i15 ) :: unit_input ! class ( ccs ) :: wf ! character ( len = 40 ) :: line ! !     File is open, and positioned at the top of the ground state section !     thus we will NOT rewind. ! do ! General do loop - ends when it reaches 'exit'. ! read ( unit_input , '(a40)' ) line ! !        Remove blanks preceding text ! line = remove_preceding_blanks ( line ) ! if ( trim ( line ) == 'multipliers' ) then ! wf % tasks % multipliers = . true . ! elseif ( trim ( line ) == 'end of eT input' ) then ! backspace ( unit_input ) exit ! endif ! enddo ! !     Sanity check: ! if ( wf % excited_state_specifications % n_singlet_states == 0 . and . & wf % excited_state_specifications % n_triplet_states == 0 ) then ! write ( unit_output , * ) 'Property calculation requires specification of excited state calculation in eT.inp' stop ! endif ! end subroutine read_property_specs_ccs ! ! end submodule input_reader","tags":"","loc":"sourcefile/input_reader_submodule.f90~3.html","title":"input_reader_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~integrals_submodule.f90~~EfferentGraph sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileintegrals_submodulef90EfferentGraph = svgPanZoom('#sourcefileintegrals_submodulef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Submodules integrals Source Code integrals_submodule.F90 Source Code submodule ( ccs_class ) integrals ! !! !!    Integrals submodule (CCS) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! !!    Contains procedures for construction of general integrals, and !!    specifically: !! !!    - electronic repulsion integrals !!    - (...no other integrals yet...) !! !!    o - occupied index !!    v - virtual index !! !!    Note: for normal use, the get_pq_rs routines should be called. These !!    will call the appropriate routines for constructing (or reading) the integrals. !!    For example, !! !!       integral_type = 'electronic_repulsion' !!       call wf%get_vo_vo(integral_type, g_ai_bj) !! !!    will place the T1-transformed g_aibj integrals in the g_ai_bj array. !!    The indices may also be restricted (though this is optional): !! !!       integral_type = 'electronic_repulsion' !!       call wf%get_vo_vo(integral_type, g_ai_bj, a_first, a_last, i_first, i_last, ...) !! ! contains ! !    -::- Get integral routines -::- !    ::::::::::::::::::::::::::::::: ! ! module subroutine get_oo_oo_ccs ( wf , integral_type , x_oo_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_oo,oo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_oo,oo (ordered as x_oo_oo) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_oo_oo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_o local_index2_last = wf % n_o local_index3_last = wf % n_o local_index4_last = wf % n_o ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_oo_oo' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_oo_oo_electronic_repulsion ( x_oo_oo , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_oo_oo' stop ! endif ! end subroutine get_oo_oo_ccs ! ! module subroutine get_oo_ov_ccs ( wf , integral_type , x_oo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_oo,ov integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_oo,ov (ordered as x_oo_ov) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_oo_ov ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_o local_index2_last = wf % n_o local_index3_last = wf % n_o local_index4_last = wf % n_v ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_oo_ov' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_oo_ov_electronic_repulsion ( x_oo_ov , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_oo_ov' stop ! endif ! end subroutine get_oo_ov_ccs ! ! module subroutine get_ov_oo_ccs ( wf , integral_type , x_ov_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_ov,oo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_ov,oo (ordered as x_ov_oo) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_ov_oo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_o local_index2_last = wf % n_v local_index3_last = wf % n_o local_index4_last = wf % n_o ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_ov_oo' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_ov_oo_electronic_repulsion ( x_ov_oo , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_ov_oo' stop ! endif ! end subroutine get_ov_oo_ccs ! ! module subroutine get_oo_vo_ccs ( wf , integral_type , x_oo_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_oo,vo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_oo,vo (ordered as x_oo_vo) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_oo_vo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_o local_index2_last = wf % n_o local_index3_last = wf % n_v local_index4_last = wf % n_o ! else write ( unit_output , * ) 'Error: some optionals missing in call to get_oo_vo' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_oo_vo_electronic_repulsion ( x_oo_vo , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_oo_vo' stop ! endif ! end subroutine get_oo_vo_ccs ! ! module subroutine get_vo_oo_ccs ( wf , integral_type , x_vo_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_vo,oo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_vo,oo (ordered as x_vo_oo) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_vo_oo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_v local_index2_last = wf % n_o local_index3_last = wf % n_o local_index4_last = wf % n_o ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_vo_oo' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_vo_oo_electronic_repulsion ( x_vo_oo , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_vo_oo' stop ! endif ! end subroutine get_vo_oo_ccs ! ! module subroutine get_oo_vv_ccs ( wf , integral_type , x_oo_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_oo,vv integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_oo,vv (ordered as x_oo_vv) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_oo_vv ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_o local_index2_last = wf % n_o local_index3_last = wf % n_v local_index4_last = wf % n_v ! else write ( unit_output , * ) 'Error: some optionals missing in call to get_oo_vv' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_oo_vv_electronic_repulsion ( x_oo_vv , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_oo_vv' stop ! endif ! end subroutine get_oo_vv_ccs ! ! module subroutine get_vv_oo_ccs ( wf , integral_type , x_vv_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_vv,oo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_vv,oo (ordered as x_vv_oo) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_vv_oo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_v local_index2_last = wf % n_v local_index3_last = wf % n_o local_index4_last = wf % n_o ! else write ( unit_output , * ) 'WARNING: Some optionals missing in call to get_vv_oo' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_vv_oo_electronic_repulsion ( x_vv_oo , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'WARNING: unknown integral type requested from get_vv_oo' stop ! endif ! end subroutine get_vv_oo_ccs ! ! module subroutine get_ov_ov_ccs ( wf , integral_type , x_ov_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_ov,ov integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_ov,ov (ordered as x_ov_ov) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_ov_ov ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_o local_index2_last = wf % n_v local_index3_last = wf % n_o local_index4_last = wf % n_v ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_ov_ov' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_ov_ov_electronic_repulsion ( x_ov_ov , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_ov_ov' stop ! endif ! end subroutine get_ov_ov_ccs ! ! module subroutine get_vo_vo_ccs ( wf , integral_type , x_vo_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_vo,vo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_vo,vo (ordered as x_vo_vo) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_vo_vo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_v local_index2_last = wf % n_o local_index3_last = wf % n_v local_index4_last = wf % n_o ! else ! write ( unit_output , * ) 'Error: Some optionals missing in call to get_vo_vo' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_vo_vo_electronic_repulsion ( x_vo_vo , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_vo_vo' stop ! endif ! end subroutine get_vo_vo_ccs ! ! module subroutine get_ov_vo_ccs ( wf , integral_type , x_ov_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_ov,vo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_ov,vo (ordered as x_ov_vo) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_ov_vo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_o local_index2_last = wf % n_v local_index3_last = wf % n_v local_index4_last = wf % n_o ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_ov_vo' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_ov_vo_electronic_repulsion ( x_ov_vo , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_ov_vo' stop ! endif ! end subroutine get_ov_vo_ccs ! ! module subroutine get_vo_ov_ccs ( wf , integral_type , x_vo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_vo,ov integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_vo,ov (ordered as x_vo_ov) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_vo_ov ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_v local_index2_last = wf % n_o local_index3_last = wf % n_o local_index4_last = wf % n_v ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_vo_ov' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_vo_ov_electronic_repulsion ( x_vo_ov , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_vo_ov' stop ! endif ! end subroutine get_vo_ov_ccs ! ! module subroutine get_ov_vv_ccs ( wf , integral_type , x_ov_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_ov,vv integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_ov,vv (ordered as x_ov_vv) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_ov_vv ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_o local_index2_last = wf % n_v local_index3_last = wf % n_v local_index4_last = wf % n_v ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_ov_vv' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_ov_vv_electronic_repulsion ( x_ov_vv , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_ov_vv' stop ! endif ! end subroutine get_ov_vv_ccs ! ! module subroutine get_vv_ov_ccs ( wf , integral_type , x_vv_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_vv,ov integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_vv,ov (ordered as x_vv_ov) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_vv_ov ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_v local_index2_last = wf % n_v local_index3_last = wf % n_o local_index4_last = wf % n_v ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_vv_ov' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_vv_ov_electronic_repulsion ( x_vv_ov , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_vv_ov' stop ! endif ! end subroutine get_vv_ov_ccs ! ! module subroutine get_vo_vv_ccs ( wf , integral_type , x_vo_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_vo,vv integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_vo,vv (ordered as x_vo_vv) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_vo_vv ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_v local_index2_last = wf % n_o local_index3_last = wf % n_v local_index4_last = wf % n_v ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_vo_vv' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_vo_vv_electronic_repulsion ( x_vo_vv , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_vo_vv' stop ! endif ! end subroutine get_vo_vv_ccs ! ! module subroutine get_vv_vo_ccs ( wf , integral_type , x_vv_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_vv,vo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_vv,vo (ordered as x_vv_vo) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_vv_vo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_v local_index2_last = wf % n_v local_index3_last = wf % n_v local_index4_last = wf % n_o ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_vv_vo' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_vv_vo_electronic_repulsion ( x_vv_vo , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_vv_vo' stop ! endif ! end subroutine get_vv_vo_ccs ! ! module subroutine get_vv_vv_ccs ( wf , integral_type , x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get x_vv,vv integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct genereal two-electron integral x_vv,vv (ordered as x_vv_vv) !!    of type integral_type. !! !!    Optional parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_vv_vv ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last integer ( i15 ) :: local_index1_first , local_index1_last integer ( i15 ) :: local_index2_first , local_index2_last integer ( i15 ) :: local_index3_first , local_index3_last integer ( i15 ) :: local_index4_first , local_index4_last ! !     Set local index variables. !     Necessary because optional arguments cannot have default values ! if ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) ) then ! local_index1_first = index1_first local_index2_first = index2_first local_index3_first = index3_first local_index4_first = index4_first ! local_index1_last = index1_last local_index2_last = index2_last local_index3_last = index3_last local_index4_last = index4_last ! elseif ( . not . ( present ( index1_first ) . and . present ( index1_last ) & . and . present ( index2_first ) . and . present ( index2_last ) & . and . present ( index3_first ) . and . present ( index3_last ) & . and . present ( index4_first ) . and . present ( index4_last ) )) then ! local_index1_first = 1 local_index2_first = 1 local_index3_first = 1 local_index4_first = 1 ! local_index1_last = wf % n_v local_index2_last = wf % n_v local_index3_last = wf % n_v local_index4_last = wf % n_v ! else ! write ( unit_output , * ) 'Error: some optionals missing in call to get_vv_vv' stop ! endif ! if ( trim ( integral_type ) == 'electronic_repulsion' ) then ! call wf % get_vv_vv_electronic_repulsion ( x_vv_vv , & local_index1_first , local_index1_last , & local_index2_first , local_index2_last , & local_index3_first , local_index3_last , & local_index4_first , local_index4_last ) ! else ! write ( unit_output , * ) 'Error: unknown integral type requested from get_vv_vv' stop ! endif ! end subroutine get_vv_vv_ccs ! ! !    -::- Get electronic repulsion integral routines -::- !    :::::::::::::::::::::::::::::::::::::::::::::::::::: ! !     These routines should, normally, not be called directly. !     If \"integral_type\" equals \"electronic_repulsion\", the get_pq_rs !     routines will call the routines below to get the correct integrals. ! !     Depending on type of calculation, integrals are either read from file !     or constructed directly from the Cholesky vectors. ! ! module subroutine get_vo_vo_electronic_repulsion_ccs ( wf , x_vo_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_vo,vo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_vo,vo (ordered as g_vo_vo) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vo_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ai_J , L_bj_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ai_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_bj_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ai ( L_ai_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ai ( L_bj_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ai_J , & length_1 * length_2 , & L_bj_J , & length_3 * length_4 , & zero , & x_vo_vo , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ai_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_bj_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_vo_vo_electronic_repulsion_ccs ! ! module subroutine get_ov_vo_electronic_repulsion_ccs ( wf , x_ov_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_ov,vo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_ov,vo (ordered as g_ov_vo) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_ov_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ia_J , L_bj_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ia_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_bj_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ia ( L_ia_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ai ( L_bj_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ia_J , & length_1 * length_2 , & L_bj_J , & length_3 * length_4 , & zero , & x_ov_vo , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ia_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_bj_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_ov_vo_electronic_repulsion_ccs ! ! module subroutine get_vo_ov_electronic_repulsion_ccs ( wf , x_vo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_vo,ov integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_vo,ov (ordered as g_vo_ov) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vo_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ai_J , L_jb_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! logical :: voov_t1_on_file ! !     Test if we have T1-transformed on file ! inquire ( file = 'g_t1_aijb' , exist = voov_t1_on_file ) ! if ( voov_t1_on_file . and . wf % tasks % current . ne . 'ground_state' ) then ! call wf % read_t1_vo_ov_electronic_repulsion ( x_vo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) ! else ! !        Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !        Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ai_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_jb_J , length_3 * length_4 , wf % n_J ) ! !        Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ai ( L_ai_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ia ( L_jb_J , index3_first , index3_last , index4_first , index4_last ) ! !        Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ai_J , & length_1 * length_2 , & L_jb_J , & length_3 * length_4 , & zero , & x_vo_ov , & length_1 * length_2 ) ! !        Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ai_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_jb_J , length_3 * length_4 , wf % n_J ) ! endif ! end subroutine get_vo_ov_electronic_repulsion_ccs ! ! module subroutine get_ov_vv_electronic_repulsion_ccs ( wf , x_ov_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_vo,vv integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_vo,vv (ordered as g_vo_vv) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_ov_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ia_J , L_bc_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ia_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_bc_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ia ( L_ia_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ab ( L_bc_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ia_J , & length_1 * length_2 , & L_bc_J , & length_3 * length_4 , & zero , & x_ov_vv , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ia_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_bc_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_ov_vv_electronic_repulsion_ccs ! ! module subroutine get_vv_ov_electronic_repulsion_ccs ( wf , x_vv_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_vv,ov integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_vv,ov (ordered as g_vv_ov) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vv_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ab_J , L_ic_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! logical :: vvov_t1_on_file = . false . ! !     Test if we have T1-transformed on file ! inquire ( file = 'g_t1_bcia' , exist = vvov_t1_on_file ) ! if ( vvov_t1_on_file . and . wf % tasks % current . ne . 'ground_state' ) then ! call wf % read_t1_vv_ov_electronic_repulsion ( x_vv_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) ! else ! !        Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !        Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ab_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_ic_J , length_3 * length_4 , wf % n_J ) ! !        Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ab ( L_ab_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ia ( L_ic_J , index3_first , index3_last , index4_first , index4_last ) ! !        Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ab_J , & length_1 * length_2 , & L_ic_J , & length_3 * length_4 , & zero , & x_vv_ov , & length_1 * length_2 ) ! !        Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ab_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_ic_J , length_3 * length_4 , wf % n_J ) ! endif ! end subroutine get_vv_ov_electronic_repulsion_ccs ! ! module subroutine get_vo_vv_electronic_repulsion_ccs ( wf , x_vo_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_vo,vv integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_vo,vv (ordered as g_vo_vv) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! !!    Note: in an excited state calculation, the T1-transformed integrals !!    will be read from a file containing the vv_vo integrals. This involves !!    both reading & reordering, thus requiring twice the memory: 2 * v&#94;3 * o. !! !!    To minimize the number of wasteful reads from file, batching should be in !!    the third index, i.e. the capitalized letter in: g_vo_Vv. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vo_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ai_J , L_bc_J ! real ( dp ), dimension (:,:), allocatable :: x_vv_vo ! g_ab_ci, for reading from file integer ( i15 ) :: I = 0 , J = 0 ! logical :: t1_vvvo_on_file = . false . ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Check if the t1-transformed integrals are on file ! inquire ( file = 'g_t1_abci' , exist = t1_vvvo_on_file ) ! if ( t1_vvvo_on_file . and . wf % tasks % current . ne . 'ground_state' ) then ! !        Read the integrals from file ! call wf % mem % alloc ( x_vv_vo , length_3 * length_4 , length_1 * length_2 ) ! call wf % read_t1_vv_vo_electronic_repulsion ( x_vv_vo , & index3_first , index3_last , & index4_first , index4_last , & index1_first , index1_last , & index2_first , index2_last ) ! !        Place the integrals in the correct positions ! do I = 1 , length_1 * length_2 do J = 1 , length_3 * length_4 ! x_vo_vv ( I , J ) = x_vv_vo ( J , I ) ! enddo enddo ! call wf % mem % dealloc ( x_vv_vo , length_3 * length_4 , length_1 * length_2 ) ! else ! !        Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ai_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_bc_J , length_3 * length_4 , wf % n_J ) ! !        Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ai ( L_ai_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ab ( L_bc_J , index3_first , index3_last , index4_first , index4_last ) ! !        Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ai_J , & length_1 * length_2 , & L_bc_J , & length_3 * length_4 , & zero , & x_vo_vv , & length_1 * length_2 ) ! !        Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ai_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_bc_J , length_3 * length_4 , wf % n_J ) ! endif ! end subroutine get_vo_vv_electronic_repulsion_ccs ! ! module subroutine get_vv_vo_electronic_repulsion_ccs ( wf , x_vv_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_vv,vo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_vv,vo (ordered as g_vv_vo) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vv_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ab_J , L_ci_J ! logical :: t1_vvvo_on_file = . false . ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Check if the t1-transformed integrals are on file ! inquire ( file = 'g_t1_abci' , exist = t1_vvvo_on_file ) ! if ( t1_vvvo_on_file . and . wf % tasks % current . ne . 'ground_state' ) then ! !        Read the integrals from file ! call wf % read_t1_vv_vo_electronic_repulsion ( x_vv_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) ! else ! !        Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ab_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_ci_J , length_3 * length_4 , wf % n_J ) ! !        Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ab ( L_ab_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ai ( L_ci_J , index3_first , index3_last , index4_first , index4_last ) ! !        Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ab_J , & length_1 * length_2 , & L_ci_J , & length_3 * length_4 , & zero , & x_vv_vo , & length_1 * length_2 ) ! !        Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ab_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_ci_J , length_3 * length_4 , wf % n_J ) ! endif ! end subroutine get_vv_vo_electronic_repulsion_ccs ! ! ! module subroutine get_vv_vv_electronic_repulsion_ccs ( wf , x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_vv,vv integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_vv,vv (ordered as g_vv_vv) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vv_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ab_J , L_cd_J ! integer ( i15 ) :: ab = 0 , cd = 0 ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! logical :: vvvv_on_file = . false . logical :: t1_vvvv_on_file = . false . ! real ( dp ) :: begin_timer , end_timer ! inquire ( file = 'g_abcd' , exist = vvvv_on_file ) inquire ( file = 'g_t1_abcd' , exist = t1_vvvv_on_file ) ! if ( vvvv_on_file ) then ! !        Read x_vv_vv ! call cpu_time ( begin_timer ) ! call wf % read_vv_vv_electronic_repulsion ( x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! !         write(unit_output,'(t6,a27,f14.8)') 'Read abcd (seconds):', end_timer-begin_timer ! endif ! !        T1-transform x_vv_vv ! call cpu_time ( begin_timer ) ! call wf % t1_transform_vv_vv ( x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! !         write(unit_output,'(t6,a27,f14.8)') 't1-transform (seconds):', end_timer-begin_timer ! endif ! elseif ( t1_vvvv_on_file . and . wf % tasks % current . ne . 'ground_state' ) then ! !        Read x_vv_vv ! call cpu_time ( begin_timer ) ! call wf % read_t1_vv_vv_electronic_repulsion ( x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! !         write(unit_output,'(t6,a27,f14.8)') 'Read t1 abcd (seconds):', end_timer-begin_timer ! endif ! else ! !        Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !        Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ab_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_cd_J , length_3 * length_4 , wf % n_J ) ! !        Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ab ( L_ab_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ab ( L_cd_J , index3_first , index3_last , index4_first , index4_last ) ! !        Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ab_J , & length_1 * length_2 , & L_cd_J , & length_3 * length_4 , & zero , & x_vv_vv , & length_1 * length_2 ) ! !        Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ab_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_cd_J , length_3 * length_4 , wf % n_J ) ! endif ! end subroutine get_vv_vv_electronic_repulsion_ccs ! ! module subroutine read_vv_vv_electronic_repulsion_ccs ( wf , x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Read vvvv Electronic Repulsion (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Reads the non-T1-transformed g_abcd integrals from file, !!    with indices a,b,c and d restricted as requested. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vv_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! !     Temporary vector for holding parts of integral ! real ( dp ), dimension (:,:), allocatable :: x_v ! g_a_bcd, a = 1, n_v, for given bcd ! !     File handling integers ! integer ( i15 ) :: unit_g_abcd = - 1 ! g_abcd, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling integer ( i15 ) :: rec_number = - 1 ! The record where g_abcd is positioned ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 , ab = 0 , cd = 0 , bcd = 0 , acd = 0 ! !     Index lengths ! integer ( i15 ) :: length_a = 0 , length_b = 0 , length_c = 0 , length_d = 0 ! !     Calculate lengths of indices a,b,c,d ! length_a = index1_last - index1_first + 1 length_b = index2_last - index2_first + 1 length_c = index3_last - index3_first + 1 length_d = index4_last - index4_first + 1 ! !     Open file containing the g_abcd integrals, ordered as !     g_a_bcd, where the compound cd index is packed. ! !     The compound index (b, cd_packed) determines the record number, !     where the record includes the integrals g(a,bcd), a = 1, n_v ! call generate_unit_identifier ( unit_g_abcd ) open ( unit = unit_g_abcd , file = 'g_abcd' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) then ! write ( unit_output , * ) 'Error: could not open file g_abcd in read_vv_vv_electronic_repulsion_ccs' stop ! endif ! !     Allocate the integral x_v the integrals g_a_bcd for a given bcd, a = 1, n_v ! call wf % mem % alloc ( x_v , wf % n_v , 1 ) x_v = zero ! if ( length_a . ne . wf % n_v ) then ! Batching over first index, a ! if ( length_b . ne . wf % n_v ) then ! Batching over second index, b, as well ! !           No simple tricks available. Read all integrals g_a_bcd, a = 1, n_v, into x_v, then through away! ! do d = index4_first , index4_last do c = index3_first , index3_last do b = index2_first , index2_last ! bcd = index_two ( b , index_packed ( c , d ), wf % n_v ) ! Record number ! !                    Read g_a_bcd, a = 1, n_v, into x_v ! x_v = zero read ( unit_g_abcd , rec = bcd , iostat = ioerror ) ( x_v ( a , 1 ), a = 1 , wf % n_v ) ! !                    Place the integral into x_vv_vv = g_ab_cd ! cd = index_two ( c - index3_first + 1 , & d - index4_first + 1 , & index3_last - index3_first + 1 ) ! do a = index1_first , index1_last ! ab = index_two ( a - index1_first + 1 , & b - index2_first + 1 , & index1_last - index1_first + 1 ) ! x_vv_vv ( ab , cd ) = x_v ( a , 1 ) ! enddo ! enddo enddo enddo ! else ! Batching over first but not second index => pretend a is b to avoid reading more than necessary ! !           Pretend first index is second index (switch a and b, such that batching is over b): !           Read g_b_acd, b = 1, n_v, into x_v ! do d = index4_first , index4_last do c = index3_first , index3_last do a = index1_first , index1_last ! acd = index_two ( a , index_packed ( c , d ), wf % n_v ) ! Record number ! !                    Read g_b_acd, b = 1, n_v, into x_v ! read ( unit_g_abcd , rec = acd , iostat = ioerror ) ( x_v ( b , 1 ), b = 1 , wf % n_v ) ! !                    Place the integral into x_vv_vv = g_ab_cd ! cd = index_two ( c - index3_first + 1 , & d - index4_first + 1 , & index3_last - index3_first + 1 ) ! do b = index2_first , index2_last ! ab = index_two ( a - index1_first + 1 , & b - index2_first + 1 , & index1_last - index1_first + 1 ) ! x_vv_vv ( ab , cd ) = x_v ( b , 1 ) ! g_abcd ! enddo ! enddo enddo enddo ! endif ! else ! No batching over first index ! do d = 1 , length_d do c = 1 , length_c do b = 1 , length_b ! bcd = index_two ( b + index2_first - 1 , index_packed ( c , d ), wf % n_v ) ! Record number ! !                 Read g_a_bcd, a = 1, n_v, into x_v ! read ( unit_g_abcd , rec = bcd , iostat = ioerror ) ( x_v ( a , 1 ), a = 1 , wf % n_v ) ! !                 Place the integral into x_vv_vv = g_ab_cd ! cd = index_two ( c , d , length_c ) ! do a = 1 , length_a ! ab = index_two ( a , b , length_a ) ! x_vv_vv ( ab , cd ) = x_v ( a + index1_first - 1 , 1 ) ! enddo ! enddo enddo enddo ! endif ! !     Deallocate temporary vector ! call wf % mem % dealloc ( x_v , wf % n_v , 1 ) ! !     Close file containing the g_abcd integrals ! close ( unit_g_abcd ) ! end subroutine read_vv_vv_electronic_repulsion_ccs ! ! module subroutine read_t1_vv_vv_electronic_repulsion_ccs ( wf , x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Read T1 vvvv Electronic Repulsion (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Reads the T1-transformed g_abcd integrals from file, !!    with indices a,b,c and d restricted as requested. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vv_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! !     Temporary vector for holding parts of integral ! real ( dp ), dimension (:,:), allocatable :: x_v ! g_a_bcd, a = 1, n_v, for given bcd ! !     File handling integers ! integer ( i15 ) :: unit_g_t1_abcd = - 1 ! g_abcd, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling integer ( i15 ) :: rec_number = - 1 ! The record where g_abcd is positioned ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 , ab = 0 , cd = 0 , bcd = 0 , acd = 0 ! !     Index lengths ! integer ( i15 ) :: length_a = 0 , length_b = 0 , length_c = 0 , length_d = 0 ! !     Calculate lengths of indices a,b,c,d ! length_a = index1_last - index1_first + 1 length_b = index2_last - index2_first + 1 length_c = index3_last - index3_first + 1 length_d = index4_last - index4_first + 1 ! !     Open file containing the g_abcd integrals, ordered as !     g_a_bcd, where bcd index is unpakced ! !     The compound index bcd determines the record number, !     where the record includes the integrals g(a,bcd), a = 1, n_v ! call generate_unit_identifier ( unit_g_t1_abcd ) open ( unit = unit_g_t1_abcd , file = 'g_t1_abcd' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) then ! write ( unit_output , * ) 'Error: could not open file g_t1_abcd in read_t1_vv_vv_electronic_repulsion_ccs' stop ! endif ! !     Allocate the integral x_v the integrals g_a_bcd for a given bcd, a = 1, n_v ! call wf % mem % alloc ( x_v , wf % n_v , 1 ) x_v = zero ! if ( length_a . ne . wf % n_v ) then ! Batching over first index, a ! if ( length_b . ne . wf % n_v ) then ! Batching over second index, b, as well ! !           No simple tricks available. Read all integrals g_a_bcd, a = 1, n_v, into x_v, then through away! ! do d = index4_first , index4_last do c = index3_first , index3_last do b = index2_first , index2_last ! bcd = index_three ( b , c , d , wf % n_v , wf % n_v ) ! Record number ! !                    Read g_a_bcd, a = 1, n_v, into x_v ! x_v = zero read ( unit_g_t1_abcd , rec = bcd , iostat = ioerror ) ( x_v ( a , 1 ), a = 1 , wf % n_v ) ! !                    Place the integral into x_vv_vv = g_ab_cd ! cd = index_two ( c - index3_first + 1 , & d - index4_first + 1 , & index3_last - index3_first + 1 ) ! do a = index1_first , index1_last ! ab = index_two ( a - index1_first + 1 , & b - index2_first + 1 , & index1_last - index1_first + 1 ) ! x_vv_vv ( ab , cd ) = x_v ( a , 1 ) ! enddo ! enddo enddo enddo ! else ! Batching over first but not second index => pretend a is b to avoid reading more than necessary ! !           Pretend first index is second index (switch a and b, such that batching is over b): !           Read g_b_acd, b = 1, n_v, into x_v ! do d = index4_first , index4_last do c = index3_first , index3_last do a = index1_first , index1_last ! acd = index_three ( a , c , d , wf % n_v , wf % n_v ) ! Record number ! !                    Read g_b_acd, b = 1, n_v, into x_v ! read ( unit_g_t1_abcd , rec = acd , iostat = ioerror ) ( x_v ( b , 1 ), b = 1 , wf % n_v ) ! !                    Place the integral into x_vv_vv = g_ab_cd ! cd = index_two ( c - index3_first + 1 , & d - index4_first + 1 , & index3_last - index3_first + 1 ) ! do b = index2_first , index2_last ! ab = index_two ( a - index1_first + 1 , & b - index2_first + 1 , & index1_last - index1_first + 1 ) ! x_vv_vv ( ab , cd ) = x_v ( b , 1 ) ! g_abcd ! enddo ! enddo enddo enddo ! endif ! else ! No batching over first index ! do d = 1 , length_d do c = 1 , length_c do b = 1 , length_b ! bcd = index_three ( b + index2_first - 1 , c , d , wf % n_v , wf % n_v ) ! Record number ! !                 Read g_a_bcd, a = 1, n_v, into x_v ! read ( unit_g_t1_abcd , rec = bcd , iostat = ioerror ) ( x_v ( a , 1 ), a = 1 , wf % n_v ) ! !                 Place the integral into x_vv_vv = g_ab_cd ! cd = index_two ( c , d , length_c ) ! do a = 1 , length_a ! ab = index_two ( a , b , length_a ) ! x_vv_vv ( ab , cd ) = x_v ( a + index1_first - 1 , 1 ) ! enddo ! enddo enddo enddo ! endif ! !     Deallocate temporary vector ! call wf % mem % dealloc ( x_v , wf % n_v , 1 ) ! !     Close file containing the g_abcd integrals ! close ( unit_g_t1_abcd ) ! end subroutine read_t1_vv_vv_electronic_repulsion_ccs ! ! module subroutine get_oo_oo_electronic_repulsion_ccs ( wf , x_oo_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_oo,oo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_oo,oo (ordered as g_oo_oo) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_oo_oo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ij_J , L_kl_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ij_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_kl_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ij ( L_ij_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ij ( L_kl_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ij_J , & length_1 * length_2 , & L_kl_J , & length_3 * length_4 , & zero , & x_oo_oo , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ij_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_kl_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_oo_oo_electronic_repulsion_ccs ! ! module subroutine get_oo_ov_electronic_repulsion_ccs ( wf , x_oo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_oo,ov integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_oo,ov (ordered as g_oo_ov) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_oo_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ij_J , L_ka_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ij_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_ka_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ij ( L_ij_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ia ( L_ka_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ij_J , & length_1 * length_2 , & L_ka_J , & length_3 * length_4 , & zero , & x_oo_ov , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ij_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_ka_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_oo_ov_electronic_repulsion_ccs ! ! module subroutine get_ov_oo_electronic_repulsion_ccs ( wf , x_ov_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_ov,oo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_ov,oo (ordered as g_ov_oo) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_ov_oo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ia_J , L_jk_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ia_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_jk_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ia ( L_ia_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ij ( L_jk_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ia_J , & length_1 * length_2 , & L_jk_J , & length_3 * length_4 , & zero , & x_ov_oo , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ia_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_jk_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_ov_oo_electronic_repulsion_ccs ! ! module subroutine get_oo_vo_electronic_repulsion_ccs ( wf , x_oo_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_oo,vo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_oo,vo (ordered as g_oo_vo) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_oo_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ij_J , L_ak_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ij_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_ak_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ij ( L_ij_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ai ( L_ak_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ij_J , & length_1 * length_2 , & L_ak_J , & length_3 * length_4 , & zero , & x_oo_vo , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ij_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_ak_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_oo_vo_electronic_repulsion_ccs ! ! module subroutine get_vo_oo_electronic_repulsion_ccs ( wf , x_vo_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_vo,oo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_vooo (ordered as g_vo_oo) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vo_oo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ai_J , L_jk_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ai_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_jk_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ai ( L_ai_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ij ( L_jk_J ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ai_J , & length_1 * length_2 , & L_jk_J , & length_3 * length_4 , & zero , & x_vo_oo , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ai_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_jk_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_vo_oo_electronic_repulsion_ccs ! ! module subroutine get_oo_vv_electronic_repulsion_ccs ( wf , x_oo_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_oo,vv integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_oo,vv (ordered as g_oo_vv) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_oo_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ij_J , L_ab_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ij_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_ab_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ij ( L_ij_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ab ( L_ab_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ij_J , & length_1 * length_2 , & L_ab_J , & length_3 * length_4 , & zero , & x_oo_vv , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ij_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_ab_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_oo_vv_electronic_repulsion_ccs ! ! module subroutine get_vv_oo_electronic_repulsion_ccs ( wf , x_vv_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_vv,oo integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_vv,oo (ordered as g_vv_oo) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vv_oo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ab_J , L_ij_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ab_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_ij_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ab ( L_ab_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ij ( L_ij_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ab_J , & length_1 * length_2 , & L_ij_J , & length_3 * length_4 , & zero , & x_vv_oo , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ab_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_ij_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_vv_oo_electronic_repulsion_ccs ! ! module subroutine get_ov_ov_electronic_repulsion_ccs ( wf , x_ov_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Get g_ov,ov integral (CCS), !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep. 2017. !! !!    Construct two-electron repulsion integral g_ov,ov (ordered as g_ov_ov) !! !!    Parameters !! !!    index1_first, index1_last, !!    index2_first, index2_last, !!    index3_first, index3_last  and !!    index4_first, index4_last !! !!    are used to restrict indices of the integral. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_ov_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ia_J , L_jb_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! !     Lengths ! length_1 = index1_last - index1_first + 1 length_2 = index2_last - index2_first + 1 length_3 = index3_last - index3_first + 1 length_4 = index4_last - index4_first + 1 ! !     Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ia_J , length_1 * length_2 , wf % n_J ) call wf % mem % alloc ( L_jb_J , length_3 * length_4 , wf % n_J ) ! !     Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ia ( L_ia_J , index1_first , index1_last , index2_first , index2_last ) call wf % get_cholesky_ia ( L_jb_J , index3_first , index3_last , index4_first , index4_last ) ! !     Construct integral ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ia_J , & length_1 * length_2 , & L_jb_J , & length_3 * length_4 , & zero , & x_ov_ov , & length_1 * length_2 ) ! !     Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ia_J , length_1 * length_2 , wf % n_J ) call wf % mem % dealloc ( L_jb_J , length_3 * length_4 , wf % n_J ) ! end subroutine get_ov_ov_electronic_repulsion_ccs ! ! module subroutine t1_transform_vv_vv_ccs ( wf , g_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       T1 transformation of g_vv_vv integrals (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Oct 2017. !! !!       g_ab_cd_T1 = g_ab_cd - sum_(J) sum_(i) t_a_i * L_ib_J * L_cd_J !!                            - sum_(J) sum_(k) t_c_k * L_kd_J * L_ab_J !!                            + sum_(J) sum_(ki) t_a_i * t_c_k * L_kd_J * L_ib_J !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: g_vv_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 , ab = 0 , cd = 0 , dc = 0 , i = 0 , j = 0 ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! real ( dp ), dimension (:,:), allocatable :: L_ib_J , L_dk_J , L_cd_J , L_ab_J real ( dp ), dimension (:,:), allocatable :: x_ib_dk , x_ib_dc , x_ib_cd , x_ab_dk real ( dp ), dimension (:,:), allocatable :: g_ab_dc , g_ab_cd ! length_1 = index1_last - index1_first + 1 ! a length_2 = index2_last - index2_first + 1 ! b length_3 = index3_last - index3_first + 1 ! c length_4 = index4_last - index4_first + 1 ! d ! !     Test if we are batching ! if (( length_1 . eq . wf % n_v ) . and . ( length_2 . eq . wf % n_v ) . and . & ( length_3 . eq . wf % n_v ) . and . ( length_4 . eq . wf % n_v ) ) then !        We are NOT batching ! !        :: Term 1 and 2 :: ! !         - sum_(J) sum_(i) t_a_i * L_ib_J * L_cd_J - sum_(J) sum_(k) t_c_k * L_ab_J * L_kd_J !        = - sum_(J) sum_(i) (t_a_i * L_ib_J * L_cd_J -  t_c_i * L_ab_J * L_id_J) !        = - sum_(i) (t_a_i * x_ib_cd -  t_c_i * x_id_ab) !        = - g_ab_cd - g_cd_ab ! ! call wf % mem % alloc ( L_ib_J , ( wf % n_o ) * length_2 , wf % n_J ) call wf % mem % alloc ( L_cd_J , length_3 * length_4 , wf % n_J ) ! call wf % read_cholesky_ia ( L_ib_J , 1 , wf % n_o , index2_first , index2_last ) call wf % read_cholesky_ab ( L_cd_J , index3_first , index3_last , index4_first , index4_last ) ! call wf % mem % alloc ( x_ib_cd , wf % n_o * length_2 , length_3 * length_4 ) ! !        x_ib_cd = sum_(J) L_ib_J * L_cd_J ! call dgemm ( 'N' , 'T' , & wf % n_o * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ib_J , & wf % n_o * length_2 , & L_cd_J , & length_3 * length_4 , & zero , & x_ib_cd , & wf % n_o * length_2 ) ! call wf % mem % dealloc ( L_cd_J , length_3 * length_4 , wf % n_J ) ! !        g_ab_cd -= sum_(i)t_a_i* x_ib_cd ! call wf % mem % alloc ( g_ab_cd , length_1 * length_2 , length_3 * length_4 ) call dgemm ( 'N' , 'N' , & length_1 , & length_2 * length_4 * length_3 , & wf % n_o , & - one , & wf % t1am ( index1_first , 1 ), & ! t_a_i wf % n_v , & x_ib_cd , & wf % n_o , & zero , & g_ab_cd , & ! g_a_bcd length_1 ) ! call wf % mem % dealloc ( x_ib_cd , wf % n_o * length_2 , length_3 * length_4 ) ! !        Add to g_vv_vv !        g_vv_vv = - g_ab_cd(ab, cd) - g_ab_cd(cd, ab) ! !$omp parallel do schedule(static) private(a,c,d,ab,cd) do b = 1 , length_2 do a = 1 , length_1 ab = index_two ( a , b , length_1 ) do d = 1 , length_4 do c = 1 , length_3 cd = index_two ( c , d , length_3 ) g_vv_vv ( ab , cd ) = g_vv_vv ( ab , cd ) + g_ab_cd ( ab , cd ) + g_ab_cd ( cd , ab ) enddo enddo enddo enddo !$omp end parallel do ! call wf % mem % dealloc ( g_ab_cd , length_1 * length_2 , length_3 * length_4 ) ! !        :: Term 3 :: ! !          sum_(ik) t_a_i * t_c_k * (sum_(J) L_ib_J * L_kd_J) ! call wf % mem % alloc ( L_dk_J , wf % n_o * length_4 , wf % n_J ) ! call wf % read_cholesky_ai ( L_dk_J , index4_first , index4_last , 1 , wf % n_o ) call wf % mem % alloc ( x_ib_dk , wf % n_o * length_2 , wf % n_o * length_4 ) ! !        x_ib_dk = sum_(J)L_ib_J * L_dk_J ! call dgemm ( 'N' , 'T' , & wf % n_o * length_2 , & wf % n_o * length_4 , & wf % n_J , & one , & L_ib_J , & wf % n_o * length_2 , & L_dk_J , & wf % n_o * length_4 , & zero , & x_ib_dk , & wf % n_o * length_2 ) ! call wf % mem % dealloc ( L_dk_J , wf % n_o * length_4 , wf % n_J ) call wf % mem % dealloc ( L_ib_J , wf % n_o * length_2 , wf % n_J ) ! call wf % mem % alloc ( x_ib_dc , wf % n_o * length_2 , length_4 * length_3 ) ! !        x_ib_dc = sum_(k)t_c_k * x_ib_dk ! call dgemm ( 'N' , 'T' , & wf % n_o * length_2 * length_4 , & length_3 , & wf % n_o , & one , & x_ib_dk , & wf % n_o * length_2 * length_4 , & wf % t1am ( index3_first , 1 ), & ! t_c_k wf % n_v , & zero , & x_ib_dc , & wf % n_o * length_2 * length_4 ) ! call wf % mem % dealloc ( x_ib_dk , wf % n_o * length_2 , wf % n_o * length_4 ) ! !        g_ab_dc += sum_(i) t_a_i * x_ib_dc ! call wf % mem % alloc ( g_ab_dc , length_1 * length_2 , length_4 * length_3 ) ! call dgemm ( 'N' , 'N' , & length_1 , & length_2 * length_4 * length_3 , & wf % n_o , & one , & wf % t1am ( index1_first , 1 ), & ! t_a_i wf % n_v , & x_ib_dc , & wf % n_o , & zero , & ! g_a_bdc g_ab_dc , & length_1 ) ! call wf % mem % dealloc ( x_ib_dc , wf % n_o * length_2 , length_4 * length_3 ) ! !        g_vv_vv = g_ab_cd(ab, cd) += g_ab_dc(ab, dc) ! !$omp parallel do schedule(static) private(d,cd,dc) do c = 1 , length_3 do d = 1 , length_4 ! cd = index_two ( c , d , length_3 ) dc = index_two ( d , c , length_4 ) ! g_vv_vv (:, cd ) = g_vv_vv (:, cd ) + g_ab_dc (:, dc ) ! enddo enddo !$omp end parallel do ! call wf % mem % dealloc ( g_ab_dc , length_1 * length_2 , length_4 * length_3 ) ! else ! !        We are batching ! !        ::Term 1:: !        - sum_(J) sum_(i) t_a_i * L_ib_J * L_cd_J ! call wf % mem % alloc ( L_ib_J , ( wf % n_o ) * length_2 , wf % n_J ) call wf % mem % alloc ( L_cd_J , length_3 * length_4 , wf % n_J ) ! call wf % read_cholesky_ia ( L_ib_J , 1 , wf % n_o , index2_first , index2_last ) call wf % read_cholesky_ab ( L_cd_J , index3_first , index3_last , index4_first , index4_last ) ! call wf % mem % alloc ( x_ib_cd , wf % n_o * length_2 , length_3 * length_4 ) ! !        x_ib_cd = sum_(J) L_ib_J * L_cd_J ! call dgemm ( 'N' , 'T' , & wf % n_o * length_2 , & length_3 * length_4 , & wf % n_J , & one , & L_ib_J , & wf % n_o * length_2 , & L_cd_J , & length_3 * length_4 , & zero , & x_ib_cd , & wf % n_o * length_2 ) ! call wf % mem % dealloc ( L_cd_J , length_3 * length_4 , wf % n_J ) ! !        g_vv_vv = g_ab_cd -= sum_(i)t_a_i* x_ib_cd ! call dgemm ( 'N' , 'N' , & length_1 , & length_2 * length_4 * length_3 , & wf % n_o , & - one , & wf % t1am ( index1_first , 1 ), & ! t_a_i wf % n_v , & x_ib_cd , & wf % n_o , & one , & g_vv_vv , & ! g_a_bcd length_1 ) ! call wf % mem % dealloc ( x_ib_cd , wf % n_o * length_2 , length_3 * length_4 ) ! !        :: Term 2 and 3 :: !        - sum_(J) sum_(k) t_c_k * L_ab_J * L_kd_J !          sum_(ik) t_a_i * t_c_k * (sum_(J) L_ib_J * L_kd_J) ! call wf % mem % alloc ( L_dk_J , wf % n_o * length_4 , wf % n_J ) call wf % mem % alloc ( L_ab_J , length_1 * length_2 , wf % n_J ) ! call wf % read_cholesky_ai ( L_dk_J , index4_first , index4_last , 1 , wf % n_o ) call wf % read_cholesky_ab ( L_ab_J , index1_first , index1_last , index2_first , index2_last ) ! call wf % mem % alloc ( x_ab_dk , length_1 * length_2 , wf % n_o * length_4 ) ! !        x_ab_dk = sum_(J)L_ab_J * L_dk_J ! call dgemm ( 'N' , 'T' , & length_1 * length_2 , & wf % n_o * length_4 , & wf % n_J , & one , & L_ab_J , & length_1 * length_2 , & L_dk_J , & wf % n_o * length_4 , & zero , & x_ab_dk , & length_1 * length_2 ) ! !        g_ab_dc = - sum_(k)t_c_k * x_ab_dk ! call wf % mem % alloc ( g_ab_dc , length_1 * length_2 , length_4 * length_3 ) ! call dgemm ( 'N' , 'T' , & length_1 * length_2 * length_4 ,& length_3 , & wf % n_o , & - one , & x_ab_dk , & length_1 * length_2 * length_4 ,& wf % t1am ( index3_first , 1 ), & ! t_c_k wf % n_v , & zero , & g_ab_dc , & length_1 * length_2 * length_4 ) ! call wf % mem % dealloc ( x_ab_dk , length_1 * length_2 , wf % n_o * length_4 ) ! call wf % mem % alloc ( x_ib_dk , wf % n_o * length_2 , wf % n_o * length_4 ) ! !        x_ib_dk = sum_(J)L_ib_J * L_dk_J ! call dgemm ( 'N' , 'T' , & wf % n_o * length_2 , & wf % n_o * length_4 , & wf % n_J , & one , & L_ib_J , & wf % n_o * length_2 , & L_dk_J , & wf % n_o * length_4 , & zero , & x_ib_dk , & wf % n_o * length_2 ) ! call wf % mem % dealloc ( L_dk_J , wf % n_o * length_4 , wf % n_J ) call wf % mem % dealloc ( L_ib_J , wf % n_o * length_2 , wf % n_J ) ! call wf % mem % alloc ( x_ib_dc , wf % n_o * length_2 , length_4 * length_3 ) ! !        x_ib_dc = sum_(k)t_c_k * x_ib_dk ! call dgemm ( 'N' , 'T' , & wf % n_o * length_2 * length_4 , & length_3 , & wf % n_o , & one , & x_ib_dk , & wf % n_o * length_2 * length_4 , & wf % t1am ( index3_first , 1 ), & ! t_c_k wf % n_v , & zero , & x_ib_dc , & wf % n_o * length_2 * length_4 ) ! call wf % mem % dealloc ( x_ib_dk , wf % n_o * length_2 , wf % n_o * length_4 ) ! !        g_ab_dc += sum_(i) t_a_i * x_ib_dc ! call dgemm ( 'N' , 'N' , & length_1 , & length_2 * length_4 * length_3 , & wf % n_o , & one , & wf % t1am ( index1_first , 1 ), & ! t_a_i wf % n_v , & x_ib_dc , & wf % n_o , & one , & g_ab_dc , & length_1 ) ! call wf % mem % dealloc ( x_ib_dc , wf % n_o * length_2 , length_4 * length_3 ) ! !        g_vv_vv = g_ab_cd(ab, cd) += g_ab_dc(ab, dc) ! do c = 1 , length_3 do d = 1 , length_4 ! cd = index_two ( c , d , length_3 ) dc = index_two ( d , c , length_4 ) ! g_vv_vv (:, cd ) = g_vv_vv (:, cd ) + g_ab_dc (:, dc ) ! enddo enddo ! call wf % mem % dealloc ( g_ab_dc , length_1 * length_2 , length_4 * length_3 ) ! endif ! end subroutine t1_transform_vv_vv_ccs ! ! module subroutine store_vv_vv_electronic_repulsion_ccs ( wf ) !! !!    Store vvvv Electronic Repulsion !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Tests whether it is possible to store vir-vir-vir-vir integrals and, !!    if possible, writes the integrals to disk !! implicit none ! class ( ccs ) :: wf ! integer :: required_space real ( dp ) :: required_space_gb ! integer ( i15 ) :: unit_g_abcd = - 1 ! g_abcd, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling integer ( i15 ) :: rec_number = - 1 ! The record where g_abcd is positioned ! !     Batching variables ! integer ( i15 ) :: required_mem = - 1 integer ( i15 ) :: available_mem = - 1 ! integer ( i15 ) :: b_first = 0 , b_last = 0 , b_length = 0 , b_max_length = 0 , b_batch = 0 , b_n_batch = 0 integer ( i15 ) :: d_first = 0 , d_last = 0 , d_length = 0 , d_max_length = 0 , d_batch = 0 ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 , bcd = 0 , cd_packed = 0 , I = 0 , bcd_nonpacked = 0 ! real ( dp ) :: begin_timer , end_timer ! !     Cholesky vectors ! real ( dp ), dimension (:,:), allocatable :: L_ab_J real ( dp ), dimension (:,:), allocatable :: L_cd_J ! !     The electronic repulsion integral ! real ( dp ), dimension (:,:), allocatable :: g_a_bcd ! g_abcd ! !     Calculate the disk space (in GB) required to store the vir-vir-vir-vir integrals ! required_space = (( wf % n_v ** 3 ) * ( wf % n_v + 1 )) / 2 ! !     This is the required space in number of double precision numbers (8 bytes per such number). !     We convert this number to gigabytes. ! required_space = 8 * required_space ! in bytes ! required_space_gb = real ( required_space ) * ( 1.0D-9 ) ! !     Test whether there is room for the integrals & save if this is the case ! if ( required_space_gb . lt . wf % settings % disk_space ) then ! !        Prints ! if ( wf % settings % print_level == 'developer' ) write ( unit_output , '(/t3,a36)' ) 'Integrals g_abcd are stored on disk.' call cpu_time ( begin_timer ) ! !        Open file for writing integrals - one record: (a, bcd) = (1:n_v, bcd) ! call generate_unit_identifier ( unit_g_abcd ) open ( unit = unit_g_abcd , file = 'g_abcd' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ), iostat = ioerror ) ! !        In calculating g_ab_cd, we will batch over the b and d indices ! required_mem = max ( 2 * ( wf % n_v ) ** 2 * ( wf % n_J ) + 4 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & ! Needed to get L_ab_J & L_cd_J ( wf % n_v ) ** 4 + 2 * ( wf % n_v ) ** 2 * ( wf % n_J )) ! Needed to get g_ac_bd ! required_mem = 4 * required_mem available_mem = get_available () ! b_max_length = 0 call num_two_batch ( required_mem , available_mem , b_max_length , b_n_batch , wf % n_v ) ! do b_batch = 1 , b_n_batch ! Batch over b index ! call batch_limits ( b_first , b_last , b_batch , b_max_length , wf % n_v ) b_length = b_last - b_first + 1 ! !           Start looping over batches of d ! d_first = 0 d_last = 0 d_length = 0 ! d_max_length = b_max_length ! call wf % mem % alloc ( L_ab_J , ( wf % n_v ) * b_length , wf % n_J ) call wf % read_cholesky_ab ( L_ab_J , 1 , wf % n_v , b_first , b_last ) ! do d_batch = 1 , b_batch ! Batch over d index; restricted by b index ! call batch_limits ( d_first , d_last , d_batch , d_max_length , wf % n_v ) d_length = d_last - d_first + 1 ! !              Calculate the integrals g_ab_cd, where b and d are restricted by !              the current batching limits ! call wf % mem % alloc ( L_cd_J , ( wf % n_v ) * d_length , wf % n_J ) ! call wf % read_cholesky_ab ( L_cd_J , 1 , wf % n_v , d_first , d_last ) ! call wf % mem % alloc ( g_a_bcd , ( wf % n_v ), b_length * ( wf % n_v ) * d_length ) ! call dgemm ( 'N' , 'T' , & ( wf % n_v ) * b_length , & ( wf % n_v ) * d_length , & wf % n_J , & one , & L_ab_J , & ( wf % n_v ) * b_length , & L_cd_J , & ( wf % n_v ) * d_length , & zero , & g_a_bcd , & ! g_ab_cd ( wf % n_v ) * b_length ) ! call wf % mem % dealloc ( L_cd_J , ( wf % n_v ) * d_length , wf % n_J ) ! !              Save the integrals to disk ! do d = 1 , d_length do c = 1 , wf % n_v do b = 1 , b_length ! !                       Calculate record number ! cd_packed = index_packed ( c , d + d_first - 1 ) bcd = index_two ( b + b_first - 1 , cd_packed , wf % n_v ) ! Packed index! bcd_nonpacked = index_three ( b , c , d , b_length , wf % n_v ) ! Nonpacked index! ! if ( c . ge . ( d + d_first - 1 )) then ! !                          Write integrals to that record ! write ( unit_g_abcd , rec = bcd ) ( g_a_bcd ( I , bcd_nonpacked ), I = 1 , wf % n_v ) ! endif ! enddo enddo enddo ! call wf % mem % dealloc ( g_a_bcd , ( wf % n_v ), b_length * ( wf % n_v ) * d_length ) ! enddo ! End of batches over d ! call wf % mem % dealloc ( L_ab_J , ( wf % n_v ) * b_length , wf % n_J ) ! enddo ! End of batches over b ! !        Test for file handling error ! if ( ioerror . ne . 0 ) then ! write ( unit_output , '(t3,a)' ) 'Error: write error in store_electronic_repulsion_integrals_ccs' stop ! endif ! !        Close file ! close ( unit_g_abcd ) ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! write ( unit_output , '(t3,a36,f14.8)' ) 'Time to store g_abcd (seconds):     ' , end_timer - begin_timer flush ( unit_output ) ! endif ! endif ! end subroutine store_vv_vv_electronic_repulsion_ccs ! ! module subroutine store_t1_vv_vv_electronic_repulsion_ccs ( wf ) !! !!    Store t1 vvvv Electronic Repulsion Integrals !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Tests whether it is possible to store t1-transformed vir-vir-vir-vir integrals and, !!    if possible, writes the integrals to disk !! implicit none ! class ( ccs ) :: wf ! integer :: required_space real ( dp ) :: required_space_gb ! integer ( i15 ) :: unit_g_abcd = - 1 ! g_abcd, non-transformed integer ( i15 ) :: unit_g_t1_abcd = - 1 ! g_abcd, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling integer ( i15 ) :: rec_number = - 1 ! The record where g_abcd is positioned ! !     Batching variables ! integer ( i15 ) :: required_mem = - 1 integer ( i15 ) :: available_mem = - 1 ! integer ( i15 ) :: b_first = 0 , b_last = 0 , b_length = 0 , b_max_length = 0 , b_batch = 0 , b_n_batch = 0 integer ( i15 ) :: d_first = 0 , d_last = 0 , d_length = 0 , d_max_length = 0 , d_batch = 0 ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 , bcd = 0 , cd_packed = 0 , I = 0 , bcd_nonpacked = 0 ! real ( dp ) :: begin_timer , end_timer ! !     Cholesky vectors ! real ( dp ), dimension (:,:), allocatable :: L_ab_J real ( dp ), dimension (:,:), allocatable :: L_cd_J ! !     The electronic repulsion integral ! real ( dp ), dimension (:,:), allocatable :: g_a_bcd ! g_abcd ! !     Calculate the disk space (in GB) required to store the vir-vir-vir-vir integrals ! required_space = ( wf % n_v ) ** 4 ! !     This is the required space in number of double precision numbers (8 bytes per such number). !     We convert this number to gigabytes. ! required_space = 8 * required_space ! in bytes ! required_space_gb = real ( required_space ) * ( 1.0D-9 ) ! !     Test whether there is room for the integrals & save if this is the case ! if ( required_space_gb . lt . wf % settings % disk_space ) then ! !        Open and delete file containing non-transformed integrals - if it exists, of course ! call generate_unit_identifier ( unit_g_abcd ) open ( unit = unit_g_abcd , file = 'g_abcd' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ), iostat = ioerror ) close ( unit = unit_g_abcd , status = 'delete' ) ! call cpu_time ( begin_timer ) ! !        Open file for writing integrals - one record: (a, bcd) = (1:n_v, bcd) ! call generate_unit_identifier ( unit_g_t1_abcd ) open ( unit = unit_g_t1_abcd , file = 'g_t1_abcd' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ), iostat = ioerror ) ! !        In calculating g_ab_cd, we will batch over the b and d indices ! required_mem = max ( 2 * ( wf % n_v ) ** 2 * ( wf % n_J ) + 4 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & ! Needed to get L_ab_J & L_cd_J ( wf % n_v ) ** 4 + 2 * ( wf % n_v ) ** 2 * ( wf % n_J )) ! Needed to get g_ac_bd ! required_mem = 4 * required_mem available_mem = get_available () ! b_max_length = 0 call num_two_batch ( required_mem , available_mem , b_max_length , b_n_batch , wf % n_v ) ! do b_batch = 1 , b_n_batch ! Batch over b index ! call batch_limits ( b_first , b_last , b_batch , b_max_length , wf % n_v ) b_length = b_last - b_first + 1 ! !           Start looping over batches of d ! d_first = 0 d_last = 0 d_length = 0 ! d_max_length = b_max_length ! call wf % mem % alloc ( L_ab_J , ( wf % n_v ) * b_length , wf % n_J ) call wf % get_cholesky_ab ( L_ab_J , 1 , wf % n_v , b_first , b_last ) ! do d_batch = 1 , b_batch ! Batch over d index; restricted by b index ! call batch_limits ( d_first , d_last , d_batch , d_max_length , wf % n_v ) d_length = d_last - d_first + 1 ! !              Calculate the integrals g_ab_cd, where b and d are restricted by !              the current batching limits ! call wf % mem % alloc ( L_cd_J , ( wf % n_v ) * d_length , wf % n_J ) ! call wf % get_cholesky_ab ( L_cd_J , 1 , wf % n_v , d_first , d_last ) ! call wf % mem % alloc ( g_a_bcd , ( wf % n_v ), b_length * ( wf % n_v ) * d_length ) ! call dgemm ( 'N' , 'T' , & ( wf % n_v ) * b_length , & ( wf % n_v ) * d_length , & wf % n_J , & one , & L_ab_J , & ( wf % n_v ) * b_length , & L_cd_J , & ( wf % n_v ) * d_length , & zero , & g_a_bcd , & ! g_ab_cd ( wf % n_v ) * b_length ) ! call wf % mem % dealloc ( L_cd_J , ( wf % n_v ) * d_length , wf % n_J ) ! !              Save the integrals to disk ! do d = 1 , d_length do c = 1 , wf % n_v do b = 1 , b_length ! !                       Calculate record number ! bcd_nonpacked = index_three ( b , c , d , b_length , wf % n_v ) ! Nonpacked index ! !                       Write integrals to that record ! write ( unit_g_t1_abcd , rec = bcd_nonpacked ) ( g_a_bcd ( I , bcd_nonpacked ), I = 1 , wf % n_v ) ! enddo enddo enddo ! call wf % mem % dealloc ( g_a_bcd , ( wf % n_v ), b_length * ( wf % n_v ) * d_length ) ! enddo ! End of batches over d ! call wf % mem % dealloc ( L_ab_J , ( wf % n_v ) * b_length , wf % n_J ) ! enddo ! End of batches over b ! !        Test for file handling error ! if ( ioerror . ne . 0 ) write ( unit_output , '(t3,a)' ) 'Error: write error in store_t1_vv_vv_electronic_repulsion_integrals_ccs' ! !        Close file ! close ( unit_g_t1_abcd ) ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! write ( unit_output , '(t6,a39,f14.8)' ) 'Time used to store t1 g_abcd (seconds):' , end_timer - begin_timer flush ( unit_output ) ! endif ! endif ! end subroutine store_t1_vv_vv_electronic_repulsion_ccs ! ! module subroutine store_t1_vo_ov_electronic_repulsion_ccs ( wf ) !! !!    Store t1 voov Electronic Repulsion (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Tests whether it is possible to store t1-transformed vir-occ-occ-vir integrals and, !!    if possible, writes the integrals to disk !! implicit none ! class ( ccs ) :: wf ! integer :: required_space real ( dp ) :: required_space_gb ! integer ( i15 ) :: unit_g_t1_aijb = - 1 ! g_abcd, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling ! real ( dp ) :: begin_timer , end_timer ! !     Integral ! real ( dp ), dimension (:,:), allocatable :: g_ai_jb real ( dp ), dimension (:,:), allocatable :: L_jb_J real ( dp ), dimension (:,:), allocatable :: L_ai_J ! character ( len = 40 ) :: integral_type ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 integer ( i15 ) :: jb = 0 ! !     Disk space required to store g_vo_ov ! required_space = (( wf % n_v ) ** 2 ) * (( wf % n_o ) ** 2 ) ! !     This is the required space in number of double precision numbers (8 bytes per such number). !     We convert this number to gigabytes. ! required_space = 8 * required_space ! in bytes ! !     Required in giga bytes ! required_space_gb = real ( required_space ) * ( 1.0D-9 ) ! !     Test whether there is room for the integrals & save if this is the case ! if ( required_space_gb . lt . wf % settings % disk_space ) then ! call cpu_time ( begin_timer ) ! call wf % mem % alloc ( g_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !        Alllocate Cholesky vectors ! call wf % mem % alloc ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % mem % alloc ( L_jb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ai ( L_ai_J ) call wf % get_cholesky_ia ( L_jb_J ) ! !        Construct integral ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & L_jb_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ai_jb , & ( wf % n_o ) * ( wf % n_v )) ! !        Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % mem % dealloc ( L_jb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Open file for writing integrals - record (ai), record length (n_o)*(n_v) (bj) ! call generate_unit_identifier ( unit_g_t1_aijb ) open ( unit = unit_g_t1_aijb , file = 'g_t1_aijb' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * (( wf % n_v ) * ( wf % n_o )), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) & 'Error: error while opening file in store_t1_vo_ov_electronic_repulsion_ccs' , ioerror ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! !                 Calculate record number ! ai = index_two ( a , i , wf % n_v ) ! !                 Write integrals to that record ! write ( unit_g_t1_aijb , rec = ai , iostat = ioerror ) ( g_ai_jb ( ai , jb ), jb = 1 , wf % n_v * wf % n_o ) ! enddo enddo ! if ( ioerror . ne . 0 ) write ( unit_output , '(t3,a)' ) & 'Error: write error in store_t1_vo_ov_electronic_repulsion_integrals_ccs' ! call wf % mem % dealloc ( g_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! write ( unit_output , '(t6,a39,f14.8)' ) 'Time used to store t1 g_aijb (seconds):' , end_timer - begin_timer flush ( unit_output ) ! endif close ( unit_g_t1_aijb ) ! endif ! end subroutine store_t1_vo_ov_electronic_repulsion_ccs ! ! module subroutine store_t1_vv_vo_electronic_repulsion_ccs ( wf ) !! !!    Store t1 vvvo Electronic Repulsion (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Tests whether it is possible to store t1-transformed vir-vir-vir-occ integrals and, !!    if possible, writes the integrals to disk !! implicit none ! class ( ccs ) :: wf ! integer :: required_space real ( dp ) :: required_space_gb ! integer ( i15 ) :: unit_g_t1_abci = - 1 ! g_abic, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling ! integer ( i15 ) :: required_mem = 0 , available_mem = 0 , a_batch = 0 , bci = 0 , a_full = 0 , a = 0 , b = 0 , ci = 0 integer ( i15 ) :: a_n_batch = 0 , a_max_length = 0 , a_length = 0 , a_first = 0 , a_last = 0 , ab_rec = 0 , ab = 0 ! real ( dp ) :: begin_timer , end_timer ! !     Integral ! real ( dp ), dimension (:,:), allocatable :: g_ab_ci ! character ( len = 40 ) :: integral_type ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 integer ( i15 ) :: jb = 0 ! !     Disk space required to store g_vo_vv ! required_space = (( wf % n_v ) ** 3 ) * (( wf % n_o ) ** 2 ) ! !     This is the required space in number of double precision numbers (8 bytes per such number). !     We convert this number to gigabytes. ! required_space = 8 * required_space ! in bytes ! !     Required in giga bytes ! required_space_gb = real ( required_space ) * ( 1.0D-9 ) ! !     Test whether there is room for the integrals & save if this is the case ! if ( required_space_gb . lt . wf % settings % disk_space ) then ! call cpu_time ( begin_timer ) ! !        Open file for writing integrals ! call generate_unit_identifier ( unit_g_t1_abci ) open ( unit = unit_g_t1_abci , file = 'g_t1_abci' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * (( wf % n_o ) * ( wf % n_v )), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , * ) & 'Error: error while opening file in store_t1_vv_vo_electronic_repulsion_ccs' , ioerror ! !        In calculating g_ab_ic, we will batch over the a index ! required_mem = max (( wf % n_v ) ** 2 * ( wf % n_J ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & ! Needed to get L_ab_J (( wf % n_v ) ** 3 ) * ( wf % n_o ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J )) ! Needed to get g_ab_ci ! required_mem = 4 * required_mem available_mem = get_available () ! a_max_length = 0 call num_two_batch ( required_mem , available_mem , a_max_length , a_n_batch , wf % n_v ) ! do a_batch = 1 , a_n_batch ! Batch over a index ! call batch_limits ( a_first , a_last , a_batch , a_max_length , wf % n_v ) a_length = a_last - a_first + 1 call wf % mem % alloc ( g_ab_ci , a_length * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call wf % get_vv_vo_electronic_repulsion ( g_ab_ci , a_first , a_last , 1 , wf % n_v , 1 , wf % n_v , 1 , wf % n_o ) ! do a = 1 , a_length do b = 1 , wf % n_v ! !                 Calculate record number ! a_full = a + a_first - 1 ab_rec = index_two ( a_full , b , wf % n_v ) ! !                 Calculate ab index for (possibly restricted) g_ab_ci integral ! ab = index_two ( a , b , a_length ) ! !                 Write integrals to that record ! write ( unit_g_t1_abci , rec = ab_rec , iostat = ioerror ) ( g_ab_ci ( ab , ci ), ci = 1 , ( wf % n_o ) * ( wf % n_v )) ! enddo enddo ! if ( ioerror . ne . 0 ) write ( unit_output , '(t3,a)' ) & 'Error: write error in store_t1_vv_vo_electronic_repulsion_integrals_ccs' ! call wf % mem % dealloc ( g_ab_ci , a_length * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! enddo ! End of batches over a ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! write ( unit_output , '(t6,a39,f14.8)' ) 'Time used to store t1 g_abci (seconds):' , end_timer - begin_timer flush ( unit_output ) ! endif close ( unit_g_t1_abci ) ! endif ! end subroutine store_t1_vv_vo_electronic_repulsion_ccs ! ! module subroutine read_t1_vo_ov_electronic_repulsion_ccs ( wf , x_vo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Read t1 voov Electronic Repulsion Integrals !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Reads the T1-transformed vir-occ-occ-vir integrals from file. !! !!    g_t1_ai_jb is written such that we have full flexibility with respect to ai indices. However, get_vo_ov_ccs has !!    full flexibility wrt. all indices and we must check wether b and j are full space or not !!    (they will presumably always be full space indices). !! implicit none ! class ( ccs ) :: wf ! !     Integral ! real ( dp ), dimension (:,:) :: x_vo_ov ! ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! integer ( i15 ) :: unit_g_t1_aijb = - 1 ! g_abcd, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling ! real ( dp ) :: begin_timer , end_timer ! real ( dp ), dimension (:,:), allocatable :: g_ai_jb_full ! character ( len = 40 ) :: integral_type ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 integer ( i15 ) :: b = 0 , j = 0 , jb = 0 , jb_full = 0 ! integer ( i15 ) :: length_a = 0 , length_i = 0 , length_j = 0 , length_b = 0 ! !     Lengths ! length_a = index1_last - index1_first + 1 length_i = index2_last - index2_first + 1 length_j = index3_last - index3_first + 1 length_b = index4_last - index4_first + 1 ! call cpu_time ( begin_timer ) ! !     Open file for reading integrals - record (ai), record length (n_o)*(n_v) (bj) ! call generate_unit_identifier ( unit_g_t1_aijb ) open ( unit = unit_g_t1_aijb , file = 'g_t1_aijb' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * (( wf % n_v ) * ( wf % n_o )), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , '(t3,a)' ) & 'Error: error while opening file in read_t1_vo_ov_electronic_repulsion_ccs' ! !     Check if length_b = wf%n_v and length_j = wf%n_o -> this will usually be the case ! if ( length_b . eq . wf % n_v . and . length_j . eq . wf % n_o ) then ! do a = 1 , length_a do i = 1 , length_i ! !              Calculate record number ! ai = index_two ( a + index1_first - 1 , i + index2_first - 1 , wf % n_v ) ! !              Write integrals to that record ! read ( unit_g_t1_aijb , rec = ai , iostat = ioerror ) ( x_vo_ov ( ai , jb ), jb = 1 , ( wf % n_v ) * ( wf % n_o )) ! enddo enddo ! else ! -> Unlikely to happen ! !        Must limit jb index, will first read for all jb's ! call wf % mem % alloc ( g_ai_jb_full , length_a * length_i , ( wf % n_v ) * ( wf % n_o )) ! do a = 1 , length_a do i = 1 , length_i ! !              Calculate record number ! ai = index_two ( a + index1_first - 1 , i + index2_first - 1 , wf % n_v ) ! !              Write integrals to that record ! read ( unit_g_t1_aijb , rec = ai , iostat = ioerror ) ( g_ai_jb_full ( ai , jb ), jb = 1 , ( wf % n_v ) * ( wf % n_o )) ! enddo enddo ! !        Then sort away jb elements not required - pretty sure we will never be used ! do j = 1 , length_j do b = 1 , length_b ! jb_full = index_two ( j + index3_first - 1 , b + index4_first - 1 , wf % n_o ) jb = index_two ( j , b , length_j ) ! x_vo_ov (:, jb ) = g_ai_jb_full (:, jb_full ) ! enddo enddo ! call wf % mem % dealloc ( g_ai_jb_full , length_a * length_i , ( wf % n_v ) * ( wf % n_o )) ! endif ! if ( ioerror . ne . 0 ) write ( unit_output , '(t3,a)' ) & 'Error: read error in read_t1_vo_ov_electronic_repulsion_integrals_ccs' close ( unit_g_t1_aijb ) ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! ! write(unit_output,'(t3,a39,f14.8)') 'Time used to read t1 g_aijb (seconds):', end_timer - begin_timer ! flush(unit_output) ! endif ! end subroutine read_t1_vo_ov_electronic_repulsion_ccs ! ! module subroutine store_t1_vv_ov_electronic_repulsion_ccs ( wf ) !! !!    Store t1 ovvv Electronic Repulsion Integrals !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Tests whether it is possible to store t1-transformed occ-vir-vir-vir integrals and, !!    if possible, writes the integrals to disk !! implicit none ! class ( ccs ) :: wf ! integer :: required_space real ( dp ) :: required_space_gb ! integer ( i15 ) :: unit_g_t1_bcia = - 1 ! g_abcd, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling integer ( i15 ) :: rec_number = - 1 ! The record where g_abcd is positioned ! real ( dp ) :: begin_timer , end_timer ! !     Batching variables ! integer ( i15 ) :: required_mem = - 1 integer ( i15 ) :: available_mem = - 1 ! integer ( i15 ) :: b_first = 0 , b_last = 0 , b_length = 0 , b_max_length = 0 , b_batch = 0 , b_n_batch = 0 ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , bc = 0 , ia = 0 , record_number = 0 ! !     The electronic repulsion integral ! real ( dp ), dimension (:,:), allocatable :: g_bc_ia ! g_iabc real ( dp ), dimension (:,:), allocatable :: L_bc_J real ( dp ), dimension (:,:), allocatable :: L_ia_J ! !     Calculate the disk space (in GB) required to store the occ-vir-vir-vir integrals ! required_space = (( wf % n_v ) ** 3 ) * ( wf % n_o ) ! !     This is the required space in number of double precision numbers (8 bytes per such number). !     We convert this number to gigabytes. ! required_space = 8 * required_space ! in bytes ! required_space_gb = real ( required_space ) * ( 1.0D-9 ) ! !     Test whether there is room for the integrals & save if this is the case ! if ( required_space_gb . lt . wf % settings % disk_space ) then ! !        Begin timings ! call cpu_time ( begin_timer ) ! !        Open file for writing integrals - one record ! call generate_unit_identifier ( unit_g_t1_bcia ) open ( unit = unit_g_t1_bcia , file = 'g_t1_bcia' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) * ( wf % n_o ), iostat = ioerror ) ! !        In calculating g_ab_cd, we will batch over the b and d indices ! required_mem = max ( 2 * ( wf % n_v ) ** 2 * ( wf % n_J ) + 4 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & ! Needed to get L_ia_J & L_bc_J ( wf % n_v ) ** 3 * ( wf % n_o ) + ( wf % n_v ) ** 2 * ( wf % n_J ) + ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J )) ! Needed to get g_ia_bc ! required_mem = 4 * required_mem available_mem = get_available () ! b_max_length = 0 call num_batch ( required_mem , available_mem , b_max_length , b_n_batch , wf % n_v ) ! do b_batch = 1 , b_n_batch ! Batch over b index ! call batch_limits ( b_first , b_last , b_batch , b_max_length , wf % n_v ) b_length = b_last - b_first + 1 ! call wf % mem % alloc ( g_bc_ia , b_length * ( wf % n_v ), ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % alloc ( L_bc_J , b_length * ( wf % n_v ), wf % n_J ) call wf % mem % alloc ( L_ia_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) ! !        Get T1-transformed Cholesky vectors ! call wf % get_cholesky_ab ( L_bc_J , b_first , b_last , 1 , wf % n_v ) call wf % get_cholesky_ia ( L_ia_J ) ! !        Construct integral ! call dgemm ( 'N' , 'T' , & b_length * ( wf % n_v ), & ( wf % n_v ) * ( wf % n_o ), & wf % n_J , & one , & L_bc_J , & b_length * ( wf % n_v ), & L_ia_J , & ( wf % n_v ) * ( wf % n_o ), & zero , & g_bc_ia , & b_length * ( wf % n_v )) ! !        Deallocate Cholesky vectors ! call wf % mem % dealloc ( L_bc_J , b_length * ( wf % n_v ), wf % n_J ) call wf % mem % dealloc ( L_ia_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) ! !           Save the integrals to disk ! do b = b_first , b_last do c = 1 , wf % n_v ! !                 Write integrals to that record ! bc = index_two ( b - b_first + 1 , c , b_length ) record_number = index_two ( b , c , wf % n_v ) write ( unit_g_t1_bcia , rec = record_number ) ( g_bc_ia ( bc , ia ), ia = 1 , ( wf % n_v ) * ( wf % n_o )) ! enddo enddo ! ! enddo ! End of batches over b ! !        Test for file handling error ! if ( ioerror . ne . 0 ) write ( unit_output , '(t3,a)' ) 'Error: write error in store_t1_vv_ov_electronic_repulsion_integrals_ccs' ! !        Close file ! close ( unit_g_t1_bcia ) ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! write ( unit_output , '(t6,a39,f14.8)' ) 'Time used to store t1 g_bcia (seconds):' , end_timer - begin_timer flush ( unit_output ) ! endif ! endif ! end subroutine store_t1_vv_ov_electronic_repulsion_ccs ! ! module subroutine read_t1_vv_ov_electronic_repulsion_ccs ( wf , x_vv_ov ,& index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Read t1 vvov Electronic Repulsion Integrals !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Tests whether it is possible to store t1-transformed vir-vir-occ-vir integrals and, !!    if possible, writes the integrals to disk !! !!    Assumes batching over either b or c, so please don't batch over a because then routine will not work. !! !! implicit none ! class ( ccs ) :: wf ! !     Integral ! real ( dp ), dimension (:,:) :: x_vv_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ) :: begin_timer , end_timer ! integer ( i15 ) :: unit_g_t1_bcia = - 1 ! g_abcd, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling integer ( i15 ) :: rec_number = - 1 ! The record where g_abcd is positioned ! integer ( i15 ) :: length_a = 0 , length_i = 0 , length_c = 0 , length_b = 0 ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , bc = 0 , record_number = 0 , i = 0 , ia = 0 , ia_full = 0 ! real ( dp ), dimension (:,:), allocatable :: g_bc_ia ! !     Lengths ! length_b = index1_last - index1_first + 1 length_c = index2_last - index2_first + 1 length_i = index3_last - index3_first + 1 length_a = index4_last - index4_first + 1 ! !     Begin timings ! call cpu_time ( begin_timer ) ! !     Open file for writing integrals - one record ! call generate_unit_identifier ( unit_g_t1_bcia ) open ( unit = unit_g_t1_bcia , file = 'g_t1_bcia' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_v ) * ( wf % n_o ), iostat = ioerror ) ! do b = index1_first , index1_last do c = index2_first , index2_last ! !           Write integrals to that record ! bc = index_two ( b - index1_first + 1 , c - index2_first + 1 , length_b ) record_number = index_two ( b , c , wf % n_v ) read ( unit_g_t1_bcia , rec = record_number ) ( x_vv_ov ( bc , ia ), ia = 1 , ( wf % n_v ) * ( wf % n_o )) ! enddo enddo ! !     Test for file handling error ! if ( ioerror . ne . 0 ) write ( unit_output , '(t3,a)' ) 'Error: write error in adre_t1_vv_ov_electronic_repulsion_integrals_ccs' ! !     Close file ! close ( unit_g_t1_bcia ) ! end subroutine read_t1_vv_ov_electronic_repulsion_ccs ! ! module subroutine read_t1_vv_vo_electronic_repulsion_ccs ( wf , x_vv_vo ,& index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!    Read t1 vvvo Electronic Repulsion Integrals !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!    Reads the T1-transformed vir-vir-vir-occ integrals from file. !! !!    The integrals are stored on file as (ab,ci) = (ab, :), where a !!    is the record number and : denotes all the bci elements. !! !!    The recommended use is therefore to batch over the a or b index, !!    as this will involve the no wasteful read statements !! implicit none ! class ( ccs ) :: wf ! !     Integral ! real ( dp ), dimension (:,:) :: x_vv_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last integer ( i15 ) :: unit_g_t1_abci = - 1 ! g_abci, electronic repulsion integrals integer ( i15 ) :: ioerror = - 1 ! Error integer for file handling ! real ( dp ) :: begin_timer , end_timer ! real ( dp ), dimension (:,:), allocatable :: g_AB_ci ! Holds the elements AB, ci for a given AB index ! character ( len = 40 ) :: integral_type ! integer ( i15 ) :: a = 0 , a_full = 0 , b_full = 0 , ab_rec = 0 , c = 0 , ci = 0 , i = 0 , ci_full = 0 , b = 0 , ab = 0 ! integer ( i15 ) :: length_a = 0 , length_b = 0 , length_c = 0 , length_i = 0 ! !     Lengths ! length_a = index1_last - index1_first + 1 length_b = index2_last - index2_first + 1 length_c = index3_last - index3_first + 1 length_i = index4_last - index4_first + 1 ! call cpu_time ( begin_timer ) ! !     Open file for reading integrals - record (ai), record length (n_o)*(n_v) (bj) ! call generate_unit_identifier ( unit_g_t1_abci ) open ( unit = unit_g_t1_abci , file = 'g_t1_abci' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * (( wf % n_o ) * ( wf % n_v )), iostat = ioerror ) ! if ( ioerror . ne . 0 ) write ( unit_output , '(t3,a)' ) & 'Error: error while opening file in read_t1_vv_vo_electronic_repulsion_ccs' ! call wf % mem % alloc ( g_AB_ci , 1 , ( wf % n_o ) * ( wf % n_v )) g_AB_ci = zero ! do a = 1 , length_a do b = 1 , length_b ! !           For a given A and B, read into g_AB_ci ! a_full = a + index1_first - 1 b_full = b + index2_first - 1 ! ab_rec = index_two ( a_full , b_full , wf % n_v ) ! read ( unit_g_t1_abci , rec = ab_rec , iostat = ioerror ) ( g_AB_ci ( 1 , ci_full ), ci_full = 1 , ( wf % n_o ) * ( wf % n_v )) ! !           Place the result into the incoming integral array (ab_ci) ! do i = 1 , length_i do c = 1 , length_c ! ci = index_two ( c , i , length_c ) ! ab = index_two ( a , b , length_a ) ! ci_full = index_two ( c + index3_first - 1 , & i + index4_first - 1 , & wf % n_v ) ! x_vv_vo ( ab , ci ) = g_AB_ci ( 1 , ci_full ) ! enddo enddo enddo ! enddo ! End of read loop over a ! call wf % mem % dealloc ( g_AB_ci , 1 , ( wf % n_o ) * ( wf % n_v )) ! if ( ioerror . ne . 0 ) write ( unit_output , '(t3,a)' ) & 'Error: read error in read_t1_vv_vo_electronic_repulsion_integrals_ccs' ! close ( unit_g_t1_abci ) ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! ! write(unit_output,'(t3,a39,f14.8)') 'Time used to read t1 g_abci (seconds):', end_timer - begin_timer ! flush(unit_output) ! endif ! end subroutine read_t1_vv_vo_electronic_repulsion_ccs ! ! end submodule integrals","tags":"","loc":"sourcefile/integrals_submodule.f90.html","title":"integrals_submodule.F90 – The eT program"},{"text":"This File Depends On sourcefile~~hf_class.f90~~EfferentGraph sourcefile~hf_class.f90 hf_class.F90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilehf_classf90EfferentGraph = svgPanZoom('#sourcefilehf_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~hf_class.f90~~AfferentGraph sourcefile~hf_class.f90 hf_class.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~hf_class.f90->sourcefile~et_program.f90 sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mp2_class.f90->sourcefile~et_program.f90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefilehf_classf90AfferentGraph = svgPanZoom('#sourcefilehf_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules hf_class Source Code hf_class.F90 Source Code module hf_class ! !! !!                      Hartree-Fock (HF) class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output use calc_tasks_class use calc_settings_class use ground_state_specs_class use excited_state_specs_class use core_excited_state_specs_class use response_calc_specs_class use memory_manager_class ! implicit none ! !  :::::::::::::::::::::::::::::::::::: !  -::- Definition of the HF class -::- !  :::::::::::::::::::::::::::::::::::: ! type :: hf ! !     Model name ! character ( len = 40 ) :: name = 'HF' ! !     Orbital information variables ! integer ( i15 ) :: n_o ! Number of occupied orbitals integer ( i15 ) :: n_v ! Number of virtual orbitals integer ( i15 ) :: n_ao ! Number of atomic orbitals (AOs) integer ( i15 ) :: n_mo ! Number of molecular orbitals (MOs) integer ( i15 ) :: n_J ! Number of Cholesky vectors ! real ( dp ), dimension (:,:), allocatable :: mo_coef ! MO coefficient matrix ! !     Fock matrix variables ! real ( dp ), dimension (:,:), allocatable :: fock_diagonal ! diagonal vector ! !     Energy variables ! real ( dp ) :: energy ! Same as scf_energy for HF class, different for descendants ! real ( dp ) :: nuclear_potential ! Nuclear potential energy term real ( dp ) :: scf_energy ! The Hartree-Fock (HF/SCF) energy ! !     Calculation settings, tasks, and implemented methods ! type ( calc_settings ) :: settings ! type ( calc_tasks ) :: tasks type ( calc_tasks ) :: implemented ! type ( ground_state_specs ) :: ground_state_specifications type ( excited_state_specs ) :: excited_state_specifications type ( core_excited_state_specs ) :: core_excited_state_specifications type ( response_calc_specs ) :: response_specifications ! !     Memory manager ! type ( memory_manager ) :: mem ! contains ! !     Initialization and driver routines ! procedure :: init => init_hf procedure :: drv => drv_hf ! !     Routines to read MO Cholesky vectors from file ! procedure , non_overridable :: read_cholesky_ij => read_cholesky_ij_hf ! occ-occ procedure , non_overridable :: read_cholesky_ia => read_cholesky_ia_hf ! occ-vir procedure , non_overridable :: read_cholesky_ai => read_cholesky_ai_hf ! vir-occ procedure , non_overridable :: read_cholesky_ab => read_cholesky_ab_hf ! vir-vir ! !     Routines needed to initialize HF ! !     read_info                      : sets variables from file (n_o, n_v, scf_energy,...) !     cholesky_density_decomposition : orbital localization routine !     read_transform_cholesky        : reads AO Cholesky vectors, transforms to MO, and saves to file ! procedure , non_overridable :: read_hf_info => read_hf_info_hf procedure , non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure , non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure , non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure , non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure , non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure , non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf ! end type hf ! ! contains ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::- Initialization and driver routines -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! subroutine init_hf ( wf ) !! !!    Initialization of Hartree-Fock object !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Performs the following tasks: !! !!    1. Sets HF orbital and energy information by reading from file !!    2. Transforms AO Cholesky vectors to MO basis and saves to file !! implicit none ! class ( hf ) :: wf ! !     Initialize HF variables ! call wf % read_hf_info ! !     Initialize Cholesky vectors ! call wf % read_transform_cholesky ! end subroutine init_hf ! ! subroutine drv_hf ( wf ) !! !!    Driver (HF) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Lets the user know there is no driver for Hartree-Fock and exits !!    the program if called. The module reads Hartree-Fock information !!    from files and contains no independent solver. !! implicit none ! class ( hf ) :: wf ! write ( unit_output , * ) 'Error: There is no driver for the Hartree-Fock class.' stop ! end subroutine drv_hf ! !  ::::::::::::::::::::::::::::::::::::::::: !  -::- Class subroutines and functions -::- !  ::::::::::::::::::::::::::::::::::::::::: ! subroutine read_hf_info_hf ( wf ) !! !!    Read HF Info !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the file mlcc_hf_info and sets the following HF variables: !!    n_o, n_v, n_mo, orbital_coef, and the fock_diagonal. !! !!    The file mlcc_hf_info is written in the mlcc_write_sirifc !!    subroutine, which is called from the wr_sirifc subroutine in !!    the siropt module of the DALTON suite. !! implicit none ! class ( hf ) :: wf ! integer ( i15 ) :: unit_hf = - 1 ! Unit identifier for mlcc_hf_info file ! integer ( i15 ) :: n_lambda = 0 ! n_ao * n_mo, read but discarded integer ( i15 ) :: i = 0 , j = 0 ! !     Open the file mlcc_hf_info ! call generate_unit_identifier ( unit_hf ) open ( unit = unit_hf , file = 'MLCC_HF_INFO' , status = 'old' , form = 'formatted' ) rewind ( unit_hf ) ! !     Read mlcc_hf_info into HF variables ! read ( unit_hf , * ) wf % n_mo , wf % n_o , n_lambda , & wf % nuclear_potential , wf % scf_energy ! !     Set the energy equal to the read SCF energy ! wf % energy = wf % scf_energy ! !     Calculate the number of virtuals ! wf % n_v = wf % n_mo - wf % n_o ! !     Allocate the Fock diagonal and the MO coefficients ! call wf % mem % alloc ( wf % fock_diagonal , wf % n_mo , 1 ) wf % fock_diagonal = zero ! call wf % mem % alloc ( wf % mo_coef , n_lambda , 1 ) wf % mo_coef = zero ! !     Read in the Fock diagonal and MO coefficients ! read ( unit_hf , * ) ( wf % fock_diagonal ( i , 1 ), i = 1 , wf % n_mo ) read ( unit_hf , * ) ( wf % mo_coef ( i , 1 ), i = 1 , n_lambda ) wf % n_ao = n_lambda / wf % n_mo ! !     Close the mlcc_hf_info file ! close ( unit_hf ) ! end subroutine read_hf_info_hf ! ! subroutine read_transform_cholesky_hf ( wf ) !! !!    Read and Transform Cholesky !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, 20 Apr 2017 !! !!    Reads the AO Cholesky vectors from file, transforms the vectors !!    to the MO basis, and saves the MO vectors to file !! implicit none ! class ( hf ) :: wf ! integer ( i15 ) :: unit_chol_ao = - 1 ! Unit identifier for mlcc_cholesky file integer ( i15 ) :: unit_chol_mo_ij = - 1 ! cholesky_ij file integer ( i15 ) :: unit_chol_mo_ia = - 1 ! cholesky_ia file integer ( i15 ) :: unit_chol_mo_ab = - 1 ! cholesky_ab file integer ( i15 ) :: unit_chol_mo_ij_direct = - 1 ! cholesky_ij direct access file integer ( i15 ) :: unit_chol_mo_ia_direct = - 1 ! cholesky_ia direct access file integer ( i15 ) :: unit_chol_mo_ab_direct = - 1 ! cholesky_ab direct access file integer ( i15 ) :: ioerror = 0 integer ( i15 ) :: throw_away_index = 0 real ( dp ) :: throw_away ! integer ( i15 ) :: n_ao_sq_packed = 0 ! Packed dimensionality of (n_ao x n_ao) matrix ! real ( dp ), dimension (:,:), allocatable :: chol_ao ! Packed AO Cholesky vector real ( dp ), dimension (:,:), allocatable :: chol_ao_sq ! Unpacked AO Cholesky vector real ( dp ), dimension (:,:), allocatable :: chol_mo_sq ! Unpacked MO Cholesky vector ! real ( dp ), dimension (:,:), allocatable :: X ! An intermediate matrix real ( dp ), dimension (:,:), allocatable :: L_ij_J real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: L_ab_J ! integer ( i15 ) :: i , j , a , b , k , ij , ia , ab ! !     Timing variables ! real ( dp ) :: begin_timer , end_timer ! !     Batching variables ! integer ( i15 ) :: b_batch = 0 , b_first = 0 , b_last = 0 , b_length = 0 integer ( i15 ) :: required = 0 , available = 0 , n_batch = 0 , batch_dimension = 0 integer ( i15 ) :: max_batch_length = 0 ! call cpu_time ( begin_timer ) ! !     Open Dalton file mlcc_cholesky (see mlcc_write_cholesky.F) ! call generate_unit_identifier ( unit_chol_ao ) open ( unit = unit_chol_ao , file = 'MLCC_CHOLESKY' , status = 'old' , form = 'formatted' , iostat = ioerror ) if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'Erorr while opening file mlcc_cholesky. Error code' , ioerror flush ( unit_output ) endif rewind ( unit_chol_ao ) ! !     Read the number of Cholesky vectors (n_J) and !     the number of atomic orbitals (n_ao) ! read ( unit_chol_ao , * ) wf % n_ao , wf % n_J ! !     Open files for MO Cholesky vectors ! call generate_unit_identifier ( unit_chol_mo_ij ) call generate_unit_identifier ( unit_chol_mo_ia ) call generate_unit_identifier ( unit_chol_mo_ab ) ! open ( unit_chol_mo_ij , file = 'cholesky_ij' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ij ) ! open ( unit_chol_mo_ia , file = 'cholesky_ia' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ia ) ! open ( unit_chol_mo_ab , file = 'cholesky_ab' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ab ) ! !     Allocate packed and unpacked Cholesky AO, and !     unpacked Cholesky MO vectors ! n_ao_sq_packed = packed_size ( wf % n_ao ) ! call wf % mem % alloc ( chol_ao , n_ao_sq_packed , 1 ) call wf % mem % alloc ( chol_ao_sq , wf % n_ao , wf % n_ao ) call wf % mem % alloc ( chol_mo_sq , wf % n_mo , wf % n_mo ) ! chol_ao = zero chol_ao_sq = zero chol_mo_sq = zero ! !     Allocate an intermediate, X ! call wf % mem % alloc ( X , wf % n_ao , wf % n_mo ) ! X = zero ! !     Loop over the number of Cholesky vectors, !     reading them one by one ! do j = 1 , wf % n_J ! !        Read Cholesky AO vector ! read ( unit_chol_ao , * ) ( chol_ao ( i , 1 ), i = 1 , n_ao_sq_packed ) ! !        Unpack/square up AO vector ! call squareup ( chol_ao , chol_ao_sq , wf % n_ao ) ! !        Transform the AO vectors to form the Cholesky MO vectors ! call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_mo , & wf % n_ao , & one , & chol_ao_sq , & wf % n_ao , & wf % mo_coef , & wf % n_ao , & zero , & X , & wf % n_ao ) ! call dgemm ( 'T' , 'N' , & wf % n_mo , & wf % n_mo , & wf % n_ao , & one , & wf % mo_coef , & wf % n_ao , & X , & wf % n_ao , & zero , & chol_mo_sq , & wf % n_mo ) ! !        Write the MO vectors to files in blocks ! write ( unit_chol_mo_ij ) (( chol_mo_sq ( i , k ), k = 1 , i ), i = 1 , wf % n_o ) write ( unit_chol_mo_ia ) (( chol_mo_sq ( i , a ), i = 1 , wf % n_o ), a = wf % n_o + 1 , wf % n_mo ) write ( unit_chol_mo_ab ) (( chol_mo_sq ( a , b ), b = wf % n_o + 1 , a ), a = wf % n_o + 1 , wf % n_mo ) ! enddo ! !     Close files ! close ( unit_chol_ao ) close ( unit_chol_mo_ij ) close ( unit_chol_mo_ia ) close ( unit_chol_mo_ab ) ! !     Rewrite to direct access file, delete sequential file ! !     :: L_ij_J :: ! call generate_unit_identifier ( unit_chol_mo_ij ) open ( unit_chol_mo_ij , file = 'cholesky_ij' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ij ) ! !     Read L_ij_J ! call wf % mem % alloc ( L_ij_J , wf % n_o * ( wf % n_o + 1 ) / 2 , wf % n_J ) do J = 1 , wf % n_J read ( unit_chol_mo_ij ) ( L_ij_J ( ij , J ), ij = 1 , wf % n_o * ( wf % n_o + 1 ) / 2 ) enddo ! !     Close and delete file ! close ( unit_chol_mo_ij , status = 'delete' ) ! call generate_unit_identifier ( unit_chol_mo_ij_direct ) open ( unit = unit_chol_mo_ij_direct , file = 'cholesky_ij_direct' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) ! do i = 1 , wf % n_o do k = 1 , wf % n_o ij = index_packed ( i , k ) write ( unit_chol_mo_ij_direct , rec = ij ) ( L_ij_J ( ij , j ), j = 1 , wf % n_J ) enddo enddo ! call wf % mem % dealloc ( L_ij_J , wf % n_o * ( wf % n_o + 1 ) / 2 , wf % n_J ) close ( unit_chol_mo_ij_direct ) ! !     :: L_ia_J :: ! call generate_unit_identifier ( unit_chol_mo_ia ) open ( unit_chol_mo_ia , file = 'cholesky_ia' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ia ) ! !     Read L_ia_J ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! do J = 1 , wf % n_J read ( unit_chol_mo_ia ) ( L_ia_J ( ia , J ), ia = 1 , ( wf % n_o ) * ( wf % n_v )) enddo ! !     Close and delete file ! close ( unit_chol_mo_ia , status = 'delete' ) ! call generate_unit_identifier ( unit_chol_mo_ia_direct ) open ( unit = unit_chol_mo_ia_direct , file = 'cholesky_ia_direct' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) ! do ia = 1 , wf % n_o * wf % n_v write ( unit_chol_mo_ia_direct , rec = ia ) ( L_ia_J ( ia , j ), j = 1 , wf % n_J ) enddo ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) close ( unit_chol_mo_ia_direct ) ! !     :: L_ab_J :: ! call generate_unit_identifier ( unit_chol_mo_ab ) open ( unit_chol_mo_ab , file = 'cholesky_ab' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ab ) ! call generate_unit_identifier ( unit_chol_mo_ab_direct ) open ( unit = unit_chol_mo_ab_direct , file = 'cholesky_ab_direct' , action = 'write' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while creating cholesky_ab_direct' stop endif ! !     Read L_ab_J in batches over b ! required = (( wf % n_v ) ** 2 ) * ( wf % n_J ) ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index b max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do b_batch = 1 , n_batch ! call batch_limits ( b_first , b_last , b_batch , max_batch_length , batch_dimension ) b_length = b_last - b_first + 1 ! call wf % mem % alloc ( L_ab_J , ((( b_length + 1 ) * b_length / 2 ) + ( wf % n_v - b_length - b_first + 1 ) * b_length ), wf % n_J ) ! if ( b_first . ne . 1 ) then ! !           Calculate index of last element to throw away ! throw_away_index = index_packed ( wf % n_v , b_first - 1 ) ! !           Throw away all elements from 1 to throw_away_index, then read from batch start ! do j = 1 , wf % n_J ! read ( unit_chol_mo_ab ) ( throw_away , i = 1 , throw_away_index ), & ( L_ab_J ( a , j ), a = 1 ,((( b_length + 1 ) * b_length / 2 ) + ( wf % n_v - b_length - b_first + 1 ) * b_length )) ! enddo ! else ! !           Read from the start of each entry ! do j = 1 , wf % n_J ! read ( unit_chol_mo_ab ) ( L_ab_J ( a , j ), a = 1 , ((( b_length + 1 ) * b_length / 2 ) + ( wf % n_v - b_length - b_first + 1 ) * b_length )) ! enddo ! endif ! do a = 1 , wf % n_v do b = b_first , b_last ab = index_packed ( a , b ) write ( unit_chol_mo_ab_direct , rec = ab ) ( L_ab_J ( ab , J ), J = 1 , wf % n_J ) enddo enddo ! call wf % mem % dealloc ( L_ab_J , ((( b_length + 1 ) * b_length / 2 ) + ( wf % n_v - b_length - b_first + 1 ) * b_length ), wf % n_J ) ! enddo close ( unit_chol_mo_ab , status = 'delete' ) close ( unit_chol_mo_ab_direct ) ! !     Print timings ! call cpu_time ( end_timer ) ! if ( wf % settings % print_level == 'developer' ) then ! write ( unit_output , '(/t3,a36,f14.8)' ) 'Time to store Cholesky (seconds):   ' , end_timer - begin_timer flush ( unit_output ) ! endif ! end subroutine read_transform_cholesky_hf ! ! subroutine read_cholesky_ij_hf ( wf , L_ij_J , i_first , i_last , j_first , j_last ) !! !!    Read Cholesky IJ !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky IJ (occ-occ) vectors from file and !!    places them in the incoming L_ij_J matrix !! !!    Optional arguments: i_first, i_last, j_first, j_last can be used in order to restrict indices !! implicit none ! class ( hf ) :: wf integer ( i15 ), optional :: i_first , j_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), optional :: i_last , j_last ! Last index (can differ from n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ij_J ! L_ij&#94;J ! !     Local routine variables ! integer ( i15 ) :: unit_chol_mo_ij = - 1 ! Unit identifier for cholesky_ij file integer ( i15 ) :: ioerror ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 , ij = 0 , ik = 0 , ij_full ! integer ( i15 ) :: i_length , j_length ! number of i and j elements ! ! if ( present ( i_first ) . and . present ( i_last ) . and . present ( j_first ) . and . present ( j_last )) then i_length = i_last - i_first + 1 j_length = j_last - j_first + 1 ! !        Prepare for reading: generate unit idientifier, open file, and rewind ! call generate_unit_identifier ( unit_chol_mo_ij ) open ( unit = unit_chol_mo_ij , file = 'cholesky_ij_direct' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while reading cholesky_ij_direct' stop endif ! !        Read the Cholesky vectors into the L_ij_J matrix ! do i = 1 , i_length do k = 1 , j_length ! ij_full = index_packed (( i + i_first - 1 ), ( k + j_first - 1 )) ! ij = index_two ( i , k , i_length ) ! read ( unit_chol_mo_ij , rec = ij_full ) ( L_ij_J ( ij , j ), j = 1 , wf % n_J ) ! enddo enddo ! !        Close file ! close ( unit_chol_mo_ij ) ! elseif (. not . ( present ( i_first ) . and . present ( i_last ) . and . present ( j_first ) . and . present ( j_last ))) then ! !        Prepare for reading: generate unit idientifier, open file, and rewind ! call generate_unit_identifier ( unit_chol_mo_ij ) open ( unit = unit_chol_mo_ij , file = 'cholesky_ij_direct' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while reading cholesky_ij_direct' stop endif ! !        Read the Cholesky vectors into the L_ij_J matrix ! do i = 1 , wf % n_o do k = 1 , wf % n_o ij = index_two ( i , k , wf % n_o ) ik = index_packed ( i , k ) read ( unit_chol_mo_ij , rec = ik ) ( L_ij_J ( ij , j ), j = 1 , wf % n_J ) enddo enddo ! !        Close file ! close ( unit_chol_mo_ij ) ! else ! write ( unit_output , * ) 'WARNING: Error in call to read_cholesky_ij' stop ! endif ! end subroutine read_cholesky_ij_hf ! ! subroutine read_cholesky_ia_hf ( wf , L_ia_J , i_first , i_last , a_first , a_last ) !! !!    Read Cholesky IA !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky IA (occ-vir) vectors from file and !!    places them in the incoming L_ia_J matrix !! !! !!    Optional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( hf ) :: wf integer ( i15 ), optional :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), optional :: i_last , a_last ! Last index (can differ from n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ia_J ! L_ia&#94;J ! !     Local routine variables ! integer ( i15 ) :: unit_chol_mo_ia = - 1 ! Unit identifier for cholesky_ia file integer ( i15 ) :: ioerror = 0 ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , ia = 0 , ia_full = 0 ! integer ( i15 ) :: i_length , a_length ! if ( present ( i_first ) . and . present ( i_last ) . and . present ( a_first ) . and . present ( a_last )) then i_length = i_last - i_first + 1 a_length = a_last - a_first + 1 ! !        Prepare for reading: generate unit idientifier, open, and rewind file ! call generate_unit_identifier ( unit_chol_mo_ia ) open ( unit = unit_chol_mo_ia , file = 'cholesky_ia_direct' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while reading cholesky_ij_direct' stop endif ! !        Read Cholesky vectors into the L_ia_J matrix ! do i = 1 , i_length do a = 1 , a_length ! ia_full = index_two ( i + i_first - 1 , a + a_first - 1 , wf % n_o ) ia = index_two ( i , a , i_length ) read ( unit_chol_mo_ia , rec = ia_full ) ( L_ia_J ( ia , j ), j = 1 , wf % n_J ) ! enddo enddo ! !        Close file ! close ( unit_chol_mo_ia ) elseif (. not .( present ( i_first ) . and . present ( i_last ) . and . present ( a_first ) . and . present ( a_last ))) then ! !        Prepare for reading: generate unit idientifier, open, and rewind file ! call generate_unit_identifier ( unit_chol_mo_ia ) open ( unit = unit_chol_mo_ia , file = 'cholesky_ia_direct' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while reading cholesky_ij_direct' stop endif ! !        Read Cholesky vectors into the L_ia_J matrix ! do ia = 1 , ( wf % n_v ) * ( wf % n_o ) ! read ( unit_chol_mo_ia , rec = ia ) ( L_ia_J ( ia , j ), j = 1 , wf % n_J ) ! enddo ! !        Close file ! close ( unit_chol_mo_ia ) else write ( unit_output , * ) 'WARNING: Error in call to read_cholesky_ia' stop endif ! end subroutine read_cholesky_ia_hf ! ! subroutine read_cholesky_ai_hf ( wf , L_ai_J , a_first , a_last , i_first , i_last ) !! !!    Read Cholesky AI !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky AI (vir-occ) vectors from file and !!    places them in the incoming L_ai_J matrix !! !!    Optional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( hf ) :: wf integer ( i15 ), optional :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), optional :: i_last , a_last ! Last index (can differ from n_o when batching or for mlcc) real ( dp ), dimension (:, :) :: L_ai_J ! L_ai&#94;J ! !     Local routine variables ! real ( dp ), dimension (:,:), allocatable :: L_ia_J ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , ia = 0 , ai = 0 integer ( i15 ) :: i_length , a_length ! if ( present ( i_first ) . and . present ( i_last ) . and . present ( a_first ) . and . present ( a_last )) then i_length = i_last - i_first + 1 a_length = a_last - a_first + 1 ! !        Allocation ! call wf % mem % alloc ( L_ia_J , i_length * a_length , wf % n_J ) L_ia_J = zero ! !        Get Cholesky IA vector ! call wf % read_cholesky_ia ( L_ia_J , i_first , i_last , a_first , a_last ) ! !        Reorder and save in AI vector ! do i = 1 , i_length do a = 1 , a_length ! !              Needed indices ! ai = index_two ( a , i , a_length ) ia = index_two ( i , a , i_length ) ! do j = 1 , wf % n_J ! L_ai_J ( ai , j ) = L_ia_J ( ia , j ) ! enddo ! enddo enddo ! !        Deallocate temporary vector ! call wf % mem % dealloc ( L_ia_J , a_length * i_length , wf % n_J ) elseif (. not .( present ( i_first ) . and . present ( i_last ) . and . present ( a_first ) . and . present ( a_last ))) then ! !        Allocation ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_ia_J = zero ! !        Get Cholesky IA vector ! call wf % read_cholesky_ia ( L_ia_J ) ! !        Reorder and save in AI vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! !              Needed indices ! ai = index_two ( a , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ! do j = 1 , wf % n_J ! L_ai_J ( ai , j ) = L_ia_J ( ia , j ) ! enddo ! enddo enddo ! !        Deallocate temporary vector ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) else write ( unit_output , * ) 'WARNING: Error in call to read_cholesky_ia' stop endif ! end subroutine read_cholesky_ai_hf ! ! subroutine read_cholesky_ab_hf ( wf , L_ab_J , a_first , a_last , b_first , b_last ) !! !!    Read Cholesky AB !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky AB (vir-vir) vectors from file and !!    places them in the incoming L_ab_J matrix, with batching !!    if necessary !! !!    Optional arguments: b_first, b_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( hf ) :: wf integer ( i15 ), intent ( in ) :: a_first , b_first ! First index (can differ from 1 when batching  or for mlcc) integer ( i15 ), intent ( in ) :: a_last , b_last ! Last index  (can differ from n_v when batching or for mlcc) real ( dp ), dimension ((( a_last - a_first + 1 ) * ( b_last - b_first + 1 )), wf % n_J ) :: L_ab_J ! L_ab&#94;J ! ! integer ( i15 ) :: unit_chol_mo_ab_direct = - 1 ! Unit identifier for cholesky_ab file integer ( i15 ) :: ioerror = 0 ! integer ( i15 ) :: a = 0 , b = 0 , j = 0 , i = 0 , ab = 0 , ab_full = 0 integer ( i15 ) :: a_length , b_length ! a_length = a_last - a_first + 1 b_length = b_last - b_first + 1 ! !     Prepare for reading: generate unit identifier, open, and rewind file ! call generate_unit_identifier ( unit_chol_mo_ab_direct ) open ( unit = unit_chol_mo_ab_direct , file = 'cholesky_ab_direct' , action = 'read' , status = 'unknown' , & access = 'direct' , form = 'unformatted' , recl = dp * ( wf % n_J ), iostat = ioerror ) ! if ( ioerror . ne . 0 ) then write ( unit_output , * ) 'WARNING: error while reading cholesky_ab_direct.' , ioerror stop endif ! do a = 1 , a_length do b = 1 , b_length ab_full = index_packed ( a + a_first - 1 , b + b_first - 1 ) ab = index_two ( a , b , a_length ) read ( unit_chol_mo_ab_direct , rec = ab_full ) ( L_ab_J ( ab , J ), J = 1 , wf % n_J ) enddo enddo ! !        Close file ! close ( unit_chol_mo_ab_direct ) ! ! end subroutine read_cholesky_ab_hf ! subroutine construct_ao_fock_hf ( wf , ao_fock ) !! !! implicit none ! class ( hf ) :: wf real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: ao_fock ! real ( dp ), dimension (:, :), allocatable :: density ! real ( dp ), dimension (:,:), allocatable :: h1ao real ( dp ), dimension (:,:), allocatable :: chol_ao real ( dp ), dimension (:,:), allocatable :: chol_ao_sq real ( dp ), dimension (:,:), allocatable :: g_J_mn_ps real ( dp ), dimension (:,:), allocatable :: L_J_mn_ps ! integer ( i15 ) :: i = 0 , J = 0 , m = 0 , n = 0 , p = 0 , s = 0 integer ( i15 ) :: mn = 0 , ms = 0 , ps = 0 , pn = 0 ! integer ( i15 ) :: unit_identifier_ao_integrals = 0 , unit_chol_ao = 0 ! call wf % mem % alloc ( h1ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) h1ao = zero ! !     Open mlcc_aoint file ! call generate_unit_identifier ( unit_identifier_ao_integrals ) open ( unit = unit_identifier_ao_integrals , file = 'MLCC_AOINT' , status = 'old' , form = 'formatted' ) rewind ( unit_identifier_ao_integrals ) ! !     Read in one-electron AO integrals ! read ( unit_identifier_ao_integrals , * ) ( h1ao ( i , 1 ), i = 1 , wf % n_ao * ( wf % n_ao + 1 ) / 2 ) ! !     Close mlcc_aoint ! close ( unit_identifier_ao_integrals ) ! !     Allocate the AO Fock matrix and add the one-electron contributions ! ao_fock = zero ! call squareup ( h1ao , ao_fock , wf % n_ao ) ! !     Deallocation of one-electron AO integrals ! call wf % mem % dealloc ( h1ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) ! !     Read Cholesky in ao basis ! call generate_unit_identifier ( unit_chol_ao ) open ( unit = unit_chol_ao , file = 'MLCC_CHOLESKY' , status = 'old' , form = 'formatted' ) rewind ( unit_chol_ao ) ! !     Read the number of Cholesky vectors (n_J) and !     the number of atomic orbitals (n_ao) ! read ( unit_chol_ao , * ) wf % n_ao , wf % n_J ! call wf % mem % alloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , wf % n_J ) ! chol_ao = zero ! !        Read Cholesky AO vector ! do j = 1 , wf % n_J read ( unit_chol_ao , * ) ( chol_ao ( i , j ), i = 1 , wf % n_ao * ( wf % n_ao + 1 ) / 2 ) enddo ! ! call wf % mem % alloc ( g_J_mn_ps , ( wf % n_ao ) * ( wf % n_ao + 1 ) / 2 ,( wf % n_ao ) * ( wf % n_ao + 1 ) / 2 ) ! ! call dgemm ( 'N' , 'T' , & wf % n_ao * ( wf % n_ao + 1 ) / 2 , & wf % n_ao * ( wf % n_ao + 1 ) / 2 , & wf % n_J , & one , & chol_ao , & wf % n_ao * ( wf % n_ao + 1 ) / 2 , & chol_ao , & wf % n_ao * ( wf % n_ao + 1 ) / 2 , & zero , & g_J_mn_ps , & wf % n_ao * ( wf % n_ao + 1 ) / 2 ) ! call wf % mem % dealloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , wf % n_J ) call wf % mem % alloc ( density , wf % n_ao , wf % n_ao ) density = zero ! call wf % construct_density_matrix ( density , wf % mo_coef , wf % n_o , wf % n_v ) ! do m = 1 , wf % n_ao do n = 1 , wf % n_ao ! mn = index_packed ( m , n ) ! do p = 1 , wf % n_ao ! pn = index_packed ( p , n ) ! do s = 1 , wf % n_ao ! ms = index_packed ( m , s ) ! ps = index_packed ( p , s ) ! ao_fock ( m , n ) = ao_fock ( m , n ) + ( two * g_J_mn_ps ( mn , ps ) - g_J_mn_ps ( ms , pn )) * density ( p , s ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_J_mn_ps , ( wf % n_ao ) * ( wf % n_ao + 1 ) / 2 ,( wf % n_ao ) * ( wf % n_ao + 1 ) / 2 ) call wf % mem % dealloc ( density , wf % n_ao , wf % n_ao ) ! close ( unit_chol_ao ) close ( unit_identifier_ao_integrals ) ! end subroutine construct_ao_fock_hf subroutine construct_ao_fock_new_hf ( wf , ao_fock ) !! !! implicit none ! class ( hf ) :: wf real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: ao_fock ! real ( dp ), dimension (:, :), allocatable :: density ! real ( dp ), dimension (:,:), allocatable :: h1ao real ( dp ), dimension (:,:), allocatable :: chol_ao real ( dp ), dimension (:,:), allocatable :: chol_ao_sq real ( dp ), dimension (:,:), allocatable :: Y ! real ( dp ) :: X ! integer ( i15 ) :: i = 0 , J = 0 , m = 0 , n = 0 , p = 0 , s = 0 integer ( i15 ) :: mn = 0 , ms = 0 , ps = 0 , pn = 0 ! integer ( i15 ) :: unit_identifier_ao_integrals = 0 , unit_chol_ao = 0 ! !     Batching variables ! integer ( i15 ) :: m_batch = 0 , m_first = 0 , m_last = 0 , m_length = 0 integer ( i15 ) :: required = 0 , available = 0 , n_batch = 0 , batch_dimension = 0 integer ( i15 ) :: max_batch_length = 0 ! ! call wf % mem % alloc ( h1ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) h1ao = zero ! !     Open mlcc_aoint file ! call generate_unit_identifier ( unit_identifier_ao_integrals ) open ( unit = unit_identifier_ao_integrals , file = 'MLCC_AOINT' , status = 'old' , form = 'formatted' ) rewind ( unit_identifier_ao_integrals ) ! !     Read in one-electron AO integrals ! read ( unit_identifier_ao_integrals , * ) ( h1ao ( i , 1 ), i = 1 , wf % n_ao * ( wf % n_ao + 1 ) / 2 ) ! !     Close mlcc_aoint ! close ( unit_identifier_ao_integrals ) ! !     Allocate the AO Fock matrix and add the one-electron contributions ! ao_fock = zero ! call squareup ( h1ao , ao_fock , wf % n_ao ) ! !     Deallocation of one-electron AO integrals ! call wf % mem % dealloc ( h1ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) ! !     Read Cholesky in ao basis ! call generate_unit_identifier ( unit_chol_ao ) open ( unit = unit_chol_ao , file = 'MLCC_CHOLESKY' , status = 'old' , form = 'formatted' ) rewind ( unit_chol_ao ) ! !     Read the number of Cholesky vectors (n_J) and !     the number of atomic orbitals (n_ao) ! read ( unit_chol_ao , * ) wf % n_ao , wf % n_J ! do j = 1 , wf % n_J ! call wf % mem % alloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) ! chol_ao = zero ! !        Read Cholesky AO vector ! read ( unit_chol_ao , * ) ( chol_ao ( i , 1 ), i = 1 , wf % n_ao * ( wf % n_ao + 1 ) / 2 ) ! call wf % mem % alloc ( chol_ao_sq , wf % n_ao , wf % n_ao ) chol_ao_sq = zero ! call squareup ( chol_ao , chol_ao_sq , wf % n_ao ) ! call wf % mem % dealloc ( chol_ao , wf % n_ao * ( wf % n_ao + 1 ) / 2 , 1 ) call wf % mem % alloc ( density , wf % n_ao , wf % n_ao ) density = zero ! !        Coulomb term: sum_Jps 2 * L&#94;J_ps * D_p,s * L&#94;J_mn ! call wf % construct_density_matrix ( density , wf % mo_coef , wf % n_o , wf % n_v ) ! call dgemm ( 'N' , 'N' , & 1 , & 1 , & wf % n_ao ** 2 , & two , & chol_ao_sq , & 1 , & density , & wf % n_ao ** 2 , & zero , & X , & 1 ) ! call daxpy ( wf % n_ao ** 2 , X , chol_ao_sq , 1 , ao_fock , 1 ) ! !        Exchange term: - sum_Jps  L&#94;J_ms * D_p,s * L&#94;J_pn ! call wf % mem % alloc ( Y , wf % n_ao , wf % n_ao ) ! call dgemm ( 'N' , 'T' , & wf % n_ao , & wf % n_ao , & wf % n_ao , & one , & chol_ao_sq , & wf % n_ao , & density , & wf % n_ao , & zero , & Y , & wf % n_ao ) ! call wf % mem % dealloc ( density , wf % n_ao , wf % n_ao ) ! call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_ao , & wf % n_ao , & - one , & Y , & wf % n_ao , & chol_ao_sq , & wf % n_ao , & one , & ao_fock , & wf % n_ao ) ! call wf % mem % dealloc ( Y , wf % n_ao , wf % n_ao ) call wf % mem % dealloc ( chol_ao_sq , wf % n_ao , wf % n_ao ) ! enddo ! looping over J ! close ( unit_chol_ao ) close ( unit_identifier_ao_integrals ) ! end subroutine construct_ao_fock_new_hf ! subroutine construct_density_matrices_hf ( wf , density_o , density_v , C_matrix , n_o , n_v ) !! !! !! implicit none ! class ( hf ) :: wf real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: density_o real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: density_v real ( dp ), dimension ( wf % n_ao , n_o + n_v ) :: C_matrix integer ( i15 ) :: n_o , n_v ! real ( dp ), dimension (:,:), allocatable :: C ! integer ( i15 ) :: i = 0 , j = 0 , ij = 0 ! call dgemm ( 'N' , 'T' , & wf % n_ao , & wf % n_ao , & n_o , & one , & C_matrix , & wf % n_ao , & C_matrix , & wf % n_ao , & zero , & density_o , & wf % n_ao ) ! call wf % mem % alloc ( C , wf % n_ao , n_v ) ! do i = 1 , wf % n_ao do j = 1 , n_v ij = index_two ( i , j + n_o , wf % n_ao ) C ( i , j ) = C_matrix ( ij , 1 ) enddo enddo ! call dgemm ( 'N' , 'T' , & wf % n_ao , & wf % n_ao , & n_v , & one , & C , & wf % n_ao , & C , & wf % n_ao , & zero , & density_v , & wf % n_ao ) ! call wf % mem % dealloc ( C , wf % n_ao , n_v ) ! end subroutine construct_density_matrices_hf ! subroutine construct_density_matrix_hf ( wf , density_o , C_matrix , n_o , n_v ) !! !! implicit none ! class ( hf ) :: wf real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: density_o real ( dp ), dimension ( wf % n_ao , n_o + n_v ) :: C_matrix integer ( i15 ) :: n_o , n_v ! call dgemm ( 'N' , 'T' , & wf % n_ao , & wf % n_ao , & n_o , & one , & C_matrix , & wf % n_ao , & C_matrix , & wf % n_ao , & zero , & density_o , & wf % n_ao ) ! end subroutine construct_density_matrix_hf ! subroutine construct_density_matrix_v_hf ( wf , density_v , C_matrix , n_o , n_v ) !! !! !! implicit none ! class ( hf ) :: wf real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: density_v real ( dp ), dimension ( wf % n_ao , n_o + n_v ) :: C_matrix integer ( i15 ) :: n_v , n_o real ( dp ), dimension (:,:), allocatable :: C ! integer ( i15 ) :: i = 0 , j = 0 , ij = 0 ! call wf % mem % alloc ( C , wf % n_ao , n_v ) ! C (:, 1 : n_v ) = C_matrix (:, 1 + n_o : n_o + n_v ) ! call dgemm ( 'N' , 'T' , & wf % n_ao , & wf % n_ao , & n_v , & one , & C , & wf % n_ao , & C , & wf % n_ao , & zero , & density_v , & wf % n_ao ) ! call wf % mem % dealloc ( C , wf % n_ao , n_v ) ! end subroutine construct_density_matrix_v_hf ! end module hf_class","tags":"","loc":"sourcefile/hf_class.f90.html","title":"hf_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~mlccsd_class.f90~~EfferentGraph sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlccsd_class.f90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlccsd_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~utils.f90->sourcefile~mlccsd_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlccsd_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlccsd_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilemlccsd_classf90EfferentGraph = svgPanZoom('#sourcefilemlccsd_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mlccsd_class.f90~~AfferentGraph sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mlccsd_class Source Code mlccsd_class.F90 Source Code module mlccsd_class ! !! !!                 Multi-level CCSD (MLCCSD) class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output use input_reader ! !  The ancestor class module (MLCC2) ! use mlcc2_class ! implicit none ! !  ::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the MLCCSD class -::- !  ::::::::::::::::::::::::::::::::::::::: ! type , extends ( mlcc2 ) :: mlccsd ! !     ML-variables ! integer ( i15 ) :: n_CCSD_o = 0 integer ( i15 ) :: n_CCSD_v = 0 ! integer ( i15 ) :: first_CCSD_o = 0 integer ( i15 ) :: first_CCSD_v = 0 ! type ( mlcc_orbitals ) :: CCSD_orbitals ! real ( dp ), dimension (:,:), allocatable :: mo_coef_cc2_ccs ! MO coefficient matrix for mlccsd basis real ( dp ), dimension (:,:), allocatable :: T_o ! Occupied MO transformation matrix for mlccsd basis real ( dp ), dimension (:,:), allocatable :: T_v ! Virtual MO transformation matrix for mlccsd basis ! !     Fock matrix variables ! real ( dp ), dimension (:,:), allocatable :: fock_diagonal_cc2_ccs ! diagonal vector for mlccsd basis ! !     Amplitude variables ! integer ( i15 ) :: n_t2am = 0 ! Number CCSD of doubles amplitudes ! real ( dp ), dimension (:,:), allocatable :: t2am ! Doubles amplitude vector ! !     Schrödinger equation projection vector (the omega vector) ! !        < mu | exp(-T) H exp(T) | R > ! real ( dp ), dimension (:,:), allocatable :: omega2 ! Doubles vector ! contains ! procedure :: mlcc_reader => mlcc_reader_mlccsd procedure :: read_orbital_info => read_orbital_info_mlccsd ! procedure :: init => init_mlccsd ! !     Initialization routines ! procedure :: initialize_amplitudes => initialize_amplitudes_mlccsd procedure :: initialize_omega => initialize_omega_mlccsd ! !     Energy calculation routine ! procedure :: calc_energy => calc_energy_mlccsd ! !     Orbital partitioning ! procedure :: orbital_partitioning => orbital_partitioning_mlccsd procedure :: cholesky_localization_drv => cholesky_localization_drv_mlccsd procedure :: cholesky_localization_CCSD_CC2_CCS => cholesky_localization_CCSD_CC2_CCS_mlccsd procedure :: cholesky_localization_CCSD_CCS => cholesky_localization_CCSD_CCS_mlccsd procedure :: cholesky_localization_CCSD_CC2 => cholesky_localization_CCSD_CC2_mlccsd procedure :: construct_perturbative_doubles => construct_perturbative_doubles_mlccsd ! procedure :: construct_MO_transformation_matrix => construct_MO_transformation_matrix_mlccsd ! procedure :: cnto_orbital_drv => cnto_orbital_drv_mlccsd procedure :: ccsd_cnto_lower_level_method => ccsd_cnto_lower_level_method_mlccsd procedure :: ccsd_cnto_orbitals => ccsd_cnto_orbitals_mlccsd procedure :: print_orbital_info => print_orbital_info_mlccsd ! !     Cholesky vector routines for CC2 space ! procedure :: read_transform_cholesky_for_CC2_amplitude => read_transform_cholesky_for_CC2_amplitude_mlccsd procedure :: read_cholesky_ai_for_cc2_amplitudes => read_cholesky_ai_for_cc2_amplitudes_mlccsd procedure :: read_cholesky_ia_for_cc2_amplitudes => read_cholesky_ia_for_cc2_amplitudes_mlccsd procedure :: read_cholesky_ij_for_cc2_amplitudes => read_cholesky_ij_for_cc2_amplitudes_mlccsd procedure :: read_cholesky_ab_for_cc2_amplitudes => read_cholesky_ab_for_cc2_amplitudes_mlccsd procedure :: get_cholesky_ai_for_cc2_amplitudes => get_cholesky_ai_for_cc2_amplitudes_mlccsd ! !     ML helper routines ! procedure :: get_CC2_active_indices => get_CC2_active_indices_mlccsd procedure :: get_CC2_n_active => get_CC2_n_active_mlccsd procedure :: get_CCSD_active_indices => get_CCSD_active_indices_mlccsd procedure :: get_CCSD_n_active => get_CCSD_n_active_mlccsd ! !     Omega routines ! procedure :: construct_omega => construct_omega_mlccsd ! procedure :: omega_mlccsd_a1 => omega_mlccsd_a1_mlccsd procedure :: omega_mlccsd_b1 => omega_mlccsd_b1_mlccsd ! procedure :: get_mlccsd_x2am => get_mlccsd_x2am_mlccsd ! procedure :: omega_mlccsd_a2 => omega_mlccsd_a2_mlccsd procedure :: omega_mlccsd_b2 => omega_mlccsd_b2_mlccsd procedure :: omega_mlccsd_c2 => omega_mlccsd_c2_mlccsd procedure :: omega_mlccsd_d2 => omega_mlccsd_d2_mlccsd procedure :: omega_mlccsd_e2 => omega_mlccsd_e2_mlccsd ! !     Ground state solver routines ! procedure :: calc_ampeqs_norm => calc_ampeqs_norm_mlccsd procedure :: new_amplitudes => new_amplitudes_mlccsd procedure :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_mlccsd procedure :: initialize_ground_state => initialize_ground_state_mlccsd ! !     Helper routines for onstruction, destruction, saving and reading ! procedure :: construct_orbital_coef_CC2_CCS => construct_orbital_coef_CC2_CCS_mlccsd procedure :: construct_orbital_energy_CC2_CCS => construct_orbital_energy_CC2_CCS_mlccsd ! procedure :: destruct_orbital_coef_CC2_CCS => destruct_orbital_coef_CC2_CCS_mlccsd procedure :: destruct_orbital_energy_CC2_CCS => destruct_orbital_energy_CC2_CCS_mlccsd procedure :: destruct_amplitudes => destruct_amplitudes_mlccsd procedure :: destruct_double_amplitudes => destruct_double_amplitudes_mlccsd ! procedure :: save_amplitudes => save_amplitudes_mlccsd procedure :: read_amplitudes => read_amplitudes_mlccsd procedure :: read_mlccsd_double_amplitudes => read_mlccsd_double_amplitudes_mlccsd procedure :: read_double_amplitudes => read_double_amplitudes_mlccsd ! !     Jacobian ! procedure :: jacobian_mlccsd_transformation => jacobian_mlccsd_transformation_mlccsd ! procedure :: jacobian_mlccsd_b2 => jacobian_mlccsd_b2_mlccsd procedure :: jacobian_mlccsd_c2 => jacobian_mlccsd_c2_mlccsd procedure :: jacobian_mlccsd_d2 => jacobian_mlccsd_d2_mlccsd procedure :: jacobian_mlccsd_e2 => jacobian_mlccsd_e2_mlccsd procedure :: jacobian_mlccsd_f2 => jacobian_mlccsd_f2_mlccsd procedure :: jacobian_mlccsd_g2 => jacobian_mlccsd_g2_mlccsd procedure :: jacobian_mlccsd_h2 => jacobian_mlccsd_h2_mlccsd procedure :: jacobian_mlccsd_i2 => jacobian_mlccsd_i2_mlccsd procedure :: jacobian_mlccsd_j2 => jacobian_mlccsd_j2_mlccsd procedure :: jacobian_mlccsd_k2 => jacobian_mlccsd_k2_mlccsd ! !     Excited states ! procedure :: transform_trial_vectors => transform_trial_vectors_mlccsd procedure :: initialize_excited_states => initialize_excited_states_mlccsd procedure :: print_excitation_vector => print_excitation_vector_mlccsd procedure :: summary_excited_state_info => summary_excited_state_info_mlccsd ! end type mlccsd ! ! interface ! !    -::- Input reader submodule interface -::- !    :::::::::::::::::::::::::::::::::::::::::: ! module subroutine mlcc_reader_mlccsd ( wf , unit_input ) !! !! !! implicit none ! integer ( i15 ) :: unit_input ! class ( mlccsd ) :: wf ! end subroutine mlcc_reader_mlccsd ! ! module subroutine read_orbital_info_mlccsd ( wf , unit_input ) !! !! implicit none ! integer ( i15 ) :: unit_input ! class ( mlccsd ) :: wf ! end subroutine read_orbital_info_mlccsd ! end interface ! ! interface ! !    -::- Orbital partitioning submodule interface -::- !    :::::::::::::::::::::::::::::::::::::::::::::::::: ! ! module subroutine orbital_partitioning_mlccsd ( wf ) !! !!       Orbital partitioning, !!       Written by Sarai D. Folkestad, June 2017 !! !!       Directs the partitioning for mlcc calculations. !! !!       So far only Cholesky decomposition is available. !! implicit none ! class ( mlccsd ) :: wf ! end subroutine orbital_partitioning_mlccsd ! ! module subroutine cholesky_localization_drv_mlccsd ( wf ) !! !!       Cholesky orbital localization driver, !!       Written by Sarai D. Folkestad, July 2017. !! !!       Driver for Cholesky density decomposition !! !!       - Collects atom and ao-basis information. !!       - Constructs occupied and vacant densities. !!       - Constructs AO Fock matrix.  (This is currently an N&#94;5 operation, should be optimized/removed) !!       - By looping over active spaces, the occupied and virtual densities are Cholesky decomposed !!         and the cholesky vectors are used to generate new localized MO's. !!       - New orbitals are tested for orthonormality (Not implemented yet, only need overlap matrix from DALTON) !! !! implicit none ! class ( mlccsd ) :: wf ! end subroutine cholesky_localization_drv_mlccsd ! ! module subroutine cholesky_localization_CCSD_CC2_CCS_mlccsd ( wf , ao_center_info , n_ao_on_center ,& ao_fock , n_nuclei , unit_cholesky_decomp ) !! !!       Cholesky orbital localization CCS/CC2/CCSD, !!       Written by Sarai D. Folkestad, July 2017 !! !!       Cholesky partitiining routine for CCS/CC2/CCSD calculation !! implicit none ! !        Input arguments ! class ( mlccsd ) :: wf ! integer ( i15 ), dimension ( wf % n_ao , 2 ) :: ao_center_info integer ( i15 ), dimension ( n_nuclei , 1 ) :: n_ao_on_center ! real ( dp ), dimension (:,:) :: ao_fock ! integer ( i15 ) :: n_nuclei integer ( i15 ) :: unit_cholesky_decomp ! end subroutine cholesky_localization_CCSD_CC2_CCS_mlccsd ! ! module subroutine cholesky_localization_CCSD_CCS_mlccsd ( wf , ao_center_info , n_ao_on_center ,& ao_fock , n_nuclei , unit_cholesky_decomp ) !! !!       Cholesky orbital localization CCS/CCSD, !!       Written by Sarai D. Folkestad, July 2017 !! !!       Cholesky partitiining routine for CCS/CCSD calculation !! implicit none ! !        Input arguments ! class ( mlccsd ) :: wf ! integer ( i15 ), dimension ( wf % n_ao , 2 ) :: ao_center_info integer ( i15 ), dimension ( n_nuclei , 1 ) :: n_ao_on_center ! real ( dp ), dimension (:,:) :: ao_fock ! integer ( i15 ) :: n_nuclei integer ( i15 ) :: unit_cholesky_decomp ! end subroutine cholesky_localization_CCSD_CCS_mlccsd ! ! module subroutine cholesky_localization_CCSD_CC2_mlccsd ( wf , ao_center_info , n_ao_on_center ,& ao_fock , n_nuclei , unit_cholesky_decomp ) !! !!       Cholesky orbital localization CC2/CCSD !!       Written by Sarai D. Folkestad, July 2017 !! !!       Cholesky partitiining routine for CC2/CCSD calculation !! implicit none ! !        Input arguments ! class ( mlccsd ) :: wf ! integer ( i15 ), dimension ( wf % n_ao , 2 ) :: ao_center_info integer ( i15 ), dimension ( n_nuclei , 1 ) :: n_ao_on_center ! real ( dp ), dimension (:,:) :: ao_fock ! integer ( i15 ) :: n_nuclei integer ( i15 ) :: unit_cholesky_decomp ! end subroutine cholesky_localization_CCSD_CC2_mlccsd ! ! module subroutine construct_MO_transformation_matrix_mlccsd ( wf ) !! !!       Construct MO transformation matrix, !!       Written by Sarai D. Fokestad, July 2017 !! !!       Constructs transformation matrix, !! !!          T = (C_CCSD)&#94;T * S * C_CC2 !! !!       between CC2 basis and CCSD basis. !!       Needed for transforming s_ij_ab from CC2 to CCSD basis. !! implicit none ! class ( mlccsd ) :: wf ! end subroutine construct_MO_transformation_matrix_mlccsd ! ! module subroutine cnto_orbital_drv_mlccsd ( wf ) !! !!       CNTO orbital driver, !!       Written by Sarai D. Folkestad, July 2017. !! !!       A CCS calculation ground state and excited states is performed. !!       The M and N matrices are then constructed, !! !!          M_ij = sum_a R1_ai*R1_aj + sum_a R2_ai*R2_aj + ... !!          N_ab = sum_i R1_ai*R1_bi + sum_a R2_ai*R2_bi + ... !! !!       where Ri_ai is the i'th single excitation vector obtained from the CCS calculation. !!       The transformation matrices for the occupied and virtual part !!       are constructed by diagonalizing M and N. The number of active occupied !!       and virtual orbitals are determined from δ_o and δ_v !! !!          1 - sum_i λ&#94;o_i < δ_o !!          1 - sum_i λ&#94;v_i < δ_v !! !!       Where the orbitals of highest eigenvalues λ&#94;o/λ&#94;v are selected first. !! !!       Fock matrix is block diagonalized in active and inactive blocks in order to obtain !!       the orbitals and orbital energies used in the CC2 calculation. !! implicit none ! class ( mlccsd ) :: wf ! end subroutine cnto_orbital_drv_mlccsd ! ! module subroutine ccsd_cnto_lower_level_method_mlccsd ( wf , cc2_n_parameters , cc2_n_x2am , n_cc2_o , n_cc2_v ) !! !!    CNTO constructor (MLCCSD), !!    Written by Sarai D. Folkestad, Aug. 2017 !! !!    Constructs CNTOs and partitions orbital space !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: cc2_n_x2am , cc2_n_parameters integer ( i15 ) :: n_CC2_o , n_CC2_v ! end subroutine ccsd_cnto_lower_level_method_mlccsd ! ! module subroutine ccsd_cnto_orbitals_mlccsd ( wf , cc2_n_parameters , cc2_n_x2am , n_cc2_o , n_cc2_v ) !! !!       CNTO Oritals (MLCCSD), !!       Written by Sarai D. Folkestad Aug. 2017 !! !!       Constructs the CNTO orbitals based on exitation vectors from lower level method !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: cc2_n_x2am , cc2_n_parameters integer ( i15 ) :: n_CC2_o , n_CC2_v ! end subroutine ccsd_cnto_orbitals_mlccsd ! ! module subroutine print_orbital_info_mlccsd ( wf ) !! !!       Print CNTO info, !!       Written by Sarai D. Folkestad, Aug. 2017 !! !!       Prints information on CNTO partitioning !! implicit none ! class ( mlccsd ) :: wf ! end subroutine print_orbital_info_mlccsd ! ! end interface ! ! interface ! !     -::- Cholesky submodule interface -::- !     :::::::::::::::::::::::::::::::::::::: ! module subroutine read_transform_cholesky_for_CC2_amplitude_mlccsd ( wf ) ! implicit none ! class ( mlccsd ) :: wf ! end subroutine read_transform_cholesky_for_CC2_amplitude_mlccsd ! ! module subroutine read_cholesky_ai_for_cc2_amplitudes_mlccsd ( wf , L_ai_J , a_first , a_last , i_first , i_last ) !! !!       Read Cholesky IA !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Reads the MO Cholesky IA (occ-vir) vectors from file and !!       places them in the incoming L_ia_J matrix !! !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: L_ai_J integer ( i15 ) :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ) :: i_last , a_last ! Last index (can differ from n_o/n_v when batching or for mlcc) ! ! end subroutine read_cholesky_ai_for_cc2_amplitudes_mlccsd ! ! module subroutine get_cholesky_ai_for_cc2_amplitudes_mlccsd ( wf , L_ai_J , a_first , a_last , i_first , i_last ) !! !!       Get Cholesky AI !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Read and T1-transform Cholesky AI vectors: !! !!        L_ai_J_T1 = L_ia_J - sum_j  t_aj*L_ji_J !!                            + sum_b  t_bi*L_ab_J !!                            - sum_bj t_aj*t_bi*L_jb_J !! !!       Allocations in routine: !! !!       (1) n_J*(i_length)*(a_length) + 2*n_J*(a_length)*batch_length  ->  for L_ab_J contribution (batches of b) !!       (2) n_J*(i_length)*n_v + 2*n_J*n_o*(i_length)                  ->  for L_ij_J contribution !!       (3) 2*n_J*n_o*n_v                                              ->  for L_jb_J contribution !! !!       i_length = i_last - i_first + 1 !!       a_length = a_last - a_first + 1 !! !!       (1) determines memory requirement. !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: L_ai_J integer ( i15 ) :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ) :: i_last , a_last ! Last index (can differ from n_o/n_v when batching or for mlcc) ! end subroutine get_cholesky_ai_for_cc2_amplitudes_mlccsd ! ! module subroutine read_cholesky_ab_for_cc2_amplitudes_mlccsd ( wf , L_ab_J , a_first , a_last , b_first , b_last ) !! !!    Read Cholesky AB !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky AB (vir-vir) vectors from file and !!    places them in the incoming L_ab_J matrix, with batching !!    if necessary !! !!    Optional arguments: b_first, b_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ), intent ( in ) :: a_first , b_first ! First index (can differ from 1 when batching  or for mlcc) integer ( i15 ), intent ( in ) :: a_last , b_last ! Last index  (can differ from n_v when batching or for mlcc) real ( dp ), dimension ((( a_last - a_first + 1 ) * ( b_last - b_first + 1 )), wf % n_J ) :: L_ab_J ! L_ab&#94;J ! end subroutine read_cholesky_ab_for_cc2_amplitudes_mlccsd ! !! module subroutine read_cholesky_ia_for_cc2_amplitudes_mlccsd ( wf , L_ia_J , i_first , i_last , a_first , a_last ) !! !!    Read Cholesky IA !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky IA (occ-vir) vectors from file and !!    places them in the incoming L_ia_J matrix !! !! !!    Optional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ) :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ) :: i_last , a_last ! Last index (can differ from n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ia_J ! L_ia&#94;J ! end subroutine read_cholesky_ia_for_cc2_amplitudes_mlccsd ! ! module subroutine read_cholesky_ij_for_cc2_amplitudes_mlccsd ( wf , L_ij_J , i_first , i_last , j_first , j_last ) !! !!    Read Cholesky IJ !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky IJ (occ-occ) vectors from file and !!    places them in the incoming L_ij_J matrix !! !!    Optional arguments: i_first, i_last, j_first, j_last can be used in order to restrict indices !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ) :: i_first , j_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ) :: i_last , j_last ! Last index (can differ from n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ij_J ! L_ij&#94;J ! end subroutine read_cholesky_ij_for_cc2_amplitudes_mlccsd ! ! end interface ! ! interface ! !     -::- Omega submodule interface -::- !     ::::::::::::::::::::::::::::::::::: ! module subroutine initialize_omega_mlccsd ( wf ) ! !        Initialize Omega (MLCCSD) !        Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !        Allocates the projection vector (omega1, omega2) and sets it !        to zero. ! implicit none ! class ( mlccsd ) :: wf ! end subroutine initialize_omega_mlccsd ! ! module subroutine construct_omega_mlccsd ( wf ) !! !!       Construct Omega (MLCCSD) !!       Written by Eirik F. Kjønstad and Sarai Folkestad, Apr 2017 !! !!       Constructs the MlCC2 omega. !! !!       s2-amplitudes are constructed on the fly, according to the CC2 !!       expression for the doubles amplitudes. !! !!       Calculated by looping over active spaces, !!       Adding the omega contribution from each active space in turn. !! implicit none ! class ( mlccsd ) :: wf ! end subroutine construct_omega_mlccsd ! ! ! end interface ! ! interface ! !     -::- Omega CC2 submodule interface -::- !     ::::::::::::::::::::::::::::::::::::::: ! module subroutine get_mlccsd_x2am_mlccsd ( wf , x_ia_jb ) !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: x_ia_jb ! end subroutine get_mlccsd_x2am_mlccsd ! ! module subroutine omega_mlccsd_a1_mlccsd ( wf , x_ib_jc ) !! !!    Omega A1 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Calculates the A1 term of omega for the active space, !! !!    A1: sum_bcj g_Abjc * u_Ij&#94;bc, !! !!    where upper case letters indicate CCS space, and !!    lower case letters are the combined CC2/CCSD spaces. !! !!    A1 is added to the projection vector (omega1) of !!    the wavefunction object wf. !! !!    u_ij&#94;bc = 2*x_ij&#94;bc - x_ij&#94;cb !! !!    Batching over A. !! !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_ib_jc ! end subroutine omega_mlccsd_a1_mlccsd ! ! module subroutine omega_mlccsd_b1_mlccsd ( wf , x_ja_kb ) !! !!       Omega B1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       Calculates the B1 term of omega, !! !!       B1: - sum_bjk u_jk&#94;ab*g_kbjI + sum_bj u_ij&#94;ab F_jb, !! !!       with u_ij&#94;ab = 2*x_ij&#94;ab - x_ij&#94;ba. !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_ja_kb ! end subroutine omega_mlccsd_b1_mlccsd ! ! module subroutine omega_mlccsd_a2_mlccsd ( wf , x_IC_JD ) ! !        Omega A2 term: Omega A2 = sum_(cd)g_aC_bD * x_Ci_Dj ! !        Written by Sarai D. Folkestad and Eirik F. Kjønstad, 10 Mar 2017 ! !        Structure: Batching over both a and b for A2.2. !                   x&#94;+_Ci_Dj = x_Ci_Dj + x_Di_Cj !                   x&#94;-_Ci_Dj = x_Ci_Dj - x_Di_Cj !                   g&#94;+_aC_bD = g_aC_bD + g_bC_aD !                   g&#94;-_aC_bD = g_aC_bD - g_bC_aD ! !                   omega_A2_ai_bj = 1/4*(g&#94;+_aC_bD*x&#94;+_Ci_Dj + g&#94;-_aC_bD*x&#94;-_Ci_Dj) !                   omega_A2_aj_bi = 1/4*(g&#94;+_aC_bD*x&#94;+_Ci_Dj - g&#94;-_aC_bD*x&#94;-_Ci_Dj) ! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_IC_JD ! end subroutine omega_mlccsd_a2_mlccsd ! ! module subroutine omega_mlccsd_b2_mlccsd ( wf , x_kc_ld ) !! !!       Omega B2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, 11 Mar 2017 !! !!       Omega B2 = sum_(kl) x_ak_bl*(g_kilj + sum_(cd) x_ci_dj * g_kc_ld) !! !!       Structure: g_kilj is constructed first and reordered as g_kl_ij. !!       Then the contraction over cd is performed, and the results added to g_kl_ij. !!       x_ka_lb is then reordered as x_ab_kl and the contraction over kl is performed. !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_kc_ld ! end subroutine omega_mlccsd_b2_mlccsd ! ! module subroutine omega_mlccsd_c2_mlccsd ( wf , x_lc_kd ) !! !!       Omega C2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017 !! !!       Z_ai_bj = - sum_(ck) x&#94;bc_kj*( g_ki,ac - 1/2 * sum_(dl) x&#94;ad_li*g_kd,cl ) !! !!       Omega_ai_bj = P_ij&#94;ab (1/2 Z_ai_bj + Z_aj_bi) = 1/2 Z_ai_bj + 1/2 Z_bj_ai + Z_aj_bi+ Z_bi_aj !! !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_lc_kd ! end subroutine omega_mlccsd_c2_mlccsd ! ! module subroutine omega_mlccsd_d2_mlccsd ( wf , x_KC_LD ) !! !!       Omega D2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Calculates the D2 term, !! !!        D2: sum_ck u_jk&#94;bc g_aikc !!          - 1/2 * sum_ck u_jk&#94;bc g_acki !!          + 1/4 * sum_ck u_jk&#94;bc sum_dl L_ldkc u_il&#94;ad, !! !!       where !! !!          u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc, !!          L_ldkc  = 2 * g_ldkc  - g_lckd. !! !!       The first, second, and third terms are referred to as D2.1, D2.2, and D2.3, !!       and comes out ordered as (ai,bj). All terms are added to the omega vector of the !!       wavefunction object wf. ! !        The routine adds the terms in the following order: D2.3, D2.1, D2.2 ! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_KC_LD ! end subroutine omega_mlccsd_d2_mlccsd ! ! module subroutine omega_mlccsd_e2_mlccsd ( wf , x_kc_ld ) !! !!     Omega E2 !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Calculates the E2 term, !! !!      E2: sum_c t_ij&#94;ac (F_bc - sum_dkl g_ldkc u_kl&#94;bd) !!        - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc), !! !!     where !! !!        u_kl&#94;bc = 2 * t_kl&#94;bc - t_lk&#94;bc. !! !!     The first term is referred to as the E2.1 term, and comes out ordered as (b,jai). !!     The second term is referred to as the E2.2 term, and comes out ordered as (aib,j). !! !!     Both are permuted added to the projection vector element omega2(ai,bj) of !!     the wavefunction object wf. !! implicit none ! class ( mlccsd ) :: wf real ( dp ), dimension (:,:) :: x_kc_ld ! end subroutine omega_mlccsd_e2_mlccsd ! ! end interface ! ! interface ! !     -::- Ground state submodule interface -::- !     :::::::::::::::::::::::::::::::::::::::::: ! module subroutine calc_ampeqs_norm_mlccsd ( wf , ampeqs_norm ) ! !        Calculate Amplitude Equations Norm (MLCCSD) !        Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! implicit none ! class ( mlccsd ) :: wf ! real ( dp ) :: ampeqs_norm ! end subroutine calc_ampeqs_norm_mlccsd ! ! module subroutine new_amplitudes_mlccsd ( wf ) ! !     New Amplitudes (MLCCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !     Directs the calculation of the quasi-Newton estimate Δ t_i, !     and t_i + Δ t_i, and calls the DIIS routine to save & get !     the amplitudes for the next iteration. ! implicit none ! class ( mlccsd ) :: wf ! end subroutine new_amplitudes_mlccsd ! ! module subroutine calc_quasi_Newton_doubles_mlccsd ( wf , dt ) ! !     Calculate quasi-Newtoni doubles estimate (CCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !     Calculates the quasi-Newton estimate Δ t_i (doubbles part) !     and places the contribution in the dt vector (of length n_parameters, !     with singles first, then doubles, etc. if inherited) ! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: dt ! ! end subroutine calc_quasi_Newton_doubles_mlccsd ! ! module subroutine initialize_ground_state_mlccsd ( wf ) !! !!    Initialize Ground State (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Initializes the amplitudes and the projection vector for the ground !!    state solver. !! implicit none ! class ( mlccsd ) :: wf ! end subroutine initialize_ground_state_mlccsd ! ! end interface ! ! interface ! !     -::- Jacobi submodule interface -::- !     :::::::::::::::::::::::::::::::::::: ! module subroutine jacobian_mlccsd_transformation_mlccsd ( wf , c_a_i , c_aibj ) !! !!    Jacobian transformation (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!    Directs the transformation by the CCSD Jacobi matrix, !! !!       A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >, !! !!    where the basis employed for the brackets is biorthonormal. !!    The transformation is rho = A c, i.e., !! !!       rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck !!                  + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl). !! !!    On exit, c is overwritten by rho. That is, c_a_i = rho_a_i, !!    and c_aibj = rho_aibj. !! implicit none ! class ( mlccsd ) :: wf ! !      Incoming vector c ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_x2am , 1 ) :: c_aibj ! c_aibj ! end subroutine jacobian_mlccsd_transformation_mlccsd ! ! module subroutine jacobian_mlccsd_b2_mlccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD B2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    rho_ai_bj&#94;B2 = - sum_kc (F_kc t_ij&#94;ac c_bk + F_kc t_ik&#94;ab c_cj) !! !!    The term is added as rho_ai_bj(ai,bj) = rho_ai_bj(ai,bj) + rho_ai_bj&#94;B2, !!    where c_a_i(a,i) = c_ai above. !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (:, :) :: rho_ai_bj ! ! end subroutine jacobian_mlccsd_b2_mlccsd ! ! module subroutine jacobian_mlccsd_c2_mlccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD C2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Aug 2017 !! !!    rho_ai_bj&#94;C2 = sum_kcl (g_ljkc * t_ki&#94;ac * c_bl) + (g_ljkc * t_li&#94;bc * c_ak) !!                         + (g_ljkc * t_lk&#94;ba * c_ci) !!                         - (L_ljkc * t_ik&#94;ac * c_bl)- (L_ljkc * t_il&#94;ab * c_ck) !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (:,:) :: rho_ai_bj ! end subroutine jacobian_mlccsd_c2_mlccsd ! ! module subroutine jacobian_mlccsd_d2_mlccsd ( wf , rho_ai_bj , c_a_i ) !! !!    Jacobian CCSD D2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    rho_ai_bj&#94;D2 = - sum_kcd g_kcbd (x_ij&#94;cd c_ak + x_kj&#94;ad c_ci + x_ik&#94;ca c_dj) !!                       + sum_kcd L_kcbd (x_ik&#94;ac c_dj + x_ij&#94;ad c_ck) !! !!    Note: the code is structured so that we batch over the index b, !!          where the integrals are made as g_kc_db = g_kcbd and held !!          in some ordering or other throughout a given batch (i.e., !!          all five terms are constructed gradually in the batches). !! !!    The term is added as rho_ai_bj(ai,bj) = rho_ai_bj(ai,bj) + rho_ai_bj&#94;D2, !!    where c_a_i(a,i) = c_ai above. !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension (:,:) :: rho_ai_bj ! end subroutine jacobian_mlccsd_d2_mlccsd ! ! module subroutine jacobian_mlccsd_e2_mlccsd ( wf , rho_ai_bj , c_ai_ck ) !! !!    Jacobian MLCCSD E2 !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    rho_ai_bj&#94;E2 = 2 sum_dlck x_bj,DL * L_KC,LD * c_ai,CK !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_ck ! end subroutine jacobian_mlccsd_e2_mlccsd ! ! module subroutine jacobian_mlccsd_f2_mlccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian MLCCSD F2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;F2 =   - sum_(CKDL) x_ai,CK * L_KC,LD * c_bL,Dj !!                        - sum_(CKDL) x_ai,Dj * L_KC,LD * c_bL,CK !!                        - sum_(CKDL) x_ai_bL * L_KC,LD * c_CK,Dj !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_bj ! end subroutine jacobian_mlccsd_f2_mlccsd ! ! module subroutine jacobian_mlccsd_g2_mlccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian MLCCSD G2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;G2 =  - sum_ckdl x_bL,Dj * L_KC,LD * c_ai,CK !!                       - sum_ckdl x_CK_bL * L_KC,LD * c_ai,Dj !!                       - sum_ckld x_CK,Dj * L_KC,LD * c_ai,bL !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_bj ! end subroutine jacobian_mlccsd_g2_mlccsd ! ! module subroutine jacobian_mlccsd_h2_mlccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian MLCCSD H2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;H2 =  sum_CKDL x_Ci,aK * g_KC,LD * c_bL,Dj !!                     + sum_CKDL x_Cj,aL * g_KC,LD * c_bK,Di !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_bj ! end subroutine jacobian_mlccsd_h2_mlccsd ! ! module subroutine jacobian_mlccsd_i2_mlccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian MLCCSD I2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ai_bj&#94;I2 =  sum_C F_bC * c_ai,Cj - sum_K F_jK * c_ai,bK !!                     + sum_ck L_bj,KC * c_ai,CK !!                     - sum_ck ( g_KC,bj * c_aK,Ci + g_Ki,bC * c_aK,Cj ) !! !!       Batch over c to construct  g_ki_bC !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension (:,:) :: c_ai_bj ! end subroutine jacobian_mlccsd_i2_mlccsd ! ! module subroutine jacobian_mlccsd_j2_mlccsd ( wf , rho_ab_ij , c_ab_ij ) !! !!       Jacobian CCSD J2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ab_ij&#94;J2 =    sum_ckld t_ci,dj * g_kc,ld * c_ak,bl !!                       + sum_ckdl t_ak,bl * g_kc,ld * c_ci,dj !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ab_ij real ( dp ), dimension (:,:) :: c_ab_ij ! end subroutine jacobian_mlccsd_j2_mlccsd ! ! module subroutine jacobian_mlccsd_k2_mlccsd ( wf , rho_ab_ij , c_ab_ij ) !! !!       Jacobian MLCCSD K2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       rho_ab_ij&#94;K2 =    sum_kl g_Ki,Lj * c_aK,bL !!                       + sum_cd g_aC,bD * c_Ci,Dj !! !!       For the last term we batch over a and b and !!       add each batch to rho_ai_bj !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:) :: rho_ab_ij real ( dp ), dimension (:,:) :: c_ab_ij ! end subroutine jacobian_mlccsd_k2_mlccsd ! ! ! end interface ! ! interface ! ! !     -::- Excited state submodule interface -::- !     ::::::::::::::::::::::::::::::::::::::::::: ! module subroutine transform_trial_vectors_mlccsd ( wf , first_trial , last_trial ) !! !!    Transformation of Trial Vectors (MLCC2) !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Each trial vector in first_trial to last_trial is read from file and !!    transformed before the transformed vector is written to file. !! !!    Singles and doubles part of the transformed vectors are written to !!    the same record in file transformed_vec, record length is n_parameters long. !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ), intent ( in ) :: first_trial , last_trial ! Which trial_vectors we are to transform ! end subroutine transform_trial_vectors_mlccsd ! ! module subroutine initialize_excited_states_mlccsd ( wf ) !! !!       Initialize excited states !!       Written by Sarai D. Folkestad, Aug 2017 !! !!       Calculates and sets n_s2am, and updates n_parameters !!       for excited state calculation !! implicit none ! class ( mlccsd ) :: wf end subroutine initialize_excited_states_mlccsd ! ! module subroutine print_excitation_vector_mlccsd ( wf , vec , unit_id ) !! !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: vec ! integer ( i15 ) :: unit_id ! end subroutine print_excitation_vector_mlccsd ! ! ! ! module subroutine summary_excited_state_info_mlccsd ( wf , energies ) !! !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! end subroutine summary_excited_state_info_mlccsd ! ! end interface ! ! contains ! ! subroutine init_mlccsd ( wf ) !! !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: i , j , active_space ! integer ( i15 ) :: unit_input = - 1 ! ! write ( unit_output , '(//t3,a/)' ) ':: Initialization' ! ! !     Set model name ! wf % name = 'MLCCSD' ! !     Open input file eT.inp ! call generate_unit_identifier ( unit_input ) open ( unit = unit_input , file = 'eT.inp' , status = 'old' , form = 'formatted' ) rewind ( unit_input ) ! !     Read general specifications (memory and diskspace for calculation) ! call wf % general_specs_reader ( unit_input ) ! !     Read MLCC info ! call wf % mlcc_reader ( unit_input ) ! !     MLCC sanity check ! if ( wf % mlcc_settings % CC3 ) then write ( unit_output , * ) 'WARNING: CC3 active spaces not available for MLCCSD' stop endif ! !     Set implemented methods ! wf % implemented % ground_state = . true . wf % implemented % excited_state = . true . wf % implemented % core_excited_state = . true . ! !     Read calculation tasks from input file eT.inp ! call wf % calculation_reader ( unit_input ) ! !     Read orbital info ! call wf % read_orbital_info ( unit_input ) ! !     Close input file ! close ( unit_input ) ! !     Read Hartree-Fock info ! call wf % read_hf_info ! !     Orbital partitioning - only if we have CCS/CC2 region ! if ( wf % mlcc_settings % CC2 ) then ! call wf % construct_orbital_coef_CC2_CCS call wf % construct_orbital_energy_CC2_CCS ! endif ! if ( wf % mlcc_settings % CCS . or . wf % mlcc_settings % CC2 ) then ! call wf % orbital_partitioning ! else ! write ( unit_output , '(/t3,a)' ) 'Full CCSD requested, orbital partitioning skipped.' flush ( unit_output ) ! !        Do full space CCSD calculation ! wf % n_CCSD_o = wf % n_o wf % n_CCSD_v = wf % n_v ! wf % first_CCSD_o = 1 wf % first_CCSD_v = 1 ! wf % n_CC2_o = 0 wf % n_CC2_v = 0 ! endif ! !     Initialize amplitudes and associated attributes ! !     Set number of amplitudes for CCSD active space ! wf % n_t2am = (( wf % n_CCSD_v ) * ( wf % n_CCSD_o )) * (( wf % n_CCSD_v ) * ( wf % n_CCSD_o ) + 1 ) / 2 ! call wf % initialize_amplitudes call wf % initialize_omega ! !     Set the number of parameters in the wavefunction !     (that are solved for in the ground and excited state solvers) ! wf % n_parameters = wf % n_t1am + wf % n_t2am ! !     Read Cholesky AO integrals and transform to MO basis ! if ( wf % mlcc_settings % CC2 ) then ! call wf % read_transform_cholesky_for_CC2_amplitude call wf % construct_MO_transformation_matrix call wf % destruct_orbital_coef_CC2_CCS ! endif ! call wf % read_transform_cholesky ! !     Initialize fock matrix ! call wf % initialize_fock_matrix ! end subroutine init_mlccsd ! ! subroutine initialize_amplitudes_mlccsd ( wf ) !! !!     Initialize Amplitudes (MLCCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Allocates the amplitudes, sets them to zero, and calculates !!     the number of amplitudes. !! implicit none ! class ( mlccsd ) :: wf ! !     Allocate the doubles amplitudes and set to zero ! wf % n_t1am = ( wf % n_o ) * ( wf % n_v ) if (. not . allocated ( wf % t1am )) call wf % mem % alloc ( wf % t1am , wf % n_v , wf % n_o ) wf % t1am = zero ! wf % n_t2am = (( wf % n_CCSD_v ) * ( wf % n_CCSD_o )) * (( wf % n_CCSD_v ) * ( wf % n_CCSD_o ) + 1 ) / 2 ! if (. not . allocated ( wf % t2am )) call wf % mem % alloc ( wf % t2am , wf % n_t2am , 1 ) wf % t2am = zero ! end subroutine initialize_amplitudes_mlccsd ! subroutine construct_perturbative_doubles_mlccsd ( wf ) !! !!    Construct Perturbative Doubles (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Sets the doubles amplitudes (t2am) to its MP2 estimate. This is !!    the initial guess used in the solver for the ground state amplitude !!    equations. !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: g_ai_bj ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 integer ( i15 ) :: ai = 0 , bj = 0 , ia = 0 , jb = 0 , aibj = 0 ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Calculate first/last indeces ! call wf % get_CCSD_active_indices ( first_active_o , first_active_v ) call wf % get_CCSD_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! !     Allocate L_ia_J and g_ia_jb ! call wf % mem % alloc ( L_ai_J , ( n_active_o ) * ( n_active_v ), wf % n_J ) call wf % mem % alloc ( g_ai_bj , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * ( n_active_v )) ! L_ai_J = zero g_ai_bj = zero ! !     Get the Cholesky IA vector ! call wf % get_cholesky_ai ( L_ai_J , first_active_v , last_active_v , first_active_o , last_active_o ) ! !     Calculate g_ia_jb = g_iajb ! call dgemm ( 'N' , 'T' , & n_active_o * n_active_v , & n_active_o * n_active_v , & wf % n_J , & one , & L_ai_J , & n_active_o * n_active_v , & L_ai_J , & n_active_o * n_active_v , & zero , & g_ai_bj , & n_active_o * n_active_v ) ! !     Set the doubles amplitudes ! do i = 1 , n_active_o do a = 1 , n_active_v ! ai = index_two ( a , i , n_active_v ) ! do j = 1 , n_active_o do b = 1 , n_active_v ! bj = index_two ( b , j , n_active_v ) ! !                 Set the doubles amplitudes ! if ( ai . le . bj ) then ! To avoid setting the same element twice ! aibj = index_packed ( ai , bj ) ! wf % t2am ( aibj , 1 ) = - g_ai_bj ( ai , bj ) / ( wf % fock_diagonal ( wf % n_o + a + first_active_v - 1 , 1 ) + & wf % fock_diagonal ( wf % n_o + b + first_active_v - 1 , 1 ) - & wf % fock_diagonal ( i + first_active_o - 1 , 1 ) - & wf % fock_diagonal ( j + first_active_o - 1 , 1 )) ! endif ! enddo enddo enddo enddo ! !     Deallocations ! call wf % mem % dealloc ( L_ai_J , ( n_active_o ) * ( n_active_v ), wf % n_J ) call wf % mem % dealloc ( g_ai_bj , ( n_active_o ) * ( n_active_v ), ( n_active_o ) * ( n_active_v )) ! end subroutine construct_perturbative_doubles_mlccsd ! subroutine get_CCSD_active_indices_mlccsd ( wf , first_o , first_v ) !! !!    Get CC2 active indices, !!    Written by Sarai D. Folkestad, June 2017 !! !!    Returns the first active occupied and virtual indices !!    of the active space. !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ) :: first_o integer ( i15 ) :: first_v ! first_o = wf % first_CCSD_o first_v = wf % first_CCSD_v ! end subroutine get_CCSD_active_indices_mlccsd ! ! subroutine get_CC2_active_indices_mlccsd ( wf , first_o , first_v ) !! !!    Get CC2 active indices, !!    Written by Sarai D. Folkestad, June 2017 !! !!    Returns the first active occupied and virtual indices !!    of the active space. !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ) :: first_o integer ( i15 ) :: first_v ! first_o = wf % first_CCSD_o first_v = wf % first_CCSD_v ! end subroutine get_CC2_active_indices_mlccsd ! ! subroutine get_CC2_n_active_mlccsd ( wf , n_active_o , n_active_v ) !! !!    Get CC2 active indices, !!    Written by Sarai D. Folkestad, June 2017 !! !!    Returns the first active occupied and virtual indices !!    of the active space. !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ) :: n_active_o integer ( i15 ) :: n_active_v ! n_active_o = wf % n_CC2_o + wf % n_CCSD_o n_active_v = wf % n_CC2_v + wf % n_CCSD_v ! end subroutine get_CC2_n_active_mlccsd ! ! subroutine get_CCSD_n_active_mlccsd ( wf , n_active_o , n_active_v ) !! !!    Get CC2 active indices, !!    Written by Sarai D. Folkestad, June 2017 !! !!    Returns the first active occupied and virtual indices !!    of the active space. !! implicit none ! class ( mlccsd ) :: wf integer ( i15 ) :: n_active_o integer ( i15 ) :: n_active_v ! n_active_o = wf % n_CCSD_o n_active_v = wf % n_CCSD_v ! end subroutine get_CCSD_n_active_mlccsd ! ! subroutine calc_energy_mlccsd ( wf ) !! !!     Calculate Energy (MLCCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Calculates the MLCCSD energy for the wavefunction's current amplitudes. !! !!       E = E_scf + sum_AIBJ (t&#94;A_I * t&#94;B_J)*L_IAJB !!                 + sum aibj (s&#94;ab_ij + t&#94;ab_ij)L_ia_jb !! !!     where lower case letters indicate indices restricted to the CC2+CCSD regions. !! !!     s&#94;ab_ij is zero in the CCSD region, and t&#94;ab_ij is zero in the CC2 region. !! !! implicit none ! class ( mlccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: L_ia_J ! L_ia&#94;J real ( dp ), dimension (:,:), allocatable :: g_ia_jb ! g_iajb real ( dp ), dimension (:,:), allocatable :: x_ia_jb ! s_ij&#94;ab ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 , ai = 0 integer ( i15 ) :: bj = 0 , aibj = 0 , ia = 0 , jb = 0 , ib = 0 , ja = 0 integer ( i15 ) :: ia_full = 0 , jb_full = 0 ! !     Active space variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! !     Allocate the Cholesky vector L_ia_J = L_ia&#94;J and set to zero ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_ia_J = zero ! !     Get the Cholesky vector L_ia_J ! call wf % get_cholesky_ia ( L_ia_J ) ! !     Allocate g_ia_jb = g_iajb and set it to zero ! call wf % mem % alloc ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ia_jb = zero ! !     Calculate the integrals g_ia_jb from the Cholesky vector L_ia_J ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ia_jb , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate the Cholesky vector L_ia_J ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Set the initial value of the energy ! wf % energy = wf % scf_energy ! !     t1 amplitude contribution ! ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ia = index_two ( i , a , wf % n_o ) ! do j = 1 , wf % n_o ! ja = index_two ( j , a , wf % n_o ) ! do b = 1 , wf % n_v ! jb = index_two ( j , b , wf % n_o ) ib = index_two ( i , b , wf % n_o ) ! !                 Add the correlation energy from the single amplitudes ! wf % energy = wf % energy + & ( wf % t1am ( a , i )) * ( wf % t1am ( b , j )) * & ( two * g_ia_jb ( ia , jb ) - g_ia_jb ( ib , ja )) ! enddo enddo enddo enddo ! !     t2 amplitude contribution to the energy ! !     Calculate first/last indeces ! call wf % get_CCSD_active_indices ( first_active_o , first_active_v ) call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! call wf % mem % alloc ( x_ia_jb , n_active_v * n_active_o , n_active_v * n_active_o ) call wf % get_mlccsd_x2am ( x_ia_jb ) ! do i = 1 , n_active_o do a = 1 , n_active_v ! ia = index_two ( i , a , n_active_o ) ia_full = index_two ( i + first_active_o - 1 , a + first_active_v - 1 , wf % n_o ) ! do j = 1 , n_active_o ! ja = index_two ( j + first_active_o - 1 , a + first_active_v - 1 , wf % n_o ) ! do b = 1 , n_active_v ! jb_full = index_two ( j + first_active_o - 1 , b + first_active_v - 1 , wf % n_o ) jb = index_two ( j , b , n_active_o ) ib = index_two ( i + first_active_o - 1 , b + first_active_v - 1 , wf % n_o ) ! ! !                 Add the correlation energy from the double amplitudes ! wf % energy = wf % energy + & ( x_ia_jb ( ia , jb )) * & ( two * g_ia_jb ( ia_full , jb_full ) - g_ia_jb ( ib , ja )) ! enddo enddo enddo enddo ! !     Deallocate g_ia_jb ! call wf % mem % dealloc ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call wf % mem % dealloc ( x_ia_jb , n_active_v * n_active_o , n_active_v * n_active_o ) ! end subroutine calc_energy_mlccsd ! ! subroutine construct_orbital_coef_CC2_CCS_mlccsd ( wf ) !! !! implicit none ! class ( mlccsd ) :: wf ! if (. not . allocated ( wf % mo_coef_cc2_ccs )) call wf % mem % alloc ( wf % mo_coef_cc2_ccs , wf % n_ao , wf % n_mo ) wf % mo_coef_cc2_ccs = zero ! end subroutine construct_orbital_coef_CC2_CCS_mlccsd ! ! subroutine destruct_orbital_coef_CC2_CCS_mlccsd ( wf ) !! !! implicit none ! class ( mlccsd ) :: wf ! if ( allocated ( wf % mo_coef_cc2_ccs )) call wf % mem % dealloc ( wf % mo_coef_cc2_ccs , wf % n_ao , wf % n_mo ) ! end subroutine destruct_orbital_coef_CC2_CCS_mlccsd ! ! subroutine construct_orbital_energy_CC2_CCS_mlccsd ( wf ) !! !! implicit none ! class ( mlccsd ) :: wf ! if (. not . allocated ( wf % fock_diagonal_cc2_ccs )) call wf % mem % alloc ( wf % fock_diagonal_cc2_ccs , wf % n_mo , 1 ) wf % mo_coef_cc2_ccs = zero ! end subroutine construct_orbital_energy_CC2_CCS_mlccsd ! subroutine destruct_orbital_energy_CC2_CCS_mlccsd ( wf ) !! !! implicit none ! class ( mlccsd ) :: wf ! if ( allocated ( wf % fock_diagonal_cc2_ccs )) call wf % mem % dealloc ( wf % fock_diagonal_cc2_ccs , wf % n_mo , 1 ) ! end subroutine destruct_orbital_energy_CC2_CCS_mlccsd ! ! subroutine destruct_double_amplitudes_mlccsd ( wf ) !! !! implicit none ! class ( mlccsd ) :: wf ! if ( allocated ( wf % t2am )) call wf % mem % dealloc ( wf % t2am , wf % n_t2am , 1 ) ! end subroutine destruct_double_amplitudes_mlccsd ! subroutine destruct_amplitudes_mlccsd ( wf ) !! !! implicit none ! class ( mlccsd ) :: wf ! call wf % destruct_double_amplitudes call destruct_amplitudes_ccs ( wf ) ! end subroutine destruct_amplitudes_mlccsd ! ! subroutine save_amplitudes_mlccsd ( wf ) !! !!    Save Amplitudes (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Store the amplitudes to disk (T1AM, T2AM) !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: unit_x1am = - 1 integer ( i15 ) :: unit_x2am = - 1 integer ( i15 ) :: unit_t2am = - 1 integer ( i15 ) :: n_active_o , n_active_v ! integer ( i15 ) :: i = 0 , a = 0 , b = 0 , j = 0 integer ( i15 ) :: ia = 0 , ai = 0 , jb = 0 , bj = 0 integer ( i15 ) :: aibj = 0 ! real ( dp ), dimension (:,:), allocatable :: x_ia_jb ! !     Open amplitude files ! call generate_unit_identifier ( unit_x1am ) call generate_unit_identifier ( unit_x2am ) call generate_unit_identifier ( unit_t2am ) ! open ( unit_x1am , file = 't1am' , status = 'unknown' , form = 'unformatted' ) open ( unit_t2am , file = 't2am' , status = 'unknown' , form = 'unformatted' ) open ( unit_x2am , file = 'x2am' , status = 'unknown' , form = 'unformatted' ) ! rewind ( unit_x1am ) rewind ( unit_x2am ) rewind ( unit_t2am ) ! !     Write amplitudes to files ! write ( unit_x1am ) wf % t1am write ( unit_t2am ) wf % t2am ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) wf % n_x2am = ( n_active_v ) * ( n_active_o ) * (( n_active_v ) * ( n_active_o ) + 1 ) / 2 ! call wf % mem % alloc ( x_ia_jb , ( n_active_v ) * ( n_active_o ), ( n_active_v ) * ( n_active_o )) call wf % get_mlccsd_x2am ( x_ia_jb ) ! !     Reorder and pack in ! call wf % mem % alloc ( wf % x2am , wf % n_x2am , 1 ) ! do i = 1 , n_active_o do a = 1 , n_active_v ai = index_two ( a , i , n_active_v ) ia = index_two ( i , a , n_active_o ) do j = 1 , n_active_o do b = 1 , n_active_v ! bj = index_two ( b , j , n_active_v ) jb = index_two ( j , b , n_active_o ) ! aibj = index_packed ( ai , bj ) ! wf % x2am ( aibj , 1 ) = x_ia_jb ( ia , jb ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( x_ia_jb , ( n_active_v ) * ( n_active_o ), ( n_active_v ) * ( n_active_o )) ! write ( unit_x2am ) wf % x2am call wf % mem % dealloc ( wf % x2am , wf % n_x2am , 1 ) ! !     Close amplitude files ! close ( unit_x1am ) close ( unit_x2am ) close ( unit_t2am ) ! end subroutine save_amplitudes_mlccsd ! subroutine read_amplitudes_mlccsd ( wf ) !! !!    Read Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM) !! implicit none ! class ( mlccsd ) :: wf ! call wf % read_single_amplitudes call wf % read_mlccsd_double_amplitudes ! end subroutine read_amplitudes_mlccsd ! subroutine read_mlccsd_double_amplitudes_mlccsd ( wf ) !! !!    Read Amplitudes (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM, T2AM) !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: unit_x2am = - 1 integer ( i15 ) :: n_active_v , n_active_o ! logical :: file_exists = . false . ! !     Check to see whether file exists ! inquire ( file = 'x2am' , exist = file_exists ) ! if ( file_exists ) then ! !        Open amplitude files if they exist ! call generate_unit_identifier ( unit_x2am ) ! open ( unit_x2am , file = 'x2am' , status = 'unknown' , form = 'unformatted' ) ! rewind ( unit_x2am ) ! !        Read from file & close ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) wf % n_x2am = ( n_active_v ) * ( n_active_o ) * (( n_active_v ) * ( n_active_o ) + 1 ) / 2 ! if (. not . allocated ( wf % x2am )) call wf % mem % alloc ( wf % x2am , wf % n_x2am , 1 ) ! read ( unit_x2am ) wf % x2am ! close ( unit_x2am ) ! else ! write ( unit_output , '(t3,a)' ) 'Error: amplitude files do not exist.' stop ! endif ! end subroutine read_mlccsd_double_amplitudes_mlccsd ! ! subroutine read_double_amplitudes_mlccsd ( wf ) !! !!    Read Amplitudes (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM, T2AM) !! implicit none ! class ( mlccsd ) :: wf ! integer ( i15 ) :: unit_t2am = - 1 integer ( i15 ) :: n_active_v , n_active_o ! logical :: file_exists = . false . ! !     Check to see whether file exists ! inquire ( file = 't2am' , exist = file_exists ) ! if ( file_exists ) then ! !        Open amplitude files if they exist ! call generate_unit_identifier ( unit_t2am ) ! open ( unit_t2am , file = 't2am' , status = 'unknown' , form = 'unformatted' ) ! rewind ( unit_t2am ) ! !        Read from file & close ! call wf % get_CCSD_n_active ( n_active_o , n_active_v ) wf % n_t2am = ( n_active_v ) * ( n_active_o ) * (( n_active_v ) * ( n_active_o ) + 1 ) / 2 ! if (. not . allocated ( wf % t2am )) call wf % mem % alloc ( wf % t2am , wf % n_t2am , 1 ) ! read ( unit_t2am ) wf % t2am ! close ( unit_t2am ) ! else ! write ( unit_output , '(t3,a)' ) 'Error: amplitude files do not exist.' stop ! endif ! end subroutine read_double_amplitudes_mlccsd end module mlccsd_class","tags":"","loc":"sourcefile/mlccsd_class.f90.html","title":"mlccsd_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ccsd_class.f90~~EfferentGraph sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileccsd_classf90EfferentGraph = svgPanZoom('#sourcefileccsd_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~ccsd_class.f90~~AfferentGraph sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefileccsd_classf90AfferentGraph = svgPanZoom('#sourcefileccsd_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules ccsd_class Source Code ccsd_class.F90 Source Code module ccsd_class ! !! !! !!                Coupled cluster singles and doubles (CCSD) class module !!              Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !! !! !!    This module contains the definition of the coupled cluster singles !!    and doubles (CCSD) wavefunction class. It is structured into four sections: !! !!       1. Modules used by the class: !! !!             Basic utilities and the ancestor class (CCS) !! !!       2. Definition of the class: !! !!             Non-inherited variables, followed by non-inherited or overridden procedures !! !!       3. Interfaces to submodules: !! !!             The procedures in the class are grouped according to functionality, with !!             detailed definitions given in the following class submodules: !! !!                - Ground state !!                - Omega !!                - Excited state !!                - Jacobian (right transformation) !!                - Jacobian Transpose (left transformation) !!                - Ionized State !!                - CVS !! !!             The interfaces shows incoming variables and their type, but contains !!             no information of the procedure itself. The procedure is shown in full !!             in the corresponding submodule. !! !!       4. Class module routines (i.e., non-submodule procedures). These include !!          the initialization and driver routines of the class, along with procedures that !!          are not (yet, at least) easily gathered in a submodule. !! !! ! ! !  ::::::::::::::::::::::::::::::::::::: !  -::- 1. Modules used by the class -::- !  :::::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output ! !  Ancestor class module (CCS) ! use ccs_class ! implicit none ! ! !  ::::::::::::::::::::::::::::::::::::::::: !  -::- 2. Definition of the CCSD class -::- !  ::::::::::::::::::::::::::::::::::::::::: ! ! type , extends ( ccs ) :: ccsd ! !     Cluster amplitudes ! integer ( i15 ) :: n_t2am = 0 ! Number of doubles excitation amplitudes ! real ( dp ), dimension (:,:), allocatable :: t2am ! Doubles amplitude vector, t_ij&#94;ab ! !     The omega, or projection, vector < mu | exp(-T) H exp(T) | R > ! real ( dp ), dimension (:,:), allocatable :: omega2 ! Doubles projection vector ! contains ! ! !     -::- Initialization and driver routines -::- !     -------------------------------------------- ! procedure :: init => init_ccsd ! procedure :: initialize_amplitudes => initialize_amplitudes_ccsd procedure :: initialize_omega => initialize_omega_ccsd ! ! !     -::- Ground state submodule routine pointers -::- !     ------------------------------------------------- ! procedure :: initialize_ground_state => initialize_ground_state_ccsd procedure :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd procedure :: new_amplitudes => new_amplitudes_ccsd procedure :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd procedure :: ground_state_preparations => ground_state_preparations_ccsd ! ! !     -::- Omega submodule routine pointers -::- !     ------------------------------------------ ! procedure :: construct_omega => construct_omega_ccsd ! procedure :: omega_ccsd_a1 => omega_ccsd_a1_ccsd procedure :: omega_ccsd_b1 => omega_ccsd_b1_ccsd procedure :: omega_ccsd_c1 => omega_ccsd_c1_ccsd ! procedure :: omega_ccsd_a2 => omega_ccsd_a2_ccsd procedure :: omega_ccsd_b2 => omega_ccsd_b2_ccsd procedure :: omega_ccsd_c2 => omega_ccsd_c2_ccsd procedure :: omega_ccsd_d2 => omega_ccsd_d2_ccsd procedure :: omega_ccsd_e2 => omega_ccsd_e2_ccsd ! ! !     -::- Excited state submodule routine pointers -::- !     -------------------------------------------------- ! procedure :: calculate_orbital_differences => calculate_orbital_differences_ccsd procedure :: transform_trial_vectors => transform_trial_vectors_ccsd procedure :: print_excitation_vector => print_excitation_vector_ccsd procedure :: analyze_double_excitation_vector => analyze_double_excitation_vector_ccsd procedure :: summary_excited_state_info => summary_excited_state_info_ccsd procedure :: excited_state_preparations => excited_state_preparations_ccsd ! ! !     -::- Jacobian submodule routine pointers -::- !     --------------------------------------------- ! procedure :: jacobian_ccsd_transformation => jacobian_ccsd_transformation_ccsd ! procedure :: jacobian_ccsd_a1 => jacobian_ccsd_a1_ccsd procedure :: jacobian_ccsd_b1 => jacobian_ccsd_b1_ccsd procedure :: jacobian_ccsd_c1 => jacobian_ccsd_c1_ccsd procedure :: jacobian_ccsd_d1 => jacobian_ccsd_d1_ccsd ! procedure :: jacobian_ccsd_a2 => jacobian_ccsd_a2_ccsd procedure :: jacobian_ccsd_b2 => jacobian_ccsd_b2_ccsd procedure :: jacobian_ccsd_c2 => jacobian_ccsd_c2_ccsd procedure :: jacobian_ccsd_d2 => jacobian_ccsd_d2_ccsd procedure :: jacobian_ccsd_e2 => jacobian_ccsd_e2_ccsd procedure :: jacobian_ccsd_f2 => jacobian_ccsd_f2_ccsd procedure :: jacobian_ccsd_g2 => jacobian_ccsd_g2_ccsd procedure :: jacobian_ccsd_h2 => jacobian_ccsd_h2_ccsd procedure :: jacobian_ccsd_i2 => jacobian_ccsd_i2_ccsd procedure :: jacobian_ccsd_j2 => jacobian_ccsd_j2_ccsd procedure :: jacobian_ccsd_k2 => jacobian_ccsd_k2_ccsd ! procedure :: jacobi_test => jacobi_test_ccsd ! A debug routine ! ! !     -::- Jacobian transpose submodule routine pointers -::- !     ------------------------------------------------------- ! procedure :: jacobian_transpose_ccsd_transformation => jacobian_transpose_ccsd_transformation_ccsd ! procedure :: jacobian_transpose_ccsd_a1 => jacobian_transpose_ccsd_a1_ccsd procedure :: jacobian_transpose_ccsd_b1 => jacobian_transpose_ccsd_b1_ccsd procedure :: jacobian_transpose_ccsd_c1 => jacobian_transpose_ccsd_c1_ccsd procedure :: jacobian_transpose_ccsd_d1 => jacobian_transpose_ccsd_d1_ccsd procedure :: jacobian_transpose_ccsd_e1 => jacobian_transpose_ccsd_e1_ccsd procedure :: jacobian_transpose_ccsd_f1 => jacobian_transpose_ccsd_f1_ccsd procedure :: jacobian_transpose_ccsd_g1 => jacobian_transpose_ccsd_g1_ccsd ! procedure :: jacobian_transpose_ccsd_a2 => jacobian_transpose_ccsd_a2_ccsd procedure :: jacobian_transpose_ccsd_b2 => jacobian_transpose_ccsd_b2_ccsd procedure :: jacobian_transpose_ccsd_c2 => jacobian_transpose_ccsd_c2_ccsd procedure :: jacobian_transpose_ccsd_d2 => jacobian_transpose_ccsd_d2_ccsd procedure :: jacobian_transpose_ccsd_e2 => jacobian_transpose_ccsd_e2_ccsd procedure :: jacobian_transpose_ccsd_f2 => jacobian_transpose_ccsd_f2_ccsd procedure :: jacobian_transpose_ccsd_g2 => jacobian_transpose_ccsd_g2_ccsd procedure :: jacobian_transpose_ccsd_h2 => jacobian_transpose_ccsd_h2_ccsd procedure :: jacobian_transpose_ccsd_i2 => jacobian_transpose_ccsd_i2_ccsd ! ! !     -::- Ionized state submodule routine pointers -::- !     -------------------------------------------------- ! procedure :: ionization_residual_projection => ionization_residual_projection_ccsd procedure :: ionization_rho_aibj_projection => ionization_rho_aibj_projection_ccsd ! ! !     -::- CVS submodule routine pointers -::- !     ---------------------------------------- ! procedure :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_ccsd procedure :: cvs_residual_projection => cvs_residual_projection_ccsd ! ! !     -::- Other class routine pointers not located in submodules -::- !     ---------------------------------------------------------------- ! !     Routine to construct right projection vector (eta) ! procedure :: construct_eta => construct_eta_ccsd ! !     Routine to save and read the amplitudes ! procedure :: save_amplitudes => save_amplitudes_ccsd ! procedure :: read_amplitudes => read_amplitudes_ccsd procedure :: read_double_amplitudes => read_double_amplitudes_ccsd ! !     Routines to deallocate amplitudes and omega ! procedure :: destruct_amplitudes => destruct_amplitudes_ccsd procedure :: destruct_omega => destruct_omega_ccsd ! procedure :: construct_perturbative_doubles => construct_perturbative_doubles_ccsd ! !     Routine to calculate the energy ! procedure :: calc_energy => calc_energy_ccsd ! end type ccsd ! ! !  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- 3. Interfaces to the submodules of the CCSD class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ! ! interface ! ! !     -::- Ground state submodule interface -::- !     ------------------------------------------ ! module subroutine calc_ampeqs_norm_ccsd ( wf , ampeqs_norm ) !! !!       Calculate amplitude equations norm (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ) :: ampeqs_norm ! end subroutine calc_ampeqs_norm_ccsd ! ! module subroutine new_amplitudes_ccsd ( wf ) !! !!       New amplitudes (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine new_amplitudes_ccsd ! ! module subroutine calc_quasi_Newton_doubles_ccsd ( wf , dt ) !! !!       Calculate quasi-Newton estimate (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: dt ! end subroutine calc_quasi_Newton_doubles_ccsd ! ! module subroutine initialize_ground_state_ccsd ( wf ) !! !!       Initialize ground state (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine initialize_ground_state_ccsd ! ! module subroutine ground_state_preparations_ccsd ( wf ) !! !!       Ground state preparations (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! class ( ccsd ) :: wf ! end subroutine ground_state_preparations_ccsd ! end interface ! ! interface ! ! !     -::- Omega submodule interface -::- !     ----------------------------------- ! module subroutine initialize_omega_ccsd ( wf ) !! !!       Initialize omega (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine initialize_omega_ccsd ! ! module subroutine construct_omega_ccsd ( wf ) !! !!       Construct omega (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine construct_omega_ccsd ! ! module subroutine omega_ccsd_a1_ccsd ( wf ) !! !!       Omega CCSD A1 term !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_ccsd_a1_ccsd ! ! module subroutine omega_ccsd_b1_ccsd ( wf ) !! !!       Omega CCSD B1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_ccsd_b1_ccsd ! ! module subroutine omega_ccsd_c1_ccsd ( wf ) !! !!       Omega CCSD C1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_ccsd_c1_ccsd ! ! module subroutine omega_ccsd_a2_ccsd ( wf ) !! !!       Omega CCSD A2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_ccsd_a2_ccsd ! ! module subroutine omega_ccsd_b2_ccsd ( wf ) !! !!       Omega CCSD B2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_ccsd_b2_ccsd ! ! module subroutine omega_ccsd_c2_ccsd ( wf ) !! !!       Omega CCSD C2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_ccsd_c2_ccsd ! ! module subroutine omega_ccsd_d2_ccsd ( wf ) !! !!       Omega CCSD D2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_ccsd_d2_ccsd ! ! module subroutine omega_ccsd_e2_ccsd ( wf ) !! !!       Omega E2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_ccsd_e2_ccsd ! ! end interface ! ! interface ! ! !     -::- Excited state submodule interface -::- !     ------------------------------------------- ! module subroutine calculate_orbital_differences_ccsd ( wf , orbital_diff ) !! !!       Calculate orbital differences (CCSD) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: orbital_diff ! end subroutine calculate_orbital_differences_ccsd ! ! module subroutine transform_trial_vectors_ccsd ( wf , first_trial , last_trial ) !! !!       Transformation trial vectors (CCSD) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ), intent ( in ) :: first_trial , last_trial ! Which trial_vectors we are to transform ! end subroutine transform_trial_vectors_ccsd ! module subroutine print_excitation_vector_ccsd ( wf , vec , unit_id ) !! !!       Print excitation vector !!       Written by Sarai D. Folkestad, Oct 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: vec ! integer ( i15 ) :: unit_id ! end subroutine print_excitation_vector_ccsd ! ! module subroutine cvs_residual_projection_ccsd ( wf , residual ) !! !!       CVS residual projection (CCSD) !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccsd ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine cvs_residual_projection_ccsd ! ! module subroutine excited_state_preparations_ccsd ( wf ) !! !!       Excited State Preparations (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! class ( ccsd ) :: wf ! end subroutine excited_state_preparations_ccsd ! ! module subroutine analyze_double_excitation_vector_ccsd ( wf , vec , n , sorted_short_vec , index_list ) !! !!       Analyze double excitation vector !!       Written by Sarai D. Folkestad, Oct 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_t2am , 1 ) :: vec ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 , k = 0 ! integer ( i15 ) :: n ! real ( dp ), dimension ( n , 1 ) :: sorted_short_vec ! integer ( i15 ), dimension ( n , 4 ) :: index_list ! end subroutine analyze_double_excitation_vector_ccsd ! ! module subroutine summary_excited_state_info_ccsd ( wf , energies ) !! !!       Summary of excited state info !!       Written by Sarai D. Folkestad, Oct 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! end subroutine summary_excited_state_info_ccsd ! ! end interface ! ! interface ! ! !     -::- Ionized state submodule interface -::- !     ------------------------------------------- ! module subroutine ionization_residual_projection_ccsd ( wf , residual ) !! !!       Residual projection for CVS !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccsd ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine ionization_residual_projection_ccsd ! ! module subroutine ionization_rho_aibj_projection_ccsd ( wf , rho_aibj ) !! !!       Residual projection for CVS !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccsd ) :: wf real ( dp ), dimension (:,:) :: rho_aibj ! end subroutine ionization_rho_aibj_projection_ccsd ! ! module subroutine ionization_jacobian_ccsd_transformation_ccsd ( wf , c_a_i , c_aibj ) !! !!      Ionization Jacobian transformation (CCSD) !!      Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_t2am , 1 ) :: c_aibj ! c_aibj ! end subroutine ionization_jacobian_ccsd_transformation_ccsd ! ! module subroutine core_ionization_jacobian_ccsd_transformation_ccsd ( wf , c_a_i , c_aibj ) !! !!       Core ionization Jacobian transformation (CCSD) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_t2am , 1 ) :: c_aibj ! c_aibj ! end subroutine core_ionization_jacobian_ccsd_transformation_ccsd ! ! end interface ! ! interface ! ! !     -::- Jacobian submodule interface -::- !     -------------------------------------- ! module subroutine jacobian_ccsd_transformation_ccsd ( wf , c_a_i , c_aibj ) !! !!       Jacobian CCSD transformation !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_t2am , 1 ) :: c_aibj ! c_aibj ! end subroutine jacobian_ccsd_transformation_ccsd ! ! module subroutine cvs_jacobian_ccsd_transformation_ccsd ( wf , c_a_i , c_aibj ) !! !!       CVS Jacobian transformation (CCSD) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_t2am , 1 ) :: c_aibj ! c_aibj ! end subroutine cvs_jacobian_ccsd_transformation_ccsd ! ! module subroutine jacobian_ccsd_a1_ccsd ( wf , rho_a_i , c_a_i ) !! !!       Jacobian CCSD A1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! rho_ai ! end subroutine jacobian_ccsd_a1_ccsd ! ! module subroutine jacobian_ccsd_b1_ccsd ( wf , rho_a_i , c_ai_bj ) !! !!       Jacobian CCSD B1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj ! c_aibj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! rho_ai ! end subroutine jacobian_ccsd_b1_ccsd ! ! module subroutine jacobian_ccsd_c1_ccsd ( wf , rho_a_i , c_ai_bj ) !! !!       Jacobian CCSD C1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! rho_ai ! end subroutine jacobian_ccsd_c1_ccsd ! ! module subroutine jacobian_ccsd_d1_ccsd ( wf , rho_a_i , c_bi_cj ) !! !!       Jacobian CCSD D1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_bi_cj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! rho_ai ! end subroutine jacobian_ccsd_d1_ccsd ! ! module subroutine jacobian_ccsd_a2_ccsd ( wf , rho_ai_bj , c_a_i ) !! !!       Jacobian CCSD A2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! end subroutine jacobian_ccsd_a2_ccsd ! ! module subroutine jacobian_ccsd_b2_ccsd ( wf , rho_ai_bj , c_a_i ) !! !!       Jacobian CCSD B2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj ! end subroutine jacobian_ccsd_b2_ccsd ! ! module subroutine jacobian_ccsd_c2_ccsd ( wf , rho_ai_bj , c_a_i ) !! !!       Jacobian CCSD C2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj ! end subroutine jacobian_ccsd_c2_ccsd ! ! module subroutine jacobian_ccsd_d2_ccsd ( wf , rho_ai_bj , c_a_i ) !! !!       Jacobian CCSD D2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj ! end subroutine jacobian_ccsd_d2_ccsd ! ! module subroutine jacobian_ccsd_e2_ccsd ( wf , rho_ai_bj , c_ai_ck ) !! !!       Jacobian CCSD E2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_ck ! end subroutine jacobian_ccsd_e2_ccsd ! ! module subroutine jacobian_ccsd_f2_ccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian CCSD F2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj ! end subroutine jacobian_ccsd_f2_ccsd ! ! module subroutine jacobian_ccsd_g2_ccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian CCSD G2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj ! end subroutine jacobian_ccsd_g2_ccsd ! ! module subroutine jacobian_ccsd_h2_ccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian CCSD H2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj ! end subroutine jacobian_ccsd_h2_ccsd ! ! module subroutine jacobian_ccsd_i2_ccsd ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian CCSD I2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: rho_ai_bj real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) :: c_ai_bj ! end subroutine jacobian_ccsd_i2_ccsd ! ! module subroutine jacobian_ccsd_j2_ccsd ( wf , rho_ab_ij , c_ab_ij ) !! !!       Jacobian CCSD J2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: rho_ab_ij real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: c_ab_ij ! end subroutine jacobian_ccsd_j2_ccsd ! ! module subroutine jacobian_ccsd_k2_ccsd ( wf , rho_ab_ij , c_ab_ij ) !! !!       Jacobian CCSD K2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: rho_ab_ij real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: c_ab_ij ! end subroutine jacobian_ccsd_k2_ccsd ! ! end interface ! ! interface ! ! !     -::- Jacobian transpose submodule interface -::- !     ------------------------------------------------ ! module subroutine jacobian_transpose_ccsd_transformation_ccsd ( wf , b_a_i , b_aibj ) !! !!       Jacobian transpose transformation (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i real ( dp ), dimension ( wf % n_t2am , 1 ) :: b_aibj ! end subroutine jacobian_transpose_ccsd_transformation_ccsd ! ! module subroutine jacobian_transpose_ccsd_a1_ccsd ( wf , sigma_a_i , b_a_i ) !! !!       Jacobian transpose CCSD A1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i ! end subroutine jacobian_transpose_ccsd_a1_ccsd ! ! module subroutine jacobian_transpose_ccsd_b1_ccsd ( wf , sigma_a_i , b_a_i ) !! !!       Jacobian transpose CCSD B1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i ! end subroutine jacobian_transpose_ccsd_b1_ccsd ! ! module subroutine jacobian_transpose_ccsd_c1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!       Jacobian transpose CCSD C1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! end subroutine jacobian_transpose_ccsd_c1_ccsd ! ! module subroutine jacobian_transpose_ccsd_d1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!       Jacobian transpose CCSD D1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! end subroutine jacobian_transpose_ccsd_d1_ccsd ! ! module subroutine jacobian_transpose_ccsd_e1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!       Jacobian transpose CCSD E1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! end subroutine jacobian_transpose_ccsd_e1_ccsd ! ! module subroutine jacobian_transpose_ccsd_f1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!       Jacobian transpose CCSD F1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! end subroutine jacobian_transpose_ccsd_f1_ccsd ! ! module subroutine jacobian_transpose_ccsd_g1_ccsd ( wf , sigma_a_i , b_ai_bj ) !! !!       Jacobian transpose CCSD G1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj ! end subroutine jacobian_transpose_ccsd_g1_ccsd ! ! module subroutine jacobian_transpose_ccsd_a2_ccsd ( wf , sigma_ai_bj , b_a_i ) !! !!       Jacobian transpose CCSD A2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! end subroutine jacobian_transpose_ccsd_a2_ccsd ! ! module subroutine jacobian_transpose_ccsd_b2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!       Jacobian transpose CCSD B2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! end subroutine jacobian_transpose_ccsd_b2_ccsd ! ! module subroutine jacobian_transpose_ccsd_c2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!       Jacobian transpose CCSD C2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! end subroutine jacobian_transpose_ccsd_c2_ccsd ! ! module subroutine jacobian_transpose_ccsd_d2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!       Jacobian transpose CCSD D2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! end subroutine jacobian_transpose_ccsd_d2_ccsd ! ! module subroutine jacobian_transpose_ccsd_e2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!       Jacobian transpose CCSD E2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! end subroutine jacobian_transpose_ccsd_e2_ccsd ! ! module subroutine jacobian_transpose_ccsd_f2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!       Jacobian transpose CCSD F2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! end subroutine jacobian_transpose_ccsd_f2_ccsd ! ! module subroutine jacobian_transpose_ccsd_g2_ccsd ( wf , sigma_ai_bj , b_ai_bj ) !! !!       Jacobian transpose CCSD G2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: b_ai_bj real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: sigma_ai_bj ! end subroutine jacobian_transpose_ccsd_g2_ccsd ! ! module subroutine jacobian_transpose_ccsd_h2_ccsd ( wf , sigma_ab_ij , b_ab_ij ) !! !!       Jacobian transpose CCSD H2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: b_ab_ij real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: sigma_ab_ij ! end subroutine jacobian_transpose_ccsd_h2_ccsd ! ! module subroutine jacobian_transpose_ccsd_i2_ccsd ( wf , sigma_ab_ij , b_ab_ij ) !! !!       Jacobian transpose CCSD I2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: b_ab_ij real ( dp ), dimension (( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) :: sigma_ab_ij ! end subroutine jacobian_transpose_ccsd_i2_ccsd ! ! module subroutine cvs_rho_aibj_projection_ccsd ( wf , vec_aibj ) !! !!       CVS Rho_aibj projection (CCSD) !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccsd ) :: wf real ( dp ), dimension (:, :) :: vec_aibj ! end subroutine cvs_rho_aibj_projection_ccsd ! ! end interface ! ! contains ! ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::- 4. Class subroutines and functions -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! ! subroutine init_ccsd ( wf ) !! !!    Initialize CCSD object !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Performs the following tasks: !! !!    - Sets HF orbital and energy information by reading from file (read_hf_info) !!    - Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky) !!    - Allocates the Fock matrix and sets it to zero !!    - Initializes the amplitudes (sets their initial values and associated variables) !! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ) :: unit_input = - 1 ! !     Set model name ! wf % name = 'CCSD' ! !     Open input file eT.inp ! call generate_unit_identifier ( unit_input ) open ( unit = unit_input , file = 'eT.inp' , status = 'old' , form = 'formatted' ) rewind ( unit_input ) ! !     Read general specifications (memory and diskspace for calculation) ! call wf % general_specs_reader ( unit_input ) ! !     Set implemented methods ! wf % implemented % ground_state = . true . wf % implemented % excited_state = . true . wf % implemented % core_excited_state = . true . wf % implemented % ionized_state = . true . wf % implemented % multipliers = . true . ! !     Read calculation tasks from input file eT.inp ! call wf % calculation_reader ( unit_input ) ! !     Close input file ! close ( unit_input ) ! !     Read Hartree-Fock info from SIRIUS ! call wf % read_hf_info ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize (singles and doubles) amplitudes ! wf % n_t1am = ( wf % n_o ) * ( wf % n_v ) wf % n_t2am = ( wf % n_t1am ) * ( wf % n_t1am + 1 ) / 2 ! wf % n_parameters = wf % n_t1am + wf % n_t2am ! !     Initialize the Fock matrix (allocate and construct given the initial amplitudes) ! if (. not . allocated ( wf % t1am )) call wf % mem % alloc ( wf % t1am , wf % n_v , wf % n_o ) wf % t1am = zero ! call wf % initialize_fock_matrix ! end subroutine init_ccsd ! ! subroutine initialize_amplitudes_ccsd ( wf ) !! !!     Initialize Amplitudes (CCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Allocates the amplitudes, sets them to zero, and calculates !!     the number of amplitudes. !! implicit none ! class ( ccsd ) :: wf ! !     Allocate the doubles amplitudes and set to zero ! if (. not . allocated ( wf % t2am )) call wf % mem % alloc ( wf % t2am , wf % n_t2am , 1 ) wf % t2am = zero ! end subroutine initialize_amplitudes_ccsd ! ! subroutine construct_perturbative_doubles_ccsd ( wf ) !! !!    Construct Perturbative Doubles (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Sets the doubles amplitudes (t2am) to its MP2 estimate. This is !!    the initial guess used in the solver for the ground state amplitude !!    equations. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: g_ia_jb ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 integer ( i15 ) :: ai = 0 , bj = 0 , ia = 0 , jb = 0 , aibj = 0 ! !     Allocate L_ia_J and g_ia_jb ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % mem % alloc ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! L_ia_J = zero g_ia_jb = zero ! !     Get the Cholesky IA vector ! call wf % get_cholesky_ia ( L_ia_J ) ! !     Calculate g_ia_jb = g_iajb ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ia_jb , & ( wf % n_o ) * ( wf % n_v )) ! !     Set the doubles amplitudes ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! jb = index_two ( j , b , wf % n_o ) bj = index_two ( b , j , wf % n_v ) ! !                 Set the doubles amplitudes ! if ( ai . le . bj ) then ! To avoid setting the same element twice ! aibj = index_packed ( ai , bj ) ! wf % t2am ( aibj , 1 ) = - g_ia_jb ( ia , jb ) / ( wf % fock_diagonal ( wf % n_o + a , 1 ) + & wf % fock_diagonal ( wf % n_o + b , 1 ) - & wf % fock_diagonal ( i , 1 ) - & wf % fock_diagonal ( j , 1 )) ! endif ! enddo enddo enddo enddo ! !     Deallocations ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), ( wf % n_J )) call wf % mem % dealloc ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine construct_perturbative_doubles_ccsd ! ! subroutine calc_energy_ccsd ( wf ) !! !!     Calculate Energy (CCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Calculates the CCSD energy for the wavefunction's current amplitudes. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: L_ia_J ! L_ia&#94;J real ( dp ), dimension (:,:), allocatable :: g_ia_jb ! g_iajb ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 , ai = 0 integer ( i15 ) :: bj = 0 , aibj = 0 , ia = 0 , jb = 0 , ib = 0 , ja = 0 ! !     Allocate the Cholesky vector L_ia_J = L_ia&#94;J and set to zero ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_ia_J = zero ! !     Get the Cholesky vector L_ia_J ! call wf % get_cholesky_ia ( L_ia_J ) ! !     Allocate g_ia_jb = g_iajb and set it to zero ! call wf % mem % alloc ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ia_jb = zero ! !     Calculate the integrals g_ia_jb from the Cholesky vector L_ia_J ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ia_jb , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate the Cholesky vector L_ia_J ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Set the initial value of the energy ! wf % energy = wf % scf_energy ! !     Add the correlation energy E = E + sum_aibj (t_ij&#94;ab + t_i&#94;a t_j&#94;b) L_iajb ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ! do j = 1 , wf % n_o ! ja = index_two ( j , a , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) jb = index_two ( j , b , wf % n_o ) ib = index_two ( i , b , wf % n_o ) ! aibj = index_packed ( ai , bj ) ! !                 Add the correlation energy ! wf % energy = wf % energy + & ( wf % t2am ( aibj , 1 ) + ( wf % t1am ( a , i )) * ( wf % t1am ( b , j ))) * & ( two * g_ia_jb ( ia , jb ) - g_ia_jb ( ib , ja )) ! enddo enddo enddo enddo ! !     Deallocate g_ia_jb ! call wf % mem % dealloc ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine calc_energy_ccsd ! ! subroutine destruct_amplitudes_ccsd ( wf ) !! !!    Destruct Amplitudes (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Deallocates the (doubles) amplitudes. !! implicit none ! class ( ccsd ) :: wf ! if ( allocated ( wf % t2am )) call wf % mem % dealloc ( wf % t2am , wf % n_t2am , 1 ) ! end subroutine destruct_amplitudes_ccsd ! ! subroutine destruct_omega_ccsd ( wf ) !! !!    Destruct Omega (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Deallocates the projection vector. !! implicit none ! class ( ccsd ) :: wf ! if ( allocated ( wf % omega1 )) call wf % mem % dealloc ( wf % omega1 , wf % n_v , wf % n_o ) if ( allocated ( wf % omega2 )) call wf % mem % dealloc ( wf % omega2 , wf % n_t2am , 1 ) ! end subroutine destruct_omega_ccsd ! ! subroutine save_amplitudes_ccsd ( wf ) !! !!    Save Amplitudes (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Store the amplitudes to disk (T1AM, T2AM) !! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ) :: unit_t1am = - 1 integer ( i15 ) :: unit_t2am = - 1 ! !     Open amplitude files ! call generate_unit_identifier ( unit_t1am ) call generate_unit_identifier ( unit_t2am ) ! open ( unit_t1am , file = 't1am' , status = 'unknown' , form = 'unformatted' ) open ( unit_t2am , file = 't2am' , status = 'unknown' , form = 'unformatted' ) ! rewind ( unit_t1am ) rewind ( unit_t2am ) ! !     Write amplitudes to files ! write ( unit_t1am ) wf % t1am write ( unit_t2am ) wf % t2am ! !     Close amplitude files ! close ( unit_t1am ) close ( unit_t2am ) ! end subroutine save_amplitudes_ccsd ! subroutine read_amplitudes_ccsd ( wf ) !! !!    Read Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM) !! implicit none ! class ( ccsd ) :: wf ! call wf % read_single_amplitudes call wf % read_double_amplitudes ! end subroutine read_amplitudes_ccsd ! subroutine read_double_amplitudes_ccsd ( wf ) !! !!    Read Amplitudes (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM, T2AM) !! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ) :: unit_t2am = - 1 ! logical :: file_exists = . false . ! !     Check to see whether file exists ! inquire ( file = 't2am' , exist = file_exists ) ! if ( file_exists ) then ! !        Open amplitude files if they exist ! call generate_unit_identifier ( unit_t2am ) ! open ( unit_t2am , file = 't2am' , status = 'unknown' , form = 'unformatted' ) ! rewind ( unit_t2am ) ! !        Read from file & close ! wf % t2am = zero ! read ( unit_t2am ) wf % t2am ! close ( unit_t2am ) ! else ! write ( unit_output , '(t3,a)' ) 'Error: amplitude files do not exist.' stop ! endif ! end subroutine read_double_amplitudes_ccsd ! ! subroutine jacobi_test_ccsd ( wf ) !! !!    Jacobian test (CCSD) !!    Written by Eirik F. Kjønstad, June 2017 !! !!    Calculates the Jacobian matrix by numerically differentiating !!    the projection vector: !! !!       A_mu,nu = d Omega_mu / d t_nu. !! !!    Used to debug Jacobian transformation. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: c_a_i real ( dp ), dimension (:,:), allocatable :: c_aibj ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 , ai = 0 , bj = 0 , aibj = 0 integer ( i15 ) :: c = 0 , k = 0 , ck = 0 , ckdl = 0 , l = 0 , d = 0 , dl = 0 ! real ( dp ), dimension (:,:), allocatable :: r1am real ( dp ), dimension (:,:), allocatable :: r2am ! real ( dp ) :: displacement ! !     Calculate the transformation of the t1 amplitudes ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! call wf % mem % alloc ( r1am , wf % n_v , wf % n_o ) call wf % mem % alloc ( r2am , wf % n_t2am , 1 ) ! r1am = wf % t1am r2am = wf % t2am ! !     Make sure fock matrix is up to date ! call wf % construct_fock ! !   r1am = zero !   r2am = zero ! call wf % destruct_amplitudes ! write ( unit_output , * ) 'T1AM' ! do i = 1 , wf % n_o do a = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) write ( unit_output , * ) ai , r1am ( a , i ) enddo enddo ! write ( unit_output , * ) 'T2AM' ! do j = 1 , 15 write ( unit_output , * ) j , r2am ( j , 1 ) enddo ! !   call wf%jacobian_ccsd_transformation(r1am,r2am) call wf % jacobian_transpose_ccsd_transformation ( r1am , r2am ) ! write ( unit_output , * ) 'TRF(SINGLES)' ! do i = 1 , wf % n_o do a = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) write ( unit_output , * ) ai , r1am ( a , i ) enddo enddo ! write ( unit_output , * ) 'TRF(DOUBLES)' ! do j = 1 , 500 write ( unit_output , * ) j , r2am ( j , 1 ) enddo ! !     We wish to calculate A_mu,nu = d(omega)_mu / dt_nu, !     in two different ways: ! !        - By transforming c_tau = delta_tau,nu with A. Then (A c)_mu = sum_tau A_mu,tau c_tau = A_mu,nu !        - By calculating A_mu,nu = (omega(t+Dt_nu)_mu - omega(t)_mu)/Dt_nu. ! !     :: First approach: transform by A :: ! call wf % mem % alloc ( c_a_i , wf % n_v , wf % n_o ) call wf % mem % alloc ( c_aibj , wf % n_t2am , 1 ) ! c_a_i = zero c_aibj = zero ! write ( unit_output , * ) 'A_mu,nu, singles, by transformation' ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! !           Let c have a one for the excitation bj, zero otherwise ! c_a_i ( b , j ) = one ! !           Transform c by A. The result should be A_mu,bj ! call wf % jacobian_ccsd_transformation ( c_a_i , c_aibj ) ! !           Print these elements of A. ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! write ( unit_output , * ) 'ai, bj, A_ai,bj' , ai , bj , c_a_i ( a , i ) ! enddo enddo ! c_a_i = zero c_aibj = zero ! enddo enddo ! write ( unit_output , * ) 'A_ckdl,bj, singles, by transformation ZZ' ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! !           Let c have a one for the excitation bj, zero otherwise ! c_a_i ( b , j ) = one ! !           Transform c by A. The result should be A_mu,bj ! call wf % jacobian_ccsd_transformation ( c_a_i , c_aibj ) ! !           Print these elements of A. ! do k = 1 , wf % n_o do c = 1 , wf % n_v do l = 1 , wf % n_o do d = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) dl = index_two ( d , l , wf % n_v ) ! ckdl = index_packed ( ck , dl ) ! bj = index_two ( b , j , wf % n_v ) ! write ( unit_output , * ) 'ckdl, bj, A_ckdl,bj' , ckdl , bj , c_aibj ( ckdl , 1 ) ! enddo enddo ! enddo enddo ! c_a_i = zero c_aibj = zero ! enddo enddo ! c_a_i = zero c_aibj = zero ! write ( unit_output , * ) 'A_ck,aibj, doubles, by transformation XX' ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! c_aibj ( aibj , 1 ) = one ! !                 Transform c by A. The result should be A_mu,aibj ! call wf % jacobian_ccsd_transformation ( c_a_i , c_aibj ) ! !                 Print singles-doubles block ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! write ( unit_output , * ) 'ck, aibj, A_ck, aibj' , ck , aibj , c_a_i ( c , k ) ! enddo enddo ! c_a_i = zero c_aibj = zero ! enddo enddo enddo enddo ! write ( unit_output , * ) 'A_ckdl,aibj, doubles, by transformation YY' ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! c_aibj ( aibj , 1 ) = one ! !                 Transform c by A. The result should be A_mu,aibj ! call wf % jacobian_ccsd_transformation ( c_a_i , c_aibj ) ! !                 Print singles-doubles block ! do k = 1 , wf % n_o do c = 1 , wf % n_v do l = 1 , wf % n_o do d = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) dl = index_two ( d , l , wf % n_v ) ! ckdl = index_packed ( ck , dl ) ! write ( unit_output , * ) 'ckdl, aibj, A_ckdl, aibj' , ckdl , aibj , c_aibj ( ckdl , 1 ) ! enddo enddo enddo enddo ! c_a_i = zero c_aibj = zero ! enddo enddo enddo enddo ! !     :: Second approach: differentaition of omega :: ! write ( unit_output , * ) 'A_mu,nu, singles, by derivation' ! call wf % initialize_amplitudes call wf % read_double_amplitudes ! displacement = 1.0D-10 ! call wf % initialize_omega ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! !           Construct omega and save in c ! wf % omega1 = zero wf % omega2 = zero ! call wf % construct_fock call wf % construct_omega ! c_a_i = wf % omega1 c_aibj = wf % omega2 ! !           Shift the j,b amplitude ! wf % t1am ( b , j ) = wf % t1am ( b , j ) + displacement ! !           Construct omega ! wf % omega1 = zero wf % omega2 = zero ! call wf % construct_fock call wf % construct_omega ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! !                 Calculate A_ai,bj = (omega(t)_ai - omega(t+Dt_bj)_ai)/Dt_bj. ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! write ( unit_output , * ) 'ai, bj, A_ai,bj' , ai , bj , ( wf % omega1 ( a , i ) - c_a_i ( a , i )) / displacement ! enddo enddo ! wf % t1am ( b , j ) = wf % t1am ( b , j ) - displacement ! enddo enddo ! write ( unit_output , * ) 'A_ck,aibj, doubles, by differentiation XX' ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! !                 Construct omega and save in c ! wf % omega1 = zero wf % omega2 = zero ! call wf % construct_fock call wf % construct_omega ! c_a_i = wf % omega1 c_aibj = wf % omega2 ! !                 Shift the aibj amplitude ! wf % t2am ( aibj , 1 ) = wf % t2am ( aibj , 1 ) + displacement ! !                 Construct omega ! wf % omega1 = zero wf % omega2 = zero ! call wf % construct_fock call wf % construct_omega ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! write ( unit_output , * ) 'ck, aibj, A_ck, aibj' , ck , aibj , ( wf % omega1 ( c , k ) - c_a_i ( c , k )) / displacement ! enddo enddo ! wf % t2am ( aibj , 1 ) = wf % t2am ( aibj , 1 ) - displacement ! enddo enddo ! enddo enddo ! ! write ( unit_output , * ) 'A_ckdl,aibj, doubles, by differentiation YY' ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! !                 Construct omega and save in c ! wf % omega1 = zero wf % omega2 = zero ! call wf % construct_fock call wf % construct_omega ! c_a_i = wf % omega1 c_aibj = wf % omega2 ! !                 Shift the aibj amplitude ! wf % t2am ( aibj , 1 ) = wf % t2am ( aibj , 1 ) + displacement ! !                 Construct omega ! wf % omega1 = zero wf % omega2 = zero ! call wf % construct_fock call wf % construct_omega ! do k = 1 , wf % n_o do c = 1 , wf % n_v do l = 1 , wf % n_o do d = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) dl = index_two ( d , l , wf % n_v ) ! ckdl = index_packed ( ck , dl ) ! if ( c . eq . d . and . k . eq . l ) then write ( unit_output , * ) 'ckdl, aibj, A_ckdl, aibj' , & ckdl , aibj , half * ( wf % omega2 ( ckdl , 1 ) - c_aibj ( ckdl , 1 )) / displacement else ! write ( unit_output , * ) 'ckdl, aibj, A_ckdl, aibj' , & ckdl , aibj , ( wf % omega2 ( ckdl , 1 ) - c_aibj ( ckdl , 1 )) / displacement endif ! enddo enddo enddo enddo ! wf % t2am ( aibj , 1 ) = wf % t2am ( aibj , 1 ) - displacement ! enddo enddo ! enddo enddo ! write ( unit_output , * ) 'A_ckdl,bj, singles, by derivation ZZ' ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! !           Construct omega and save in c ! wf % omega1 = zero wf % omega2 = zero ! call wf % construct_fock call wf % construct_omega ! c_a_i = wf % omega1 c_aibj = wf % omega2 ! !           Shift the j,b amplitude ! wf % t1am ( b , j ) = wf % t1am ( b , j ) + displacement ! !           Construct omega ! wf % omega1 = zero wf % omega2 = zero ! call wf % construct_fock call wf % construct_omega ! do k = 1 , wf % n_o do c = 1 , wf % n_v do l = 1 , wf % n_o do d = 1 , wf % n_v ! !                       Calculate A_ckdl,bj = (omega(t)_ckdl - omega(t+Dt_bj)_ckdl)/Dt_bj. ! ck = index_two ( c , k , wf % n_v ) dl = index_two ( d , l , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! ckdl = index_packed ( ck , dl ) ! if ( c . eq . d . and . k . eq . l ) then ! write ( unit_output , * ) 'ckdl, bj, A_ckdl,bj' , ckdl , bj , & half * ( wf % omega2 ( ckdl , 1 ) - c_aibj ( ckdl , 1 )) / displacement ! else ! write ( unit_output , * ) 'ckdl, bj, A_ckdl,bj' , ckdl , bj , & ( wf % omega2 ( ckdl , 1 ) - c_aibj ( ckdl , 1 )) / displacement endif ! enddo enddo enddo enddo ! wf % t1am ( b , j ) = wf % t1am ( b , j ) - displacement ! enddo enddo ! end subroutine jacobi_test_ccsd ! ! subroutine construct_eta_ccsd ( wf , eta ) !! !!    Construct Eta (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Note: the routine assumes that eta is initialized and that the Fock matrix !!    has been constructed. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: eta ! eta = ( eta_ai eta_aibj ) ! real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: g_ia_jb ! real ( dp ), dimension (:,:), allocatable :: eta_ai_bj ! integer ( i15 ) :: i = 0 , a = 0 , j = 0 , b = 0 , aibj = 0 integer ( i15 ) :: ib = 0 , ja = 0 , jb = 0 , ia = 0 , bj = 0 , ai = 0 ! eta = zero ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) eta ( ai , 1 ) = two * ( wf % fock_ia ( i , a )) ! eta_ai = 2 F_ia ! enddo enddo ! !     Form g_ia_jb = g_iajb ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % get_cholesky_ia ( L_ia_J ) ! call wf % mem % alloc ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ia_jb , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Form eta_ai_bj = 2* L_iajb = 2 * ( 2 * g_iajb - g_ibja) !                                = 4 * g_ia_jb(ia,jb) - 2 * g_ia_jb(ib,ja) ! call wf % mem % alloc ( eta_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) eta_ai_bj = zero ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) jb = index_two ( j , b , wf % n_o ) ! do i = 1 , wf % n_o ! ib = index_two ( i , b , wf % n_o ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ja = index_two ( j , a , wf % n_o ) ! eta_ai_bj ( ai , bj ) = four * g_ia_jb ( ia , jb ) - two * g_ia_jb ( ib , ja ) ! 2 * L_iajb ! enddo enddo enddo enddo ! !     Pack vector into doubles eta ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! eta ( wf % n_t1am + aibj , 1 ) = eta_ai_bj ( ai , bj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( eta_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine construct_eta_ccsd ! ! end module ccsd_class !","tags":"","loc":"sourcefile/ccsd_class.f90.html","title":"ccsd_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ccs_class.f90~~EfferentGraph sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileccs_classf90EfferentGraph = svgPanZoom('#sourcefileccs_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~ccs_class.f90~~AfferentGraph sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~fock_submodule.f90 fock_submodule.F90 sourcefile~ccs_class.f90->sourcefile~fock_submodule.f90 sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~excited_state_submodule.f90~5 excited_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~excited_state_submodule.f90~5 sourcefile~input_reader_submodule.f90~3 input_reader_submodule.F90 sourcefile~ccs_class.f90->sourcefile~input_reader_submodule.f90~3 sourcefile~et_program.f90 eT_program.F90 sourcefile~ccs_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_transpose_submodule.f90~2 jacobian_transpose_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_transpose_submodule.f90~2 sourcefile~ionized_state_submodule.f90~2 ionized_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ionized_state_submodule.f90~2 sourcefile~integrals_submodule.f90 integrals_submodule.F90 sourcefile~ccs_class.f90->sourcefile~integrals_submodule.f90 sourcefile~cholesky_submodule.f90~2 cholesky_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cholesky_submodule.f90~2 sourcefile~jacobian_submodule.f90~5 jacobian_submodule.F90 sourcefile~ccs_class.f90->sourcefile~jacobian_submodule.f90~5 sourcefile~response_submodule.f90 response_submodule.F90 sourcefile~ccs_class.f90->sourcefile~response_submodule.f90 sourcefile~cvs_submodule.f90~2 cvs_submodule.F90 sourcefile~ccs_class.f90->sourcefile~cvs_submodule.f90~2 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~ground_state_submodule.f90~4 ground_state_submodule.F90 sourcefile~ccs_class.f90->sourcefile~ground_state_submodule.f90~4 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 sourcefile~ccsd_class.f90->sourcefile~et_program.f90 sourcefile~excited_state_submodule.f90~3 excited_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~excited_state_submodule.f90~3 sourcefile~cvs_submodule.f90 cvs_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~cvs_submodule.f90 sourcefile~ionized_state_submodule.f90 ionized_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ionized_state_submodule.f90 sourcefile~jacobian_submodule.f90~3 jacobian_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_submodule.f90~3 sourcefile~ground_state_submodule.f90~2 ground_state_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~ground_state_submodule.f90~2 sourcefile~jacobian_transpose_submodule.f90 jacobian_transpose_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~jacobian_transpose_submodule.f90 sourcefile~omega_submodule.f90~4 omega_submodule.F90 sourcefile~ccsd_class.f90->sourcefile~omega_submodule.f90~4 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 var pansourcefileccs_classf90AfferentGraph = svgPanZoom('#sourcefileccs_classf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules ccs_class Source Code ccs_class.F90 Source Code module ccs_class ! !! !! !! !!                      Coupled cluster singles (CCS) class module !!                Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !! !! !!    This module contains the definition of the coupled cluster singles (CCS) !!    wavefunction class. It is structured into four sections: !! !!       1. Modules used by the class: !! !!             Basic utilities and the ancestor class (HF) !! !!       2. Definition of the class: !! !!             Non-inherited variables, followed by non-inherited or overridden procedures !! !!       3. Interfaces to submodules: !! !!             The procedures in the class are grouped according to functionality, with !!             detailed definitions given in the following class submodules: !! !!                - Ground state !!                - Excited state !!                - Response !!                - Input Reader !!                - Cholesky !!                - Integrals !!                - Fock !!                - Jacobian (right transformation) !!                - Jacobian Transpose (left transformation) !!                - Ionized State !!                - CVS !! !!             The interfaces shows incoming variables and their type, but contains !!             no information of the procedure itself. The procedure is shown in full !!             in the corresponding submodule. !! !!       4. Class module routines (i.e., non-submodule procedures). These include !!          the initialization and driver routines of the class, along with procedures that !!          are not (yet, at least) easily gathered in a submodule. !! !! !! ! ! !  :::::::::::::::::::::::::::::::::::::: !  -::- 1. Modules used by the class -::- !  :::::::::::::::::::::::::::::::::::::: ! ! !  General tools ! use types use utils use workspace use input_output ! !  The ancestor class module (HF) ! use hf_class ! implicit none ! ! !  :::::::::::::::::::::::::::::::::::::::: !  -::- 2. Definition of the CCS class -::- !  :::::::::::::::::::::::::::::::::::::::: ! ! type , extends ( hf ) :: ccs ! !     Cluster amplitudes ! integer ( i15 ) :: n_t1am = 0 ! Number of single excitation amplitudes integer ( i15 ) :: n_parameters = 0 ! Number of parameters in the wavefunction ! real ( dp ), dimension (:,:), allocatable :: t1am ! Single excitation amplitudes vector, t_i&#94;a ! !     The omega, or projection, vector < mu | exp(-T) H exp(T) | R > ! real ( dp ), dimension (:,:), allocatable :: omega1 ! Singles projection vector ! !     The T1-transformed Fock matrix ! real ( dp ), dimension (:,:), allocatable :: fock_ij real ( dp ), dimension (:,:), allocatable :: fock_ia real ( dp ), dimension (:,:), allocatable :: fock_ai real ( dp ), dimension (:,:), allocatable :: fock_ab ! contains ! ! !     -::- Initialization and driver routines -::- !     -------------------------------------------- ! procedure :: init => init_ccs ! Initialization of class procedure :: drv => drv_ccs ! Driver of class ! procedure :: initialize_amplitudes => initialize_amplitudes_ccs ! Initialize cluster amplitudes procedure :: initialize_omega => initialize_omega_ccs ! Initialize projection vector ! ! !     -::- Ground state submodule routine pointers -::- !     ------------------------------------------------- ! !     Driver and solver ! procedure :: ground_state_driver => ground_state_driver_ccs procedure :: ground_state_solver => ground_state_solver_ccs ! !     Preparations and cleanup routines (before and after solver) ! procedure :: ground_state_preparations => ground_state_preparations_ccs procedure :: ground_state_cleanup => ground_state_cleanup_ccs ! procedure :: initialize_ground_state => initialize_ground_state_ccs procedure :: destruct_ground_state => destruct_ground_state_ccs ! !     DIIS component of solver, with helper routines ! procedure , non_overridable :: diis => diis_ccs ! procedure :: new_amplitudes => new_amplitudes_ccs procedure :: calc_ampeqs => calc_ampeqs_ccs procedure :: calc_ampeqs_norm => calc_ampeqs_norm_ccs procedure :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs ! !     Ground state energy calculation routine ! procedure :: calc_energy => calc_energy_ccs ! ! !     -::- Excited state submodule routine pointers -::- !     -------------------------------------------------- ! !     Driver and solver ! procedure :: excited_state_driver => excited_state_driver_ccs procedure , non_overridable :: excited_state_solver => excited_state_solver_ccs ! !     Preparations and cleanup (before and after solver) ! procedure :: excited_state_preparations => excited_state_preparations_ccs procedure :: excited_state_cleanup => excited_state_cleanup_ccs ! !     Helper routines for excited state solver ! procedure :: initialize_excited_states => initialize_excited_states_ccs procedure :: transform_trial_vectors => transform_trial_vectors_ccs procedure :: calculate_orbital_differences => calculate_orbital_differences_ccs ! procedure :: precondition_residual => precondition_residual_ccs procedure :: precondition_residual_valence => precondition_residual_valence_ccs ! procedure :: print_excited_state_info => print_excited_state_info_ccs procedure :: print_excitation_vector => print_excitation_vector_ccs ! procedure :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs procedure :: summary_excited_state_info => summary_excited_state_info_ccs ! !     Valence excited states specific routines ! procedure , non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs procedure , non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs procedure , non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs procedure , non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs ! !     Core excited states specific routines ! procedure :: precondition_residual_core => precondition_residual_core_ccs procedure , non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs procedure , non_overridable :: find_core_mo => find_core_mo_ccs procedure , non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs ! procedure , non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs procedure , non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs ! ! !     -::- Response submodule routine pointers -::- !     --------------------------------------------- ! !     Driver and solver ! procedure :: response_driver => response_driver_ccs procedure :: response_solver => response_solver_ccs ! !     Helper routines for solver ! procedure :: response_preparations => response_preparations_ccs procedure :: initialize_response => initialize_response_ccs procedure :: solve_reduced_response_equation => solve_reduced_response_equation_ccs procedure :: construct_reduced_matrix => construct_reduced_matrix_ccs procedure :: construct_reduced_gradient => construct_reduced_gradient_ccs procedure :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs procedure :: construct_gradient_vector => construct_gradient_vector_ccs ! ! !     -::- Input reader submodule routine pointers -::- !     ------------------------------------------------- ! procedure :: general_specs_reader => general_specs_reader_ccs procedure :: calculation_reader => calculation_reader_ccs procedure :: read_ground_state_specs => read_ground_state_specs_ccs procedure :: read_excited_state_specs => read_excited_state_specs_ccs procedure :: read_property_specs => read_property_specs_ccs ! ! !     -::- Cholesky submodule routine pointers -::- !     --------------------------------------------- ! procedure , non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure , non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure , non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure , non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs ! ! !     -::- Integrals submodule routine pointers -::- !     ---------------------------------------------- ! !     Get integral routines ! procedure :: get_oo_oo => get_oo_oo_ccs procedure :: get_oo_ov => get_oo_ov_ccs procedure :: get_ov_oo => get_ov_oo_ccs procedure :: get_oo_vo => get_oo_vo_ccs procedure :: get_vo_oo => get_vo_oo_ccs procedure :: get_oo_vv => get_oo_vv_ccs procedure :: get_vv_oo => get_vv_oo_ccs procedure :: get_ov_ov => get_ov_ov_ccs ! procedure :: get_vo_vo => get_vo_vo_ccs procedure :: get_ov_vo => get_ov_vo_ccs procedure :: get_vo_ov => get_vo_ov_ccs procedure :: get_ov_vv => get_ov_vv_ccs procedure :: get_vv_ov => get_vv_ov_ccs procedure :: get_vo_vv => get_vo_vv_ccs procedure :: get_vv_vo => get_vv_vo_ccs procedure :: get_vv_vv => get_vv_vv_ccs ! procedure :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs procedure :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs procedure :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs procedure :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs procedure :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs procedure :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs procedure :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs procedure :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs ! procedure :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs procedure :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs procedure :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs procedure :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs procedure :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs procedure :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs procedure :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs procedure :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs ! !     Routines to store, read, and T1-transform electronic repulsion integrals ! procedure :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs ! procedure :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs procedure :: t1_transform_vv_vv => t1_transform_vv_vv_ccs ! procedure :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs procedure :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs procedure :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs procedure :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs ! procedure :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs procedure :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs procedure :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs procedure :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs ! ! !     -::- Fock submodule routine pointers -::- !     ----------------------------------------- ! procedure , non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure , non_overridable :: construct_fock => construct_fock_ccs procedure , non_overridable :: one_electron_t1 => one_electron_t1_ccs ! ! !     -::- Jacobian submodule routine pointers -::- !     --------------------------------------------- ! procedure :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs ! procedure , non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs procedure , non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs ! procedure :: jacobi_test => jacobi_test_ccs ! A debug routine ! ! !     -::- Jacobian transpose submodule routine pointers -::- !     ------------------------------------------------------- ! procedure :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs ! procedure , non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs procedure , non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs ! ! !     -::- Ionized state submodule routine pointers -::- !     -------------------------------------------------- ! procedure :: ionized_state_driver => ionized_state_driver_ccs procedure :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs procedure :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs procedure :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs procedure :: ionization_residual_projection => ionization_residual_projection_ccs procedure :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs procedure :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs ! ! !     -::- CVS submodule routine pointers -::- !     ---------------------------------------- ! procedure :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs procedure :: cvs_residual_projection => cvs_residual_projection_ccs ! ! !     -::- Other class routine pointers not located in submodules -::- !     ---------------------------------------------------------------- ! !     Routine to construct omega, or projection, vector ! procedure :: construct_omega => construct_omega_ccs procedure :: omega_ccs_a1 => omega_ccs_a1_ccs ! !     Routine to construct eta, or right projection, vector ! procedure :: construct_eta => construct_eta_ccs ! !     Routine to save and read the amplitudes (to/from disk) ! procedure :: save_amplitudes => save_amplitudes_ccs ! procedure :: read_amplitudes => read_amplitudes_ccs procedure :: read_single_amplitudes => read_single_amplitudes_ccs ! !     Routines to deallocate amplitudes and omega ! procedure :: destruct_amplitudes => destruct_amplitudes_ccs procedure :: destruct_omega => destruct_omega_ccs ! ! end type ccs ! ! !  :::::::::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- 3. Interfaces to the submodules of the CCS class -::- !  :::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ! ! interface ! ! !     -::- Ground state submodule interface -::- !     ------------------------------------------ ! module subroutine ground_state_driver_ccs ( wf ) !! !!       Ground State Driver (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine ground_state_driver_ccs ! ! module subroutine ground_state_preparations_ccs ( wf ) !! !!       Ground State Preparations (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! class ( ccs ) :: wf ! end subroutine ground_state_preparations_ccs ! ! module subroutine ground_state_cleanup_ccs ( wf ) !! !!       Ground State Cleanup (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! class ( ccs ) :: wf ! end subroutine ground_state_cleanup_ccs ! ! module subroutine ground_state_solver_ccs ( wf ) !! !!       Ground State Solver !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine ground_state_solver_ccs ! ! module subroutine calc_ampeqs_ccs ( wf ) !! !!       Calculate Amplitude Equations (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine calc_ampeqs_ccs ! ! module subroutine calc_ampeqs_norm_ccs ( wf , ampeqs_norm ) !! !!       Calculate Amplitude Equations Norm (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ) :: ampeqs_norm ! end subroutine calc_ampeqs_norm_ccs ! ! module subroutine new_amplitudes_ccs ( wf ) !! !!       New Amplitudes (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine new_amplitudes_ccs ! ! module subroutine calc_quasi_Newton_singles_ccs ( wf , dt ) !! !!       Calculate quasi-Newton Singles (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: dt ! end subroutine calc_quasi_Newton_singles_ccs ! ! module subroutine diis_ccs ( wf , dt , t_dt ) !! !!       DIIS (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ), intent ( in ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: dt real ( dp ), dimension ( wf % n_parameters , 1 ) :: t_dt ! end subroutine diis_ccs ! ! module subroutine initialize_ground_state_ccs ( wf ) !! !!       Initialize Ground State (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_ground_state_ccs ! ! module subroutine destruct_ground_state_ccs ( wf ) !! !!       Destruct Ground State (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine destruct_ground_state_ccs ! ! end interface ! ! interface ! !     -::- Excited state submodule interface -::- !     ------------------------------------------- ! module subroutine initialize_trial_vectors_ccs ( wf ) !! !!       Initialize Trial Vectors (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_trial_vectors_ccs ! ! module subroutine find_start_trial_indices_ccs ( wf , index_list ) !! !!       Find Start Trial Indices (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf integer ( i15 ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ), intent ( inout ) :: index_list ! end subroutine find_start_trial_indices_ccs ! ! module subroutine transform_trial_vectors_ccs ( wf , first_trial , last_trial ) !! !!       Transform trial vectors (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf integer ( i15 ), intent ( in ) :: first_trial , last_trial ! end subroutine transform_trial_vectors_ccs ! ! module subroutine excited_state_driver_ccs ( wf ) !! !!       Excited state driver (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine excited_state_driver_ccs ! ! module subroutine excited_state_preparations_ccs ( wf ) !! !!       Excited State Preparations (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! class ( ccs ) :: wf ! end subroutine excited_state_preparations_ccs ! ! module subroutine excited_state_cleanup_ccs ( wf ) !! !!       Excited State Cleanup (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! class ( ccs ) :: wf ! end subroutine excited_state_cleanup_ccs ! ! module subroutine excited_state_solver_ccs ( wf ) !! !!       Excited State Solver !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine excited_state_solver_ccs ! ! module subroutine solve_reduced_eigenvalue_equation_ccs ( wf , eigenvalues_Re , eigenvalues_Im , & solution_vectors_reduced , reduced_dim , n_new_trials ) !! !!       Solve Reduced Eigenvalue Equation !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: eigenvalues_Re real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: eigenvalues_Im ! real ( dp ), dimension ( reduced_dim , wf % excited_state_specifications % n_singlet_states ) :: solution_vectors_reduced ! end subroutine solve_reduced_eigenvalue_equation_ccs ! ! module subroutine construct_next_trial_vectors_ccs ( wf , eigenvalues_Re , eigenvalues_Im , & solution_vectors_reduced , & reduced_dim , n_new_trials ) !! !!       Construct Next Trial Vectors !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: eigenvalues_Re real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: eigenvalues_Im ! integer ( i15 ) :: reduced_dim integer ( i15 ) :: n_new_trials real ( dp ), dimension ( reduced_dim , wf % excited_state_specifications % n_singlet_states ) :: solution_vectors_reduced ! end subroutine construct_next_trial_vectors_ccs ! ! module subroutine initialize_trial_vectors_valence_ccs ( wf ) !! !!       Initialize Trial Vectors Valence !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_trial_vectors_valence_ccs ! ! ! module subroutine initialize_trial_vectors_core_ccs ( wf ) !! !!       Initialize trial vectors, for CVS calculation !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_trial_vectors_core_ccs ! ! module subroutine trial_vectors_from_stored_solutions_ccs ( wf ) !! !!    Trial Vectors from Old Solutions !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine trial_vectors_from_stored_solutions_ccs ! ! module subroutine find_start_trial_indices_core_ccs ( wf , index_list ) !! !!       Find Start Trial Indices Core !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf integer ( i15 ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ), intent ( inout ) :: index_list ! end subroutine find_start_trial_indices_core_ccs ! ! module subroutine find_core_mo_ccs ( wf ) !! !!       Find Core MO !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine find_core_mo_ccs ! ! module subroutine calculate_orbital_differences_ccs ( wf , orbital_diff ) !! !!       Calculate Orbital Differences !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: orbital_diff ! end subroutine calculate_orbital_differences_ccs ! ! module subroutine initialize_excited_states_ccs ( wf ) !! !!       Initialize Excited States !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_excited_states_ccs ! ! module subroutine precondition_residual_ccs ( wf , residual ) !! !!       Precondition Residual !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine precondition_residual_ccs ! ! module subroutine precondition_residual_valence_ccs ( wf , residual ) !! !!       Precondition Residual Valence !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine precondition_residual_valence_ccs ! ! module subroutine precondition_residual_core_ccs ( wf , residual ) !! !!       Precondition Residual Core !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! ! end subroutine precondition_residual_core_ccs ! ! module subroutine print_excited_state_info_ccs ( wf ) !! !!       Print Excited State Information !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine print_excited_state_info_ccs ! ! module subroutine print_excitation_vector_ccs ( wf , vec , unit_id ) !! !!       Print Excitation Vector !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: vec ! integer ( i15 ) :: unit_id ! end subroutine print_excitation_vector_ccs ! ! module subroutine analyze_single_excitation_vector_ccs ( wf , vec , n , sorted_short_vec , index_list ) !! !!       Analyze Single Excitation Vector (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_o * wf % n_v , 1 ) :: vec ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 ! integer ( i15 ) :: n ! Number of elements wanted ! real ( dp ), dimension ( n , 1 ) :: sorted_short_vec ! integer ( i15 ), dimension ( n , 2 ) :: index_list ! end subroutine analyze_single_excitation_vector_ccs ! ! module subroutine summary_excited_state_info_ccs ( wf , energies ) !! !!       Summary Excited State Info (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! end subroutine summary_excited_state_info_ccs ! ! end interface ! ! interface ! !     -::- Response submodule interface -::- !     -------------------------------------- ! module subroutine response_driver_ccs ( wf ) !! !!       Response Driver (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine response_driver_ccs ! ! module subroutine response_solver_ccs ( wf ) !! !!       Response Solver (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine response_solver_ccs ! ! module subroutine response_preparations_ccs ( wf ) !! !!       Response calculation preparations (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Dec 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine response_preparations_ccs ! ! module subroutine initialize_response_ccs ( wf ) !! !!       Initialize Response (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_response_ccs ! ! module subroutine solve_reduced_response_equation_ccs ( wf , solution_vector_reduced , reduced_dim , n_new_trials ) !! !!       Solve Reduced Response Equation !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension ( reduced_dim , 1 ) :: solution_vector_reduced ! end subroutine solve_reduced_response_equation_ccs ! ! module subroutine construct_reduced_matrix_ccs ( wf , A_reduced , reduced_dim , n_new_trials ) !! !!       Construct Reduced Matrix (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension ( reduced_dim , reduced_dim ) :: A_reduced ! end subroutine construct_reduced_matrix_ccs ! ! module subroutine construct_reduced_gradient_ccs ( wf , F_reduced , reduced_dim , n_new_trials ) !! !!       Construct Reduced Gradient (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension ( reduced_dim , 1 ) :: F_reduced ! end subroutine construct_reduced_gradient_ccs ! ! module subroutine construct_gradient_vector_ccs ( wf ) !! !!       Construct Gradient Vector (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine construct_gradient_vector_ccs ! ! module subroutine construct_next_response_trial_vectors_ccs ( wf , solution_vector_reduced , reduced_dim , n_new_trials ) !! !!       Construct Next Response Trial Vectors (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: reduced_dim , n_new_trials ! real ( dp ), dimension ( reduced_dim , 1 ) :: solution_vector_reduced ! X_reduced ! end subroutine construct_next_response_trial_vectors_ccs ! ! end interface ! ! interface ! ! !     -::- Input reader submodule interface -::- !     ------------------------------------------ ! module subroutine general_specs_reader_ccs ( wf , unit_input ) !! !!       General Specifications Reader !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017 !! implicit none ! class ( ccs ) :: wf integer ( i15 ) :: unit_input ! integer :: memory = 0 , disk_space = 0 ! end subroutine general_specs_reader_ccs ! ! module subroutine calculation_reader_ccs ( wf , unit_input ) !! !!       Calculation Reader !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017 !! implicit none ! integer ( i15 ) :: unit_input ! class ( ccs ) :: wf ! end subroutine calculation_reader_ccs ! ! module subroutine read_ground_state_specs_ccs ( wf , unit_input ) !! !!       Read Ground State Specifications !!       Written by Eirik F. Kjønstad and Sarai Dery Folkestad, Nov. 2017 !! implicit none ! integer :: unit_input ! class ( ccs ) :: wf ! end subroutine read_ground_state_specs_ccs ! ! module subroutine read_excited_state_specs_ccs ( wf , unit_input ) !! !!       Read Excited State Specifications !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017 !! implicit none ! integer ( i15 ) :: unit_input ! class ( ccs ) :: wf ! end subroutine read_excited_state_specs_ccs ! ! module subroutine read_property_specs_ccs ( wf , unit_input ) !! !!       Read Property Specifications !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017 !! implicit none ! integer ( i15 ) :: unit_input ! class ( ccs ) :: wf ! end subroutine read_property_specs_ccs ! ! end interface ! ! interface ! ! !     -::- Cholesky submodule interface -::- !     -------------------------------------- ! module subroutine get_cholesky_ij_ccs ( wf , L_ij_J , i_first , i_last , j_first , j_last ) !! !!       Get Cholesky IJ !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccs ) :: wf integer ( i15 ), optional :: i_first , j_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), optional :: i_last , j_last ! Last index (can differ from n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ij_J ! end subroutine get_cholesky_ij_ccs ! ! module subroutine get_cholesky_ia_ccs ( wf , L_ia_J , i_first , i_last , a_first , a_last ) !! !!       Get Cholesky IA !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccs ) :: wf integer ( i15 ), optional :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), optional :: i_last , a_last ! Last index (can differ from n_v/n_o when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ia_J ! end subroutine get_cholesky_ia_ccs ! ! module subroutine get_cholesky_ai_ccs ( wf , L_ai_J , a_first , a_last , i_first , i_last ) !! !!       Get Cholesky AI !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccs ) :: wf integer ( i15 ), optional :: i_first , a_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), optional :: i_last , a_last ! Last index (can differ from n_o/n_v when batching or for mlcc) real ( dp ), dimension (:,:) :: L_ai_J ! end subroutine get_cholesky_ai_ccs ! ! module subroutine get_cholesky_ab_ccs ( wf , L_ab_J , a_first , a_last , b_first , b_last ) !! !!       Get Cholesky AB !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccs ) :: wf integer ( i15 ), intent ( in ) :: a_first , b_first ! First index (can differ from 1 when batching or for mlcc) integer ( i15 ), intent ( in ) :: a_last , b_last ! Last index (can differ from n_v when batching or for mlcc) real ( dp ), dimension ((( b_last - b_first + 1 ) * ( a_last - a_first + 1 )), wf % n_J ) :: L_ab_J ! L_ab&#94;J ! end subroutine get_cholesky_ab_ccs ! ! end interface ! ! interface ! !     -::- Integral submodule interface -::- !     -------------------------------------- ! module subroutine store_vv_vv_electronic_repulsion_ccs ( wf ) !! !!       Store vvvv Electronic Repulsion !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine store_vv_vv_electronic_repulsion_ccs ! ! module subroutine store_t1_vv_vv_electronic_repulsion_ccs ( wf ) !! !!       Store t1 vvvv Electronic Repulsion Integrals !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine store_t1_vv_vv_electronic_repulsion_ccs ! ! module subroutine store_t1_vo_ov_electronic_repulsion_ccs ( wf ) !! !!       Store t1 voov Electronic Repulsion Integrals !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine store_t1_vo_ov_electronic_repulsion_ccs ! ! module subroutine store_t1_vv_ov_electronic_repulsion_ccs ( wf ) !! !!       Store t1 voov Electronic Repulsion Integrals !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine store_t1_vv_ov_electronic_repulsion_ccs ! ! module subroutine store_t1_vv_vo_electronic_repulsion_ccs ( wf ) !! !!       Store t1 vvvo Electronic Repulsion Integrals !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine store_t1_vv_vo_electronic_repulsion_ccs ! ! module subroutine read_vv_vv_electronic_repulsion_ccs ( wf , x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Read vvvv Electronic Repulsion !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vv_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine read_vv_vv_electronic_repulsion_ccs ! ! module subroutine read_t1_vv_vv_electronic_repulsion_ccs ( wf , x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Read t1 vvvv Electronic Repulsion !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vv_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine read_t1_vv_vv_electronic_repulsion_ccs ! ! module subroutine read_t1_vo_ov_electronic_repulsion_ccs ( wf , x_vo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Read t1 voov Electronic Repulsion !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vo_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine read_t1_vo_ov_electronic_repulsion_ccs ! ! module subroutine read_t1_vv_vo_electronic_repulsion_ccs ( wf , x_vv_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Read t1 vvvo Electronic Repulsion Integrals !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! !        Integral ! real ( dp ), dimension (:,:) :: x_vv_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine read_t1_vv_vo_electronic_repulsion_ccs ! ! module subroutine read_t1_vv_ov_electronic_repulsion_ccs ( wf , x_vv_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Read t1 vvov Electronic Repulsion Integrals !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! implicit none ! class ( ccs ) :: wf ! !        Integral ! real ( dp ), dimension (:,:) :: x_vv_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine read_t1_vv_ov_electronic_repulsion_ccs ! ! module subroutine get_oo_oo_ccs ( wf , integral_type , x_oo_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_oo,oo integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:, :) :: x_oo_oo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_oo_oo_ccs ! ! module subroutine get_oo_ov_ccs ( wf , integral_type , x_oo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_oo,ov integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_oo_ov ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_oo_ov_ccs ! ! module subroutine get_ov_oo_ccs ( wf , integral_type , x_ov_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_ov,oo integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_ov_oo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_ov_oo_ccs ! ! module subroutine get_oo_vo_ccs ( wf , integral_type , x_oo_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_oo,vo integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_oo_vo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_oo_vo_ccs ! ! module subroutine get_vo_oo_ccs ( wf , integral_type , x_vo_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_vo,oo integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_vo_oo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_vo_oo_ccs ! ! module subroutine get_oo_vv_ccs ( wf , integral_type , x_oo_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_oo,vv integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_oo_vv ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_oo_vv_ccs ! ! module subroutine get_vv_oo_ccs ( wf , integral_type , x_vv_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_vv,oo integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_vv_oo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_vv_oo_ccs ! ! module subroutine get_ov_ov_ccs ( wf , integral_type , x_ov_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_ov,ov integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_ov_ov ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_ov_ov_ccs ! ! module subroutine get_vo_vo_ccs ( wf , integral_type , x_vo_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_vo,vo integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_vo_vo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_vo_vo_ccs ! ! module subroutine get_ov_vo_ccs ( wf , integral_type , x_ov_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_ov,vo integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_ov_vo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_ov_vo_ccs ! ! module subroutine get_vo_ov_ccs ( wf , integral_type , x_vo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_vo,ov integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_vo_ov ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_vo_ov_ccs ! ! module subroutine get_ov_vv_ccs ( wf , integral_type , x_ov_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_ov,vv integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_ov_vv ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_ov_vv_ccs ! ! module subroutine get_vv_ov_ccs ( wf , integral_type , x_vv_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_vv,ov integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_vv_ov ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_vv_ov_ccs ! ! module subroutine get_vo_vv_ccs ( wf , integral_type , x_vo_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_vo,vv integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_vo_vv ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_vo_vv_ccs ! ! module subroutine get_vv_vo_ccs ( wf , integral_type , x_vv_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_vv,vo integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_vv_vo ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_vv_vo_ccs ! ! module subroutine get_vv_vv_ccs ( wf , integral_type , x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get x_vv,vv integral (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! character ( len = 40 ) :: integral_type ! real ( dp ), dimension (:,:) :: x_vv_vv ! integer ( i15 ), optional :: index1_first , index1_last integer ( i15 ), optional :: index2_first , index2_last integer ( i15 ), optional :: index3_first , index3_last integer ( i15 ), optional :: index4_first , index4_last ! end subroutine get_vv_vv_ccs ! ! module subroutine get_oo_oo_electronic_repulsion_ccs ( wf , x_oo_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get oooo Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_oo_oo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ij_J , L_kl_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! end subroutine get_oo_oo_electronic_repulsion_ccs ! ! module subroutine get_oo_ov_electronic_repulsion_ccs ( wf , x_oo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get ooov Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_oo_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ij_J , L_ka_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! end subroutine get_oo_ov_electronic_repulsion_ccs ! ! module subroutine get_ov_oo_electronic_repulsion_ccs ( wf , x_ov_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get ovoo Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_ov_oo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ia_J , L_jk_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! end subroutine get_ov_oo_electronic_repulsion_ccs ! ! module subroutine get_oo_vo_electronic_repulsion_ccs ( wf , x_oo_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get oovo Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_oo_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ij_J , L_ak_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! end subroutine get_oo_vo_electronic_repulsion_ccs ! ! module subroutine get_oo_vv_electronic_repulsion_ccs ( wf , x_oo_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get oovv Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_oo_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ij_J , L_ab_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! end subroutine get_oo_vv_electronic_repulsion_ccs ! ! module subroutine get_vv_oo_electronic_repulsion_ccs ( wf , x_vv_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get vvoo Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vv_oo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ab_J , L_ij_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! end subroutine get_vv_oo_electronic_repulsion_ccs ! ! module subroutine get_ov_ov_electronic_repulsion_ccs ( wf , x_ov_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get ovov Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_ov_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ia_J , L_jb_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! end subroutine get_ov_ov_electronic_repulsion_ccs ! ! module subroutine get_vo_oo_electronic_repulsion_ccs ( wf , x_vo_oo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get vooo Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: x_vo_oo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! real ( dp ), dimension (:,:), allocatable :: L_ai_J , L_jk_J ! integer ( i15 ) :: length_1 = 0 , length_2 = 0 , length_3 = 0 , length_4 = 0 ! end subroutine get_vo_oo_electronic_repulsion_ccs ! ! module subroutine get_vo_vo_electronic_repulsion_ccs ( wf , x_vo_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get vovo Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vo_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine get_vo_vo_electronic_repulsion_ccs ! ! module subroutine get_ov_vo_electronic_repulsion_ccs ( wf , x_ov_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get ovvo Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_ov_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine get_ov_vo_electronic_repulsion_ccs ! ! module subroutine get_vo_ov_electronic_repulsion_ccs ( wf , x_vo_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get voov Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vo_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine get_vo_ov_electronic_repulsion_ccs ! ! module subroutine get_ov_vv_electronic_repulsion_ccs ( wf , x_ov_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get ovvv Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_ov_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine get_ov_vv_electronic_repulsion_ccs ! ! module subroutine get_vv_ov_electronic_repulsion_ccs ( wf , x_vv_ov , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get vvov Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vv_ov ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine get_vv_ov_electronic_repulsion_ccs ! ! module subroutine get_vo_vv_electronic_repulsion_ccs ( wf , x_vo_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get vovv Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vo_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine get_vo_vv_electronic_repulsion_ccs ! ! module subroutine get_vv_vo_electronic_repulsion_ccs ( wf , x_vv_vo , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get vvvo Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vv_vo ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine get_vv_vo_electronic_repulsion_ccs ! ! module subroutine get_vv_vv_electronic_repulsion_ccs ( wf , x_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       Get vvvv Electronic Repulsion (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:) :: x_vv_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine get_vv_vv_electronic_repulsion_ccs ! ! module subroutine t1_transform_vv_vv_ccs ( wf , g_vv_vv , & index1_first , index1_last , & index2_first , index2_last , & index3_first , index3_last , & index4_first , index4_last ) !! !!       T1 Transformation of g_vv_vv Integrals (CCS) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, Oct 2017. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:, :) :: g_vv_vv ! integer ( i15 ) :: index1_first , index1_last integer ( i15 ) :: index2_first , index2_last integer ( i15 ) :: index3_first , index3_last integer ( i15 ) :: index4_first , index4_last ! end subroutine t1_transform_vv_vv_ccs ! end interface ! ! interface ! ! !    -::- Fock submodule interface -::- !    ---------------------------------- ! module subroutine initialize_fock_matrix_ccs ( wf ) !! !!       Initialize Fock Matrix !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_fock_matrix_ccs ! ! module subroutine construct_fock_ccs ( wf ) !! !!       Construct Fock !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine construct_fock_ccs ! ! module subroutine one_electron_t1_ccs ( wf , h1 , h1_T1 ) !! !!       One-electron T1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_mo , wf % n_mo ) :: h1 real ( dp ), dimension ( wf % n_mo , wf % n_mo ) :: h1_T1 ! end subroutine one_electron_t1_ccs ! ! end interface ! ! interface ! ! !    -::- Ionized state submodule interface -::- !    ------------------------------------------- ! module subroutine ionized_state_driver_ccs ( wf ) !! !!       Ionized State Driver (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine ionized_state_driver_ccs ! ! module subroutine initialize_trial_vectors_valence_ionization_ccs ( wf ) !! !!       Initialize Trial Vectors for Valence Ionization !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_trial_vectors_valence_ionization_ccs ! ! module subroutine initialize_trial_vectors_core_ionization_ccs ( wf ) !! !!       Initialize Trial Vectors for Core Ionization !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_trial_vectors_core_ionization_ccs ! ! module subroutine precondition_residual_valence_ionization_ccs ( wf , residual ) !! !!       Precondition Residual Valence !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine precondition_residual_valence_ionization_ccs ! ! module subroutine ionization_residual_projection_ccs ( wf , residual ) !! !!       Core Ionization Residual Projection (CCS) !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine ionization_residual_projection_ccs ! ! module subroutine ionization_rho_a_i_projection_ccs ( wf , rho_a_i ) !! !!       Ionization rho_a_i Projection (CCS) !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! end subroutine ionization_rho_a_i_projection_ccs ! ! module subroutine precondition_residual_core_ionization_ccs ( wf , residual ) !! !!       Precondition Residual Valence !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine precondition_residual_core_ionization_ccs ! ! end interface ! ! interface ! ! !     -::- Jacobian submodule interface -::- !     -------------------------------------- ! module subroutine jacobian_ccs_transformation_ccs ( wf , c_a_i ) !! !!       Jacobian CCS transformation !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! end subroutine jacobian_ccs_transformation_ccs ! ! module subroutine jacobian_ccs_a1_ccs ( wf , rho , c1 ) !! !!       Jacobian CCS A1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_o , wf % n_v ) :: c1 real ( dp ), dimension ( wf % n_o , wf % n_v ) :: rho ! end subroutine jacobian_ccs_a1_ccs ! ! module subroutine jacobian_ccs_b1_ccs ( wf , rho , c1 ) !! !!       Jacobian CCS B1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_o , wf % n_v ) :: c1 real ( dp ), dimension ( wf % n_o , wf % n_v ) :: rho ! end subroutine jacobian_ccs_b1_ccs ! end interface ! ! interface ! ! !     -::- Jacobian transpose submodule interface -::- !     ------------------------------------------------ ! module subroutine jacobian_transpose_ccs_transformation_ccs ( wf , b_a_i ) !! !!       Jacobian transpose transformation (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i ! end subroutine jacobian_transpose_ccs_transformation_ccs ! ! module subroutine jacobian_transpose_ccs_a1_ccs ( wf , sigma_a_i , b_a_i ) !! !!       Jacobian transpose A1 (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i ! end subroutine jacobian_transpose_ccs_a1_ccs ! ! module subroutine jacobian_transpose_ccs_b1_ccs ( wf , sigma_a_i , b_a_i ) !! !!       Jacobian transpose B1 (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: sigma_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: b_a_i ! end subroutine jacobian_transpose_ccs_b1_ccs ! ! end interface ! ! interface ! !     -::- CVS submodule interface -::- !     --------------------------------- ! module subroutine cvs_rho_a_i_projection_ccs ( wf , vec_a_i ) !! !!       CVS rho_a_i Projection !!       Written by Sarai D. Folkestad, Aug 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_o , wf % n_v ) :: vec_a_i ! end subroutine cvs_rho_a_i_projection_ccs ! ! module subroutine cvs_residual_projection_ccs ( wf , residual ) !! !!       CVS Residual Projection !!       Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine cvs_residual_projection_ccs ! ! end interface ! ! contains ! ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::- 4. Class subroutines and functions -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! ! subroutine init_ccs ( wf ) !! !!    Initialize CCS object !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Performs the following tasks !! !!    - Sets HF orbital and energy information by reading from file !!    - Transforms AO Cholesky vectors to MO basis and saves to file !!    - Allocates the singles amplitudes and sets them to zero, and sets associated properties !!    - Allocates the omega vector and sets it to zero !!    - Initializes the Fock matrix and sets it to zero !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: unit_input = - 1 ! !     Set model name ! wf % name = 'CCS' ! !     Open input file eT.inp ! call generate_unit_identifier ( unit_input ) open ( unit = unit_input , file = 'eT.inp' , status = 'old' , form = 'formatted' ) rewind ( unit_input ) ! !     Read general specifications (memory and diskspace for calculation) ! call wf % general_specs_reader ( unit_input ) ! !     Set implemented generic methods ! wf % implemented % ground_state = . true . wf % implemented % excited_state = . true . wf % implemented % ionized_state = . true . wf % implemented % core_excited_state = . true . wf % implemented % core_ionized_state = . true . wf % implemented % multipliers = . false . ! !     Read calculation tasks from input file eT.inp ! call wf % calculation_reader ( unit_input ) ! !     Close input file ! close ( unit_input ) ! !     Read Hartree-Fock info from SIRIUS ! call wf % read_hf_info ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize amplitudes and associated attributes ! call wf % initialize_amplitudes ! !     Set the number of parameters in the wavefunction !     (that are solved for in the ground and excited state solvers) ! wf % n_parameters = wf % n_t1am ! !     Initialize the projection vector ! call wf % initialize_omega ! !     Allocate Fock matrix and set to zero ! call wf % initialize_fock_matrix ! end subroutine init_ccs ! ! subroutine drv_ccs ( wf ) !! !!    CCS Driver !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    The driver for CCS is written so as to be inherited unaltered. !!    It finds which calculations are requested by the user, and controls !!    that the calculation can be done. If the method is implemented, it !!    calls the driver for that particular calculation (e.g., ground state !!    energy). !! implicit none ! class ( ccs ) :: wf ! if ( wf % tasks % ground_state ) then ! !        Ground state calculation requested ! if ( wf % implemented % ground_state ) then ! call wf % ground_state_driver ! else ! write ( unit_output , '(t3,a,a)' ) & 'Error: ground state solver not implemented for ' , trim ( wf % name ) stop ! endif endif ! if ( wf % tasks % excited_state ) then ! if ( wf % implemented % excited_state ) then ! call wf % excited_state_driver ! else ! write ( unit_output , '(t3,a,a)' ) & 'Error: excited state solver not implemented for ' , trim ( wf % name ) flush ( unit_output ) stop ! endif ! endif ! if ( wf % tasks % core_excited_state ) then ! !        Excited state calculation requested ! if ( wf % implemented % core_excited_state ) then ! call wf % excited_state_driver ! else ! write ( unit_output , '(t3,a,a)' ) & 'Error: core excited state solver not implemented for ' , trim ( wf % name ) flush ( unit_output ) stop ! endif ! endif ! if ( wf % tasks % ionized_state ) then ! if ( wf % implemented % ionized_state ) then ! call wf % ionized_state_driver ! else ! write ( unit_output , '(t3,a,a)' ) & 'Error: ionized state solver not implemented for ' , trim ( wf % name ) flush ( unit_output ) stop ! endif ! endif ! if ( wf % tasks % core_ionized_state ) then ! if ( wf % implemented % core_ionized_state ) then ! call wf % ionized_state_driver ! else ! write ( unit_output , '(t3,a,a)' ) & 'Error: core ionized state solver not implemented for ' , trim ( wf % name ) flush ( unit_output ) stop ! endif ! endif ! if ( wf % tasks % multipliers ) then ! !        Multipliers calculation requested ! if ( wf % implemented % multipliers ) then ! call wf % response_driver ! else ! write ( unit_output , '(t3,a,a)' ) 'Error: Multipliers not implemented for ' , trim ( wf % name ) stop ! endif ! endif ! end subroutine drv_ccs ! ! subroutine initialize_amplitudes_ccs ( wf ) !! !!    Initialize Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Allocates the singles amplitudes, sets them to zero, and calculates !!    the number of singles amplitudes. !! implicit none ! class ( ccs ) :: wf ! !     Calculate the number of singles amplitudes ! wf % n_t1am = ( wf % n_o ) * ( wf % n_v ) ! !     Allocate the singles amplitudes and set to zero !     (which is also the value that solves the projected Scrödinger eq.) ! if (. not . allocated ( wf % t1am )) call wf % mem % alloc ( wf % t1am , wf % n_v , wf % n_o ) wf % t1am = zero ! end subroutine initialize_amplitudes_ccs ! ! subroutine initialize_omega_ccs ( wf ) !! !!    Initialize Omega (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Allocates and sets the projection vector to zero (which is !!    also its correct value, by Brillouin) !! implicit none ! class ( ccs ) :: wf ! if (. not . allocated ( wf % omega1 )) call wf % mem % alloc ( wf % omega1 , wf % n_v , wf % n_o ) wf % omega1 = zero ! end subroutine initialize_omega_ccs ! ! subroutine calc_energy_ccs ( wf ) !! !!    Calculate Energy (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! wf % energy = wf % scf_energy ! end subroutine calc_energy_ccs ! ! subroutine construct_omega_ccs ( wf ) !! !!    Construct Omega (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! wf % omega1 = zero ! Brillouin ! end subroutine construct_omega_ccs ! ! subroutine omega_ccs_a1_ccs ( wf ) !! !!    Omega D1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, March 2017 !! !!    Omega_ai&#94;D1 = F_ai_T1 !! implicit none ! class ( ccs ) :: wf ! !     Add F_a_i to omega ! call daxpy (( wf % n_o ) * ( wf % n_v ), one , wf % fock_ai , 1 , wf % omega1 , 1 ) ! end subroutine omega_ccs_a1_ccs ! ! subroutine construct_eta_ccs ( wf , eta ) !! !!    Construct Eta (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017 !! !!    Note: the routine assumes that the Fock matrix !!    has been constructed. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: eta ! eta_ai ! integer ( i15 ) :: i = 0 , a = 0 , ai = 0 ! eta = zero ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) eta ( ai , 1 ) = two * ( wf % fock_ia ( i , a )) ! eta_ai = 2 F_ia ! enddo enddo ! end subroutine construct_eta_ccs ! ! subroutine save_amplitudes_ccs ( wf ) !! !!    Save Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Store the amplitudes to disk (T1AM) !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: unit_t1am = - 1 ! !     Open amplitude file ! call generate_unit_identifier ( unit_t1am ) open ( unit_t1am , file = 't1am' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_t1am ) ! write ( unit_t1am ) wf % t1am ! !     Close amplitude file ! close ( unit_t1am ) ! end subroutine save_amplitudes_ccs ! ! subroutine read_amplitudes_ccs ( wf ) !! !!    Read Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM) !! implicit none ! class ( ccs ) :: wf ! call wf % read_single_amplitudes ! end subroutine read_amplitudes_ccs ! subroutine read_single_amplitudes_ccs ( wf ) !! !!    Read Amplitudes (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM, T2AM) !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ) :: unit_t1am = - 1 ! logical :: file_exists = . false . ! !     Check to see whether file exists ! inquire ( file = 't1am' , exist = file_exists ) ! if ( file_exists ) then ! !        Open amplitude files if they exist ! call generate_unit_identifier ( unit_t1am ) ! open ( unit_t1am , file = 't1am' , status = 'unknown' , form = 'unformatted' ) ! rewind ( unit_t1am ) ! !        Read from file & close ! wf % t1am = zero ! read ( unit_t1am ) wf % t1am ! close ( unit_t1am ) ! else ! write ( unit_output , '(t3,a)' ) 'Error: amplitude files do not exist.' stop ! endif ! end subroutine read_single_amplitudes_ccs ! ! subroutine destruct_amplitudes_ccs ( wf ) !! !!    Destruct Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Deallocates the amplitudes. !! implicit none ! class ( ccs ) :: wf ! if ( allocated ( wf % t1am )) then call wf % mem % dealloc ( wf % t1am , wf % n_v , wf % n_o ) endif ! end subroutine destruct_amplitudes_ccs ! ! subroutine destruct_omega_ccs ( wf ) !! !!    Destruct Omega (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Deallocates the projection vector. !! implicit none ! class ( ccs ) :: wf ! if ( allocated ( wf % omega1 )) then call wf % mem % dealloc ( wf % omega1 , wf % n_v , wf % n_o ) endif ! end subroutine destruct_omega_ccs ! ! subroutine jacobi_test_ccs ( wf ) ! implicit none ! class ( ccs ) :: wf ! end subroutine jacobi_test_ccs ! ! subroutine read_atom_info ( n_nuclei , n_ao ) !! !!    Read atom info, !!    Written by Sarai Dery Folkestad, June 2017. !! !!    Reads atom info from DALTON generated file: !!    Reads: !!       - Number of nuclei !!       - Number of AO's !! implicit none ! integer ( i15 ) :: n_nuclei , n_ao ! integer ( i15 ) :: unit_center = 0 integer ( i15 ) :: ioerror = 0 ! call generate_unit_identifier ( unit_center ) open ( unit = unit_center , file = 'center_info' , status = 'unknown' , form = 'unformatted' , iostat = ioerror ) if ( ioerror . ne . 0 ) write ( unit_output , * ) 'WARNING: Error while opening center_info' rewind ( unit_center ) ! !     Read number of nuclei and aos ! read ( unit_center ) n_nuclei , n_ao ! close ( unit_center ) ! end subroutine read_atom_info ! subroutine read_center_info ( n_nuclei , n_ao , n_ao_on_center , ao_center_info ) !! !!    Read center info, !!    Written by Sarai Dery Folkestad, June 2017. !! !!    Reads atom info from DALTON generated file: !!    Reads: !!       - Information of which ao's belong to which nuclei !! implicit none ! integer ( i15 ) :: n_nuclei integer ( i15 ) :: n_ao integer , dimension ( n_nuclei , 1 ) :: n_ao_on_center integer , dimension ( n_ao , 2 ) :: ao_center_info ! integer ( i15 ) :: offset = 0 , nucleus = 0 integer ( i15 ) :: i = 0 integer ( i15 ) :: unit_center = 0 , ioerror = 0 ! !     Read number of aos on each center ! call generate_unit_identifier ( unit_center ) open ( unit = unit_center , file = 'center_info' , status = 'unknown' , form = 'unformatted' , iostat = ioerror ) if ( ioerror . ne . 0 ) write ( unit_output , * ) 'WARNING: Error while opening center_info' rewind ( unit_center ) ! !     Empty read ! read ( unit_center ) ! read ( unit_center , iostat = ioerror ) n_ao_on_center if ( ioerror . ne . 0 ) write ( unit_output , * ) 'WARNING: Error while reading center_info' ! offset = 1 ! do nucleus = 1 , n_nuclei ! do i = 1 , n_ao_on_center ( nucleus , 1 ) ao_center_info ( offset + i - 1 , 1 ) = nucleus enddo ! !        Read which aos are on which centers ! read ( unit_center , iostat = ioerror ) ( ao_center_info ( offset + i - 1 , 2 ), i = 1 , n_ao_on_center ( nucleus , 1 )) if ( ioerror . ne . 0 ) write ( unit_output , * ) 'WARNING: Error while reading center_info' ! offset = offset + n_ao_on_center ( nucleus , 1 ) ! enddo ! close ( unit_center ) ! end subroutine read_center_info ! ! end module ccs_class","tags":"","loc":"sourcefile/ccs_class.f90.html","title":"ccs_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~mp2_class.f90~~EfferentGraph sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~hf_class.f90->sourcefile~mp2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mp2_class.f90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~mp2_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~mp2_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~mp2_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilemp2_classf90EfferentGraph = svgPanZoom('#sourcefilemp2_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mp2_class.f90~~AfferentGraph sourcefile~mp2_class.f90 mp2_class.F90 sourcefile~et_program.f90 eT_program.F90 sourcefile~mp2_class.f90->sourcefile~et_program.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mp2_class Source Code mp2_class.F90 Source Code module mp2_class ! !! !!              Second-order Möller-Plesset (MP2) class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output ! !  The ancestor class module (HF) ! use hf_class ! implicit none ! !  ::::::::::::::::::::::::::::::::::::: !  -::- Definition of the MP2 class -::- !  ::::::::::::::::::::::::::::::::::::: ! type , extends ( hf ) :: mp2 ! !     No unique variables (inherits all of them from HF) ! contains ! !     Initialization and driver routines ! procedure :: init => init_mp2 procedure :: drv => drv_mp2 ! !     Routine to calculate the MP2 energy ! procedure :: calc_energy => calc_energy_mp2 ! end type mp2 ! ! contains ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::- Initialization and driver routines -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! subroutine init_mp2 ( wf ) !! !!    Initialize MP2 object !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Performs the following tasks !! !!    - Sets HF orbital and energy information by reading from file !!    - Transforms AO Cholesky vectors to MO basis and saves to file !! implicit none ! class ( mp2 ) :: wf ! !     Set model name ! wf % name = 'MP2' ! !     Set implemented methods ! wf % implemented % ground_state = . true . ! !     Read Hartree-Fock info from SIRIUS ! call wf % read_hf_info ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! end subroutine init_mp2 ! ! subroutine drv_mp2 ( wf ) !! !!    MP2 Driver !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    The driver for MP2 checks whether the ground state is requested, !!    and if so, calls the calculation of the MP2 energy. !! implicit none ! class ( mp2 ) :: wf ! if ( wf % tasks % ground_state ) then ! !        Ground state calculation requested ! if ( wf % implemented % ground_state ) then ! call wf % calc_energy ! else ! write ( unit_output , '(t3,a,a)' ) & 'Error: ground state solver not implemented for ' , trim ( wf % name ) stop ! endif ! else ! write ( unit_output , '(t3,a,a)' ) & 'Error: only the ground state is implemented for ' , trim ( wf % name ) stop ! endif ! end subroutine drv_mp2 ! !  ::::::::::::::::::::::::::::::::::::::::: !  -::- Class subroutines and functions -::- !  ::::::::::::::::::::::::::::::::::::::::: ! subroutine calc_energy_mp2 ( wf ) !! !!    Calculate Energy (MP2) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Calculates the MP2 energy. !! implicit none ! class ( mp2 ) :: wf ! real ( dp ), dimension (:,:), allocatable :: L_ia_J ! L_ia&#94;J real ( dp ), dimension (:,:), allocatable :: g_ia_jb ! g_iajb ! integer ( i15 ) :: i = 0 , a = 0 , j = 0 , b = 0 integer ( i15 ) :: ia = 0 , jb = 0 , ib = 0 , ja = 0 ! real ( dp ) :: begin_timer , end_timer , integral_time ! write ( unit_output , '(/t3,a/)' ) 'Calculating the MP2 energy:' flush ( unit_output ) ! call cpu_time ( begin_timer ) ! !     Read L_ia&#94;J from disk ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call wf % read_cholesky_ia ( L_ia_J ) ! !     Form g_iajb = sum_J L_ia&#94;J L_ia&#94;J ! call wf % mem % alloc ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ia_jb , & ( wf % n_o ) * ( wf % n_v )) ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Add the MP2 correction to the Hartree-Fock energy ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ia = index_two ( i , a , wf % n_o ) ! do b = 1 , wf % n_v ! ib = index_two ( i , b , wf % n_o ) ! do j = 1 , wf % n_o ! ja = index_two ( j , a , wf % n_o ) jb = index_two ( j , b , wf % n_o ) ! wf % energy = wf % energy - & ( g_ia_jb ( ia , jb ) * ( two * g_ia_jb ( ia , jb ) - g_ia_jb ( ib , ja ))) / & ( wf % fock_diagonal ( wf % n_o + a , 1 ) + & wf % fock_diagonal ( wf % n_o + b , 1 ) - & wf % fock_diagonal ( i , 1 ) - & wf % fock_diagonal ( j , 1 )) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Print the energy to the main output file ! write ( unit_output , '(t3,a27,f14.8)' ) 'Total energy (hartrees):' , wf % energy ! call cpu_time ( end_timer ) write ( unit_output , '(t3,a27,f14.8/)' ) 'Total time (seconds):' , end_timer - begin_timer flush ( unit_output ) ! end subroutine calc_energy_mp2 ! ! end module mp2_class","tags":"","loc":"sourcefile/mp2_class.f90.html","title":"mp2_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~cc2_class.f90~~EfferentGraph sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~ccs_class.f90->sourcefile~cc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~cc2_class.f90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~input_output.f90->sourcefile~cc2_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~cc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~cc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilecc2_classf90EfferentGraph = svgPanZoom('#sourcefilecc2_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~cc2_class.f90~~AfferentGraph sourcefile~cc2_class.f90 cc2_class.F90 sourcefile~omega_submodule.f90~5 omega_submodule.F90 sourcefile~cc2_class.f90->sourcefile~omega_submodule.f90~5 sourcefile~excited_state_submodule.f90~4 excited_state_submodule.F90 sourcefile~cc2_class.f90->sourcefile~excited_state_submodule.f90~4 sourcefile~et_program.f90 eT_program.F90 sourcefile~cc2_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~4 jacobian_submodule.F90 sourcefile~cc2_class.f90->sourcefile~jacobian_submodule.f90~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules cc2_class Source Code cc2_class.F90 Source Code module cc2_class ! !! !!            Coupled cluster perturbative doubles (CC2) class module !!         Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output ! !  The ancestor class module (CCS) ! use ccs_class ! ! implicit none ! !  ::::::::::::::::::::::::::::::::::::: !  -::- Definition of the CC2 class -::- !  ::::::::::::::::::::::::::::::::::::: ! type , extends ( ccs ) :: cc2 ! real ( dp ), dimension (:,:), allocatable :: s2am ! integer ( dp ) :: n_s2am ! contains ! !     Initialization and driver routines ! procedure :: init => init_cc2 ! !     Routines to construct the projection vector (omega) ! procedure :: construct_omega => construct_omega_cc2 ! !     Helper routines for construct_omega ! procedure :: omega_cc2_a1 => omega_cc2_a1_cc2 procedure :: omega_cc2_b1 => omega_cc2_b1_cc2 procedure :: get_s2am => get_s2am_cc2 ! procedure :: read_cc2_double_amplitudes => read_cc2_double_amplitudes_cc2 procedure :: read_amplitudes => read_amplitudes_cc2 procedure :: save_amplitudes => save_amplitudes_cc2 procedure :: destruct_s2am => destruct_s2am_cc2 ! !     Ground state solver helper routines ! procedure :: calc_energy => calc_energy_cc2 ! !     Jacobian ! procedure :: jacobian_cc2_transformation => jacobian_cc2_transformation_cc2 ! procedure :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_cc2 ! procedure :: jacobian_cc2_a1 => jacobian_cc2_a1_cc2 procedure :: jacobian_cc2_b1 => jacobian_cc2_b1_cc2 procedure :: jacobian_cc2_a2 => jacobian_cc2_a2_cc2 procedure :: jacobian_cc2_b2 => jacobian_cc2_b2_cc2 ! !     Excited states ! procedure :: initialize_excited_states => initialize_excited_states_cc2 procedure :: calculate_orbital_differences => calculate_orbital_differences_cc2 procedure :: transform_trial_vectors => transform_trial_vectors_cc2 procedure :: cvs_residual_projection => cvs_residual_projection_cc2 procedure :: excited_state_preparations => excited_state_preparations_cc2 ! procedure :: analyze_double_excitation_vector => analyze_double_excitation_vector_cc2 procedure :: summary_excited_state_info => summary_excited_state_info_cc2 ! end type cc2 ! !  :::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Interface to the submodule routines of CCS -::- !  :::::::::::::::::::::::::::::::::::::::::::::::::::: ! interface ! !     -::- Omega interface -::- !     ::::::::::::::::::::::::: ! module subroutine construct_omega_cc2 ( wf ) !! !!        Construct Omega !!        Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!        Directs the construction of the projection vector < mu | exp(-T) H exp(T) | R > !!        for the current amplitudes of the object wf !! implicit none ! class ( cc2 ) :: wf ! end subroutine construct_omega_cc2 ! ! module subroutine omega_cc2_a1_cc2 ( wf ) !! !!        Omega A1 !!        Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!        Calculates the A1 term of omega, !! !!        A1: sum_ckd g_adkc * u_ki&#94;cd, !! !!        and adds it to the projection vector (omega1) of !!        the wavefunction object wf !! !!        u_ki&#94;cd = 2*t_ki&#94;cd - t_ik&#94;cd !! implicit none ! class ( cc2 ) :: wf ! end subroutine omega_cc2_a1_cc2 ! ! module subroutine omega_cc2_b1_cc2 ( wf ) !! !!        Omega B1 !!        Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!        Calculates the B1 term of omega, !! !!        B1: - sum_ckl u_kl&#94;ac * g_kilc, !! !!        and adds it to the projection vector (omeg1) of !!        the wavefunction object wf !! !!        u_kl&#94;ac = 2*t_kl&#94;ac - t_lk&#94;ac !! implicit none ! class ( cc2 ) :: wf ! end subroutine omega_cc2_b1_cc2 ! ! module subroutine get_s2am_cc2 ( wf , s_ia_jb , b_first , b_length ) !! !!       Get S_2 amplitudes, !!       Written by Sarai D. Folkestad, July 2017 !! !!       Construct !! !!          s_ai_bj = - 1/ε_ij&#94;ab * g_aibj, !! !!       while batching over b. !! implicit none ! class ( cc2 ) :: wf ! integer ( i15 ) :: b_first , b_length real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), b_length * ( wf % n_o )) :: s_ia_jb ! end subroutine get_s2am_cc2 ! ! end interface ! ! interface ! !     -::- Jacobian transformation submodule -::- !     ::::::::::::::::::::::::::::::::::::::::::: ! module subroutine jacobian_cc2_transformation_cc2 ( wf , c_a_i , c_aibj ) !! !!       Jacobian transformation (CC2) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Directs the transformation by the CC2 Jacobi matrix, !! !!          A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >, !! !!       where the basis employed for the brackets is biorthonormal. !!       The transformation is rho = A c, i.e., !! !!          rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck !!                  + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl). !! !!       On exit, c is overwritten by rho. That is, c_a_i = rho_a_i, !!       and c_aibj = rho_aibj. !! implicit none ! class ( cc2 ) :: wf ! !        Incoming vector c ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_s2am , 1 ) :: c_aibj ! c_aibj ! end subroutine jacobian_cc2_transformation_cc2 ! ! module subroutine jacobian_cc2_a1_cc2 ( wf , rho_a_i , c_a_i ) !! !!       Jacobian tem A1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Calculates the A1 contribution to the jacobi transformation, !! !!          A1: 2*sum_BJck u_ik&#94;ac*g_kc,JB*c_BJ - sum_Bjck u_kj&#94;ca*g_kc,jB*c_BI !!            - sum_BJck u_ik&#94;ac*g_kB,Jc*c_BJ - sum_bJck u_ki&#94;cb*g_kc,Jb*c_AJ, !! !!       with, !! !!       u_ik&#94;ac = 2*s_ik&#94;ac - 2*s_ik&#94;ca, !! !!       which is constructed while batching over c !! implicit none ! class ( cc2 ) :: wf ! !        Incoming vectors c and rho ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! end subroutine jacobian_cc2_a1_cc2 ! ! module subroutine jacobian_cc2_b1_cc2 ( wf , rho_a_i , c_ai_bj ) !! !!       Jacobian tem B1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Calculates the B1 contribution to the jacobi transformation, !! !!       B1:   sum_ck F_kc*(2c_ai,ck - c_ak,ci) !!           - sum_ckj L_jIkc * c_aj,ck + sum_cbk L_Abkc * c_bi,ck !! !! !!       L_Abkc is constructed while batching over A. !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension (:,:) :: c_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! end subroutine jacobian_cc2_b1_cc2 ! ! module subroutine jacobian_cc2_a2_cc2 ( wf , rho_ai_bj , c_a_i ) !! !!       Jacobian tem A2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Calculates the A2 contribution to the jacobi transformation, !! !!          A2:   sum_C g_ai,bC * c_Cj - sum_K g_ai,Kj * C_bK. !! !!       g_ai,bC is constructed in batches of C. !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! end subroutine jacobian_cc2_a2_cc2 ! ! module subroutine jacobian_cc2_b2_cc2 ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian tem B2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Calculates the B2 contribution to the jacobi transformation, !! !!          B2:   ε_ij&#94;ab*c_ai,bj. !! !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension (:,:) :: c_ai_bj real ( dp ), dimension (:,:) :: rho_ai_bj ! ! end subroutine jacobian_cc2_b2_cc2 ! ! module subroutine cvs_rho_aibj_projection_cc2 ( wf , vec_aibj ) !! !!       Rho projection for CVS (CC2), !!       Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( cc2 ) :: wf real ( dp ), dimension (:, :) :: vec_aibj ! end subroutine cvs_rho_aibj_projection_cc2 ! ! end interface ! ! interface ! !     -::- Excited state submodule interface -::- !     ::::::::::::::::::::::::::::::::::::::::::: ! module subroutine initialize_excited_states_cc2 ( wf ) !! !!       Initialize excited states !!       Written by Sarai D. Folkestad, June 2017 !! !!       Calculates and sets n_s2am, and updates n_parameters !!       for excited state calculation !! implicit none ! class ( cc2 ) :: wf ! end subroutine initialize_excited_states_cc2 ! ! module subroutine calculate_orbital_differences_cc2 ( wf , orbital_diff ) !! !!       Calculate Orbital Differences (CC2) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad May 2017 !! !!       Calculates orbital differences !! !!          1) ε_I&#94;A = ε_A - ε_I !!          2) ε_ij&#94;ab = ε_a + ε_b - ε_i - ε_j (for active spaces only) !! !!       and puts them in orbital_diff, which is a vector of length n_parameters. !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: orbital_diff ! end subroutine calculate_orbital_differences_cc2 ! ! module subroutine transform_trial_vectors_cc2 ( wf , first_trial , last_trial ) !! !!       Transformation Trial Vectors (CC2) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       Each trial vector in first_trial to last_trial is read from file and !!       transformed before the transformed vector is written to file. !! !!       Singles and doubles part of the transformed vectors are written to !!       the same record in file transformed_vec, record length is n_parameters long. !! implicit none ! class ( cc2 ) :: wf ! integer ( i15 ), intent ( in ) :: first_trial , last_trial ! Which trial_vectors we are to transform ! end subroutine transform_trial_vectors_cc2 ! ! module subroutine cvs_residual_projection_cc2 ( wf , residual ) !! !!       Residual projection (CC2), !!       Written by Sarai D. Folkestad Aug. 2017 !! implicit none ! class ( cc2 ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine cvs_residual_projection_cc2 ! ! module subroutine excited_state_preparations_cc2 ( wf ) !! !!       Excited State Preparations (CC2) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!       A routine for preparation tasks (if any). Can be overwritten !!       in descendants if other preparations prove necessary. !! class ( cc2 ) :: wf ! end subroutine excited_state_preparations_cc2 ! ! module subroutine analyze_double_excitation_vector_cc2 ( wf , vec , n , sorted_short_vec , index_list ) !! !! !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension ( wf % n_s2am , 1 ) :: vec ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 , k = 0 ! integer ( i15 ) :: n ! Number of elements wanted ! real ( dp ), dimension ( n , 1 ) :: sorted_short_vec ! integer ( i15 ), dimension ( n , 4 ) :: index_list ! end subroutine analyze_double_excitation_vector_cc2 ! ! module subroutine summary_excited_state_info_cc2 ( wf , energies ) !! !! !! implicit none ! class ( cc2 ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! end subroutine summary_excited_state_info_cc2 end interface ! ! contains ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::- Initialization and driver routines -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! subroutine init_cc2 ( wf ) !! !!     Initialize CC2 object !!     Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!     Performs the following tasks !! !!     1. Sets HF orbital and energy information by reading from file (read_hf_info) !!     2. Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky) !!     3. Allocates the Fock matrix and sets it to zero (note: the matrix is constructed in !!        the descendant classes) !!     4. Allocates the singles amplitudes and sets them to zero, and sets associated properties !!     5. Allocate Omega vector !! implicit none ! class ( cc2 ) :: wf ! integer ( i15 ) :: unit_input = - 1 ! !     Set model name ! wf % name = 'CC2' ! !     Open input file eT.inp ! call generate_unit_identifier ( unit_input ) open ( unit = unit_input , file = 'eT.inp' , status = 'old' , form = 'formatted' ) rewind ( unit_input ) ! !     Read general specifications (memory and diskspace for calculation) ! call wf % general_specs_reader ( unit_input ) ! !     Set implemented ! wf % implemented % ground_state = . true . wf % implemented % excited_state = . true . wf % implemented % core_excited_state = . true . ! !     Read calculation tasks from input file eT.inp ! call wf % calculation_reader ( unit_input ) ! !     Close input file ! close ( unit_input ) ! !     Read Hartree-Fock info from SIRIUS ! call wf % read_hf_info ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize amplitudes and associated attributes ! call wf % initialize_amplitudes ! !     Allocate Fock matrix and set to zero ! call wf % initialize_fock_matrix ! wf % n_parameters = wf % n_t1am ! !     Initialize omega vector ! call wf % initialize_omega ! end subroutine init_cc2 ! ! !  ::::::::::::::::::::::::::::::::::::::::: !  -::- Class subroutines and functions -::- !  ::::::::::::::::::::::::::::::::::::::::: ! subroutine calc_energy_cc2 ( wf ) !! !!    Calculate Energy (CC2) !! !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Calculates the CC2 energy, !! !!    E_CC2 = E_HF + sum_aibj L_iajb*(t_ij&#94;ab + t_i&#94;a*t_j&#94;b), !! !!    with t_ij&#94;ab = - g_aibj/(e_a + e_b - e_i - e_j) where !!    g_aibj are T1-transformed integrals. !!    Batching over a. !! implicit none ! class ( cc2 ) :: wf ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: L_bj_J real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: g_ia_bj ! = g_aibj real ( dp ), dimension (:,:), allocatable :: g_ia_jb ! !     t2 amplitudes ! real ( dp ), dimension (:,:), allocatable :: t_ia_bj ! = g_aibj/(e_a + e_b - e_i - e_j) ! !     Batching variables ! integer ( i15 ) :: a_batch , a_first , a_last , a_length integer ( i15 ) :: required , available , n_batch , batch_dimension , max_batch_length ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: ai = 0 , bj = 0 integer ( i15 ) :: ia = 0 , ib = 0 , jb = 0 , ja = 0 ! integer ( i15 ) :: aibj = 0 ! !     Prepare for batching over index a ! required = ( 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ) & ! + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ) & ! Needed for g_aibj + 2 * (( wf % n_v ) ** 2 ) * ( wf % n_J ) + (( wf % n_o ) ** 2 ) * ( wf % n_J ) & ! and 't2' amplitudes + 2 * ( wf % n_v ) ** 2 * ( wf % n_o ) ** 2 ) ! ! required = 4 * required ! In words available = get_available () ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_first , a_last , a_batch , max_batch_length , batch_dimension ) a_length = a_last - a_first + 1 ! !        :: Calculate cc2 doubles amplitudes :: ! !        Allocate L_bj_J and L_ia_J (= reordering of L_bj_J constrained to the batch) ! call wf % mem % alloc ( L_bj_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) call wf % mem % alloc ( L_ia_J , a_length * ( wf % n_o ), wf % n_J ) L_bj_J = zero L_ia_J = zero ! call wf % get_cholesky_ai ( L_bj_J ) ! !        Create L_ia_J ! do a = 1 , a_length do i = 1 , wf % n_o do J = 1 , wf % n_J ! !                 Calculate compound indices ! ia = index_two ( i , a , wf % n_o ) ai = index_two ( a + a_first - 1 , i , wf % n_v ) ! L_ia_J ( ia , J ) = L_bj_J ( ai , J ) ! enddo enddo enddo ! !        Allocate g_ia_bj ! call wf % mem % alloc ( g_ia_bj , a_length * ( wf % n_o ), ( wf % n_o ) * ( wf % n_v )) ! !        Construct integral g_ia_bj (= g_aibj for the batch) ! call dgemm ( 'N' , 'T' , & a_length * ( wf % n_o ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J , & a_length * ( wf % n_o ), & L_bj_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ia_bj , & a_length * ( wf % n_o )) ! !        L_bj_J and L_ia_J ! call wf % mem % dealloc ( L_bj_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) call wf % mem % dealloc ( L_ia_J , a_length * ( wf % n_o ), wf % n_J ) ! !        :: Construct the needed integrals for the enegry :: ! !        Allocate t_ia_bj ! call wf % mem % alloc ( t_ia_bj , a_length * ( wf % n_o ), ( wf % n_o ) * ( wf % n_v )) ! !        Create t2 amplitudes ! do a = 1 , a_length do i = 1 , wf % n_o ! ia = index_two ( i , a , wf % n_o ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! t_ia_bj ( ia , bj ) = - g_ia_bj ( ia , bj ) / ( wf % fock_diagonal ( a + wf % n_o , 1 ) & + wf % fock_diagonal ( b + wf % n_o , 1 ) & - wf % fock_diagonal ( i , 1 ) - wf % fock_diagonal ( j , 1 )) ! enddo enddo enddo enddo ! !        Deallocate g_ia_bj ! call wf % mem % dealloc ( g_ia_bj , a_length * ( wf % n_o ), ( wf % n_o ) * ( wf % n_v )) ! !        Allocate the Cholesky vector L_ia_J = L_ia&#94;J and set to zero ! call wf % mem % alloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_ia_J = zero ! !         Get the Cholesky vector L_ia_J ! call wf % get_cholesky_ia ( L_ia_J ) ! !        Allocate g_ia_jb = g_iajb and set it to zero ! call wf % mem % alloc ( g_ia_jb , ( wf % n_o ) * a_length , ( wf % n_o ) * ( wf % n_v )) g_ia_jb = zero ! !        Calculate the integrals g_ia_jb from the Cholesky vector L_ia_J ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * a_length , & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J ( index_two ( 1 , a_first , wf % n_o ), 1 ), & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ia_jb , & ( wf % n_o ) * a_length ) ! !     Deallocate the Cholesky vector L_ia_J ! call wf % mem % dealloc ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Set the initial value of the energy ! wf % energy = wf % scf_energy ! !     Add the correlation energy E = E + sum_aibj (t_ij&#94;ab + t_i&#94;a t_j&#94;b) L_iajb ! do i = 1 , wf % n_o do a = 1 , a_length ! ai = index_two ( a , i , a_length ) ia = index_two ( i , a , wf % n_o ) ! do j = 1 , wf % n_o ! ja = index_two ( j , a , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) jb = index_two ( j , b , wf % n_o ) ib = index_two ( i , b , wf % n_o ) ! aibj = index_packed ( ai , bj ) ! !                    Add the correlation energy ! wf % energy = wf % energy + & ( two * g_ia_jb ( ia , jb ) - g_ia_jb ( ja , ib )) * ( t_ia_bj ( ia , bj ) + ( wf % t1am ( a , i )) * ( wf % t1am ( b , j ))) ! enddo enddo enddo enddo ! !        Deallocate g_ia_jb ! call wf % mem % dealloc ( g_ia_jb , ( wf % n_o ) * a_length , ( wf % n_o ) * ( wf % n_v )) ! !        Deallocate t_ia_bj ! call wf % mem % dealloc ( t_ia_bj , a_length * ( wf % n_o ), ( wf % n_o ) * ( wf % n_v )) ! enddo ! End of batching ! end subroutine calc_energy_cc2 ! ! subroutine save_amplitudes_cc2 ( wf ) !! !!    Save Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Store the amplitudes to disk (T1AM) !! implicit none ! class ( cc2 ) :: wf ! integer ( i15 ) :: unit_t1am = - 1 integer ( i15 ) :: unit_s2am = - 1 ! real ( dp ), dimension (:,:), allocatable :: s_ia_jb real ( dp ), dimension (:,:), allocatable :: s2am ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , ia = 0 , b = 0 , j = 0 , bj = 0 , jb = 0 integer ( i15 ) :: aibj = 0 ! !     Open amplitude files ! call generate_unit_identifier ( unit_t1am ) open ( unit_t1am , file = 't1am' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_t1am ) ! call generate_unit_identifier ( unit_s2am ) open ( unit_s2am , file = 's2am' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_s2am ) ! !     Write t1 amplitudes ! write ( unit_t1am ) wf % t1am ! !     Construct s2 amplitudes ! call wf % mem % alloc ( s_ia_jb , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) call wf % get_s2am ( s_ia_jb , 1 , wf % n_v ) ! !     Reorder and pack in ! call wf % mem % alloc ( s2am , ( wf % n_v ) * ( wf % n_o ) * (( wf % n_v ) * ( wf % n_o ) + 1 ) / 2 , 1 ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ai = index_two ( a , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) jb = index_two ( j , b , wf % n_o ) ! aibj = index_packed ( ai , bj ) ! s2am ( aibj , 1 ) = s_ia_jb ( ia , jb ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( s_ia_jb , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! !     Write s2 amplitudes ! write ( unit_s2am ) s2am ! call wf % mem % dealloc ( s2am , ( wf % n_v ) * ( wf % n_o ) * (( wf % n_v ) * ( wf % n_o ) + 1 ) / 2 , 1 ) ! !     Close amplitude file ! close ( unit_t1am ) close ( unit_s2am ) ! end subroutine save_amplitudes_cc2 ! ! subroutine destruct_s2am_cc2 ( wf ) !! !! implicit none ! class ( cc2 ) :: wf ! if ( allocated ( wf % s2am )) call wf % mem % dealloc ( wf % s2am , wf % n_s2am , 1 ) ! end subroutine destruct_s2am_cc2 ! subroutine read_amplitudes_cc2 ( wf ) !! !!    Read Amplitudes (CC2) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM) !! implicit none ! class ( cc2 ) :: wf ! call wf % read_single_amplitudes call wf % read_cc2_double_amplitudes ! end subroutine read_amplitudes_cc2 ! ! subroutine read_cc2_double_amplitudes_cc2 ( wf ) !! !!    Read Amplitudes (CC2) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM, S2AM) !! implicit none ! class ( cc2 ) :: wf ! integer ( i15 ) :: unit_s2am = - 1 ! logical :: file_exists = . false . ! !     Check to see whether file exists ! inquire ( file = 's2am' , exist = file_exists ) ! if ( file_exists ) then ! !        Open amplitude files if they exist ! call generate_unit_identifier ( unit_s2am ) ! open ( unit_s2am , file = 's2am' , status = 'unknown' , form = 'unformatted' ) ! rewind ( unit_s2am ) ! !        Read from file & close ! wf % n_s2am = + (( wf % n_v ) * ( wf % n_o ))& * (( wf % n_v ) * ( wf % n_o ) + 1 ) / 2 ! if (. not . allocated ( wf % s2am )) call wf % mem % alloc ( wf % s2am , wf % n_s2am , 1 ) read ( unit_s2am ) wf % s2am ! close ( unit_s2am ) ! else ! write ( unit_output , '(t3,a)' ) 'Error: amplitude files do not exist.' stop ! endif ! end subroutine read_cc2_double_amplitudes_cc2 ! end module cc2_class","tags":"","loc":"sourcefile/cc2_class.f90.html","title":"cc2_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~cc3_class.f90~~EfferentGraph sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~cc3_class.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~cc3_class.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilecc3_classf90EfferentGraph = svgPanZoom('#sourcefilecc3_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~cc3_class.f90~~AfferentGraph sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~omega_submodule.f90~3 omega_submodule.F90 sourcefile~cc3_class.f90->sourcefile~omega_submodule.f90~3 sourcefile~et_program.f90 eT_program.F90 sourcefile~cc3_class.f90->sourcefile~et_program.f90 sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules cc3_class Source Code cc3_class.F90 Source Code module cc3_class ! !! !!                           CC3 class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output ! !  Ancestor class module (CCSD) ! use ccsd_class ! implicit none ! !  ::::::::::::::::::::::::::::::::::::: !  -::- Definition of the CC3 class -::- !  ::::::::::::::::::::::::::::::::::::: ! type , extends ( ccsd ) :: cc3 ! !     No unique variables (inherits all of them from CCSD) ! contains ! !     Initialization routine ! procedure :: init => init_cc3 ! !     Routines to construct the projection vector (omega) ! procedure :: construct_omega => construct_omega_cc3 ! !     Helper routines ! procedure :: omega_integrals => omega_integrals_cc3 procedure :: calc_triples => calc_triples_cc3 ! procedure :: omega_cc3_a1 => omega_cc3_a1_cc3 ! procedure :: omega_cc3_a2 => omega_cc3_a2_cc3 procedure :: omega_cc3_b2 => omega_cc3_b2_cc3 ! end type cc3 ! !  :::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Interface to the submodule routines of CC3 -::- !  :::::::::::::::::::::::::::::::::::::::::::::::::::: ! interface ! ! module subroutine construct_omega_cc3 ( wf ) !! !!       Construct Omega (CC3) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Directs the calculation of the projection vector (omega1, omega2) !!       for the CC3 level of theory. !! implicit none ! class ( cc3 ) :: wf ! end subroutine construct_omega_cc3 ! ! module subroutine omega_integrals_cc3 ( wf ) !! !!       Omega Integrals (CC3) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Calculates g_bdck and saves to disk in the order bcd, k (one record per d and k) !!       Calculates g_ljck and saves to disk in the order lc, jk (one record per j and k) !!       Calculates g_jbkc and saves to disk in the order bc, kj (one record per k and j) !!       Calculates g_ilkc and saves to disk in the order cl, ik (one record per i and k) !!       Calculates g_dbkc and saves to disk in the order bcd, k (one record per d and k) !! implicit none ! class ( cc3 ) :: wf ! end subroutine omega_integrals_cc3 ! ! module subroutine calc_triples_cc3 ( wf , w_abc , i , j , k ) !! !!       Calculate Triples (CC3) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Calculate W_abc = P_ijk&#94;abc ( sum_d t_ij&#94;ad g_bdck - sum_l t_il&#94;ab g_ljck ) !!       and divide by orbital energy difference, t_abc = - W_abc / e_abc. On exit, !!       w_abc = t_abc, the CC3 triples amplitude t_ijk&#94;abc for a given set of occupied !!       indices i, j, and k. !! implicit none ! class ( cc3 ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 3 , 1 ) :: w_abc ! integer ( i15 ), intent ( in ) :: i , j , k ! end subroutine calc_triples_cc3 ! ! module subroutine omega_cc3_a1_cc3 ( wf , t_abc , i , j , k ) !! !!       Omega A1 (CC3) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Calculates the A1 term, !! !!          sum_bc (t_ijk&#94;abc - t_ijk&#94;cba) L_jbkc, !! !!       for a given set of i, j, and k, and adds the contribution to !!       the singles projection vector (omega1). !! implicit none ! class ( cc3 ) :: wf ! real ( dp ), dimension (( wf % n_v ) ** 3 , 1 ) :: t_abc ! integer ( i15 ), intent ( in ) :: i , j , k ! end subroutine omega_cc3_a1_cc3 ! ! module subroutine omega_cc3_a2_cc3 ( wf , omega_ai_bj , t_abc , i , j , k ) !! !!       Omega A2 (CC3) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Calculates the A2 term, !! !!          sum_c (t_ijk&#94;abc - t_ijk&#94;cba) F_kc, !! !!       for a given set of i, j, and k, and adds the contribution to !!       the doubles projection vector (omega2), element ai_bj. !! implicit none ! class ( cc3 ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: omega_ai_bj real ( dp ), dimension (( wf % n_v ) ** 3 , 1 ) :: t_abc ! integer ( i15 ), intent ( in ) :: i , j , k ! end subroutine omega_cc3_a2_cc3 ! ! module subroutine omega_cc3_b2_cc3 ( wf , omega_ai_bj , t_abc , i , j , k ) !! !!       Omega B2 (CC3) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Calculates the B2 term, !! !!          omega(al,bj) = - sum_c  (2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb) g_ilkc !!          omega(ai,dj) = + sum_bc (2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb) g_dbkc !! !!       for a given set of i, j, and k, and adds the contribution to !!       the doubles projection vector (omega2). !! implicit none ! class ( cc3 ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) :: omega_ai_bj real ( dp ), dimension (( wf % n_v ) ** 3 , 1 ) :: t_abc ! integer ( i15 ), intent ( in ) :: i , j , k ! end subroutine omega_cc3_b2_cc3 ! ! end interface ! ! contains ! ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::-       Initialization routine       -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! ! subroutine init_cc3 ( wf ) !! !!    Initialize CC3 object !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Performs the following tasks: !! !!       1. Sets HF orbital and energy information by reading from file (read_hf_info) !!       2. Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky) !!       3. Allocates the Fock matrix and sets it to zero !!       4. Initializes the amplitudes (sets their initial values and associated variables) !! !!    Note: this routine does not calculate the energy, which is postponed until the wavefunction !!    is passed to the ground-state solver. !! implicit none ! class ( cc3 ) :: wf ! integer ( i15 ) :: unit_input = - 1 ! !     Set model name ! wf % name = 'CC3' !     Open input file eT.inp ! call generate_unit_identifier ( unit_input ) open ( unit = unit_input , file = 'eT.inp' , status = 'old' , form = 'formatted' ) rewind ( unit_input ) ! !     Read general specifications (memory and diskspace for calculation) ! call wf % general_specs_reader ( unit_input ) ! !     Set implemented methods ! wf % implemented % ground_state = . true . ! !     Read calculation tasks from input file eT.inp ! call wf % calculation_reader ( unit_input ) ! !     Close input file ! close ( unit_input ) ! !     Read Hartree-Fock info from SIRIUS ! call wf % read_hf_info ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize (singles and doubles) amplitudes ! wf % n_t1am = ( wf % n_o ) * ( wf % n_v ) wf % n_t2am = ( wf % n_t1am ) * ( wf % n_t1am + 1 ) / 2 ! wf % n_parameters = wf % n_t1am + wf % n_t2am ! !     Initialize the Fock matrix (allocate and construct given the initial amplitudes) ! if (. not . allocated ( wf % t1am )) call wf % mem % alloc ( wf % t1am , wf % n_v , wf % n_o ) wf % t1am = zero ! call wf % initialize_fock_matrix ! end subroutine init_cc3 ! ! end module cc3_class","tags":"","loc":"sourcefile/cc3_class.f90.html","title":"cc3_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~mlcc2_class.f90~~EfferentGraph sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlcc_calculation_settings_class.f90 mlcc_calculation_settings_class.F90 sourcefile~mlcc_calculation_settings_class.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~mlcc2_class.f90 sourcefile~types.f90->sourcefile~mlcc_calculation_settings_class.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~mlcc_orbitals_class.f90 mlcc_orbitals_class.F90 sourcefile~types.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~input_reader.f90 input_reader.F90 sourcefile~types.f90->sourcefile~input_reader.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~workspace.f90->sourcefile~mlcc2_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~input_reader.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccs_class.f90->sourcefile~mlcc2_class.f90 sourcefile~mlcc_orbitals_class.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~mlcc2_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~mlcc2_class.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~input_reader.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc2_class.f90 sourcefile~input_reader.f90->sourcefile~mlcc_orbitals_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefilemlcc2_classf90EfferentGraph = svgPanZoom('#sourcefilemlcc2_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~mlcc2_class.f90~~AfferentGraph sourcefile~mlcc2_class.f90 mlcc2_class.F90 sourcefile~mlccsd_class.f90 mlccsd_class.F90 sourcefile~mlcc2_class.f90->sourcefile~mlccsd_class.f90 sourcefile~orbital_partitioning_submodule.f90 orbital_partitioning_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~orbital_partitioning_submodule.f90 sourcefile~omega_submodule.f90 omega_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~omega_submodule.f90 sourcefile~input_reader_submodule.f90 input_reader_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~input_reader_submodule.f90 sourcefile~excited_state_submodule.f90 excited_state_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~excited_state_submodule.f90 sourcefile~et_program.f90 eT_program.F90 sourcefile~mlcc2_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90 jacobian_submodule.F90 sourcefile~mlcc2_class.f90->sourcefile~jacobian_submodule.f90 sourcefile~mlccsd_class.f90->sourcefile~et_program.f90 sourcefile~jacobian_submodule.f90~2 jacobian_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~jacobian_submodule.f90~2 sourcefile~omega_submodule.f90~2 omega_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~omega_submodule.f90~2 sourcefile~ground_state_submodule.f90 ground_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~ground_state_submodule.f90 sourcefile~cholesky_submodule.f90 cholesky_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~cholesky_submodule.f90 sourcefile~excited_state_submodule.f90~2 excited_state_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~excited_state_submodule.f90~2 sourcefile~input_reader_submodule.f90~2 input_reader_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~input_reader_submodule.f90~2 sourcefile~orbital_partitioning_submodule.f90~2 orbital_partitioning_submodule.F90 sourcefile~mlccsd_class.f90->sourcefile~orbital_partitioning_submodule.f90~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules mlcc2_class Source Code mlcc2_class.F90 Source Code module mlcc2_class ! !! !!                 Multi-level CC2 (MLCC2) class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output use input_reader use mlcc_orbitals_class use mlcc_calculation_settings_class ! !  The ancestor class module (CCS) ! use ccs_class ! implicit none ! !  ::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the MLCC2 class -::- !  ::::::::::::::::::::::::::::::::::::::: ! type , extends ( ccs ) :: mlcc2 ! !     ML variables ! type ( mlcc_calculation_settings ) :: mlcc_settings ! integer ( i15 ) :: n_CCS_o = 0 integer ( i15 ) :: n_CCS_v = 0 ! integer ( i15 ) :: first_CCS_o = 0 integer ( i15 ) :: first_CCS_v = 0 ! integer ( i15 ) :: n_CC2_o = 0 integer ( i15 ) :: n_CC2_v = 0 ! integer ( i15 ) :: first_CC2_o = 0 integer ( i15 ) :: first_CC2_v = 0 ! type ( mlcc_orbitals ) :: CC2_orbitals ! !     Excited state variables ! integer ( i15 ) :: n_x2am = 0 real ( dp ), dimension (:,:), allocatable :: x2am ! contains ! !     Reading eT.inp ! procedure :: mlcc_reader => mlcc_reader_mlcc2 procedure :: read_orbital_info => read_orbital_info_mlcc2 ! !     Initialization and driver routines ! procedure :: init => init_mlcc2 ! !     Orbital partitioning ! procedure :: orbital_partitioning => orbital_partitioning_mlcc2 procedure :: cholesky_decomposition => cholesky_decomposition_mlcc2 procedure :: cholesky_localization_drv => cholesky_localization_drv_mlcc2 procedure :: cholesky_orbitals => cholesky_orbitals_mlcc2 procedure :: cholesky_orbital_constructor => cholesky_orbital_constructor_mlcc2 ! procedure :: cnto_orbital_drv => cnto_orbital_drv_mlcc2 procedure :: cc2_cnto_lower_level_method => cc2_cnto_lower_level_method_mlcc2 procedure :: cc2_cnto_orbitals => cc2_cnto_orbitals_mlcc2 procedure :: print_orbital_info => print_orbital_info_mlcc2 ! !     ML helper routines ! procedure :: get_CC2_active_indices => get_CC2_active_indices_mlcc2 procedure :: get_CC2_n_active => get_CC2_n_active_mlcc2 ! !     Amplitude routines ! procedure :: save_amplitudes => save_amplitudes_mlcc2 procedure :: read_amplitudes => read_amplitudes_mlcc2 procedure :: read_cc2_double_amplitudes => read_cc2_double_amplitudes_mlcc2 procedure :: destruct_x2am => destruct_x2am_mlcc2 ! !     Omega ! procedure :: omega_mlcc2_a1 => omega_mlcc2_a1_mlcc2 procedure :: omega_mlcc2_b1 => omega_mlcc2_b1_mlcc2 procedure :: construct_omega => construct_omega_mlcc2 procedure :: get_s2am => get_s2am_mlcc2 ! !     Ground state energy calculation ! procedure :: calc_energy => calc_energy_mlcc2 ! !     Excited states ! procedure :: excited_state_preparations => excited_state_preparations_mlcc2 procedure :: initialize_excited_states => initialize_excited_states_mlcc2 procedure :: calculate_orbital_differences => calculate_orbital_differences_mlcc2 procedure :: transform_trial_vectors => transform_trial_vectors_mlcc2 procedure :: cvs_residual_projection => cvs_residual_projection_mlcc2 ! procedure :: analyze_double_excitation_vector => analyze_double_excitation_vector_mlcc2 procedure :: summary_excited_state_info => summary_excited_state_info_mlcc2 ! procedure :: print_excitation_vector => print_excitation_vector_mlcc2 ! !     Jacobian ! procedure :: jacobian_mlcc2_transformation => jacobian_mlcc2_transformation_mlcc2 ! procedure :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_mlcc2 ! procedure :: jacobian_mlcc2_a1 => jacobian_mlcc2_a1_mlcc2 procedure :: jacobian_mlcc2_b1 => jacobian_mlcc2_b1_mlcc2 procedure :: jacobian_mlcc2_a2 => jacobian_mlcc2_a2_mlcc2 procedure :: jacobian_mlcc2_b2 => jacobian_mlcc2_b2_mlcc2 ! end type mlcc2 ! ! interface ! !     -::- Input reader submodule interface -::- !     :::::::::::::::::::::::::::::::::::::::::: ! module subroutine mlcc_reader_mlcc2 ( wf , unit_input ) !! !! !! implicit none ! integer ( i15 ) :: unit_input ! class ( mlcc2 ) :: wf ! end subroutine mlcc_reader_mlcc2 ! ! module subroutine read_orbital_info_mlcc2 ( wf , unit_input ) !! !! implicit none ! integer ( i15 ) :: unit_input ! class ( mlcc2 ) :: wf ! end subroutine read_orbital_info_mlcc2 ! ! end interface ! ! interface ! !     -::- Orbital partitioning submodule interface -::- !     :::::::::::::::::::::::::::::::::::::::::::::::::: ! module subroutine orbital_partitioning_mlcc2 ( wf ) !! !!       Orbital partitioning, !!       Written by Sarai D. Folkestad, June 2017 !! !!       Directs the partitioning for mlcc calculations. !! !!       So far only Cholesky decomposition is available. !! implicit none ! class ( mlcc2 ) :: wf ! end subroutine orbital_partitioning_mlcc2 ! ! module subroutine cholesky_localization_drv_mlcc2 ( wf ) !! !!       Cholesky orbital localization. driver, !!       Written by Sarai D. Folkestad, June 2017 !! !!       Driver for Cholesky density decomposition. !! !!       - Collects atom and ao-basis information. !!       - Constructs occupied and vacant densities. !!       - Constructs AO Fock matrix.  (This is currently an N&#94;5 operation, should be optimized/removed) !!       - By looping over active spaces, the occupied and virtual densities are Cholesky decomposed !!         and the cholesky vectors are used to generate new localized MO's. !!       - New orbitals are tested for orthonormality (Not implemented yet, only need overlap matrix from DALTON) !! !! implicit none ! class ( mlcc2 ) :: wf ! end subroutine cholesky_localization_drv_mlcc2 ! ! ! module subroutine cholesky_decomposition_mlcc2 ( wf , density , cholesky_vectors ,& n_vectors , selection , n_active_aos , active_ao_index_list ) !! !!       Cholesky decomposition, !!       Written by Sarai dery Folkestad, June 2017. !! !!       Cholesky decomposes the density (occupied/virtual). !!       Pivoting elements are chosen according to the active ao-list if it is pressent. !!       If not, maximum diagonal elements are chosen as pivoting elements. !! !!       The Cholesky vectors are subtracted from the incoming density matrix, and the returned density can be furteh decomposed !!       for inactive region. !! implicit none ! class ( mlcc2 ) :: wf integer ( i15 ) :: n_active_aos integer ( i15 ) :: n_vectors real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: density real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: cholesky_vectors logical :: selection integer ( i15 ), dimension ( n_active_aos , 1 ), optional :: active_ao_index_list ! end subroutine cholesky_decomposition_mlcc2 ! ! module subroutine cholesky_orbitals_mlcc2 ( wf , cholesky_vectors , n_vectors , orbitals , orbital_energies , ao_fock ) !! !!       Cholesky orbitals, !!       Written by Sarai Dery Folkestad, June 2017 !! !!       Makes the new MO's fromthe Cholesky vectors !!       - Transforms the AO fock matrix by the Cholesky vectors !!       - Diagonalize the MO fock to get orbital energies and new orbitals. !! implicit none ! class ( mlcc2 ) :: wf real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: cholesky_vectors real ( dp ), dimension ( wf % n_ao , n_vectors ) :: orbitals real ( dp ), dimension ( n_vectors , 1 ) :: orbital_energies integer ( i15 ) :: n_vectors real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: ao_fock ! end subroutine cholesky_orbitals_mlcc2 ! module subroutine cholesky_orbital_constructor_mlcc2 ( wf , orbitals , orbital_energies , offset , ao_fock , density , n_vectors ,& selection , n_active_aos , active_ao_index_list ) !! !!       Cholesky orbital constructor, !!       Written by Sarai Dery Folkestad, June 2017 !! !!       Constructs new localized orbitals (occupied/virtual) by !!       - Decomposing the density (occupied/virual) !!       - Transforming Fock matrix with Cholesky vectors, and diagonalizing it. !!         New orbitals are eigenvectors, orbital energies are eigenvectors. !! implicit none ! class ( mlcc2 ) :: wf real ( dp ), dimension ( wf % n_ao , wf % n_mo ) :: orbitals real ( dp ), dimension ( wf % n_mo , 1 ) :: orbital_energies real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: ao_fock integer ( i15 ) :: n_active_aos , offset integer ( i15 ) :: n_vectors real ( dp ), dimension ( wf % n_ao , wf % n_ao ) :: density logical :: selection integer ( i15 ), dimension ( n_active_aos , 1 ), optional :: active_ao_index_list ! end subroutine cholesky_orbital_constructor_mlcc2 ! ! module subroutine construct_active_ao_index_list ( active_ao_index_list , n_active_aos , active_atoms , & n_active_atoms , ao_center_info , n_ao ) !! !!       Construct active ao index list, !!       Written by Sarai Dery Folkestad, June 2017. !! !!       Constructs list of active ao's for cholesky decomposition. !! implicit none ! integer ( i15 ) :: n_active_aos integer ( i15 ) :: n_active_atoms integer ( i15 ) :: n_ao integer ( i15 ), dimension ( n_active_aos , 1 ) :: active_ao_index_list integer ( i15 ), dimension ( n_active_atoms , 1 ) :: active_atoms integer ( i15 ), dimension ( n_ao , 2 ) :: ao_center_info ! end subroutine construct_active_ao_index_list ! ! module subroutine cnto_orbital_drv_mlcc2 ( wf ) !! !!       CNTO orbital driver, !!       Written by Sarai D. Folkestad, June 2017. !! !!       Directs the construction of CNTOs and the selection of the active space !!       A CCS calculation ground state and excited states is performed. !!       The M and N matrices are then constructed, !! !!          M_ij = 1/n sum_{k=1,n} (sum_a R&#94;k_ai*R1_aj) !!          N_ab = 1/n sum_{k=1,n} (sum_i R&#94;k_ai*R1_bi) !! !!       where n > 1. !! !!       Ri_ai is the i'th single excitation vector obtained from the CCS calculation. !!       The transformation matrices for the occupied and virtual part !!       are constructed by diagonalizing M and N. The number of active occupied !!       and virtual orbitals are determined from δ_o and δ_v !! !!          1 - sum_i λ&#94;o_i < δ_o !!          1 - sum_i λ&#94;v_i < δ_v !! !!       Where the orbitals of highest eigenvalues λ&#94;o/λ&#94;v are selected first. !! !!       Fock matrix is block diagonalized in active and inactive blocks in order to obtain !!       the orbitals and orbital energies used in the CC2 calculation. !! implicit none ! class ( mlcc2 ) :: wf ! end subroutine cnto_orbital_drv_mlcc2 ! ! module subroutine cc2_cnto_lower_level_method_mlcc2 ( wf ) !! !!       CNTO lower level calculation (MLCC2), !!       Written by Sarai D. Folkestad, June 2017. !! !!       Runs lower level method for CNTOs !! implicit none ! class ( mlcc2 ) :: wf ! end subroutine cc2_cnto_lower_level_method_mlcc2 ! ! module subroutine cc2_cnto_orbitals_mlcc2 ( wf ) !! !!       CNTO Oritals (MLCC2), !!       Written by Sarai D. Folkestad Aug. 2017 !! !!       Constructs the CNTO orbitals based on exitation vectors from lower level method !! implicit none ! class ( mlcc2 ) :: wf ! end subroutine cc2_cnto_orbitals_mlcc2 ! ! module subroutine print_orbital_info_mlcc2 ( wf ) !! !!       Print CNTO info, !!       Written by Sarai D. Folkestad, Aug. 2017 !! !!       Prints information on CNTO partitioning !! implicit none ! class ( mlcc2 ) :: wf ! end subroutine print_orbital_info_mlcc2 ! ! end interface ! ! interface ! !     -::- Omega submodule interface -::- !     ::::::::::::::::::::::::::::::::::: ! module subroutine omega_mlcc2_a1_mlcc2 ( wf ) !! !!       Omega A1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       Calculates the A1 term of omega, !! !!       A1: sum_ckd g_adkc * u_ki&#94;cd, !! !!       and adds it to the projection vector (omega1) of !!       the wavefunction object wf !! !!       u_ki&#94;cd = 2*s_ki&#94;cd - s_ik&#94;cd !! implicit none ! class ( mlcc2 ) :: wf ! end subroutine omega_mlcc2_a1_mlcc2 ! ! module subroutine omega_mlcc2_b1_mlcc2 ( wf ) !! !!       Omega B1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       Calculates the B1 term of omega, !! !!       B1: - sum_bjk u_jk&#94;ab*g_jikb !! implicit none ! class ( mlcc2 ) :: wf end subroutine omega_mlcc2_b1_mlcc2 ! ! module subroutine construct_omega_mlcc2 ( wf ) !! !!       Construct Omega (CC2) !!       Written by Eirik F. Kjønstad and Sarai Folkestad, Apr 2017 !! !!       Constructs t2-amplitudes on the fly, according to the CC2 !!       expression for the doubles amplitudes, !! !!       t_ij&#94;ab = - g_ai_bj / (e_a + e_b - e_i - e_j), !! !!       where g_ai_bj are T1-transformed two-electron integrals !!       and e_x is the orbital enegy of orbital x. !! !!       The routine also sets up timing variables. !! implicit none ! class ( mlcc2 ) :: wf ! end subroutine construct_omega_mlcc2 ! module subroutine get_s2am_mlcc2 ( wf , s_ai_bj , b_first , b_length ) !! !!       Get S_2 amplitudes, !!       Written by Sarai D. Folkestad, July 2017 !! !!       Construct !! !!          s_ai_bj = - 1/ε_ij&#94;ab * g_aibj, !! !!       while batching over b. !! implicit none ! class ( mlcc2 ) :: wf ! integer ( i15 ) :: b_first , b_length real ( dp ), dimension (( wf % n_CC2_v ) * ( wf % n_CC2_o ), b_length * ( wf % n_CC2_o )) :: s_ai_bj ! end subroutine get_s2am_mlcc2 ! ! end interface ! ! interface ! !     -::- Excited state submodule interface -::- !     ::::::::::::::::::::::::::::::::::::::::::: ! ! module subroutine excited_state_preparations_mlcc2 ( wf ) !! !!       Excited State Preparations (MLCC2) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017 !! !!       A routine for preparation tasks (if any). Can be overwritten !!       in descendants if other preparations prove necessary. !! class ( mlcc2 ) :: wf ! !        Do nothing for mlcc2 ! end subroutine excited_state_preparations_mlcc2 ! module subroutine initialize_excited_states_mlcc2 ( wf ) !! !!       Initialize excited states !!       Written by Sarai D. Folkestad, June 2017 !! !!       Calculates and sets n_s2am, and updates n_parameters !!       for excited state calculation !! implicit none ! class ( mlcc2 ) :: wf ! end subroutine initialize_excited_states_mlcc2 ! ! module subroutine calculate_orbital_differences_mlcc2 ( wf , orbital_diff ) !! !!       Calculate Orbital Differences (CCSD) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad May 2017 !! !!       Calculates orbital differences !! !!          1) ε_I&#94;A = ε_A - ε_I !!          2) ε_ij&#94;ab = ε_a + ε_b - ε_i - ε_j (for active spaces only) !! !!       and puts them in orbital_diff, which is a vector of length n_parameters. !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: orbital_diff ! end subroutine calculate_orbital_differences_mlcc2 ! ! module subroutine transform_trial_vectors_mlcc2 ( wf , first_trial , last_trial ) !! !!       Transformation Trial Vectors (MLCC2) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!       Each trial vector in first_trial to last_trial is read from file and !!       transformed before the transformed vector is written to file. !! !!       Singles and doubles part of the transformed vectors are written to !!       the same record in file transformed_vec, record length is n_parameters long. !! implicit none ! class ( mlcc2 ) :: wf ! integer ( i15 ), intent ( in ) :: first_trial , last_trial ! Which trial_vectors we are to transform ! end subroutine transform_trial_vectors_mlcc2 ! ! module subroutine cvs_residual_projection_mlcc2 ( wf , residual ) !! !!       Residual projection (MLCC2), !!       Written by Sarai D. Folkestad Aug. 2017 !! implicit none ! class ( mlcc2 ) :: wf real ( dp ), dimension ( wf % n_parameters , 1 ) :: residual ! end subroutine cvs_residual_projection_mlcc2 ! ! module subroutine print_excitation_vector_mlcc2 ( wf , vec , unit_id ) !! !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension ( wf % n_parameters , 1 ) :: vec ! integer ( i15 ) :: unit_id ! end subroutine print_excitation_vector_mlcc2 ! ! module subroutine analyze_double_excitation_vector_mlcc2 ( wf , vec , n , sorted_short_vec , index_list ) !! !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension ( wf % n_x2am , 1 ) :: vec ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , b = 0 , j = 0 , bj = 0 , aibj = 0 , k = 0 ! integer ( i15 ) :: n ! Number of elements wanted ! real ( dp ), dimension ( n , 1 ) :: sorted_short_vec ! integer ( i15 ), dimension ( n , 4 ) :: index_list ! end subroutine analyze_double_excitation_vector_mlcc2 ! ! module subroutine summary_excited_state_info_mlcc2 ( wf , energies ) !! !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension ( wf % excited_state_specifications % n_singlet_states , 1 ) :: energies ! end subroutine summary_excited_state_info_mlcc2 ! ! end interface ! ! interface ! !     -::- Jacobian transformation submodule -::- !     ::::::::::::::::::::::::::::::::::::::::::: ! module subroutine jacobian_mlcc2_transformation_mlcc2 ( wf , c_a_i , c_aibj ) !! !!       Jacobian transformation (MLCC2) !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Directs the transformation by the CCSD Jacobi matrix, !! !!          A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >, !! !!       where the basis employed for the brackets is biorthonormal. !!       The transformation is rho = A c, i.e., !! !!          rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck !!                  + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl). !! !!       On exit, c is overwritten by rho. That is, c_a_i = rho_a_i, !!       and c_aibj = rho_aibj. !! implicit none ! class ( mlcc2 ) :: wf ! !        Incoming vector c ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! c_ai real ( dp ), dimension ( wf % n_x2am , 1 ) :: c_aibj ! c_aibj ! end subroutine jacobian_mlcc2_transformation_mlcc2 ! ! module subroutine jacobian_mlcc2_a1_mlcc2 ( wf , rho_a_i , c_a_i ) !! !!       Jacobian tem A1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Calculates the A1 contribution to the jacobi transformation, !! !!          A1: 2*sum_BJck u_ik&#94;ac*g_kc,JB*c_BJ - sum_Bjck u_kj&#94;ca*g_kc,jB*c_BI !!            - sum_BJck u_ik&#94;ac*g_kB,Jc*c_BJ - sum_bJck u_ki&#94;cb*g_kc,Jb*c_AJ, !! !!       with, !! !!       u_ik&#94;ac = 2*s_ik&#94;ac - 2*s_ik&#94;ca, !! !!       which is constructed while batching over c !! implicit none ! class ( mlcc2 ) :: wf ! !        Incoming vectors c and rho ! real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! end subroutine jacobian_mlcc2_a1_mlcc2 ! ! module subroutine jacobian_mlcc2_b1_mlcc2 ( wf , rho_a_i , c_ai_bj ) !! !!       Jacobian tem B1 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Calculates the B1 contribution to the jacobi transformation, !! !!       B1:   sum_ck F_kc*(2c_ai,ck - c_ak,ci) !!           - sum_ckj L_jIkc * c_aj,ck + sum_cbk L_Abkc * c_bi,ck !! !! !!       L_Abkc is constructed while batching over A. !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension (:,:) :: c_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: rho_a_i ! end subroutine jacobian_mlcc2_b1_mlcc2 ! ! module subroutine jacobian_mlcc2_a2_mlcc2 ( wf , rho_ai_bj , c_a_i ) !! !!       Jacobian tem A2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Calculates the A2 contribution to the jacobi transformation, !! !!          A2:   sum_C g_ai,bC * c_Cj - sum_K g_ai,Kj * C_bK. !! !!       g_ai,bC is constructed in batches of C. !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension (:,:) :: rho_ai_bj real ( dp ), dimension ( wf % n_v , wf % n_o ) :: c_a_i ! end subroutine jacobian_mlcc2_a2_mlcc2 ! ! module subroutine jacobian_mlcc2_b2_mlcc2 ( wf , rho_ai_bj , c_ai_bj ) !! !!       Jacobian tem B2 !!       Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 !! !!       Calculates the B2 contribution to the jacobi transformation, !! !!          B2:   ε_ij&#94;ab*c_ai,bj. !! !! implicit none ! class ( mlcc2 ) :: wf ! real ( dp ), dimension (:,:) :: c_ai_bj real ( dp ), dimension (:,:) :: rho_ai_bj ! ! end subroutine jacobian_mlcc2_b2_mlcc2 ! ! module subroutine cvs_rho_aibj_projection_mlcc2 ( wf , vec_aibj ) !! !!       Rho projection for CVS (MLCC2), !!       Written by Sarai D. Folkestad, Aug. 2017 !! implicit none ! class ( mlcc2 ) :: wf real ( dp ), dimension (:, :) :: vec_aibj ! end subroutine cvs_rho_aibj_projection_mlcc2 ! ! end interface ! ! contains ! !  -::- MLCC2 initialization routine -::- !  :::::::::::::::::::::::::::::::::::::: ! subroutine init_mlcc2 ( wf ) !! !! implicit none ! class ( mlcc2 ) :: wf ! integer ( i15 ) :: i , j ! integer ( i15 ) :: unit_input = - 1 ! write ( unit_output , '(//t3,a/)' ) ':: Initialization' ! ! !     Set model name ! wf % name = 'MLCC2' ! !     Open input file eT.inp ! call generate_unit_identifier ( unit_input ) open ( unit = unit_input , file = 'eT.inp' , status = 'old' , form = 'formatted' ) rewind ( unit_input ) ! !     Read general specifications (memory and diskspace for calculation) ! call wf % general_specs_reader ( unit_input ) ! !     Read MLCC info ! call wf % mlcc_reader ( unit_input ) ! !     MLCC sanity check ! if ( wf % mlcc_settings % CC3 . or . wf % mlcc_settings % CCSD ) then write ( unit_output , * ) 'WARNING: CC3 and CCSD active spaces not available for MLCC2' stop endif ! !     Set implemented methods ! wf % implemented % ground_state = . true . wf % implemented % excited_state = . true . wf % implemented % core_excited_state = . true . ! !     Read calculation tasks from input file eT.inp ! call wf % calculation_reader ( unit_input ) ! !     Read orbital info ! call wf % read_orbital_info ( unit_input ) ! !     Close input file ! close ( unit_input ) ! !     Read Hartree-Fock info ! call wf % read_hf_info ! !     Orbital partitioning - only if we have CCS region ! if ( wf % mlcc_settings % CCS ) then ! call wf % orbital_partitioning ! else ! !        Do full space CC2 calculation ! write ( unit_output , '(/t3,a50/)' ) 'Full CC2 requested, orbital partitioning skipped.' ! wf % n_CC2_o = wf % n_o wf % n_CC2_v = wf % n_v ! wf % first_CC2_o = 1 wf % first_CC2_v = 1 ! endif ! !     Initialize amplitudes and associated attributes ! call wf % initialize_amplitudes call wf % initialize_omega ! !     Set the number of parameters in the wavefunction !     (that are solved for in the ground and excited state solvers) ! wf % n_parameters = wf % n_t1am ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize fock matrix ! call wf % initialize_fock_matrix ! end subroutine init_mlcc2 ! ! !  ::::::::::::::::::::::::::::::::::::::::: !  -::- Class subroutines and functions -::- !  ::::::::::::::::::::::::::::::::::::::::: ! !  -::- Energy routine -::- !  :::::::::::::::::::::::: ! subroutine calc_energy_mlcc2 ( wf ) !! !!    Calculate Energy (MLCC2) !! !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!    Calculates the MLCC2 energy, !! !!    E_CC2 = E_HF + sum_aibj L_iajb*(s_ij&#94;ab + t_i&#94;a*t_j&#94;b), !! !!    with s_ij&#94;ab = - g_aibj/(e_a + e_b - e_i - e_j) where !!    g_aibj are T1-transformed integrals. !!    Batching over a. !! !! implicit none ! class ( mlcc2 ) :: wf ! logical :: debug = . false . ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: L_IA_J real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: g_IA_JB ! = g_aibj ! !     s2 amplitudes ! real ( dp ), dimension (:,:), allocatable :: s_ia_jb ! = g_aibj/(e_a + e_b - e_i - e_j) ! !     Batching variables ! integer ( i15 ) :: a_batch , a_first , a_last , a_length integer ( i15 ) :: required , available , n_batch , batch_dimension , max_batch_length , offset ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: ai = 0 , bj = 0 integer ( i15 ) :: ia = 0 , ib = 0 , jb = 0 , ja = 0 integer ( i15 ) :: IA_full = 0 , IB_full = 0 , JB_full = 0 , JA_full = 0 ! integer ( i15 ) :: aibj = 0 ! !     ML variables ! integer ( i15 ) :: n_active_o = 0 , n_active_v = 0 integer ( i15 ) :: first_active_o ! first active occupied index integer ( i15 ) :: first_active_v ! first active virtual index integer ( i15 ) :: last_active_o ! first active occupied index integer ( i15 ) :: last_active_v ! first active virtual index ! ! !     :: t1 contribution :: ! !     sum_aibj t_ai*t_bj*L_ia_jb ! ! !     Allocate the Cholesky vector L_ia_J = L_ia&#94;J and set to zero ! call wf % mem % alloc ( L_IA_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_IA_J = zero ! !     Get the Cholesky vector L_ia_J ! call wf % get_cholesky_ia ( L_IA_J ) ! !     Allocate g_ia_jb = g_iajb and set it to zero ! call wf % mem % alloc ( g_IA_JB , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_IA_JB = zero ! !     Calculate the integrals g_ia_jb from the Cholesky vector L_ia_J ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_IA_J , & ( wf % n_o ) * ( wf % n_v ), & L_IA_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_IA_JB , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate the Cholesky vector L_ia_J ! call wf % mem % dealloc ( L_IA_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Set the initial value of the energy ! wf % energy = wf % scf_energy ! ! !     Add the correlation energy E = E + sum_aibj (t_ij&#94;ab + t_i&#94;a t_j&#94;b) L_iajb ! do I = 1 , wf % n_o do A = 1 , wf % n_v ! IA = index_two ( I , A , wf % n_o ) ! do J = 1 , wf % n_o ! JA = index_two ( J , A , wf % n_o ) ! do B = 1 , wf % n_v ! JB = index_two ( J , B , wf % n_o ) IB = index_two ( I , B , wf % n_o ) ! !                 Add the correlation energy ! wf % energy = wf % energy & + ( two * g_IA_JB ( IA , JB ) - g_IA_JB ( JA , IB )) * ( wf % t1am ( A , I )) * ( wf % t1am ( B , J )) ! enddo enddo enddo enddo ! !     :: s2 contribution :: ! !     sum_aibj s_ai_bj*L_ia_jb ! !     Set ML variables ! call wf % get_CC2_active_indices ( first_active_o , first_active_v ) ! call wf % get_CC2_n_active ( n_active_o , n_active_v ) ! last_active_o = first_active_o + n_active_o - 1 last_active_v = first_active_v + n_active_v - 1 ! !     Prepare for batching over index a ! required = ( 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ) & ! Needed for g_aibj + 2 * (( wf % n_v ) ** 2 ) * ( wf % n_J ) & ! and 's2' amplitudes + 2 * ( wf % n_v ) ** 2 * ( wf % n_o ) ** 2 ) ! ! required = 4 * required ! In words available = get_available () ! batch_dimension = n_active_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_first , a_last , a_batch , max_batch_length , batch_dimension ) ! !        a is active index, and thus a_first and a_last must be displaced ! a_first = a_first + ( first_active_v - 1 ) a_last = a_last + ( first_active_v - 1 ) ! if ( a_last . gt . last_active_v ) a_last = last_active_v ! a_length = a_last - a_first + 1 !        :: Calculate cc2 doubles amplitudes :: ! call wf % mem % alloc ( L_ai_J , n_active_o * n_active_v , wf % n_J ) L_ai_J = zero ! call wf % get_cholesky_ai ( L_ai_J , first_active_v , last_active_v , first_active_o , last_active_o ) ! call wf % mem % alloc ( L_ia_J , ( n_active_o ) * ( n_active_v ), wf % n_J ) ! !        reorder and constrain L_bi_J ! do a = 1 , n_active_v do i = 1 , n_active_o ! ia = index_two ( i , a , n_active_o ) ai = index_two ( a , i , n_active_v ) ! do J = 1 , wf % n_J ! L_ia_J ( ia , J ) = L_ai_J ( ai , J ) ! enddo enddo enddo ! call wf % mem % dealloc ( L_ai_J , n_active_o * n_active_v , wf % n_J ) ! call wf % mem % alloc ( s_ia_jb , ( n_active_o ) * a_length , ( n_active_o ) * n_active_v ) ! offset = index_two ( 1 , a_first , n_active_o ) ! call dgemm ( 'N' , 'T' , & ( n_active_o ) * a_length , & ( n_active_o ) * ( n_active_v ), & ( wf % n_J ), & one , & L_ia_J ( offset , 1 ), & ( n_active_o ) * ( n_active_v ), & L_ia_J , & ( n_active_o ) * ( n_active_v ), & zero , & s_ia_jb , & ( n_active_o ) * a_length ) ! ! call wf % mem % dealloc ( L_ia_J , ( n_active_o ) * ( n_active_v ), wf % n_J ) ! !        Add the rest of the correlation energy E = E + sum_aibj (s_ij&#94;ab ) L_iajb ! do a = 1 , a_length do i = 1 , n_active_o ! ia = index_two ( i , a , n_active_o ) IA_full = index_two ( i + first_active_o - 1 , a + a_first - 1 , wf % n_o ) ! do b = 1 , n_active_v ! IB_full = index_two ( i + first_active_o - 1 , b + first_active_v - 1 , wf % n_o ) ! do j = 1 , n_active_o ! jb = index_two ( j , b , n_active_o ) JB_full = index_two ( j + first_active_o - 1 , b + first_active_v - 1 , wf % n_o ) JA_full = index_two ( j + first_active_o - 1 , a + a_first - 1 , wf % n_o ) ! wf % energy = wf % energy + ( two * g_ia_jb ( IA_full , JB_full ) - g_ia_jb ( JA_full , IB_full )) * (( s_ia_jb ( ia , jb ))& / ( wf % fock_diagonal ( i + first_active_o - 1 , 1 )& + wf % fock_diagonal ( j + first_active_o - 1 , 1 ) & - wf % fock_diagonal ( wf % n_o + a + a_first - 1 , 1 )& - wf % fock_diagonal ( wf % n_o + b + first_active_v - 1 , 1 ))) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( s_ia_jb , a_length * n_active_o , n_active_o * n_active_v ) ! enddo ! End of batching ! call wf % mem % dealloc ( g_ia_jb , wf % n_o * wf % n_v , wf % n_o * wf % n_v ) ! end subroutine calc_energy_mlcc2 ! !  -::- ML helper routines -::- !  :::::::::::::::::::::::::::: ! subroutine get_CC2_active_indices_mlcc2 ( wf , first_o , first_v ) !! !!    Get CC2 active indices, !!    Written by Sarai D. Folkestad, June 2017 !! !!    Returns the first active occupied and virtual indices !!    of the active space. !! implicit none ! class ( mlcc2 ) :: wf integer ( i15 ) :: first_o integer ( i15 ) :: first_v ! first_o = wf % first_CC2_o first_v = wf % first_CC2_v ! end subroutine get_CC2_active_indices_mlcc2 ! ! subroutine get_CC2_n_active_mlcc2 ( wf , n_active_o , n_active_v ) !! !!    Get CC2 active indices, !!    Written by Sarai D. Folkestad, June 2017 !! !!    Returns the first active occupied and virtual indices !!    of the active space. !! implicit none ! class ( mlcc2 ) :: wf integer ( i15 ) :: n_active_o integer ( i15 ) :: n_active_v ! n_active_o = wf % n_CC2_o n_active_v = wf % n_CC2_v ! end subroutine get_CC2_n_active_mlcc2 ! !  -::- Amplitude routines -::- !  :::::::::::::::::::::::::::: ! subroutine save_amplitudes_mlcc2 ( wf ) !! !!    Save Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Store the amplitudes to disk (T1AM) !! implicit none ! class ( mlcc2 ) :: wf ! integer ( i15 ) :: unit_x1am = - 1 integer ( i15 ) :: unit_x2am = - 1 ! real ( dp ), dimension (:,:), allocatable :: s_ai_bj real ( dp ), dimension (:,:), allocatable :: s2am ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 , ia = 0 , b = 0 , j = 0 , bj = 0 , jb = 0 integer ( i15 ) :: aibj = 0 ! !     Open amplitude files ! call generate_unit_identifier ( unit_x1am ) open ( unit_x1am , file = 't1am' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_x1am ) ! call generate_unit_identifier ( unit_x2am ) open ( unit_x2am , file = 'x2am' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_x2am ) ! !     Write t1 amplitudes ! write ( unit_x1am ) wf % t1am ! !     Construct s2 amplitudes ! call wf % mem % alloc ( s_ai_bj , ( wf % n_CC2_v ) * ( wf % n_CC2_o ), ( wf % n_CC2_v ) * ( wf % n_CC2_o )) call wf % get_s2am ( s_ai_bj , wf % first_CC2_v , wf % first_CC2_v + wf % n_CC2_v - 1 ) ! !     Reorder and pack in ! call wf % mem % alloc ( s2am , ( wf % n_CC2_v ) * ( wf % n_CC2_o ) * (( wf % n_CC2_v ) * ( wf % n_CC2_o ) + 1 ) / 2 , 1 ) ! do i = 1 , wf % n_CC2_o do a = 1 , wf % n_CC2_v ai = index_two ( a , i , wf % n_CC2_v ) do j = 1 , wf % n_CC2_o do b = 1 , wf % n_CC2_v ! bj = index_two ( b , j , wf % n_CC2_v ) ! aibj = index_packed ( ai , bj ) ! s2am ( aibj , 1 ) = s_ai_bj ( ai , bj ) ! enddo enddo enddo enddo ! call wf % mem % dealloc ( s_ai_bj , ( wf % n_CC2_v ) * ( wf % n_CC2_o ), ( wf % n_CC2_v ) * ( wf % n_CC2_o )) ! !     Write s2 amplitudes ! write ( unit_x2am ) s2am ! call wf % mem % dealloc ( s2am , ( wf % n_CC2_v ) * ( wf % n_CC2_o ) * (( wf % n_CC2_v ) * ( wf % n_CC2_o ) + 1 ) / 2 , 1 ) ! !     Close amplitude file ! close ( unit_x1am ) close ( unit_x2am ) ! end subroutine save_amplitudes_mlcc2 ! ! subroutine read_amplitudes_mlcc2 ( wf ) !! !!    Read Amplitudes (MLCC2) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM) !! implicit none ! class ( mlcc2 ) :: wf ! call wf % read_single_amplitudes call wf % read_cc2_double_amplitudes ! end subroutine read_amplitudes_mlcc2 ! subroutine read_cc2_double_amplitudes_mlcc2 ( wf ) !! !!    Read Amplitudes (MLCC2) !!    Written by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017 !! !!    Reads the amplitudes from disk (T1AM, S2AM) !! implicit none ! class ( mlcc2 ) :: wf ! integer ( i15 ) :: unit_x2am = - 1 ! logical :: file_exists = . false . ! !     Check to see whether file exists ! inquire ( file = 'x2am' , exist = file_exists ) ! if ( file_exists ) then ! !        Open amplitude files if they exist ! call generate_unit_identifier ( unit_x2am ) ! open ( unit_x2am , file = 'x2am' , status = 'unknown' , form = 'unformatted' ) ! rewind ( unit_x2am ) ! !        Read from file & close ! wf % n_x2am = + (( wf % n_CC2_v ) * ( wf % n_CC2_o ))& * (( wf % n_CC2_v ) * ( wf % n_CC2_o ) + 1 ) / 2 ! if (. not . allocated ( wf % x2am )) call wf % mem % alloc ( wf % x2am , wf % n_x2am , 1 ) read ( unit_x2am ) wf % x2am ! close ( unit_x2am ) ! else ! write ( unit_output , '(t3,a)' ) 'Error: amplitude files do not exist.' stop ! endif ! end subroutine read_cc2_double_amplitudes_mlcc2 ! subroutine destruct_x2am_mlcc2 ( wf ) !! !! !! implicit none ! class ( mlcc2 ) :: wf ! if ( allocated ( wf % x2am )) call wf % mem % dealloc ( wf % x2am , wf % n_x2am , 1 ) ! end subroutine destruct_x2am_mlcc2 ! end module mlcc2_class","tags":"","loc":"sourcefile/mlcc2_class.f90.html","title":"mlcc2_class.F90 – The eT program"},{"text":"This File Depends On sourcefile~~ccsdpt_class.f90~~EfferentGraph sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~types.f90 types.F90 sourcefile~types.f90->sourcefile~ccsdpt_class.f90 sourcefile~cc3_class.f90 cc3_class.F90 sourcefile~types.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90 input_output.F90 sourcefile~types.f90->sourcefile~input_output.f90 sourcefile~utils.f90 utils.F90 sourcefile~types.f90->sourcefile~utils.f90 sourcefile~workspace.f90 workspace.F90 sourcefile~types.f90->sourcefile~workspace.f90 sourcefile~ccsd_class.f90 ccsd_class.F90 sourcefile~types.f90->sourcefile~ccsd_class.f90 sourcefile~ccs_class.f90 ccs_class.F90 sourcefile~types.f90->sourcefile~ccs_class.f90 sourcefile~hf_class.f90 hf_class.F90 sourcefile~types.f90->sourcefile~hf_class.f90 sourcefile~calc_tasks_class.f90 calc_tasks_class.F90 sourcefile~types.f90->sourcefile~calc_tasks_class.f90 sourcefile~response_calc_specs_class.f90 response_calc_specs_class.F90 sourcefile~types.f90->sourcefile~response_calc_specs_class.f90 sourcefile~ground_state_specs_class.f90 ground_state_specs_class.F90 sourcefile~types.f90->sourcefile~ground_state_specs_class.f90 sourcefile~memory_manager_class.f90 memory_manager_class.F90 sourcefile~types.f90->sourcefile~memory_manager_class.f90 sourcefile~calc_settings_class.f90 calc_settings_class.F90 sourcefile~types.f90->sourcefile~calc_settings_class.f90 sourcefile~core_excited_state_specs_class.f90 core_excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~core_excited_state_specs_class.f90 sourcefile~excited_state_specs_class.f90 excited_state_specs_class.F90 sourcefile~types.f90->sourcefile~excited_state_specs_class.f90 sourcefile~batching_index_class.f90 batching_index_class.F90 sourcefile~types.f90->sourcefile~batching_index_class.f90 sourcefile~cc3_class.f90->sourcefile~ccsdpt_class.f90 sourcefile~input_output.f90->sourcefile~ccsdpt_class.f90 sourcefile~input_output.f90->sourcefile~cc3_class.f90 sourcefile~input_output.f90->sourcefile~utils.f90 sourcefile~input_output.f90->sourcefile~workspace.f90 sourcefile~input_output.f90->sourcefile~ccsd_class.f90 sourcefile~input_output.f90->sourcefile~ccs_class.f90 sourcefile~input_output.f90->sourcefile~hf_class.f90 sourcefile~input_output.f90->sourcefile~memory_manager_class.f90 sourcefile~input_output.f90->sourcefile~batching_index_class.f90 sourcefile~utils.f90->sourcefile~ccsdpt_class.f90 sourcefile~utils.f90->sourcefile~cc3_class.f90 sourcefile~utils.f90->sourcefile~ccsd_class.f90 sourcefile~utils.f90->sourcefile~ccs_class.f90 sourcefile~utils.f90->sourcefile~hf_class.f90 sourcefile~workspace.f90->sourcefile~ccsdpt_class.f90 sourcefile~workspace.f90->sourcefile~cc3_class.f90 sourcefile~workspace.f90->sourcefile~utils.f90 sourcefile~workspace.f90->sourcefile~ccsd_class.f90 sourcefile~workspace.f90->sourcefile~ccs_class.f90 sourcefile~workspace.f90->sourcefile~hf_class.f90 sourcefile~ccsd_class.f90->sourcefile~cc3_class.f90 sourcefile~ccs_class.f90->sourcefile~ccsd_class.f90 sourcefile~hf_class.f90->sourcefile~ccs_class.f90 sourcefile~calc_tasks_class.f90->sourcefile~hf_class.f90 sourcefile~response_calc_specs_class.f90->sourcefile~hf_class.f90 sourcefile~ground_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~memory_manager_class.f90->sourcefile~hf_class.f90 sourcefile~calc_settings_class.f90->sourcefile~hf_class.f90 sourcefile~core_excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~excited_state_specs_class.f90->sourcefile~hf_class.f90 sourcefile~batching_index_class.f90->sourcefile~memory_manager_class.f90 var pansourcefileccsdpt_classf90EfferentGraph = svgPanZoom('#sourcefileccsdpt_classf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~ccsdpt_class.f90~~AfferentGraph sourcefile~ccsdpt_class.f90 ccsdpt_class.F90 sourcefile~omega_submodule.f90~6 omega_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~omega_submodule.f90~6 sourcefile~et_program.f90 eT_program.F90 sourcefile~ccsdpt_class.f90->sourcefile~et_program.f90 sourcefile~ground_state_submodule.f90~3 ground_state_submodule.F90 sourcefile~ccsdpt_class.f90->sourcefile~ground_state_submodule.f90~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules ccsdpt_class Source Code ccsdpt_class.F90 Source Code module ccsdpt_class ! !! !!                          CCSD(T) class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output ! !  Ancestor class module (CC3) ! use cc3_class ! implicit none ! !  ::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the CCSD(T) class -::- !  ::::::::::::::::::::::::::::::::::::::::: ! type , extends ( cc3 ) :: ccsdpt ! !     No unique variables (inherits all of them from CC3) ! contains ! !     Initialization routine ! procedure :: init => init_ccsdpt ! !     Routines to construct the projection vector (omega) ! procedure :: construct_omega => construct_omega_ccsdpt ! !     Energy correction routine ! procedure :: calc_energy_correction => calc_energy_correction_ccsdpt ! !     ... which is called before the ground state is destroyed: ! procedure :: destruct_ground_state => destruct_ground_state_ccsdpt ! end type ccsdpt ! !  :::::::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Interface to the submodule routines of CCSD(T) -::- !  :::::::::::::::::::::::::::::::::::::::::::::::::::::::: ! interface ! ! module subroutine construct_omega_ccsdpt ( wf ) !! !!       Construct Omega (CCSD(T)) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Directs the calculation of the projection vector (omega1, omega2) !!       for the CCSD(T) level of theory. This is simply the calculation of !!       the CCSD omega vector. !! implicit none ! class ( ccsdpt ) :: wf ! end subroutine construct_omega_ccsdpt ! ! module subroutine destruct_ground_state_ccsdpt ( wf ) !! !!       Destruct Ground State (CCSD(T)) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Calculates the CCSD(T) energy correction to the CCSD !!       energy, thereafter deallocating the amplitudes and the !!       projection vector. !! implicit none ! class ( ccsdpt ) :: wf ! end subroutine destruct_ground_state_ccsdpt ! ! end interface ! ! contains ! ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::-       Initialization routine       -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! ! subroutine init_ccsdpt ( wf ) !! !!    Initialize CCSD(T) object !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Performs the following tasks: !! !!       1. Sets HF orbital and energy information by reading from file (read_hf_info) !!       2. Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky) !!       3. Allocates the Fock matrix and sets it to zero !!       4. Initializes the amplitudes (sets their initial values and associated variables) !! !!    Note: this routine does not calculate the energy, which is postponed until the wavefunction !!    is passed to the ground-state solver. !! implicit none ! class ( ccsdpt ) :: wf ! integer ( i15 ) :: unit_input = - 1 ! !     Set model name ! wf % name = 'CCSD(T)' ! !     Open input file eT.inp ! call generate_unit_identifier ( unit_input ) open ( unit = unit_input , file = 'eT.inp' , status = 'old' , form = 'formatted' ) rewind ( unit_input ) ! !     Read general specifications (memory and diskspace for calculation) ! call wf % general_specs_reader ( unit_input ) ! !     Set implemented methods ! wf % implemented % ground_state = . true . ! !     Read calculation tasks from input file eT.inp ! call wf % calculation_reader ( unit_input ) ! !     Close input file ! close ( unit_input ) ! !     Read Hartree-Fock info from SIRIUS ! call wf % read_hf_info ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize (singles and doubles) amplitudes ! wf % n_t1am = ( wf % n_o ) * ( wf % n_v ) wf % n_t2am = ( wf % n_t1am ) * ( wf % n_t1am + 1 ) / 2 ! wf % n_parameters = wf % n_t1am + wf % n_t2am ! !     Initialize the Fock matrix (allocate and construct given the initial amplitudes) ! if (. not . allocated ( wf % t1am )) call wf % mem % alloc ( wf % t1am , wf % n_v , wf % n_o ) wf % t1am = zero ! call wf % initialize_fock_matrix ! end subroutine init_ccsdpt ! ! subroutine calc_energy_correction_ccsdpt ( wf ) !! !!    Calculate Energy Correction (CCSD(T)) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Calculates the CCSD(T) correction to the CCSD energy: !! !!       E(CCSD(T)) = E(CCSD) + sum_ai u_ai v_ai + sum_aibj u_ai_bj v_ai_bj, !! !!    where !! !!       v_ai    = sum_cdkl (t_ikl&#94;acd - t_lki&#94;acd) L_kcld !!       v_ai_bj = sum_cdk (t_ijk&#94;acd L_bckd - t_kji&#94;acd g_kdbc) - !!                 sum_ckl (t_ikl&#94;abc L_kjlc - t_lki&#94;abc g_kjlc) !! !!    and !! !!       u_ai    = 2 * t_i&#94;a !!       u_ai_bj = 4 t_ij&#94;ab - 2 t_ji&#94;ab. !! !!    Note: the vector v is similar to the CC3 omega vector. The !!    routine therefore relies heavily on the omega routines of !!    the parent CC3 class. !! !!    Note: as is the case for CC3 omega, this routine (in particular !!    the i >= j >= k saving) is not optimized. Both CC3 and CCSD(T) !!    should be optimized simultaneously. !! class ( ccsdpt ) :: wf ! real ( dp ), dimension (:,:), allocatable :: u_ai real ( dp ), dimension (:,:), allocatable :: u_ai_bj ! real ( dp ), dimension (:,:), allocatable :: v_ai real ( dp ), dimension (:,:), allocatable :: v_ai_bj ! integer ( i15 ) :: a = 0 , i = 0 , j = 0 , k = 0 , b = 0 , ai = 0 integer ( i15 ) :: bj = 0 , aj = 0 , bi = 0 , aibj = 0 , ajbi = 0 ! real ( dp ), dimension (:,:), allocatable :: t_abc ! Triples, t_ijk&#94;abc, fixed ijk ! real ( dp ) :: ddot , correction ! !     Let the user know the CCSD(T) correction is being computed ! write ( unit_output , '(t3,a/,t3,a/)' ) 'Adding the CCSD(T) correction to the above,' ,& 'iterated CCSD energy.' flush ( unit_output ) ! !     :: Calculate the v vector :: ! call wf % mem % alloc ( v_ai , wf % n_v , wf % n_o ) ! !     Write to disk the integrals needed for calculation of v ! !     Note: These are the same as for CC3 omega, without the !           T1 transformation. We therefore reuse this routine. ! v_ai = wf % t1am ! Make a copy of the singles wf % t1am = zero ! Set the singles to zero ! call wf % omega_integrals ! Get the (non-T1) transformed integrals ! wf % t1am = v_ai ! Put the singles amplitudes back v_ai = zero ! Reset the W_ai vector ! wf % omega1 = zero ! Will hold the singles part of W, ! arising from the E1 term ! call wf % mem % alloc ( t_abc , ( wf % n_v ) ** 3 , 1 ) t_abc = zero ! call wf % mem % alloc ( v_ai_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) v_ai_bj = zero ! do i = 1 , wf % n_o do j = 1 , wf % n_o do k = 1 , wf % n_o ! !              Calculate the triples amplitudes: ! !              Calculate W_abc = P_ijk&#94;abc ( sum_d t_ij&#94;ad g_bdck - sum_l t_il&#94;ab g_ljck ) !              and divide by orbital energy difference, t_abc = - W_abc / e_abc ! t_abc = zero call wf % calc_triples ( t_abc , i , j , k ) ! !              Note: v_ai is identical to the CC3 omega1(a,i), !              with non-transformed integrals: ! call wf % omega_cc3_a1 ( t_abc , i , j , k ) ! !              Note: v_ai_bj is identical the CC3 B2 contribution !              to omega2(ai,bj): ! call wf % omega_cc3_b2 ( v_ai_bj , t_abc , i , j , k ) ! enddo enddo enddo ! call dcopy (( wf % n_o ) * ( wf % n_v ), wf % omega1 , 1 , v_ai , 1 ) ! !     Deallocate the triples amplitude ! call wf % mem % dealloc ( t_abc , ( wf % n_v ) ** 3 , 1 ) ! !     Calculate the u vector ! call wf % mem % alloc ( u_ai , wf % n_v , wf % n_o ) u_ai = zero ! call wf % mem % alloc ( u_ai_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) u_ai_bj = zero ! call daxpy (( wf % n_o ) * ( wf % n_v ), two , wf % t1am , 1 , u_ai , 1 ) ! u_ai = 2 * t_ai ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o ! aj = index_two ( a , j , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) bi = index_two ( b , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ajbi = index_packed ( aj , bi ) ! u_ai_bj ( ai , bj ) = four * ( wf % t2am ( aibj , 1 )) - two * ( wf % t2am ( ajbi , 1 )) ! enddo enddo enddo enddo ! !     Find the energy corrections and print the CCSD(T) energy !     to the main output file ! correction = zero correction = ddot (( wf % n_o ) * ( wf % n_v ), u_ai , 1 , v_ai , 1 ) ! wf % energy = wf % energy + correction ! correction = zero correction = ddot (( wf % n_o ) * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_v ), u_ai_bj , 1 , v_ai_bj , 1 ) ! wf % energy = wf % energy + correction ! write ( unit_output , '(t3,a27,f14.8)' ) 'CCSD(T) energy (hartrees):' , wf % energy ! !     Deallocations ! call wf % mem % dealloc ( u_ai , wf % n_v , wf % n_o ) call wf % mem % dealloc ( u_ai_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! call wf % mem % dealloc ( v_ai , wf % n_v , wf % n_o ) call wf % mem % dealloc ( v_ai_bj , ( wf % n_v ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_o )) ! end subroutine calc_energy_correction_ccsdpt ! ! end module ccsdpt_class","tags":"","loc":"sourcefile/ccsdpt_class.f90.html","title":"ccsdpt_class.F90 – The eT program"},{"text":"type, public :: memory_manager Inherited By type~~memory_manager~~InheritedByGraph type~memory_manager memory_manager type~mlcc2 mlcc2 type~memory_manager->type~mlcc2 mem type~cc3 cc3 type~memory_manager->type~cc3 mem type~cc2 cc2 type~memory_manager->type~cc2 mem type~ccsd ccsd type~memory_manager->type~ccsd mem type~hf hf type~memory_manager->type~hf mem type~ccs ccs type~memory_manager->type~ccs mem type~ccsdpt ccsdpt type~memory_manager->type~ccsdpt mem type~mp2 mp2 type~memory_manager->type~mp2 mem type~mlccsd mlccsd type~memory_manager->type~mlccsd mem type~mlcc2->type~mlccsd type~cc3->type~ccsdpt type~ccsd->type~cc3 type~hf->type~ccs type~hf->type~mp2 type~ccs->type~mlcc2 type~ccs->type~cc2 type~ccs->type~ccsd Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables total available buffer Type-Bound Procedures init alloc dealloc alloc_int dealloc_int num_batch num_two_batch Components Type Visibility Attributes Name Initial integer(kind=i15), public :: total = 30000000000 integer(kind=i15), public :: available = 30000000000 integer(kind=i15), public :: buffer = 10 Type-Bound Procedures procedure, public :: init => init_memory_manager public subroutine init_memory_manager (mem, total) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem integer(kind=i15) :: total procedure, public :: alloc => alloc_memory_manager public subroutine alloc_memory_manager (mem, array, M, N) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem real(kind=dp), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N procedure, public :: dealloc => dealloc_memory_manager public subroutine dealloc_memory_manager (mem, array, M, N) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem real(kind=dp), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N procedure, public :: alloc_int => alloc_int_memory_manager public subroutine alloc_int_memory_manager (mem, array, M, N) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem integer(kind=i15), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N procedure, public :: dealloc_int => dealloc_int_memory_manager public subroutine dealloc_int_memory_manager (mem, array, M, N) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem integer(kind=i15), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N procedure, public :: num_batch => num_batch_memory_manager public subroutine num_batch_memory_manager (mem, batch_p, required) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem class( batching_index ) :: batch_p integer(kind=i15) :: required procedure, public :: num_two_batch => num_two_batch_memory_manager public subroutine num_two_batch_memory_manager (mem, batch_p, batch_q, required) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem class( batching_index ) :: batch_p class( batching_index ) :: batch_q integer(kind=i15) :: required","tags":"","loc":"type/memory_manager.html","title":"memory_manager – The eT program "},{"text":"type, public :: batching_index Variables first last length max_length num_batches index_dimension initialized Type-Bound Procedures init determine_limits Components Type Visibility Attributes Name Initial integer(kind=i15), public :: first = 0 integer(kind=i15), public :: last = 0 integer(kind=i15), public :: length = 0 integer(kind=i15), public :: max_length = 0 integer(kind=i15), public :: num_batches = 0 integer(kind=i15), public :: index_dimension = 0 logical, public :: initialized = .false. Type-Bound Procedures procedure, public :: init => init_batching_index public subroutine init_batching_index (batch_p, dimension) Arguments Type Intent Optional Attributes Name class( batching_index ) :: batch_p integer(kind=i15), intent(in) :: dimension procedure, public :: determine_limits => determine_limits_batching_index public subroutine determine_limits_batching_index (batch_p, batch_number) Arguments Type Intent Optional Attributes Name class( batching_index ) :: batch_p integer(kind=i15), intent(in) :: batch_number","tags":"","loc":"type/batching_index.html","title":"batching_index – The eT program "},{"text":"type, public :: excited_state_specs Inherited By type~~excited_state_specs~~InheritedByGraph type~excited_state_specs excited_state_specs type~mlcc2 mlcc2 type~excited_state_specs->type~mlcc2 excited_state_specifications type~cc3 cc3 type~excited_state_specs->type~cc3 excited_state_specifications type~cc2 cc2 type~excited_state_specs->type~cc2 excited_state_specifications type~ccsd ccsd type~excited_state_specs->type~ccsd excited_state_specifications type~hf hf type~excited_state_specs->type~hf excited_state_specifications type~ccs ccs type~excited_state_specs->type~ccs excited_state_specifications type~ccsdpt ccsdpt type~excited_state_specs->type~ccsdpt excited_state_specifications type~mp2 mp2 type~excited_state_specs->type~mp2 excited_state_specifications type~mlccsd mlccsd type~excited_state_specs->type~mlccsd excited_state_specifications type~mlcc2->type~mlccsd type~cc3->type~ccsdpt type~ccsd->type~cc3 type~hf->type~ccs type~hf->type~mp2 type~ccs->type~mlcc2 type~ccs->type~cc2 type~ccs->type~ccsd var pantypeexcited_state_specsInheritedByGraph = svgPanZoom('#typeexcited_state_specsInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables energy_threshold residual_threshold max_iterations restart user_specified_start_vector start_vectors n_singlet_states n_triplet_states right left solution_file Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy_threshold = 1.0D-06 real(kind=dp), public :: residual_threshold = 1.0D-06 integer(kind=i15), public :: max_iterations = 50 logical, public :: restart = .false. logical, public :: user_specified_start_vector = .false. integer(kind=i15), public, dimension(:,:), allocatable :: start_vectors integer(kind=i15), public :: n_singlet_states = 0 integer(kind=i15), public :: n_triplet_states = 0 logical, public :: right = .true. logical, public :: left = .false. character(len=40), public :: solution_file = 'right_valence'","tags":"","loc":"type/excited_state_specs.html","title":"excited_state_specs – The eT program "},{"text":"type, public :: mlcc_calculation_settings Inherited By type~~mlcc_calculation_settings~~InheritedByGraph type~mlcc_calculation_settings mlcc_calculation_settings type~mlcc2 mlcc2 type~mlcc_calculation_settings->type~mlcc2 mlcc_settings type~mlccsd mlccsd type~mlcc_calculation_settings->type~mlccsd mlcc_settings type~mlcc2->type~mlccsd Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables CCS CC2 CCSD CC3 Components Type Visibility Attributes Name Initial logical, public :: CCS = .false. logical, public :: CC2 = .false. logical, public :: CCSD = .false. logical, public :: CC3 = .false.","tags":"","loc":"type/mlcc_calculation_settings.html","title":"mlcc_calculation_settings – The eT program "},{"text":"type, public :: mlcc_orbitals Inherited By type~~mlcc_orbitals~~InheritedByGraph type~mlcc_orbitals mlcc_orbitals type~mlcc2 mlcc2 type~mlcc_orbitals->type~mlcc2 CC2_orbitals type~mlccsd mlccsd type~mlcc_orbitals->type~mlccsd CC2_orbitals type~mlcc2->type~mlccsd Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables cholesky cnto delta_o delta_v n_active_atoms active_atoms Type-Bound Procedures orbital_reader Components Type Visibility Attributes Name Initial logical, public :: cholesky = .false. logical, public :: cnto = .true. real(kind=dp), public :: delta_o = 1.0D-06 real(kind=dp), public :: delta_v = 1.0D-06 integer(kind=i15), public :: n_active_atoms integer(kind=i15), public, dimension(:,:), allocatable :: active_atoms Type-Bound Procedures procedure, public :: orbital_reader => orbital_reader_mlcc_orb public subroutine orbital_reader_mlcc_orb (orbital_info, unit_input) Arguments Type Intent Optional Attributes Name class( mlcc_orbitals ) :: orbital_info integer(kind=i15) :: unit_input","tags":"","loc":"type/mlcc_orbitals.html","title":"mlcc_orbitals – The eT program "},{"text":"type, public :: ground_state_specs Inherited By type~~ground_state_specs~~InheritedByGraph type~ground_state_specs ground_state_specs type~mlcc2 mlcc2 type~ground_state_specs->type~mlcc2 ground_state_specifications type~cc3 cc3 type~ground_state_specs->type~cc3 ground_state_specifications type~cc2 cc2 type~ground_state_specs->type~cc2 ground_state_specifications type~ccsd ccsd type~ground_state_specs->type~ccsd ground_state_specifications type~hf hf type~ground_state_specs->type~hf ground_state_specifications type~ccs ccs type~ground_state_specs->type~ccs ground_state_specifications type~ccsdpt ccsdpt type~ground_state_specs->type~ccsdpt ground_state_specifications type~mp2 mp2 type~ground_state_specs->type~mp2 ground_state_specifications type~mlccsd mlccsd type~ground_state_specs->type~mlccsd ground_state_specifications type~mlcc2->type~mlccsd type~cc3->type~ccsdpt type~ccsd->type~cc3 type~hf->type~ccs type~hf->type~mp2 type~ccs->type~mlcc2 type~ccs->type~cc2 type~ccs->type~ccsd var pantypeground_state_specsInheritedByGraph = svgPanZoom('#typeground_state_specsInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables energy_threshold residual_threshold max_iterations restart Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy_threshold = 1.0D-06 real(kind=dp), public :: residual_threshold = 1.0D-06 integer(kind=i15), public :: max_iterations = 50 logical, public :: restart = .false.","tags":"","loc":"type/ground_state_specs.html","title":"ground_state_specs – The eT program "},{"text":"type, public :: calc_settings Inherited By type~~calc_settings~~InheritedByGraph type~calc_settings calc_settings type~mlcc2 mlcc2 type~calc_settings->type~mlcc2 settings type~cc3 cc3 type~calc_settings->type~cc3 settings type~cc2 cc2 type~calc_settings->type~cc2 settings type~ccsd ccsd type~calc_settings->type~ccsd settings type~hf hf type~calc_settings->type~hf settings type~ccs ccs type~calc_settings->type~ccs settings type~ccsdpt ccsdpt type~calc_settings->type~ccsdpt settings type~mp2 mp2 type~calc_settings->type~mp2 settings type~mlccsd mlccsd type~calc_settings->type~mlccsd settings type~mlcc2->type~mlccsd type~cc3->type~ccsdpt type~ccsd->type~cc3 type~hf->type~ccs type~hf->type~mp2 type~ccs->type~mlcc2 type~ccs->type~cc2 type~ccs->type~ccsd Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables disk_space print_level Components Type Visibility Attributes Name Initial real(kind=dp), public :: disk_space = 100D0 character(len=40), public :: print_level = 'developer'","tags":"","loc":"type/calc_settings.html","title":"calc_settings – The eT program "},{"text":"type, public :: calc_tasks Inherited By type~~calc_tasks~~InheritedByGraph type~calc_tasks calc_tasks type~mlcc2 mlcc2 type~calc_tasks->type~mlcc2 tasks, implemented type~cc3 cc3 type~calc_tasks->type~cc3 tasks, implemented type~cc2 cc2 type~calc_tasks->type~cc2 tasks, implemented type~ccsd ccsd type~calc_tasks->type~ccsd tasks, implemented type~hf hf type~calc_tasks->type~hf tasks, implemented type~ccs ccs type~calc_tasks->type~ccs tasks, implemented type~ccsdpt ccsdpt type~calc_tasks->type~ccsdpt tasks, implemented type~mp2 mp2 type~calc_tasks->type~mp2 tasks, implemented type~mlccsd mlccsd type~calc_tasks->type~mlccsd tasks, implemented type~mlcc2->type~mlccsd type~cc3->type~ccsdpt type~ccsd->type~cc3 type~hf->type~ccs type~hf->type~mp2 type~ccs->type~mlcc2 type~ccs->type~cc2 type~ccs->type~ccsd var pantypecalc_tasksInheritedByGraph = svgPanZoom('#typecalc_tasksInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables ground_state excited_state core_excited_state ionized_state core_ionized_state multipliers current Components Type Visibility Attributes Name Initial logical, public :: ground_state = .false. logical, public :: excited_state = .false. logical, public :: core_excited_state = .false. logical, public :: ionized_state = .false. logical, public :: core_ionized_state = .false. logical, public :: multipliers = .false. character(len=40), public :: current = 'ground_state'","tags":"","loc":"type/calc_tasks.html","title":"calc_tasks – The eT program "},{"text":"type, public :: core_excited_state_specs Inherited By type~~core_excited_state_specs~~InheritedByGraph type~core_excited_state_specs core_excited_state_specs type~mlcc2 mlcc2 type~core_excited_state_specs->type~mlcc2 core_excited_state_specifications type~cc3 cc3 type~core_excited_state_specs->type~cc3 core_excited_state_specifications type~cc2 cc2 type~core_excited_state_specs->type~cc2 core_excited_state_specifications type~ccsd ccsd type~core_excited_state_specs->type~ccsd core_excited_state_specifications type~hf hf type~core_excited_state_specs->type~hf core_excited_state_specifications type~ccs ccs type~core_excited_state_specs->type~ccs core_excited_state_specifications type~ccsdpt ccsdpt type~core_excited_state_specs->type~ccsdpt core_excited_state_specifications type~mp2 mp2 type~core_excited_state_specs->type~mp2 core_excited_state_specifications type~mlccsd mlccsd type~core_excited_state_specs->type~mlccsd core_excited_state_specifications type~mlcc2->type~mlccsd type~cc3->type~ccsdpt type~ccsd->type~cc3 type~hf->type~ccs type~hf->type~mp2 type~ccs->type~mlcc2 type~ccs->type~cc2 type~ccs->type~ccsd var pantypecore_excited_state_specsInheritedByGraph = svgPanZoom('#typecore_excited_state_specsInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables n_equivalent_cores cores index_core_mo Components Type Visibility Attributes Name Initial integer(kind=i15), public :: n_equivalent_cores integer(kind=i15), public, dimension(:,:), allocatable :: cores integer(kind=i15), public, dimension(:,:), allocatable :: index_core_mo","tags":"","loc":"type/core_excited_state_specs.html","title":"core_excited_state_specs – The eT program "},{"text":"type, public :: calc_tasks Variables ground_state excited_state core_excited_state ionized_state core_ionized_state properties current Components Type Visibility Attributes Name Initial logical, public :: ground_state = .false. logical, public :: excited_state = .false. logical, public :: core_excited_state = .false. logical, public :: ionized_state = .false. logical, public :: core_ionized_state = .false. logical, public :: properties = .false. character(len=40), public :: current = 'ground_state'","tags":"","loc":"type/calc_tasks~2.html","title":"calc_tasks – The eT program "},{"text":"type, public :: response_calc_specs Inherited By type~~response_calc_specs~~InheritedByGraph type~response_calc_specs response_calc_specs type~mlcc2 mlcc2 type~response_calc_specs->type~mlcc2 response_specifications type~cc3 cc3 type~response_calc_specs->type~cc3 response_specifications type~cc2 cc2 type~response_calc_specs->type~cc2 response_specifications type~ccsd ccsd type~response_calc_specs->type~ccsd response_specifications type~hf hf type~response_calc_specs->type~hf response_specifications type~ccs ccs type~response_calc_specs->type~ccs response_specifications type~ccsdpt ccsdpt type~response_calc_specs->type~ccsdpt response_specifications type~mp2 mp2 type~response_calc_specs->type~mp2 response_specifications type~mlccsd mlccsd type~response_calc_specs->type~mlccsd response_specifications type~mlcc2->type~mlccsd type~cc3->type~ccsdpt type~ccsd->type~cc3 type~hf->type~ccs type~hf->type~mp2 type~ccs->type~mlcc2 type~ccs->type~cc2 type~ccs->type~ccsd var pantyperesponse_calc_specsInheritedByGraph = svgPanZoom('#typeresponse_calc_specsInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables energy_threshold residual_threshold max_iterations restart Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy_threshold = 1.0D-06 real(kind=dp), public :: residual_threshold = 1.0D-06 integer(kind=i15), public :: max_iterations = 50 logical, public :: restart = .false.","tags":"","loc":"type/response_calc_specs.html","title":"response_calc_specs – The eT program "},{"text":"type, public :: hf type~~hf~~InheritsGraph type~hf hf type~core_excited_state_specs core_excited_state_specs type~core_excited_state_specs->type~hf core_excited_state_specifications type~response_calc_specs response_calc_specs type~response_calc_specs->type~hf response_specifications type~calc_tasks calc_tasks type~calc_tasks->type~hf tasks, implemented type~memory_manager memory_manager type~memory_manager->type~hf mem type~excited_state_specs excited_state_specs type~excited_state_specs->type~hf excited_state_specifications type~calc_settings calc_settings type~calc_settings->type~hf settings type~ground_state_specs ground_state_specs type~ground_state_specs->type~hf ground_state_specifications Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Inherited By type~~hf~~InheritedByGraph type~hf hf type~ccs ccs type~hf->type~ccs type~mp2 mp2 type~hf->type~mp2 type~cc2 cc2 type~ccs->type~cc2 type~mlcc2 mlcc2 type~ccs->type~mlcc2 type~ccsd ccsd type~ccs->type~ccsd type~mlccsd mlccsd type~mlcc2->type~mlccsd type~cc3 cc3 type~ccsd->type~cc3 type~ccsdpt ccsdpt type~cc3->type~ccsdpt Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented ground_state_specifications excited_state_specifications core_excited_state_specifications response_specifications mem Type-Bound Procedures init drv read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky construct_ao_fock construct_ao_fock_new construct_density_matrices construct_density_matrix construct_density_matrix_v Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem Type-Bound Procedures procedure, public :: init => init_hf public subroutine init_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public :: drv => drv_hf public subroutine drv_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v","tags":"","loc":"type/hf.html","title":"hf – The eT program "},{"text":"type, public, extends( mlcc2 ) :: mlccsd type~~mlccsd~~InheritsGraph type~mlccsd mlccsd type~core_excited_state_specs core_excited_state_specs type~core_excited_state_specs->type~mlccsd core_excited_state_specifications type~mlcc2 mlcc2 type~core_excited_state_specs->type~mlcc2 core_excited_state_specifications type~ccs ccs type~core_excited_state_specs->type~ccs core_excited_state_specifications type~hf hf type~core_excited_state_specs->type~hf core_excited_state_specifications type~response_calc_specs response_calc_specs type~response_calc_specs->type~mlccsd response_specifications type~response_calc_specs->type~mlcc2 response_specifications type~response_calc_specs->type~ccs response_specifications type~response_calc_specs->type~hf response_specifications type~calc_tasks calc_tasks type~calc_tasks->type~mlccsd tasks, implemented type~calc_tasks->type~mlcc2 tasks, implemented type~calc_tasks->type~ccs tasks, implemented type~calc_tasks->type~hf tasks, implemented type~memory_manager memory_manager type~memory_manager->type~mlccsd mem type~memory_manager->type~mlcc2 mem type~memory_manager->type~ccs mem type~memory_manager->type~hf mem type~excited_state_specs excited_state_specs type~excited_state_specs->type~mlccsd excited_state_specifications type~excited_state_specs->type~mlcc2 excited_state_specifications type~excited_state_specs->type~ccs excited_state_specifications type~excited_state_specs->type~hf excited_state_specifications type~mlcc_orbitals mlcc_orbitals type~mlcc_orbitals->type~mlccsd CC2_orbitals type~mlcc_orbitals->type~mlcc2 CC2_orbitals type~calc_settings calc_settings type~calc_settings->type~mlccsd settings type~calc_settings->type~mlcc2 settings type~calc_settings->type~ccs settings type~calc_settings->type~hf settings mlcc_orbitals mlcc_orbitals mlcc_orbitals->type~mlccsd CCSD_orbitals type~mlcc_calculation_settings mlcc_calculation_settings type~mlcc_calculation_settings->type~mlccsd mlcc_settings type~mlcc_calculation_settings->type~mlcc2 mlcc_settings type~ground_state_specs ground_state_specs type~ground_state_specs->type~mlccsd ground_state_specifications type~ground_state_specs->type~mlcc2 ground_state_specifications type~ground_state_specs->type~ccs ground_state_specifications type~ground_state_specs->type~hf ground_state_specifications type~mlcc2->type~mlccsd type~ccs->type~mlcc2 type~hf->type~ccs var pantypemlccsdInheritsGraph = svgPanZoom('#typemlccsdInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented ground_state_specifications excited_state_specifications core_excited_state_specifications response_specifications mem n_t1am n_parameters t1am omega1 fock_ij fock_ia fock_ai fock_ab mlcc_settings n_CCS_o n_CCS_v first_CCS_o first_CCS_v n_CC2_o n_CC2_v first_CC2_o first_CC2_v CC2_orbitals n_x2am x2am n_CCSD_o n_CCSD_v first_CCSD_o first_CCSD_v CCSD_orbitals mo_coef_cc2_ccs T_o T_v fock_diagonal_cc2_ccs n_t2am t2am omega2 Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky construct_ao_fock construct_ao_fock_new construct_density_matrices construct_density_matrix construct_density_matrix_v drv ground_state_driver ground_state_solver ground_state_preparations ground_state_cleanup destruct_ground_state diis calc_ampeqs calc_quasi_Newton_singles excited_state_driver excited_state_solver excited_state_cleanup precondition_residual precondition_residual_valence print_excited_state_info analyze_single_excitation_vector initialize_trial_vectors initialize_trial_vectors_valence find_start_trial_indices trial_vectors_from_stored_solutions precondition_residual_core find_start_trial_indices_core find_core_mo initialize_trial_vectors_core solve_reduced_eigenvalue_equation construct_next_trial_vectors response_driver response_solver response_preparations initialize_response solve_reduced_response_equation construct_reduced_matrix construct_reduced_gradient construct_next_response_trial_vectors construct_gradient_vector general_specs_reader calculation_reader read_ground_state_specs read_excited_state_specs read_property_specs get_cholesky_ij get_cholesky_ia get_cholesky_ai get_cholesky_ab get_oo_oo get_oo_ov get_ov_oo get_oo_vo get_vo_oo get_oo_vv get_vv_oo get_ov_ov get_vo_vo get_ov_vo get_vo_ov get_ov_vv get_vv_ov get_vo_vv get_vv_vo get_vv_vv get_oo_oo_electronic_repulsion get_oo_ov_electronic_repulsion get_ov_oo_electronic_repulsion get_oo_vo_electronic_repulsion get_vo_oo_electronic_repulsion get_oo_vv_electronic_repulsion get_vv_oo_electronic_repulsion get_ov_ov_electronic_repulsion get_vo_vo_electronic_repulsion get_ov_vo_electronic_repulsion get_vo_ov_electronic_repulsion get_ov_vv_electronic_repulsion get_vv_ov_electronic_repulsion get_vo_vv_electronic_repulsion get_vv_vo_electronic_repulsion get_vv_vv_electronic_repulsion store_vv_vv_electronic_repulsion read_vv_vv_electronic_repulsion t1_transform_vv_vv store_t1_vv_vv_electronic_repulsion store_t1_vo_ov_electronic_repulsion store_t1_vv_vo_electronic_repulsion store_t1_vv_ov_electronic_repulsion read_t1_vv_vo_electronic_repulsion read_t1_vv_vv_electronic_repulsion read_t1_vo_ov_electronic_repulsion read_t1_vv_ov_electronic_repulsion initialize_fock_matrix construct_fock one_electron_t1 jacobian_ccs_transformation jacobian_ccs_a1 jacobian_ccs_b1 jacobi_test jacobian_transpose_ccs_transformation jacobian_transpose_ccs_a1 jacobian_transpose_ccs_b1 ionized_state_driver initialize_trial_vectors_core_ionization initialize_trial_vectors_valence_ionization precondition_residual_valence_ionization ionization_residual_projection ionization_rho_a_i_projection precondition_residual_core_ionization cvs_rho_a_i_projection omega_ccs_a1 construct_eta read_single_amplitudes destruct_omega cholesky_decomposition cholesky_orbitals cholesky_orbital_constructor cc2_cnto_lower_level_method cc2_cnto_orbitals read_cc2_double_amplitudes destruct_x2am omega_mlcc2_a1 omega_mlcc2_b1 get_s2am excited_state_preparations calculate_orbital_differences cvs_residual_projection analyze_double_excitation_vector jacobian_mlcc2_transformation cvs_rho_aibj_projection jacobian_mlcc2_a1 jacobian_mlcc2_b1 jacobian_mlcc2_a2 jacobian_mlcc2_b2 mlcc_reader read_orbital_info init initialize_amplitudes initialize_omega calc_energy orbital_partitioning cholesky_localization_drv cholesky_localization_CCSD_CC2_CCS cholesky_localization_CCSD_CCS cholesky_localization_CCSD_CC2 construct_perturbative_doubles construct_MO_transformation_matrix cnto_orbital_drv ccsd_cnto_lower_level_method ccsd_cnto_orbitals print_orbital_info read_transform_cholesky_for_CC2_amplitude read_cholesky_ai_for_cc2_amplitudes read_cholesky_ia_for_cc2_amplitudes read_cholesky_ij_for_cc2_amplitudes read_cholesky_ab_for_cc2_amplitudes get_cholesky_ai_for_cc2_amplitudes get_CC2_active_indices get_CC2_n_active get_CCSD_active_indices get_CCSD_n_active construct_omega omega_mlccsd_a1 omega_mlccsd_b1 get_mlccsd_x2am omega_mlccsd_a2 omega_mlccsd_b2 omega_mlccsd_c2 omega_mlccsd_d2 omega_mlccsd_e2 calc_ampeqs_norm new_amplitudes calc_quasi_Newton_doubles initialize_ground_state construct_orbital_coef_CC2_CCS construct_orbital_energy_CC2_CCS destruct_orbital_coef_CC2_CCS destruct_orbital_energy_CC2_CCS destruct_amplitudes destruct_double_amplitudes save_amplitudes read_amplitudes read_mlccsd_double_amplitudes read_double_amplitudes jacobian_mlccsd_transformation jacobian_mlccsd_b2 jacobian_mlccsd_c2 jacobian_mlccsd_d2 jacobian_mlccsd_e2 jacobian_mlccsd_f2 jacobian_mlccsd_g2 jacobian_mlccsd_h2 jacobian_mlccsd_i2 jacobian_mlccsd_j2 jacobian_mlccsd_k2 transform_trial_vectors initialize_excited_states print_excitation_vector summary_excited_state_info Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab type( mlcc_calculation_settings ), public :: mlcc_settings integer(kind=i15), public :: n_CCS_o = 0 integer(kind=i15), public :: n_CCS_v = 0 integer(kind=i15), public :: first_CCS_o = 0 integer(kind=i15), public :: first_CCS_v = 0 integer(kind=i15), public :: n_CC2_o = 0 integer(kind=i15), public :: n_CC2_v = 0 integer(kind=i15), public :: first_CC2_o = 0 integer(kind=i15), public :: first_CC2_v = 0 type( mlcc_orbitals ), public :: CC2_orbitals integer(kind=i15), public :: n_x2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: x2am integer(kind=i15), public :: n_CCSD_o = 0 integer(kind=i15), public :: n_CCSD_v = 0 integer(kind=i15), public :: first_CCSD_o = 0 integer(kind=i15), public :: first_CCSD_v = 0 type(mlcc_orbitals), public :: CCSD_orbitals real(kind=dp), public, dimension(:,:), allocatable :: mo_coef_cc2_ccs real(kind=dp), public, dimension(:,:), allocatable :: T_o real(kind=dp), public, dimension(:,:), allocatable :: T_v real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal_cc2_ccs integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public :: drv => drv_ccs public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: ground_state_driver => ground_state_driver_ccs public interface ground_state_driver_ccs () Arguments None procedure, public :: ground_state_solver => ground_state_solver_ccs public interface ground_state_solver_ccs () Arguments None procedure, public :: ground_state_preparations => ground_state_preparations_ccs public interface ground_state_preparations_ccs () Arguments None procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs public interface ground_state_cleanup_ccs () Arguments None procedure, public :: destruct_ground_state => destruct_ground_state_ccs public interface destruct_ground_state_ccs () Arguments None procedure, public, non_overridable :: diis => diis_ccs public interface diis_ccs () Arguments None procedure, public :: calc_ampeqs => calc_ampeqs_ccs public interface calc_ampeqs_ccs () Arguments None procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs public interface calc_quasi_Newton_singles_ccs () Arguments None procedure, public :: excited_state_driver => excited_state_driver_ccs public interface excited_state_driver_ccs () Arguments None procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs public interface excited_state_solver_ccs () Arguments None procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs public interface excited_state_cleanup_ccs () Arguments None procedure, public :: precondition_residual => precondition_residual_ccs public interface precondition_residual_ccs () Arguments None procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs public interface precondition_residual_valence_ccs () Arguments None procedure, public :: print_excited_state_info => print_excited_state_info_ccs public interface print_excited_state_info_ccs () Arguments None procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs public interface analyze_single_excitation_vector_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs public interface initialize_trial_vectors_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs public interface initialize_trial_vectors_valence_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs public interface find_start_trial_indices_ccs () Arguments None procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs public interface trial_vectors_from_stored_solutions_ccs () Arguments None procedure, public :: precondition_residual_core => precondition_residual_core_ccs public interface precondition_residual_core_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs public interface find_start_trial_indices_core_ccs () Arguments None procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs public interface find_core_mo_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs public interface initialize_trial_vectors_core_ccs () Arguments None procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs public interface solve_reduced_eigenvalue_equation_ccs () Arguments None procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs public interface construct_next_trial_vectors_ccs () Arguments None procedure, public :: response_driver => response_driver_ccs public interface response_driver_ccs () Arguments None procedure, public :: response_solver => response_solver_ccs public interface response_solver_ccs () Arguments None procedure, public :: response_preparations => response_preparations_ccs public interface response_preparations_ccs () Arguments None procedure, public :: initialize_response => initialize_response_ccs public interface initialize_response_ccs () Arguments None procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs public interface solve_reduced_response_equation_ccs () Arguments None procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs public interface construct_reduced_matrix_ccs () Arguments None procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs public interface construct_reduced_gradient_ccs () Arguments None procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs public interface construct_next_response_trial_vectors_ccs () Arguments None procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs public interface construct_gradient_vector_ccs () Arguments None procedure, public :: general_specs_reader => general_specs_reader_ccs public interface general_specs_reader_ccs () Arguments None procedure, public :: calculation_reader => calculation_reader_ccs public interface calculation_reader_ccs () Arguments None procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs public interface read_ground_state_specs_ccs () Arguments None procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs public interface read_excited_state_specs_ccs () Arguments None procedure, public :: read_property_specs => read_property_specs_ccs public interface read_property_specs_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs public interface get_cholesky_ij_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs public interface get_cholesky_ia_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs public interface get_cholesky_ai_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs public interface get_cholesky_ab_ccs () Arguments None procedure, public :: get_oo_oo => get_oo_oo_ccs public interface get_oo_oo_ccs () Arguments None procedure, public :: get_oo_ov => get_oo_ov_ccs public interface get_oo_ov_ccs () Arguments None procedure, public :: get_ov_oo => get_ov_oo_ccs public interface get_ov_oo_ccs () Arguments None procedure, public :: get_oo_vo => get_oo_vo_ccs public interface get_oo_vo_ccs () Arguments None procedure, public :: get_vo_oo => get_vo_oo_ccs public interface get_vo_oo_ccs () Arguments None procedure, public :: get_oo_vv => get_oo_vv_ccs public interface get_oo_vv_ccs () Arguments None procedure, public :: get_vv_oo => get_vv_oo_ccs public interface get_vv_oo_ccs () Arguments None procedure, public :: get_ov_ov => get_ov_ov_ccs public interface get_ov_ov_ccs () Arguments None procedure, public :: get_vo_vo => get_vo_vo_ccs public interface get_vo_vo_ccs () Arguments None procedure, public :: get_ov_vo => get_ov_vo_ccs public interface get_ov_vo_ccs () Arguments None procedure, public :: get_vo_ov => get_vo_ov_ccs public interface get_vo_ov_ccs () Arguments None procedure, public :: get_ov_vv => get_ov_vv_ccs public interface get_ov_vv_ccs () Arguments None procedure, public :: get_vv_ov => get_vv_ov_ccs public interface get_vv_ov_ccs () Arguments None procedure, public :: get_vo_vv => get_vo_vv_ccs public interface get_vo_vv_ccs () Arguments None procedure, public :: get_vv_vo => get_vv_vo_ccs public interface get_vv_vo_ccs () Arguments None procedure, public :: get_vv_vv => get_vv_vv_ccs public interface get_vv_vv_ccs () Arguments None procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs public interface get_oo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs public interface get_oo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs public interface get_ov_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs public interface get_oo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs public interface get_vo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs public interface get_oo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs public interface get_vv_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs public interface get_ov_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs public interface get_vo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs public interface get_ov_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs public interface get_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs public interface get_ov_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs public interface get_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs public interface get_vo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs public interface get_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs public interface get_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs public interface store_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs public interface read_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs public interface t1_transform_vv_vv_ccs () Arguments None procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs public interface store_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs public interface store_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs public interface store_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs public interface store_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs public interface read_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs public interface read_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs public interface read_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs public interface read_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs public interface initialize_fock_matrix_ccs () Arguments None procedure, public, non_overridable :: construct_fock => construct_fock_ccs public interface construct_fock_ccs () Arguments None procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs public interface one_electron_t1_ccs () Arguments None procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs public interface jacobian_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs public interface jacobian_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs public interface jacobian_ccs_b1_ccs () Arguments None procedure, public :: jacobi_test => jacobi_test_ccs public subroutine jacobi_test_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs public interface jacobian_transpose_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs public interface jacobian_transpose_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs public interface jacobian_transpose_ccs_b1_ccs () Arguments None procedure, public :: ionized_state_driver => ionized_state_driver_ccs public interface ionized_state_driver_ccs () Arguments None procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs public interface initialize_trial_vectors_core_ionization_ccs () Arguments None procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs public interface initialize_trial_vectors_valence_ionization_ccs () Arguments None procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs public interface precondition_residual_valence_ionization_ccs () Arguments None procedure, public :: ionization_residual_projection => ionization_residual_projection_ccs public interface ionization_residual_projection_ccs () Arguments None procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs public interface ionization_rho_a_i_projection_ccs () Arguments None procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs public interface precondition_residual_core_ionization_ccs () Arguments None procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs public interface cvs_rho_a_i_projection_ccs () Arguments None procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs public subroutine omega_ccs_a1_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: construct_eta => construct_eta_ccs public subroutine construct_eta_ccs (wf, eta) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs public subroutine read_single_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: destruct_omega => destruct_omega_ccs public subroutine destruct_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: cholesky_decomposition => cholesky_decomposition_mlcc2 public interface cholesky_decomposition_mlcc2 () Arguments None procedure, public :: cholesky_orbitals => cholesky_orbitals_mlcc2 public interface cholesky_orbitals_mlcc2 () Arguments None procedure, public :: cholesky_orbital_constructor => cholesky_orbital_constructor_mlcc2 public interface cholesky_orbital_constructor_mlcc2 () Arguments None procedure, public :: cc2_cnto_lower_level_method => cc2_cnto_lower_level_method_mlcc2 public interface cc2_cnto_lower_level_method_mlcc2 () Arguments None procedure, public :: cc2_cnto_orbitals => cc2_cnto_orbitals_mlcc2 public interface cc2_cnto_orbitals_mlcc2 () Arguments None procedure, public :: read_cc2_double_amplitudes => read_cc2_double_amplitudes_mlcc2 public subroutine read_cc2_double_amplitudes_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf procedure, public :: destruct_x2am => destruct_x2am_mlcc2 public subroutine destruct_x2am_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf procedure, public :: omega_mlcc2_a1 => omega_mlcc2_a1_mlcc2 public interface omega_mlcc2_a1_mlcc2 () Arguments None procedure, public :: omega_mlcc2_b1 => omega_mlcc2_b1_mlcc2 public interface omega_mlcc2_b1_mlcc2 () Arguments None procedure, public :: get_s2am => get_s2am_mlcc2 public interface get_s2am_mlcc2 () Arguments None procedure, public :: excited_state_preparations => excited_state_preparations_mlcc2 public interface excited_state_preparations_mlcc2 () Arguments None procedure, public :: calculate_orbital_differences => calculate_orbital_differences_mlcc2 public interface calculate_orbital_differences_mlcc2 () Arguments None procedure, public :: cvs_residual_projection => cvs_residual_projection_mlcc2 public interface cvs_residual_projection_mlcc2 () Arguments None procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_mlcc2 public interface analyze_double_excitation_vector_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_transformation => jacobian_mlcc2_transformation_mlcc2 public interface jacobian_mlcc2_transformation_mlcc2 () Arguments None procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_mlcc2 public interface cvs_rho_aibj_projection_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_a1 => jacobian_mlcc2_a1_mlcc2 public interface jacobian_mlcc2_a1_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_b1 => jacobian_mlcc2_b1_mlcc2 public interface jacobian_mlcc2_b1_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_a2 => jacobian_mlcc2_a2_mlcc2 public interface jacobian_mlcc2_a2_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_b2 => jacobian_mlcc2_b2_mlcc2 public interface jacobian_mlcc2_b2_mlcc2 () Arguments None procedure, public :: mlcc_reader => mlcc_reader_mlccsd public interface mlcc_reader_mlccsd () Arguments None procedure, public :: read_orbital_info => read_orbital_info_mlccsd public interface read_orbital_info_mlccsd () Arguments None procedure, public :: init => init_mlccsd public subroutine init_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: initialize_amplitudes => initialize_amplitudes_mlccsd public subroutine initialize_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: initialize_omega => initialize_omega_mlccsd public interface initialize_omega_mlccsd () Arguments None procedure, public :: calc_energy => calc_energy_mlccsd public subroutine calc_energy_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: orbital_partitioning => orbital_partitioning_mlccsd public interface orbital_partitioning_mlccsd () Arguments None procedure, public :: cholesky_localization_drv => cholesky_localization_drv_mlccsd public interface cholesky_localization_drv_mlccsd () Arguments None procedure, public :: cholesky_localization_CCSD_CC2_CCS => cholesky_localization_CCSD_CC2_CCS_mlccsd public interface cholesky_localization_CCSD_CC2_CCS_mlccsd () Arguments None procedure, public :: cholesky_localization_CCSD_CCS => cholesky_localization_CCSD_CCS_mlccsd public interface cholesky_localization_CCSD_CCS_mlccsd () Arguments None procedure, public :: cholesky_localization_CCSD_CC2 => cholesky_localization_CCSD_CC2_mlccsd public interface cholesky_localization_CCSD_CC2_mlccsd () Arguments None procedure, public :: construct_perturbative_doubles => construct_perturbative_doubles_mlccsd public subroutine construct_perturbative_doubles_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: construct_MO_transformation_matrix => construct_MO_transformation_matrix_mlccsd public interface construct_MO_transformation_matrix_mlccsd () Arguments None procedure, public :: cnto_orbital_drv => cnto_orbital_drv_mlccsd public interface cnto_orbital_drv_mlccsd () Arguments None procedure, public :: ccsd_cnto_lower_level_method => ccsd_cnto_lower_level_method_mlccsd public interface ccsd_cnto_lower_level_method_mlccsd () Arguments None procedure, public :: ccsd_cnto_orbitals => ccsd_cnto_orbitals_mlccsd public interface ccsd_cnto_orbitals_mlccsd () Arguments None procedure, public :: print_orbital_info => print_orbital_info_mlccsd public interface print_orbital_info_mlccsd () Arguments None procedure, public :: read_transform_cholesky_for_CC2_amplitude => read_transform_cholesky_for_CC2_amplitude_mlccsd public interface read_transform_cholesky_for_CC2_amplitude_mlccsd () Arguments None procedure, public :: read_cholesky_ai_for_cc2_amplitudes => read_cholesky_ai_for_cc2_amplitudes_mlccsd public interface read_cholesky_ai_for_cc2_amplitudes_mlccsd () Arguments None procedure, public :: read_cholesky_ia_for_cc2_amplitudes => read_cholesky_ia_for_cc2_amplitudes_mlccsd public interface read_cholesky_ia_for_cc2_amplitudes_mlccsd () Arguments None procedure, public :: read_cholesky_ij_for_cc2_amplitudes => read_cholesky_ij_for_cc2_amplitudes_mlccsd public interface read_cholesky_ij_for_cc2_amplitudes_mlccsd () Arguments None procedure, public :: read_cholesky_ab_for_cc2_amplitudes => read_cholesky_ab_for_cc2_amplitudes_mlccsd public interface read_cholesky_ab_for_cc2_amplitudes_mlccsd () Arguments None procedure, public :: get_cholesky_ai_for_cc2_amplitudes => get_cholesky_ai_for_cc2_amplitudes_mlccsd public interface get_cholesky_ai_for_cc2_amplitudes_mlccsd () Arguments None procedure, public :: get_CC2_active_indices => get_CC2_active_indices_mlccsd public subroutine get_CC2_active_indices_mlccsd (wf, first_o, first_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: first_o integer(kind=i15) :: first_v procedure, public :: get_CC2_n_active => get_CC2_n_active_mlccsd public subroutine get_CC2_n_active_mlccsd (wf, n_active_o, n_active_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: n_active_o integer(kind=i15) :: n_active_v procedure, public :: get_CCSD_active_indices => get_CCSD_active_indices_mlccsd public subroutine get_CCSD_active_indices_mlccsd (wf, first_o, first_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: first_o integer(kind=i15) :: first_v procedure, public :: get_CCSD_n_active => get_CCSD_n_active_mlccsd public subroutine get_CCSD_n_active_mlccsd (wf, n_active_o, n_active_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: n_active_o integer(kind=i15) :: n_active_v procedure, public :: construct_omega => construct_omega_mlccsd public interface construct_omega_mlccsd () Arguments None procedure, public :: omega_mlccsd_a1 => omega_mlccsd_a1_mlccsd public interface omega_mlccsd_a1_mlccsd () Arguments None procedure, public :: omega_mlccsd_b1 => omega_mlccsd_b1_mlccsd public interface omega_mlccsd_b1_mlccsd () Arguments None procedure, public :: get_mlccsd_x2am => get_mlccsd_x2am_mlccsd public interface get_mlccsd_x2am_mlccsd () Arguments None procedure, public :: omega_mlccsd_a2 => omega_mlccsd_a2_mlccsd public interface omega_mlccsd_a2_mlccsd () Arguments None procedure, public :: omega_mlccsd_b2 => omega_mlccsd_b2_mlccsd public interface omega_mlccsd_b2_mlccsd () Arguments None procedure, public :: omega_mlccsd_c2 => omega_mlccsd_c2_mlccsd public interface omega_mlccsd_c2_mlccsd () Arguments None procedure, public :: omega_mlccsd_d2 => omega_mlccsd_d2_mlccsd public interface omega_mlccsd_d2_mlccsd () Arguments None procedure, public :: omega_mlccsd_e2 => omega_mlccsd_e2_mlccsd public interface omega_mlccsd_e2_mlccsd () Arguments None procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_mlccsd public interface calc_ampeqs_norm_mlccsd () Arguments None procedure, public :: new_amplitudes => new_amplitudes_mlccsd public interface new_amplitudes_mlccsd () Arguments None procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_mlccsd public interface calc_quasi_Newton_doubles_mlccsd () Arguments None procedure, public :: initialize_ground_state => initialize_ground_state_mlccsd public interface initialize_ground_state_mlccsd () Arguments None procedure, public :: construct_orbital_coef_CC2_CCS => construct_orbital_coef_CC2_CCS_mlccsd public subroutine construct_orbital_coef_CC2_CCS_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: construct_orbital_energy_CC2_CCS => construct_orbital_energy_CC2_CCS_mlccsd public subroutine construct_orbital_energy_CC2_CCS_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: destruct_orbital_coef_CC2_CCS => destruct_orbital_coef_CC2_CCS_mlccsd public subroutine destruct_orbital_coef_CC2_CCS_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: destruct_orbital_energy_CC2_CCS => destruct_orbital_energy_CC2_CCS_mlccsd public subroutine destruct_orbital_energy_CC2_CCS_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: destruct_amplitudes => destruct_amplitudes_mlccsd public subroutine destruct_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: destruct_double_amplitudes => destruct_double_amplitudes_mlccsd public subroutine destruct_double_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: save_amplitudes => save_amplitudes_mlccsd public subroutine save_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: read_amplitudes => read_amplitudes_mlccsd public subroutine read_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: read_mlccsd_double_amplitudes => read_mlccsd_double_amplitudes_mlccsd public subroutine read_mlccsd_double_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: read_double_amplitudes => read_double_amplitudes_mlccsd public subroutine read_double_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf procedure, public :: jacobian_mlccsd_transformation => jacobian_mlccsd_transformation_mlccsd public interface jacobian_mlccsd_transformation_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_b2 => jacobian_mlccsd_b2_mlccsd public interface jacobian_mlccsd_b2_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_c2 => jacobian_mlccsd_c2_mlccsd public interface jacobian_mlccsd_c2_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_d2 => jacobian_mlccsd_d2_mlccsd public interface jacobian_mlccsd_d2_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_e2 => jacobian_mlccsd_e2_mlccsd public interface jacobian_mlccsd_e2_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_f2 => jacobian_mlccsd_f2_mlccsd public interface jacobian_mlccsd_f2_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_g2 => jacobian_mlccsd_g2_mlccsd public interface jacobian_mlccsd_g2_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_h2 => jacobian_mlccsd_h2_mlccsd public interface jacobian_mlccsd_h2_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_i2 => jacobian_mlccsd_i2_mlccsd public interface jacobian_mlccsd_i2_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_j2 => jacobian_mlccsd_j2_mlccsd public interface jacobian_mlccsd_j2_mlccsd () Arguments None procedure, public :: jacobian_mlccsd_k2 => jacobian_mlccsd_k2_mlccsd public interface jacobian_mlccsd_k2_mlccsd () Arguments None procedure, public :: transform_trial_vectors => transform_trial_vectors_mlccsd public interface transform_trial_vectors_mlccsd () Arguments None procedure, public :: initialize_excited_states => initialize_excited_states_mlccsd public interface initialize_excited_states_mlccsd () Arguments None procedure, public :: print_excitation_vector => print_excitation_vector_mlccsd public interface print_excitation_vector_mlccsd () Arguments None procedure, public :: summary_excited_state_info => summary_excited_state_info_mlccsd public interface summary_excited_state_info_mlccsd () Arguments None","tags":"","loc":"type/mlccsd.html","title":"mlccsd – The eT program "},{"text":"type, public, extends( ccs ) :: ccsd type~~ccsd~~InheritsGraph type~ccsd ccsd type~core_excited_state_specs core_excited_state_specs type~core_excited_state_specs->type~ccsd core_excited_state_specifications type~ccs ccs type~core_excited_state_specs->type~ccs core_excited_state_specifications type~hf hf type~core_excited_state_specs->type~hf core_excited_state_specifications type~response_calc_specs response_calc_specs type~response_calc_specs->type~ccsd response_specifications type~response_calc_specs->type~ccs response_specifications type~response_calc_specs->type~hf response_specifications type~calc_tasks calc_tasks type~calc_tasks->type~ccsd tasks, implemented type~calc_tasks->type~ccs tasks, implemented type~calc_tasks->type~hf tasks, implemented type~memory_manager memory_manager type~memory_manager->type~ccsd mem type~memory_manager->type~ccs mem type~memory_manager->type~hf mem type~excited_state_specs excited_state_specs type~excited_state_specs->type~ccsd excited_state_specifications type~excited_state_specs->type~ccs excited_state_specifications type~excited_state_specs->type~hf excited_state_specifications type~calc_settings calc_settings type~calc_settings->type~ccsd settings type~calc_settings->type~ccs settings type~calc_settings->type~hf settings type~ground_state_specs ground_state_specs type~ground_state_specs->type~ccsd ground_state_specifications type~ground_state_specs->type~ccs ground_state_specifications type~ground_state_specs->type~hf ground_state_specifications type~ccs->type~ccsd type~hf->type~ccs var pantypeccsdInheritsGraph = svgPanZoom('#typeccsdInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Inherited By type~~ccsd~~InheritedByGraph type~ccsd ccsd type~cc3 cc3 type~ccsd->type~cc3 type~ccsdpt ccsdpt type~cc3->type~ccsdpt Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented ground_state_specifications excited_state_specifications core_excited_state_specifications response_specifications mem n_t1am n_parameters t1am omega1 fock_ij fock_ia fock_ai fock_ab n_t2am t2am omega2 Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky construct_ao_fock construct_ao_fock_new construct_density_matrices construct_density_matrix construct_density_matrix_v drv ground_state_driver ground_state_solver ground_state_cleanup destruct_ground_state diis calc_ampeqs calc_quasi_Newton_singles excited_state_driver excited_state_solver excited_state_cleanup initialize_excited_states precondition_residual precondition_residual_valence print_excited_state_info analyze_single_excitation_vector initialize_trial_vectors initialize_trial_vectors_valence find_start_trial_indices trial_vectors_from_stored_solutions precondition_residual_core find_start_trial_indices_core find_core_mo initialize_trial_vectors_core solve_reduced_eigenvalue_equation construct_next_trial_vectors response_driver response_solver response_preparations initialize_response solve_reduced_response_equation construct_reduced_matrix construct_reduced_gradient construct_next_response_trial_vectors construct_gradient_vector general_specs_reader calculation_reader read_ground_state_specs read_excited_state_specs read_property_specs get_cholesky_ij get_cholesky_ia get_cholesky_ai get_cholesky_ab get_oo_oo get_oo_ov get_ov_oo get_oo_vo get_vo_oo get_oo_vv get_vv_oo get_ov_ov get_vo_vo get_ov_vo get_vo_ov get_ov_vv get_vv_ov get_vo_vv get_vv_vo get_vv_vv get_oo_oo_electronic_repulsion get_oo_ov_electronic_repulsion get_ov_oo_electronic_repulsion get_oo_vo_electronic_repulsion get_vo_oo_electronic_repulsion get_oo_vv_electronic_repulsion get_vv_oo_electronic_repulsion get_ov_ov_electronic_repulsion get_vo_vo_electronic_repulsion get_ov_vo_electronic_repulsion get_vo_ov_electronic_repulsion get_ov_vv_electronic_repulsion get_vv_ov_electronic_repulsion get_vo_vv_electronic_repulsion get_vv_vo_electronic_repulsion get_vv_vv_electronic_repulsion store_vv_vv_electronic_repulsion read_vv_vv_electronic_repulsion t1_transform_vv_vv store_t1_vv_vv_electronic_repulsion store_t1_vo_ov_electronic_repulsion store_t1_vv_vo_electronic_repulsion store_t1_vv_ov_electronic_repulsion read_t1_vv_vo_electronic_repulsion read_t1_vv_vv_electronic_repulsion read_t1_vo_ov_electronic_repulsion read_t1_vv_ov_electronic_repulsion initialize_fock_matrix construct_fock one_electron_t1 jacobian_ccs_transformation jacobian_ccs_a1 jacobian_ccs_b1 jacobian_transpose_ccs_transformation jacobian_transpose_ccs_a1 jacobian_transpose_ccs_b1 ionized_state_driver initialize_trial_vectors_core_ionization initialize_trial_vectors_valence_ionization precondition_residual_valence_ionization ionization_rho_a_i_projection precondition_residual_core_ionization cvs_rho_a_i_projection omega_ccs_a1 read_single_amplitudes init initialize_amplitudes initialize_omega initialize_ground_state calc_ampeqs_norm new_amplitudes calc_quasi_Newton_doubles ground_state_preparations construct_omega omega_ccsd_a1 omega_ccsd_b1 omega_ccsd_c1 omega_ccsd_a2 omega_ccsd_b2 omega_ccsd_c2 omega_ccsd_d2 omega_ccsd_e2 calculate_orbital_differences transform_trial_vectors print_excitation_vector analyze_double_excitation_vector summary_excited_state_info excited_state_preparations jacobian_ccsd_transformation jacobian_ccsd_a1 jacobian_ccsd_b1 jacobian_ccsd_c1 jacobian_ccsd_d1 jacobian_ccsd_a2 jacobian_ccsd_b2 jacobian_ccsd_c2 jacobian_ccsd_d2 jacobian_ccsd_e2 jacobian_ccsd_f2 jacobian_ccsd_g2 jacobian_ccsd_h2 jacobian_ccsd_i2 jacobian_ccsd_j2 jacobian_ccsd_k2 jacobi_test jacobian_transpose_ccsd_transformation jacobian_transpose_ccsd_a1 jacobian_transpose_ccsd_b1 jacobian_transpose_ccsd_c1 jacobian_transpose_ccsd_d1 jacobian_transpose_ccsd_e1 jacobian_transpose_ccsd_f1 jacobian_transpose_ccsd_g1 jacobian_transpose_ccsd_a2 jacobian_transpose_ccsd_b2 jacobian_transpose_ccsd_c2 jacobian_transpose_ccsd_d2 jacobian_transpose_ccsd_e2 jacobian_transpose_ccsd_f2 jacobian_transpose_ccsd_g2 jacobian_transpose_ccsd_h2 jacobian_transpose_ccsd_i2 ionization_residual_projection ionization_rho_aibj_projection cvs_rho_aibj_projection cvs_residual_projection construct_eta save_amplitudes read_amplitudes read_double_amplitudes destruct_amplitudes destruct_omega construct_perturbative_doubles calc_energy Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public :: drv => drv_ccs public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: ground_state_driver => ground_state_driver_ccs public interface ground_state_driver_ccs () Arguments None procedure, public :: ground_state_solver => ground_state_solver_ccs public interface ground_state_solver_ccs () Arguments None procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs public interface ground_state_cleanup_ccs () Arguments None procedure, public :: destruct_ground_state => destruct_ground_state_ccs public interface destruct_ground_state_ccs () Arguments None procedure, public, non_overridable :: diis => diis_ccs public interface diis_ccs () Arguments None procedure, public :: calc_ampeqs => calc_ampeqs_ccs public interface calc_ampeqs_ccs () Arguments None procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs public interface calc_quasi_Newton_singles_ccs () Arguments None procedure, public :: excited_state_driver => excited_state_driver_ccs public interface excited_state_driver_ccs () Arguments None procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs public interface excited_state_solver_ccs () Arguments None procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs public interface excited_state_cleanup_ccs () Arguments None procedure, public :: initialize_excited_states => initialize_excited_states_ccs public interface initialize_excited_states_ccs () Arguments None procedure, public :: precondition_residual => precondition_residual_ccs public interface precondition_residual_ccs () Arguments None procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs public interface precondition_residual_valence_ccs () Arguments None procedure, public :: print_excited_state_info => print_excited_state_info_ccs public interface print_excited_state_info_ccs () Arguments None procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs public interface analyze_single_excitation_vector_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs public interface initialize_trial_vectors_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs public interface initialize_trial_vectors_valence_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs public interface find_start_trial_indices_ccs () Arguments None procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs public interface trial_vectors_from_stored_solutions_ccs () Arguments None procedure, public :: precondition_residual_core => precondition_residual_core_ccs public interface precondition_residual_core_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs public interface find_start_trial_indices_core_ccs () Arguments None procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs public interface find_core_mo_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs public interface initialize_trial_vectors_core_ccs () Arguments None procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs public interface solve_reduced_eigenvalue_equation_ccs () Arguments None procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs public interface construct_next_trial_vectors_ccs () Arguments None procedure, public :: response_driver => response_driver_ccs public interface response_driver_ccs () Arguments None procedure, public :: response_solver => response_solver_ccs public interface response_solver_ccs () Arguments None procedure, public :: response_preparations => response_preparations_ccs public interface response_preparations_ccs () Arguments None procedure, public :: initialize_response => initialize_response_ccs public interface initialize_response_ccs () Arguments None procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs public interface solve_reduced_response_equation_ccs () Arguments None procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs public interface construct_reduced_matrix_ccs () Arguments None procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs public interface construct_reduced_gradient_ccs () Arguments None procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs public interface construct_next_response_trial_vectors_ccs () Arguments None procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs public interface construct_gradient_vector_ccs () Arguments None procedure, public :: general_specs_reader => general_specs_reader_ccs public interface general_specs_reader_ccs () Arguments None procedure, public :: calculation_reader => calculation_reader_ccs public interface calculation_reader_ccs () Arguments None procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs public interface read_ground_state_specs_ccs () Arguments None procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs public interface read_excited_state_specs_ccs () Arguments None procedure, public :: read_property_specs => read_property_specs_ccs public interface read_property_specs_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs public interface get_cholesky_ij_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs public interface get_cholesky_ia_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs public interface get_cholesky_ai_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs public interface get_cholesky_ab_ccs () Arguments None procedure, public :: get_oo_oo => get_oo_oo_ccs public interface get_oo_oo_ccs () Arguments None procedure, public :: get_oo_ov => get_oo_ov_ccs public interface get_oo_ov_ccs () Arguments None procedure, public :: get_ov_oo => get_ov_oo_ccs public interface get_ov_oo_ccs () Arguments None procedure, public :: get_oo_vo => get_oo_vo_ccs public interface get_oo_vo_ccs () Arguments None procedure, public :: get_vo_oo => get_vo_oo_ccs public interface get_vo_oo_ccs () Arguments None procedure, public :: get_oo_vv => get_oo_vv_ccs public interface get_oo_vv_ccs () Arguments None procedure, public :: get_vv_oo => get_vv_oo_ccs public interface get_vv_oo_ccs () Arguments None procedure, public :: get_ov_ov => get_ov_ov_ccs public interface get_ov_ov_ccs () Arguments None procedure, public :: get_vo_vo => get_vo_vo_ccs public interface get_vo_vo_ccs () Arguments None procedure, public :: get_ov_vo => get_ov_vo_ccs public interface get_ov_vo_ccs () Arguments None procedure, public :: get_vo_ov => get_vo_ov_ccs public interface get_vo_ov_ccs () Arguments None procedure, public :: get_ov_vv => get_ov_vv_ccs public interface get_ov_vv_ccs () Arguments None procedure, public :: get_vv_ov => get_vv_ov_ccs public interface get_vv_ov_ccs () Arguments None procedure, public :: get_vo_vv => get_vo_vv_ccs public interface get_vo_vv_ccs () Arguments None procedure, public :: get_vv_vo => get_vv_vo_ccs public interface get_vv_vo_ccs () Arguments None procedure, public :: get_vv_vv => get_vv_vv_ccs public interface get_vv_vv_ccs () Arguments None procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs public interface get_oo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs public interface get_oo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs public interface get_ov_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs public interface get_oo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs public interface get_vo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs public interface get_oo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs public interface get_vv_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs public interface get_ov_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs public interface get_vo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs public interface get_ov_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs public interface get_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs public interface get_ov_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs public interface get_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs public interface get_vo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs public interface get_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs public interface get_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs public interface store_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs public interface read_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs public interface t1_transform_vv_vv_ccs () Arguments None procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs public interface store_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs public interface store_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs public interface store_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs public interface store_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs public interface read_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs public interface read_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs public interface read_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs public interface read_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs public interface initialize_fock_matrix_ccs () Arguments None procedure, public, non_overridable :: construct_fock => construct_fock_ccs public interface construct_fock_ccs () Arguments None procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs public interface one_electron_t1_ccs () Arguments None procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs public interface jacobian_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs public interface jacobian_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs public interface jacobian_ccs_b1_ccs () Arguments None procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs public interface jacobian_transpose_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs public interface jacobian_transpose_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs public interface jacobian_transpose_ccs_b1_ccs () Arguments None procedure, public :: ionized_state_driver => ionized_state_driver_ccs public interface ionized_state_driver_ccs () Arguments None procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs public interface initialize_trial_vectors_core_ionization_ccs () Arguments None procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs public interface initialize_trial_vectors_valence_ionization_ccs () Arguments None procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs public interface precondition_residual_valence_ionization_ccs () Arguments None procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs public interface ionization_rho_a_i_projection_ccs () Arguments None procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs public interface precondition_residual_core_ionization_ccs () Arguments None procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs public interface cvs_rho_a_i_projection_ccs () Arguments None procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs public subroutine omega_ccs_a1_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs public subroutine read_single_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: init => init_ccsd public subroutine init_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: initialize_amplitudes => initialize_amplitudes_ccsd public subroutine initialize_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: initialize_omega => initialize_omega_ccsd public interface initialize_omega_ccsd () Arguments None procedure, public :: initialize_ground_state => initialize_ground_state_ccsd public interface initialize_ground_state_ccsd () Arguments None procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd public interface calc_ampeqs_norm_ccsd () Arguments None procedure, public :: new_amplitudes => new_amplitudes_ccsd public interface new_amplitudes_ccsd () Arguments None procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd public interface calc_quasi_Newton_doubles_ccsd () Arguments None procedure, public :: ground_state_preparations => ground_state_preparations_ccsd public interface ground_state_preparations_ccsd () Arguments None procedure, public :: construct_omega => construct_omega_ccsd public interface construct_omega_ccsd () Arguments None procedure, public :: omega_ccsd_a1 => omega_ccsd_a1_ccsd public interface omega_ccsd_a1_ccsd () Arguments None procedure, public :: omega_ccsd_b1 => omega_ccsd_b1_ccsd public interface omega_ccsd_b1_ccsd () Arguments None procedure, public :: omega_ccsd_c1 => omega_ccsd_c1_ccsd public interface omega_ccsd_c1_ccsd () Arguments None procedure, public :: omega_ccsd_a2 => omega_ccsd_a2_ccsd public interface omega_ccsd_a2_ccsd () Arguments None procedure, public :: omega_ccsd_b2 => omega_ccsd_b2_ccsd public interface omega_ccsd_b2_ccsd () Arguments None procedure, public :: omega_ccsd_c2 => omega_ccsd_c2_ccsd public interface omega_ccsd_c2_ccsd () Arguments None procedure, public :: omega_ccsd_d2 => omega_ccsd_d2_ccsd public interface omega_ccsd_d2_ccsd () Arguments None procedure, public :: omega_ccsd_e2 => omega_ccsd_e2_ccsd public interface omega_ccsd_e2_ccsd () Arguments None procedure, public :: calculate_orbital_differences => calculate_orbital_differences_ccsd public interface calculate_orbital_differences_ccsd () Arguments None procedure, public :: transform_trial_vectors => transform_trial_vectors_ccsd public interface transform_trial_vectors_ccsd () Arguments None procedure, public :: print_excitation_vector => print_excitation_vector_ccsd public interface print_excitation_vector_ccsd () Arguments None procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_ccsd public interface analyze_double_excitation_vector_ccsd () Arguments None procedure, public :: summary_excited_state_info => summary_excited_state_info_ccsd public interface summary_excited_state_info_ccsd () Arguments None procedure, public :: excited_state_preparations => excited_state_preparations_ccsd public interface excited_state_preparations_ccsd () Arguments None procedure, public :: jacobian_ccsd_transformation => jacobian_ccsd_transformation_ccsd public interface jacobian_ccsd_transformation_ccsd () Arguments None procedure, public :: jacobian_ccsd_a1 => jacobian_ccsd_a1_ccsd public interface jacobian_ccsd_a1_ccsd () Arguments None procedure, public :: jacobian_ccsd_b1 => jacobian_ccsd_b1_ccsd public interface jacobian_ccsd_b1_ccsd () Arguments None procedure, public :: jacobian_ccsd_c1 => jacobian_ccsd_c1_ccsd public interface jacobian_ccsd_c1_ccsd () Arguments None procedure, public :: jacobian_ccsd_d1 => jacobian_ccsd_d1_ccsd public interface jacobian_ccsd_d1_ccsd () Arguments None procedure, public :: jacobian_ccsd_a2 => jacobian_ccsd_a2_ccsd public interface jacobian_ccsd_a2_ccsd () Arguments None procedure, public :: jacobian_ccsd_b2 => jacobian_ccsd_b2_ccsd public interface jacobian_ccsd_b2_ccsd () Arguments None procedure, public :: jacobian_ccsd_c2 => jacobian_ccsd_c2_ccsd public interface jacobian_ccsd_c2_ccsd () Arguments None procedure, public :: jacobian_ccsd_d2 => jacobian_ccsd_d2_ccsd public interface jacobian_ccsd_d2_ccsd () Arguments None procedure, public :: jacobian_ccsd_e2 => jacobian_ccsd_e2_ccsd public interface jacobian_ccsd_e2_ccsd () Arguments None procedure, public :: jacobian_ccsd_f2 => jacobian_ccsd_f2_ccsd public interface jacobian_ccsd_f2_ccsd () Arguments None procedure, public :: jacobian_ccsd_g2 => jacobian_ccsd_g2_ccsd public interface jacobian_ccsd_g2_ccsd () Arguments None procedure, public :: jacobian_ccsd_h2 => jacobian_ccsd_h2_ccsd public interface jacobian_ccsd_h2_ccsd () Arguments None procedure, public :: jacobian_ccsd_i2 => jacobian_ccsd_i2_ccsd public interface jacobian_ccsd_i2_ccsd () Arguments None procedure, public :: jacobian_ccsd_j2 => jacobian_ccsd_j2_ccsd public interface jacobian_ccsd_j2_ccsd () Arguments None procedure, public :: jacobian_ccsd_k2 => jacobian_ccsd_k2_ccsd public interface jacobian_ccsd_k2_ccsd () Arguments None procedure, public :: jacobi_test => jacobi_test_ccsd public subroutine jacobi_test_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: jacobian_transpose_ccsd_transformation => jacobian_transpose_ccsd_transformation_ccsd public interface jacobian_transpose_ccsd_transformation_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_a1 => jacobian_transpose_ccsd_a1_ccsd public interface jacobian_transpose_ccsd_a1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_b1 => jacobian_transpose_ccsd_b1_ccsd public interface jacobian_transpose_ccsd_b1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_c1 => jacobian_transpose_ccsd_c1_ccsd public interface jacobian_transpose_ccsd_c1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_d1 => jacobian_transpose_ccsd_d1_ccsd public interface jacobian_transpose_ccsd_d1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_e1 => jacobian_transpose_ccsd_e1_ccsd public interface jacobian_transpose_ccsd_e1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_f1 => jacobian_transpose_ccsd_f1_ccsd public interface jacobian_transpose_ccsd_f1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_g1 => jacobian_transpose_ccsd_g1_ccsd public interface jacobian_transpose_ccsd_g1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_a2 => jacobian_transpose_ccsd_a2_ccsd public interface jacobian_transpose_ccsd_a2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_b2 => jacobian_transpose_ccsd_b2_ccsd public interface jacobian_transpose_ccsd_b2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_c2 => jacobian_transpose_ccsd_c2_ccsd public interface jacobian_transpose_ccsd_c2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_d2 => jacobian_transpose_ccsd_d2_ccsd public interface jacobian_transpose_ccsd_d2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_e2 => jacobian_transpose_ccsd_e2_ccsd public interface jacobian_transpose_ccsd_e2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_f2 => jacobian_transpose_ccsd_f2_ccsd public interface jacobian_transpose_ccsd_f2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_g2 => jacobian_transpose_ccsd_g2_ccsd public interface jacobian_transpose_ccsd_g2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_h2 => jacobian_transpose_ccsd_h2_ccsd public interface jacobian_transpose_ccsd_h2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_i2 => jacobian_transpose_ccsd_i2_ccsd public interface jacobian_transpose_ccsd_i2_ccsd () Arguments None procedure, public :: ionization_residual_projection => ionization_residual_projection_ccsd public interface ionization_residual_projection_ccsd () Arguments None procedure, public :: ionization_rho_aibj_projection => ionization_rho_aibj_projection_ccsd public interface ionization_rho_aibj_projection_ccsd () Arguments None procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_ccsd public interface cvs_rho_aibj_projection_ccsd () Arguments None procedure, public :: cvs_residual_projection => cvs_residual_projection_ccsd public interface cvs_residual_projection_ccsd () Arguments None procedure, public :: construct_eta => construct_eta_ccsd public subroutine construct_eta_ccsd (wf, eta) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta procedure, public :: save_amplitudes => save_amplitudes_ccsd public subroutine save_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: read_amplitudes => read_amplitudes_ccsd public subroutine read_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: read_double_amplitudes => read_double_amplitudes_ccsd public subroutine read_double_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: destruct_amplitudes => destruct_amplitudes_ccsd public subroutine destruct_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: destruct_omega => destruct_omega_ccsd public subroutine destruct_omega_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: construct_perturbative_doubles => construct_perturbative_doubles_ccsd public subroutine construct_perturbative_doubles_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: calc_energy => calc_energy_ccsd public subroutine calc_energy_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"type/ccsd.html","title":"ccsd – The eT program "},{"text":"type, public, extends( hf ) :: ccs type~~ccs~~InheritsGraph type~ccs ccs type~core_excited_state_specs core_excited_state_specs type~core_excited_state_specs->type~ccs core_excited_state_specifications type~hf hf type~core_excited_state_specs->type~hf core_excited_state_specifications type~response_calc_specs response_calc_specs type~response_calc_specs->type~ccs response_specifications type~response_calc_specs->type~hf response_specifications type~calc_tasks calc_tasks type~calc_tasks->type~ccs tasks, implemented type~calc_tasks->type~hf tasks, implemented type~memory_manager memory_manager type~memory_manager->type~ccs mem type~memory_manager->type~hf mem type~excited_state_specs excited_state_specs type~excited_state_specs->type~ccs excited_state_specifications type~excited_state_specs->type~hf excited_state_specifications type~calc_settings calc_settings type~calc_settings->type~ccs settings type~calc_settings->type~hf settings type~ground_state_specs ground_state_specs type~ground_state_specs->type~ccs ground_state_specifications type~ground_state_specs->type~hf ground_state_specifications type~hf->type~ccs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Inherited By type~~ccs~~InheritedByGraph type~ccs ccs type~cc2 cc2 type~ccs->type~cc2 type~mlcc2 mlcc2 type~ccs->type~mlcc2 type~ccsd ccsd type~ccs->type~ccsd type~mlccsd mlccsd type~mlcc2->type~mlccsd type~cc3 cc3 type~ccsd->type~cc3 type~ccsdpt ccsdpt type~cc3->type~ccsdpt Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented ground_state_specifications excited_state_specifications core_excited_state_specifications response_specifications mem n_t1am n_parameters t1am omega1 fock_ij fock_ia fock_ai fock_ab Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky construct_ao_fock construct_ao_fock_new construct_density_matrices construct_density_matrix construct_density_matrix_v init drv initialize_amplitudes initialize_omega ground_state_driver ground_state_solver ground_state_preparations ground_state_cleanup initialize_ground_state destruct_ground_state diis new_amplitudes calc_ampeqs calc_ampeqs_norm calc_quasi_Newton_singles calc_energy excited_state_driver excited_state_solver excited_state_preparations excited_state_cleanup initialize_excited_states transform_trial_vectors calculate_orbital_differences precondition_residual precondition_residual_valence print_excited_state_info print_excitation_vector analyze_single_excitation_vector summary_excited_state_info initialize_trial_vectors initialize_trial_vectors_valence find_start_trial_indices trial_vectors_from_stored_solutions precondition_residual_core find_start_trial_indices_core find_core_mo initialize_trial_vectors_core solve_reduced_eigenvalue_equation construct_next_trial_vectors response_driver response_solver response_preparations initialize_response solve_reduced_response_equation construct_reduced_matrix construct_reduced_gradient construct_next_response_trial_vectors construct_gradient_vector general_specs_reader calculation_reader read_ground_state_specs read_excited_state_specs read_property_specs get_cholesky_ij get_cholesky_ia get_cholesky_ai get_cholesky_ab get_oo_oo get_oo_ov get_ov_oo get_oo_vo get_vo_oo get_oo_vv get_vv_oo get_ov_ov get_vo_vo get_ov_vo get_vo_ov get_ov_vv get_vv_ov get_vo_vv get_vv_vo get_vv_vv get_oo_oo_electronic_repulsion get_oo_ov_electronic_repulsion get_ov_oo_electronic_repulsion get_oo_vo_electronic_repulsion get_vo_oo_electronic_repulsion get_oo_vv_electronic_repulsion get_vv_oo_electronic_repulsion get_ov_ov_electronic_repulsion get_vo_vo_electronic_repulsion get_ov_vo_electronic_repulsion get_vo_ov_electronic_repulsion get_ov_vv_electronic_repulsion get_vv_ov_electronic_repulsion get_vo_vv_electronic_repulsion get_vv_vo_electronic_repulsion get_vv_vv_electronic_repulsion store_vv_vv_electronic_repulsion read_vv_vv_electronic_repulsion t1_transform_vv_vv store_t1_vv_vv_electronic_repulsion store_t1_vo_ov_electronic_repulsion store_t1_vv_vo_electronic_repulsion store_t1_vv_ov_electronic_repulsion read_t1_vv_vo_electronic_repulsion read_t1_vv_vv_electronic_repulsion read_t1_vo_ov_electronic_repulsion read_t1_vv_ov_electronic_repulsion initialize_fock_matrix construct_fock one_electron_t1 jacobian_ccs_transformation jacobian_ccs_a1 jacobian_ccs_b1 jacobi_test jacobian_transpose_ccs_transformation jacobian_transpose_ccs_a1 jacobian_transpose_ccs_b1 ionized_state_driver initialize_trial_vectors_core_ionization initialize_trial_vectors_valence_ionization precondition_residual_valence_ionization ionization_residual_projection ionization_rho_a_i_projection precondition_residual_core_ionization cvs_rho_a_i_projection cvs_residual_projection construct_omega omega_ccs_a1 construct_eta save_amplitudes read_amplitudes read_single_amplitudes destruct_amplitudes destruct_omega Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public :: init => init_ccs public subroutine init_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: drv => drv_ccs public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_amplitudes => initialize_amplitudes_ccs public subroutine initialize_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_omega => initialize_omega_ccs public subroutine initialize_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: ground_state_driver => ground_state_driver_ccs public interface ground_state_driver_ccs () Arguments None procedure, public :: ground_state_solver => ground_state_solver_ccs public interface ground_state_solver_ccs () Arguments None procedure, public :: ground_state_preparations => ground_state_preparations_ccs public interface ground_state_preparations_ccs () Arguments None procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs public interface ground_state_cleanup_ccs () Arguments None procedure, public :: initialize_ground_state => initialize_ground_state_ccs public interface initialize_ground_state_ccs () Arguments None procedure, public :: destruct_ground_state => destruct_ground_state_ccs public interface destruct_ground_state_ccs () Arguments None procedure, public, non_overridable :: diis => diis_ccs public interface diis_ccs () Arguments None procedure, public :: new_amplitudes => new_amplitudes_ccs public interface new_amplitudes_ccs () Arguments None procedure, public :: calc_ampeqs => calc_ampeqs_ccs public interface calc_ampeqs_ccs () Arguments None procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccs public interface calc_ampeqs_norm_ccs () Arguments None procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs public interface calc_quasi_Newton_singles_ccs () Arguments None procedure, public :: calc_energy => calc_energy_ccs public subroutine calc_energy_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: excited_state_driver => excited_state_driver_ccs public interface excited_state_driver_ccs () Arguments None procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs public interface excited_state_solver_ccs () Arguments None procedure, public :: excited_state_preparations => excited_state_preparations_ccs public interface excited_state_preparations_ccs () Arguments None procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs public interface excited_state_cleanup_ccs () Arguments None procedure, public :: initialize_excited_states => initialize_excited_states_ccs public interface initialize_excited_states_ccs () Arguments None procedure, public :: transform_trial_vectors => transform_trial_vectors_ccs public interface transform_trial_vectors_ccs () Arguments None procedure, public :: calculate_orbital_differences => calculate_orbital_differences_ccs public interface calculate_orbital_differences_ccs () Arguments None procedure, public :: precondition_residual => precondition_residual_ccs public interface precondition_residual_ccs () Arguments None procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs public interface precondition_residual_valence_ccs () Arguments None procedure, public :: print_excited_state_info => print_excited_state_info_ccs public interface print_excited_state_info_ccs () Arguments None procedure, public :: print_excitation_vector => print_excitation_vector_ccs public interface print_excitation_vector_ccs () Arguments None procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs public interface analyze_single_excitation_vector_ccs () Arguments None procedure, public :: summary_excited_state_info => summary_excited_state_info_ccs public interface summary_excited_state_info_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs public interface initialize_trial_vectors_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs public interface initialize_trial_vectors_valence_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs public interface find_start_trial_indices_ccs () Arguments None procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs public interface trial_vectors_from_stored_solutions_ccs () Arguments None procedure, public :: precondition_residual_core => precondition_residual_core_ccs public interface precondition_residual_core_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs public interface find_start_trial_indices_core_ccs () Arguments None procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs public interface find_core_mo_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs public interface initialize_trial_vectors_core_ccs () Arguments None procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs public interface solve_reduced_eigenvalue_equation_ccs () Arguments None procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs public interface construct_next_trial_vectors_ccs () Arguments None procedure, public :: response_driver => response_driver_ccs public interface response_driver_ccs () Arguments None procedure, public :: response_solver => response_solver_ccs public interface response_solver_ccs () Arguments None procedure, public :: response_preparations => response_preparations_ccs public interface response_preparations_ccs () Arguments None procedure, public :: initialize_response => initialize_response_ccs public interface initialize_response_ccs () Arguments None procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs public interface solve_reduced_response_equation_ccs () Arguments None procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs public interface construct_reduced_matrix_ccs () Arguments None procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs public interface construct_reduced_gradient_ccs () Arguments None procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs public interface construct_next_response_trial_vectors_ccs () Arguments None procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs public interface construct_gradient_vector_ccs () Arguments None procedure, public :: general_specs_reader => general_specs_reader_ccs public interface general_specs_reader_ccs () Arguments None procedure, public :: calculation_reader => calculation_reader_ccs public interface calculation_reader_ccs () Arguments None procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs public interface read_ground_state_specs_ccs () Arguments None procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs public interface read_excited_state_specs_ccs () Arguments None procedure, public :: read_property_specs => read_property_specs_ccs public interface read_property_specs_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs public interface get_cholesky_ij_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs public interface get_cholesky_ia_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs public interface get_cholesky_ai_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs public interface get_cholesky_ab_ccs () Arguments None procedure, public :: get_oo_oo => get_oo_oo_ccs public interface get_oo_oo_ccs () Arguments None procedure, public :: get_oo_ov => get_oo_ov_ccs public interface get_oo_ov_ccs () Arguments None procedure, public :: get_ov_oo => get_ov_oo_ccs public interface get_ov_oo_ccs () Arguments None procedure, public :: get_oo_vo => get_oo_vo_ccs public interface get_oo_vo_ccs () Arguments None procedure, public :: get_vo_oo => get_vo_oo_ccs public interface get_vo_oo_ccs () Arguments None procedure, public :: get_oo_vv => get_oo_vv_ccs public interface get_oo_vv_ccs () Arguments None procedure, public :: get_vv_oo => get_vv_oo_ccs public interface get_vv_oo_ccs () Arguments None procedure, public :: get_ov_ov => get_ov_ov_ccs public interface get_ov_ov_ccs () Arguments None procedure, public :: get_vo_vo => get_vo_vo_ccs public interface get_vo_vo_ccs () Arguments None procedure, public :: get_ov_vo => get_ov_vo_ccs public interface get_ov_vo_ccs () Arguments None procedure, public :: get_vo_ov => get_vo_ov_ccs public interface get_vo_ov_ccs () Arguments None procedure, public :: get_ov_vv => get_ov_vv_ccs public interface get_ov_vv_ccs () Arguments None procedure, public :: get_vv_ov => get_vv_ov_ccs public interface get_vv_ov_ccs () Arguments None procedure, public :: get_vo_vv => get_vo_vv_ccs public interface get_vo_vv_ccs () Arguments None procedure, public :: get_vv_vo => get_vv_vo_ccs public interface get_vv_vo_ccs () Arguments None procedure, public :: get_vv_vv => get_vv_vv_ccs public interface get_vv_vv_ccs () Arguments None procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs public interface get_oo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs public interface get_oo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs public interface get_ov_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs public interface get_oo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs public interface get_vo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs public interface get_oo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs public interface get_vv_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs public interface get_ov_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs public interface get_vo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs public interface get_ov_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs public interface get_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs public interface get_ov_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs public interface get_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs public interface get_vo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs public interface get_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs public interface get_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs public interface store_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs public interface read_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs public interface t1_transform_vv_vv_ccs () Arguments None procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs public interface store_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs public interface store_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs public interface store_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs public interface store_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs public interface read_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs public interface read_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs public interface read_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs public interface read_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs public interface initialize_fock_matrix_ccs () Arguments None procedure, public, non_overridable :: construct_fock => construct_fock_ccs public interface construct_fock_ccs () Arguments None procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs public interface one_electron_t1_ccs () Arguments None procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs public interface jacobian_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs public interface jacobian_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs public interface jacobian_ccs_b1_ccs () Arguments None procedure, public :: jacobi_test => jacobi_test_ccs public subroutine jacobi_test_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs public interface jacobian_transpose_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs public interface jacobian_transpose_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs public interface jacobian_transpose_ccs_b1_ccs () Arguments None procedure, public :: ionized_state_driver => ionized_state_driver_ccs public interface ionized_state_driver_ccs () Arguments None procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs public interface initialize_trial_vectors_core_ionization_ccs () Arguments None procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs public interface initialize_trial_vectors_valence_ionization_ccs () Arguments None procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs public interface precondition_residual_valence_ionization_ccs () Arguments None procedure, public :: ionization_residual_projection => ionization_residual_projection_ccs public interface ionization_residual_projection_ccs () Arguments None procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs public interface ionization_rho_a_i_projection_ccs () Arguments None procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs public interface precondition_residual_core_ionization_ccs () Arguments None procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs public interface cvs_rho_a_i_projection_ccs () Arguments None procedure, public :: cvs_residual_projection => cvs_residual_projection_ccs public interface cvs_residual_projection_ccs () Arguments None procedure, public :: construct_omega => construct_omega_ccs public subroutine construct_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs public subroutine omega_ccs_a1_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: construct_eta => construct_eta_ccs public subroutine construct_eta_ccs (wf, eta) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta procedure, public :: save_amplitudes => save_amplitudes_ccs public subroutine save_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: read_amplitudes => read_amplitudes_ccs public subroutine read_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs public subroutine read_single_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: destruct_amplitudes => destruct_amplitudes_ccs public subroutine destruct_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: destruct_omega => destruct_omega_ccs public subroutine destruct_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"type/ccs.html","title":"ccs – The eT program "},{"text":"type, public, extends( hf ) :: mp2 type~~mp2~~InheritsGraph type~mp2 mp2 type~core_excited_state_specs core_excited_state_specs type~core_excited_state_specs->type~mp2 core_excited_state_specifications type~hf hf type~core_excited_state_specs->type~hf core_excited_state_specifications type~response_calc_specs response_calc_specs type~response_calc_specs->type~mp2 response_specifications type~response_calc_specs->type~hf response_specifications type~calc_tasks calc_tasks type~calc_tasks->type~mp2 tasks, implemented type~calc_tasks->type~hf tasks, implemented type~memory_manager memory_manager type~memory_manager->type~mp2 mem type~memory_manager->type~hf mem type~excited_state_specs excited_state_specs type~excited_state_specs->type~mp2 excited_state_specifications type~excited_state_specs->type~hf excited_state_specifications type~calc_settings calc_settings type~calc_settings->type~mp2 settings type~calc_settings->type~hf settings type~ground_state_specs ground_state_specs type~ground_state_specs->type~mp2 ground_state_specifications type~ground_state_specs->type~hf ground_state_specifications type~hf->type~mp2 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented ground_state_specifications excited_state_specifications core_excited_state_specifications response_specifications mem Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky construct_ao_fock construct_ao_fock_new construct_density_matrices construct_density_matrix construct_density_matrix_v init drv calc_energy Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public :: init => init_mp2 public subroutine init_mp2 (wf) Arguments Type Intent Optional Attributes Name class( mp2 ) :: wf procedure, public :: drv => drv_mp2 public subroutine drv_mp2 (wf) Arguments Type Intent Optional Attributes Name class( mp2 ) :: wf procedure, public :: calc_energy => calc_energy_mp2 public subroutine calc_energy_mp2 (wf) Arguments Type Intent Optional Attributes Name class( mp2 ) :: wf","tags":"","loc":"type/mp2.html","title":"mp2 – The eT program "},{"text":"type, public, extends( ccs ) :: cc2 type~~cc2~~InheritsGraph type~cc2 cc2 type~core_excited_state_specs core_excited_state_specs type~core_excited_state_specs->type~cc2 core_excited_state_specifications type~ccs ccs type~core_excited_state_specs->type~ccs core_excited_state_specifications type~hf hf type~core_excited_state_specs->type~hf core_excited_state_specifications type~response_calc_specs response_calc_specs type~response_calc_specs->type~cc2 response_specifications type~response_calc_specs->type~ccs response_specifications type~response_calc_specs->type~hf response_specifications type~calc_tasks calc_tasks type~calc_tasks->type~cc2 tasks, implemented type~calc_tasks->type~ccs tasks, implemented type~calc_tasks->type~hf tasks, implemented type~memory_manager memory_manager type~memory_manager->type~cc2 mem type~memory_manager->type~ccs mem type~memory_manager->type~hf mem type~excited_state_specs excited_state_specs type~excited_state_specs->type~cc2 excited_state_specifications type~excited_state_specs->type~ccs excited_state_specifications type~excited_state_specs->type~hf excited_state_specifications type~calc_settings calc_settings type~calc_settings->type~cc2 settings type~calc_settings->type~ccs settings type~calc_settings->type~hf settings type~ground_state_specs ground_state_specs type~ground_state_specs->type~cc2 ground_state_specifications type~ground_state_specs->type~ccs ground_state_specifications type~ground_state_specs->type~hf ground_state_specifications type~ccs->type~cc2 type~hf->type~ccs var pantypecc2InheritsGraph = svgPanZoom('#typecc2InheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented ground_state_specifications excited_state_specifications core_excited_state_specifications response_specifications mem n_t1am n_parameters t1am omega1 fock_ij fock_ia fock_ai fock_ab s2am n_s2am Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky construct_ao_fock construct_ao_fock_new construct_density_matrices construct_density_matrix construct_density_matrix_v drv initialize_amplitudes initialize_omega ground_state_driver ground_state_solver ground_state_preparations ground_state_cleanup initialize_ground_state destruct_ground_state diis new_amplitudes calc_ampeqs calc_ampeqs_norm calc_quasi_Newton_singles excited_state_driver excited_state_solver excited_state_cleanup precondition_residual precondition_residual_valence print_excited_state_info print_excitation_vector analyze_single_excitation_vector initialize_trial_vectors initialize_trial_vectors_valence find_start_trial_indices trial_vectors_from_stored_solutions precondition_residual_core find_start_trial_indices_core find_core_mo initialize_trial_vectors_core solve_reduced_eigenvalue_equation construct_next_trial_vectors response_driver response_solver response_preparations initialize_response solve_reduced_response_equation construct_reduced_matrix construct_reduced_gradient construct_next_response_trial_vectors construct_gradient_vector general_specs_reader calculation_reader read_ground_state_specs read_excited_state_specs read_property_specs get_cholesky_ij get_cholesky_ia get_cholesky_ai get_cholesky_ab get_oo_oo get_oo_ov get_ov_oo get_oo_vo get_vo_oo get_oo_vv get_vv_oo get_ov_ov get_vo_vo get_ov_vo get_vo_ov get_ov_vv get_vv_ov get_vo_vv get_vv_vo get_vv_vv get_oo_oo_electronic_repulsion get_oo_ov_electronic_repulsion get_ov_oo_electronic_repulsion get_oo_vo_electronic_repulsion get_vo_oo_electronic_repulsion get_oo_vv_electronic_repulsion get_vv_oo_electronic_repulsion get_ov_ov_electronic_repulsion get_vo_vo_electronic_repulsion get_ov_vo_electronic_repulsion get_vo_ov_electronic_repulsion get_ov_vv_electronic_repulsion get_vv_ov_electronic_repulsion get_vo_vv_electronic_repulsion get_vv_vo_electronic_repulsion get_vv_vv_electronic_repulsion store_vv_vv_electronic_repulsion read_vv_vv_electronic_repulsion t1_transform_vv_vv store_t1_vv_vv_electronic_repulsion store_t1_vo_ov_electronic_repulsion store_t1_vv_vo_electronic_repulsion store_t1_vv_ov_electronic_repulsion read_t1_vv_vo_electronic_repulsion read_t1_vv_vv_electronic_repulsion read_t1_vo_ov_electronic_repulsion read_t1_vv_ov_electronic_repulsion initialize_fock_matrix construct_fock one_electron_t1 jacobian_ccs_transformation jacobian_ccs_a1 jacobian_ccs_b1 jacobi_test jacobian_transpose_ccs_transformation jacobian_transpose_ccs_a1 jacobian_transpose_ccs_b1 ionized_state_driver initialize_trial_vectors_core_ionization initialize_trial_vectors_valence_ionization precondition_residual_valence_ionization ionization_residual_projection ionization_rho_a_i_projection precondition_residual_core_ionization cvs_rho_a_i_projection omega_ccs_a1 construct_eta read_single_amplitudes destruct_amplitudes destruct_omega init construct_omega omega_cc2_a1 omega_cc2_b1 get_s2am read_cc2_double_amplitudes read_amplitudes save_amplitudes destruct_s2am calc_energy jacobian_cc2_transformation cvs_rho_aibj_projection jacobian_cc2_a1 jacobian_cc2_b1 jacobian_cc2_a2 jacobian_cc2_b2 initialize_excited_states calculate_orbital_differences transform_trial_vectors cvs_residual_projection excited_state_preparations analyze_double_excitation_vector summary_excited_state_info Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab real(kind=dp), public, dimension(:,:), allocatable :: s2am integer(kind=dp), public :: n_s2am Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public :: drv => drv_ccs public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_amplitudes => initialize_amplitudes_ccs public subroutine initialize_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_omega => initialize_omega_ccs public subroutine initialize_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: ground_state_driver => ground_state_driver_ccs public interface ground_state_driver_ccs () Arguments None procedure, public :: ground_state_solver => ground_state_solver_ccs public interface ground_state_solver_ccs () Arguments None procedure, public :: ground_state_preparations => ground_state_preparations_ccs public interface ground_state_preparations_ccs () Arguments None procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs public interface ground_state_cleanup_ccs () Arguments None procedure, public :: initialize_ground_state => initialize_ground_state_ccs public interface initialize_ground_state_ccs () Arguments None procedure, public :: destruct_ground_state => destruct_ground_state_ccs public interface destruct_ground_state_ccs () Arguments None procedure, public, non_overridable :: diis => diis_ccs public interface diis_ccs () Arguments None procedure, public :: new_amplitudes => new_amplitudes_ccs public interface new_amplitudes_ccs () Arguments None procedure, public :: calc_ampeqs => calc_ampeqs_ccs public interface calc_ampeqs_ccs () Arguments None procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccs public interface calc_ampeqs_norm_ccs () Arguments None procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs public interface calc_quasi_Newton_singles_ccs () Arguments None procedure, public :: excited_state_driver => excited_state_driver_ccs public interface excited_state_driver_ccs () Arguments None procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs public interface excited_state_solver_ccs () Arguments None procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs public interface excited_state_cleanup_ccs () Arguments None procedure, public :: precondition_residual => precondition_residual_ccs public interface precondition_residual_ccs () Arguments None procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs public interface precondition_residual_valence_ccs () Arguments None procedure, public :: print_excited_state_info => print_excited_state_info_ccs public interface print_excited_state_info_ccs () Arguments None procedure, public :: print_excitation_vector => print_excitation_vector_ccs public interface print_excitation_vector_ccs () Arguments None procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs public interface analyze_single_excitation_vector_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs public interface initialize_trial_vectors_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs public interface initialize_trial_vectors_valence_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs public interface find_start_trial_indices_ccs () Arguments None procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs public interface trial_vectors_from_stored_solutions_ccs () Arguments None procedure, public :: precondition_residual_core => precondition_residual_core_ccs public interface precondition_residual_core_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs public interface find_start_trial_indices_core_ccs () Arguments None procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs public interface find_core_mo_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs public interface initialize_trial_vectors_core_ccs () Arguments None procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs public interface solve_reduced_eigenvalue_equation_ccs () Arguments None procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs public interface construct_next_trial_vectors_ccs () Arguments None procedure, public :: response_driver => response_driver_ccs public interface response_driver_ccs () Arguments None procedure, public :: response_solver => response_solver_ccs public interface response_solver_ccs () Arguments None procedure, public :: response_preparations => response_preparations_ccs public interface response_preparations_ccs () Arguments None procedure, public :: initialize_response => initialize_response_ccs public interface initialize_response_ccs () Arguments None procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs public interface solve_reduced_response_equation_ccs () Arguments None procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs public interface construct_reduced_matrix_ccs () Arguments None procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs public interface construct_reduced_gradient_ccs () Arguments None procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs public interface construct_next_response_trial_vectors_ccs () Arguments None procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs public interface construct_gradient_vector_ccs () Arguments None procedure, public :: general_specs_reader => general_specs_reader_ccs public interface general_specs_reader_ccs () Arguments None procedure, public :: calculation_reader => calculation_reader_ccs public interface calculation_reader_ccs () Arguments None procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs public interface read_ground_state_specs_ccs () Arguments None procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs public interface read_excited_state_specs_ccs () Arguments None procedure, public :: read_property_specs => read_property_specs_ccs public interface read_property_specs_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs public interface get_cholesky_ij_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs public interface get_cholesky_ia_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs public interface get_cholesky_ai_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs public interface get_cholesky_ab_ccs () Arguments None procedure, public :: get_oo_oo => get_oo_oo_ccs public interface get_oo_oo_ccs () Arguments None procedure, public :: get_oo_ov => get_oo_ov_ccs public interface get_oo_ov_ccs () Arguments None procedure, public :: get_ov_oo => get_ov_oo_ccs public interface get_ov_oo_ccs () Arguments None procedure, public :: get_oo_vo => get_oo_vo_ccs public interface get_oo_vo_ccs () Arguments None procedure, public :: get_vo_oo => get_vo_oo_ccs public interface get_vo_oo_ccs () Arguments None procedure, public :: get_oo_vv => get_oo_vv_ccs public interface get_oo_vv_ccs () Arguments None procedure, public :: get_vv_oo => get_vv_oo_ccs public interface get_vv_oo_ccs () Arguments None procedure, public :: get_ov_ov => get_ov_ov_ccs public interface get_ov_ov_ccs () Arguments None procedure, public :: get_vo_vo => get_vo_vo_ccs public interface get_vo_vo_ccs () Arguments None procedure, public :: get_ov_vo => get_ov_vo_ccs public interface get_ov_vo_ccs () Arguments None procedure, public :: get_vo_ov => get_vo_ov_ccs public interface get_vo_ov_ccs () Arguments None procedure, public :: get_ov_vv => get_ov_vv_ccs public interface get_ov_vv_ccs () Arguments None procedure, public :: get_vv_ov => get_vv_ov_ccs public interface get_vv_ov_ccs () Arguments None procedure, public :: get_vo_vv => get_vo_vv_ccs public interface get_vo_vv_ccs () Arguments None procedure, public :: get_vv_vo => get_vv_vo_ccs public interface get_vv_vo_ccs () Arguments None procedure, public :: get_vv_vv => get_vv_vv_ccs public interface get_vv_vv_ccs () Arguments None procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs public interface get_oo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs public interface get_oo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs public interface get_ov_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs public interface get_oo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs public interface get_vo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs public interface get_oo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs public interface get_vv_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs public interface get_ov_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs public interface get_vo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs public interface get_ov_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs public interface get_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs public interface get_ov_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs public interface get_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs public interface get_vo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs public interface get_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs public interface get_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs public interface store_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs public interface read_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs public interface t1_transform_vv_vv_ccs () Arguments None procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs public interface store_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs public interface store_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs public interface store_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs public interface store_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs public interface read_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs public interface read_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs public interface read_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs public interface read_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs public interface initialize_fock_matrix_ccs () Arguments None procedure, public, non_overridable :: construct_fock => construct_fock_ccs public interface construct_fock_ccs () Arguments None procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs public interface one_electron_t1_ccs () Arguments None procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs public interface jacobian_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs public interface jacobian_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs public interface jacobian_ccs_b1_ccs () Arguments None procedure, public :: jacobi_test => jacobi_test_ccs public subroutine jacobi_test_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs public interface jacobian_transpose_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs public interface jacobian_transpose_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs public interface jacobian_transpose_ccs_b1_ccs () Arguments None procedure, public :: ionized_state_driver => ionized_state_driver_ccs public interface ionized_state_driver_ccs () Arguments None procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs public interface initialize_trial_vectors_core_ionization_ccs () Arguments None procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs public interface initialize_trial_vectors_valence_ionization_ccs () Arguments None procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs public interface precondition_residual_valence_ionization_ccs () Arguments None procedure, public :: ionization_residual_projection => ionization_residual_projection_ccs public interface ionization_residual_projection_ccs () Arguments None procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs public interface ionization_rho_a_i_projection_ccs () Arguments None procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs public interface precondition_residual_core_ionization_ccs () Arguments None procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs public interface cvs_rho_a_i_projection_ccs () Arguments None procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs public subroutine omega_ccs_a1_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: construct_eta => construct_eta_ccs public subroutine construct_eta_ccs (wf, eta) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs public subroutine read_single_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: destruct_amplitudes => destruct_amplitudes_ccs public subroutine destruct_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: destruct_omega => destruct_omega_ccs public subroutine destruct_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: init => init_cc2 public subroutine init_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf procedure, public :: construct_omega => construct_omega_cc2 public interface construct_omega_cc2 () Arguments None procedure, public :: omega_cc2_a1 => omega_cc2_a1_cc2 public interface omega_cc2_a1_cc2 () Arguments None procedure, public :: omega_cc2_b1 => omega_cc2_b1_cc2 public interface omega_cc2_b1_cc2 () Arguments None procedure, public :: get_s2am => get_s2am_cc2 public interface get_s2am_cc2 () Arguments None procedure, public :: read_cc2_double_amplitudes => read_cc2_double_amplitudes_cc2 public subroutine read_cc2_double_amplitudes_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf procedure, public :: read_amplitudes => read_amplitudes_cc2 public subroutine read_amplitudes_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf procedure, public :: save_amplitudes => save_amplitudes_cc2 public subroutine save_amplitudes_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf procedure, public :: destruct_s2am => destruct_s2am_cc2 public subroutine destruct_s2am_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf procedure, public :: calc_energy => calc_energy_cc2 public subroutine calc_energy_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf procedure, public :: jacobian_cc2_transformation => jacobian_cc2_transformation_cc2 public interface jacobian_cc2_transformation_cc2 () Arguments None procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_cc2 public interface cvs_rho_aibj_projection_cc2 () Arguments None procedure, public :: jacobian_cc2_a1 => jacobian_cc2_a1_cc2 public interface jacobian_cc2_a1_cc2 () Arguments None procedure, public :: jacobian_cc2_b1 => jacobian_cc2_b1_cc2 public interface jacobian_cc2_b1_cc2 () Arguments None procedure, public :: jacobian_cc2_a2 => jacobian_cc2_a2_cc2 public interface jacobian_cc2_a2_cc2 () Arguments None procedure, public :: jacobian_cc2_b2 => jacobian_cc2_b2_cc2 public interface jacobian_cc2_b2_cc2 () Arguments None procedure, public :: initialize_excited_states => initialize_excited_states_cc2 public interface initialize_excited_states_cc2 () Arguments None procedure, public :: calculate_orbital_differences => calculate_orbital_differences_cc2 public interface calculate_orbital_differences_cc2 () Arguments None procedure, public :: transform_trial_vectors => transform_trial_vectors_cc2 public interface transform_trial_vectors_cc2 () Arguments None procedure, public :: cvs_residual_projection => cvs_residual_projection_cc2 public interface cvs_residual_projection_cc2 () Arguments None procedure, public :: excited_state_preparations => excited_state_preparations_cc2 public interface excited_state_preparations_cc2 () Arguments None procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_cc2 public interface analyze_double_excitation_vector_cc2 () Arguments None procedure, public :: summary_excited_state_info => summary_excited_state_info_cc2 public interface summary_excited_state_info_cc2 () Arguments None","tags":"","loc":"type/cc2.html","title":"cc2 – The eT program "},{"text":"type, public, extends( ccsd ) :: cc3 type~~cc3~~InheritsGraph type~cc3 cc3 type~core_excited_state_specs core_excited_state_specs type~core_excited_state_specs->type~cc3 core_excited_state_specifications type~ccsd ccsd type~core_excited_state_specs->type~ccsd core_excited_state_specifications type~ccs ccs type~core_excited_state_specs->type~ccs core_excited_state_specifications type~hf hf type~core_excited_state_specs->type~hf core_excited_state_specifications type~response_calc_specs response_calc_specs type~response_calc_specs->type~cc3 response_specifications type~response_calc_specs->type~ccsd response_specifications type~response_calc_specs->type~ccs response_specifications type~response_calc_specs->type~hf response_specifications type~calc_tasks calc_tasks type~calc_tasks->type~cc3 tasks, implemented type~calc_tasks->type~ccsd tasks, implemented type~calc_tasks->type~ccs tasks, implemented type~calc_tasks->type~hf tasks, implemented type~memory_manager memory_manager type~memory_manager->type~cc3 mem type~memory_manager->type~ccsd mem type~memory_manager->type~ccs mem type~memory_manager->type~hf mem type~excited_state_specs excited_state_specs type~excited_state_specs->type~cc3 excited_state_specifications type~excited_state_specs->type~ccsd excited_state_specifications type~excited_state_specs->type~ccs excited_state_specifications type~excited_state_specs->type~hf excited_state_specifications type~calc_settings calc_settings type~calc_settings->type~cc3 settings type~calc_settings->type~ccsd settings type~calc_settings->type~ccs settings type~calc_settings->type~hf settings type~ground_state_specs ground_state_specs type~ground_state_specs->type~cc3 ground_state_specifications type~ground_state_specs->type~ccsd ground_state_specifications type~ground_state_specs->type~ccs ground_state_specifications type~ground_state_specs->type~hf ground_state_specifications type~ccsd->type~cc3 type~ccs->type~ccsd type~hf->type~ccs var pantypecc3InheritsGraph = svgPanZoom('#typecc3InheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Inherited By type~~cc3~~InheritedByGraph type~cc3 cc3 type~ccsdpt ccsdpt type~cc3->type~ccsdpt Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented ground_state_specifications excited_state_specifications core_excited_state_specifications response_specifications mem n_t1am n_parameters t1am omega1 fock_ij fock_ia fock_ai fock_ab n_t2am t2am omega2 Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky construct_ao_fock construct_ao_fock_new construct_density_matrices construct_density_matrix construct_density_matrix_v drv ground_state_driver ground_state_solver ground_state_cleanup destruct_ground_state diis calc_ampeqs calc_quasi_Newton_singles excited_state_driver excited_state_solver excited_state_cleanup initialize_excited_states precondition_residual precondition_residual_valence print_excited_state_info analyze_single_excitation_vector initialize_trial_vectors initialize_trial_vectors_valence find_start_trial_indices trial_vectors_from_stored_solutions precondition_residual_core find_start_trial_indices_core find_core_mo initialize_trial_vectors_core solve_reduced_eigenvalue_equation construct_next_trial_vectors response_driver response_solver response_preparations initialize_response solve_reduced_response_equation construct_reduced_matrix construct_reduced_gradient construct_next_response_trial_vectors construct_gradient_vector general_specs_reader calculation_reader read_ground_state_specs read_excited_state_specs read_property_specs get_cholesky_ij get_cholesky_ia get_cholesky_ai get_cholesky_ab get_oo_oo get_oo_ov get_ov_oo get_oo_vo get_vo_oo get_oo_vv get_vv_oo get_ov_ov get_vo_vo get_ov_vo get_vo_ov get_ov_vv get_vv_ov get_vo_vv get_vv_vo get_vv_vv get_oo_oo_electronic_repulsion get_oo_ov_electronic_repulsion get_ov_oo_electronic_repulsion get_oo_vo_electronic_repulsion get_vo_oo_electronic_repulsion get_oo_vv_electronic_repulsion get_vv_oo_electronic_repulsion get_ov_ov_electronic_repulsion get_vo_vo_electronic_repulsion get_ov_vo_electronic_repulsion get_vo_ov_electronic_repulsion get_ov_vv_electronic_repulsion get_vv_ov_electronic_repulsion get_vo_vv_electronic_repulsion get_vv_vo_electronic_repulsion get_vv_vv_electronic_repulsion store_vv_vv_electronic_repulsion read_vv_vv_electronic_repulsion t1_transform_vv_vv store_t1_vv_vv_electronic_repulsion store_t1_vo_ov_electronic_repulsion store_t1_vv_vo_electronic_repulsion store_t1_vv_ov_electronic_repulsion read_t1_vv_vo_electronic_repulsion read_t1_vv_vv_electronic_repulsion read_t1_vo_ov_electronic_repulsion read_t1_vv_ov_electronic_repulsion initialize_fock_matrix construct_fock one_electron_t1 jacobian_ccs_transformation jacobian_ccs_a1 jacobian_ccs_b1 jacobian_transpose_ccs_transformation jacobian_transpose_ccs_a1 jacobian_transpose_ccs_b1 ionized_state_driver initialize_trial_vectors_core_ionization initialize_trial_vectors_valence_ionization precondition_residual_valence_ionization ionization_rho_a_i_projection precondition_residual_core_ionization cvs_rho_a_i_projection omega_ccs_a1 read_single_amplitudes initialize_amplitudes initialize_omega initialize_ground_state calc_ampeqs_norm new_amplitudes calc_quasi_Newton_doubles ground_state_preparations omega_ccsd_a1 omega_ccsd_b1 omega_ccsd_c1 omega_ccsd_a2 omega_ccsd_b2 omega_ccsd_c2 omega_ccsd_d2 omega_ccsd_e2 calculate_orbital_differences transform_trial_vectors print_excitation_vector analyze_double_excitation_vector summary_excited_state_info excited_state_preparations jacobian_ccsd_transformation jacobian_ccsd_a1 jacobian_ccsd_b1 jacobian_ccsd_c1 jacobian_ccsd_d1 jacobian_ccsd_a2 jacobian_ccsd_b2 jacobian_ccsd_c2 jacobian_ccsd_d2 jacobian_ccsd_e2 jacobian_ccsd_f2 jacobian_ccsd_g2 jacobian_ccsd_h2 jacobian_ccsd_i2 jacobian_ccsd_j2 jacobian_ccsd_k2 jacobi_test jacobian_transpose_ccsd_transformation jacobian_transpose_ccsd_a1 jacobian_transpose_ccsd_b1 jacobian_transpose_ccsd_c1 jacobian_transpose_ccsd_d1 jacobian_transpose_ccsd_e1 jacobian_transpose_ccsd_f1 jacobian_transpose_ccsd_g1 jacobian_transpose_ccsd_a2 jacobian_transpose_ccsd_b2 jacobian_transpose_ccsd_c2 jacobian_transpose_ccsd_d2 jacobian_transpose_ccsd_e2 jacobian_transpose_ccsd_f2 jacobian_transpose_ccsd_g2 jacobian_transpose_ccsd_h2 jacobian_transpose_ccsd_i2 ionization_residual_projection ionization_rho_aibj_projection cvs_rho_aibj_projection cvs_residual_projection construct_eta save_amplitudes read_amplitudes read_double_amplitudes destruct_amplitudes destruct_omega construct_perturbative_doubles calc_energy init construct_omega omega_integrals calc_triples omega_cc3_a1 omega_cc3_a2 omega_cc3_b2 Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public :: drv => drv_ccs public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: ground_state_driver => ground_state_driver_ccs public interface ground_state_driver_ccs () Arguments None procedure, public :: ground_state_solver => ground_state_solver_ccs public interface ground_state_solver_ccs () Arguments None procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs public interface ground_state_cleanup_ccs () Arguments None procedure, public :: destruct_ground_state => destruct_ground_state_ccs public interface destruct_ground_state_ccs () Arguments None procedure, public, non_overridable :: diis => diis_ccs public interface diis_ccs () Arguments None procedure, public :: calc_ampeqs => calc_ampeqs_ccs public interface calc_ampeqs_ccs () Arguments None procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs public interface calc_quasi_Newton_singles_ccs () Arguments None procedure, public :: excited_state_driver => excited_state_driver_ccs public interface excited_state_driver_ccs () Arguments None procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs public interface excited_state_solver_ccs () Arguments None procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs public interface excited_state_cleanup_ccs () Arguments None procedure, public :: initialize_excited_states => initialize_excited_states_ccs public interface initialize_excited_states_ccs () Arguments None procedure, public :: precondition_residual => precondition_residual_ccs public interface precondition_residual_ccs () Arguments None procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs public interface precondition_residual_valence_ccs () Arguments None procedure, public :: print_excited_state_info => print_excited_state_info_ccs public interface print_excited_state_info_ccs () Arguments None procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs public interface analyze_single_excitation_vector_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs public interface initialize_trial_vectors_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs public interface initialize_trial_vectors_valence_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs public interface find_start_trial_indices_ccs () Arguments None procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs public interface trial_vectors_from_stored_solutions_ccs () Arguments None procedure, public :: precondition_residual_core => precondition_residual_core_ccs public interface precondition_residual_core_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs public interface find_start_trial_indices_core_ccs () Arguments None procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs public interface find_core_mo_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs public interface initialize_trial_vectors_core_ccs () Arguments None procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs public interface solve_reduced_eigenvalue_equation_ccs () Arguments None procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs public interface construct_next_trial_vectors_ccs () Arguments None procedure, public :: response_driver => response_driver_ccs public interface response_driver_ccs () Arguments None procedure, public :: response_solver => response_solver_ccs public interface response_solver_ccs () Arguments None procedure, public :: response_preparations => response_preparations_ccs public interface response_preparations_ccs () Arguments None procedure, public :: initialize_response => initialize_response_ccs public interface initialize_response_ccs () Arguments None procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs public interface solve_reduced_response_equation_ccs () Arguments None procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs public interface construct_reduced_matrix_ccs () Arguments None procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs public interface construct_reduced_gradient_ccs () Arguments None procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs public interface construct_next_response_trial_vectors_ccs () Arguments None procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs public interface construct_gradient_vector_ccs () Arguments None procedure, public :: general_specs_reader => general_specs_reader_ccs public interface general_specs_reader_ccs () Arguments None procedure, public :: calculation_reader => calculation_reader_ccs public interface calculation_reader_ccs () Arguments None procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs public interface read_ground_state_specs_ccs () Arguments None procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs public interface read_excited_state_specs_ccs () Arguments None procedure, public :: read_property_specs => read_property_specs_ccs public interface read_property_specs_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs public interface get_cholesky_ij_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs public interface get_cholesky_ia_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs public interface get_cholesky_ai_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs public interface get_cholesky_ab_ccs () Arguments None procedure, public :: get_oo_oo => get_oo_oo_ccs public interface get_oo_oo_ccs () Arguments None procedure, public :: get_oo_ov => get_oo_ov_ccs public interface get_oo_ov_ccs () Arguments None procedure, public :: get_ov_oo => get_ov_oo_ccs public interface get_ov_oo_ccs () Arguments None procedure, public :: get_oo_vo => get_oo_vo_ccs public interface get_oo_vo_ccs () Arguments None procedure, public :: get_vo_oo => get_vo_oo_ccs public interface get_vo_oo_ccs () Arguments None procedure, public :: get_oo_vv => get_oo_vv_ccs public interface get_oo_vv_ccs () Arguments None procedure, public :: get_vv_oo => get_vv_oo_ccs public interface get_vv_oo_ccs () Arguments None procedure, public :: get_ov_ov => get_ov_ov_ccs public interface get_ov_ov_ccs () Arguments None procedure, public :: get_vo_vo => get_vo_vo_ccs public interface get_vo_vo_ccs () Arguments None procedure, public :: get_ov_vo => get_ov_vo_ccs public interface get_ov_vo_ccs () Arguments None procedure, public :: get_vo_ov => get_vo_ov_ccs public interface get_vo_ov_ccs () Arguments None procedure, public :: get_ov_vv => get_ov_vv_ccs public interface get_ov_vv_ccs () Arguments None procedure, public :: get_vv_ov => get_vv_ov_ccs public interface get_vv_ov_ccs () Arguments None procedure, public :: get_vo_vv => get_vo_vv_ccs public interface get_vo_vv_ccs () Arguments None procedure, public :: get_vv_vo => get_vv_vo_ccs public interface get_vv_vo_ccs () Arguments None procedure, public :: get_vv_vv => get_vv_vv_ccs public interface get_vv_vv_ccs () Arguments None procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs public interface get_oo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs public interface get_oo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs public interface get_ov_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs public interface get_oo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs public interface get_vo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs public interface get_oo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs public interface get_vv_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs public interface get_ov_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs public interface get_vo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs public interface get_ov_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs public interface get_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs public interface get_ov_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs public interface get_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs public interface get_vo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs public interface get_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs public interface get_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs public interface store_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs public interface read_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs public interface t1_transform_vv_vv_ccs () Arguments None procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs public interface store_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs public interface store_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs public interface store_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs public interface store_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs public interface read_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs public interface read_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs public interface read_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs public interface read_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs public interface initialize_fock_matrix_ccs () Arguments None procedure, public, non_overridable :: construct_fock => construct_fock_ccs public interface construct_fock_ccs () Arguments None procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs public interface one_electron_t1_ccs () Arguments None procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs public interface jacobian_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs public interface jacobian_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs public interface jacobian_ccs_b1_ccs () Arguments None procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs public interface jacobian_transpose_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs public interface jacobian_transpose_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs public interface jacobian_transpose_ccs_b1_ccs () Arguments None procedure, public :: ionized_state_driver => ionized_state_driver_ccs public interface ionized_state_driver_ccs () Arguments None procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs public interface initialize_trial_vectors_core_ionization_ccs () Arguments None procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs public interface initialize_trial_vectors_valence_ionization_ccs () Arguments None procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs public interface precondition_residual_valence_ionization_ccs () Arguments None procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs public interface ionization_rho_a_i_projection_ccs () Arguments None procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs public interface precondition_residual_core_ionization_ccs () Arguments None procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs public interface cvs_rho_a_i_projection_ccs () Arguments None procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs public subroutine omega_ccs_a1_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs public subroutine read_single_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_amplitudes => initialize_amplitudes_ccsd public subroutine initialize_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: initialize_omega => initialize_omega_ccsd public interface initialize_omega_ccsd () Arguments None procedure, public :: initialize_ground_state => initialize_ground_state_ccsd public interface initialize_ground_state_ccsd () Arguments None procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd public interface calc_ampeqs_norm_ccsd () Arguments None procedure, public :: new_amplitudes => new_amplitudes_ccsd public interface new_amplitudes_ccsd () Arguments None procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd public interface calc_quasi_Newton_doubles_ccsd () Arguments None procedure, public :: ground_state_preparations => ground_state_preparations_ccsd public interface ground_state_preparations_ccsd () Arguments None procedure, public :: omega_ccsd_a1 => omega_ccsd_a1_ccsd public interface omega_ccsd_a1_ccsd () Arguments None procedure, public :: omega_ccsd_b1 => omega_ccsd_b1_ccsd public interface omega_ccsd_b1_ccsd () Arguments None procedure, public :: omega_ccsd_c1 => omega_ccsd_c1_ccsd public interface omega_ccsd_c1_ccsd () Arguments None procedure, public :: omega_ccsd_a2 => omega_ccsd_a2_ccsd public interface omega_ccsd_a2_ccsd () Arguments None procedure, public :: omega_ccsd_b2 => omega_ccsd_b2_ccsd public interface omega_ccsd_b2_ccsd () Arguments None procedure, public :: omega_ccsd_c2 => omega_ccsd_c2_ccsd public interface omega_ccsd_c2_ccsd () Arguments None procedure, public :: omega_ccsd_d2 => omega_ccsd_d2_ccsd public interface omega_ccsd_d2_ccsd () Arguments None procedure, public :: omega_ccsd_e2 => omega_ccsd_e2_ccsd public interface omega_ccsd_e2_ccsd () Arguments None procedure, public :: calculate_orbital_differences => calculate_orbital_differences_ccsd public interface calculate_orbital_differences_ccsd () Arguments None procedure, public :: transform_trial_vectors => transform_trial_vectors_ccsd public interface transform_trial_vectors_ccsd () Arguments None procedure, public :: print_excitation_vector => print_excitation_vector_ccsd public interface print_excitation_vector_ccsd () Arguments None procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_ccsd public interface analyze_double_excitation_vector_ccsd () Arguments None procedure, public :: summary_excited_state_info => summary_excited_state_info_ccsd public interface summary_excited_state_info_ccsd () Arguments None procedure, public :: excited_state_preparations => excited_state_preparations_ccsd public interface excited_state_preparations_ccsd () Arguments None procedure, public :: jacobian_ccsd_transformation => jacobian_ccsd_transformation_ccsd public interface jacobian_ccsd_transformation_ccsd () Arguments None procedure, public :: jacobian_ccsd_a1 => jacobian_ccsd_a1_ccsd public interface jacobian_ccsd_a1_ccsd () Arguments None procedure, public :: jacobian_ccsd_b1 => jacobian_ccsd_b1_ccsd public interface jacobian_ccsd_b1_ccsd () Arguments None procedure, public :: jacobian_ccsd_c1 => jacobian_ccsd_c1_ccsd public interface jacobian_ccsd_c1_ccsd () Arguments None procedure, public :: jacobian_ccsd_d1 => jacobian_ccsd_d1_ccsd public interface jacobian_ccsd_d1_ccsd () Arguments None procedure, public :: jacobian_ccsd_a2 => jacobian_ccsd_a2_ccsd public interface jacobian_ccsd_a2_ccsd () Arguments None procedure, public :: jacobian_ccsd_b2 => jacobian_ccsd_b2_ccsd public interface jacobian_ccsd_b2_ccsd () Arguments None procedure, public :: jacobian_ccsd_c2 => jacobian_ccsd_c2_ccsd public interface jacobian_ccsd_c2_ccsd () Arguments None procedure, public :: jacobian_ccsd_d2 => jacobian_ccsd_d2_ccsd public interface jacobian_ccsd_d2_ccsd () Arguments None procedure, public :: jacobian_ccsd_e2 => jacobian_ccsd_e2_ccsd public interface jacobian_ccsd_e2_ccsd () Arguments None procedure, public :: jacobian_ccsd_f2 => jacobian_ccsd_f2_ccsd public interface jacobian_ccsd_f2_ccsd () Arguments None procedure, public :: jacobian_ccsd_g2 => jacobian_ccsd_g2_ccsd public interface jacobian_ccsd_g2_ccsd () Arguments None procedure, public :: jacobian_ccsd_h2 => jacobian_ccsd_h2_ccsd public interface jacobian_ccsd_h2_ccsd () Arguments None procedure, public :: jacobian_ccsd_i2 => jacobian_ccsd_i2_ccsd public interface jacobian_ccsd_i2_ccsd () Arguments None procedure, public :: jacobian_ccsd_j2 => jacobian_ccsd_j2_ccsd public interface jacobian_ccsd_j2_ccsd () Arguments None procedure, public :: jacobian_ccsd_k2 => jacobian_ccsd_k2_ccsd public interface jacobian_ccsd_k2_ccsd () Arguments None procedure, public :: jacobi_test => jacobi_test_ccsd public subroutine jacobi_test_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: jacobian_transpose_ccsd_transformation => jacobian_transpose_ccsd_transformation_ccsd public interface jacobian_transpose_ccsd_transformation_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_a1 => jacobian_transpose_ccsd_a1_ccsd public interface jacobian_transpose_ccsd_a1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_b1 => jacobian_transpose_ccsd_b1_ccsd public interface jacobian_transpose_ccsd_b1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_c1 => jacobian_transpose_ccsd_c1_ccsd public interface jacobian_transpose_ccsd_c1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_d1 => jacobian_transpose_ccsd_d1_ccsd public interface jacobian_transpose_ccsd_d1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_e1 => jacobian_transpose_ccsd_e1_ccsd public interface jacobian_transpose_ccsd_e1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_f1 => jacobian_transpose_ccsd_f1_ccsd public interface jacobian_transpose_ccsd_f1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_g1 => jacobian_transpose_ccsd_g1_ccsd public interface jacobian_transpose_ccsd_g1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_a2 => jacobian_transpose_ccsd_a2_ccsd public interface jacobian_transpose_ccsd_a2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_b2 => jacobian_transpose_ccsd_b2_ccsd public interface jacobian_transpose_ccsd_b2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_c2 => jacobian_transpose_ccsd_c2_ccsd public interface jacobian_transpose_ccsd_c2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_d2 => jacobian_transpose_ccsd_d2_ccsd public interface jacobian_transpose_ccsd_d2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_e2 => jacobian_transpose_ccsd_e2_ccsd public interface jacobian_transpose_ccsd_e2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_f2 => jacobian_transpose_ccsd_f2_ccsd public interface jacobian_transpose_ccsd_f2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_g2 => jacobian_transpose_ccsd_g2_ccsd public interface jacobian_transpose_ccsd_g2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_h2 => jacobian_transpose_ccsd_h2_ccsd public interface jacobian_transpose_ccsd_h2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_i2 => jacobian_transpose_ccsd_i2_ccsd public interface jacobian_transpose_ccsd_i2_ccsd () Arguments None procedure, public :: ionization_residual_projection => ionization_residual_projection_ccsd public interface ionization_residual_projection_ccsd () Arguments None procedure, public :: ionization_rho_aibj_projection => ionization_rho_aibj_projection_ccsd public interface ionization_rho_aibj_projection_ccsd () Arguments None procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_ccsd public interface cvs_rho_aibj_projection_ccsd () Arguments None procedure, public :: cvs_residual_projection => cvs_residual_projection_ccsd public interface cvs_residual_projection_ccsd () Arguments None procedure, public :: construct_eta => construct_eta_ccsd public subroutine construct_eta_ccsd (wf, eta) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta procedure, public :: save_amplitudes => save_amplitudes_ccsd public subroutine save_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: read_amplitudes => read_amplitudes_ccsd public subroutine read_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: read_double_amplitudes => read_double_amplitudes_ccsd public subroutine read_double_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: destruct_amplitudes => destruct_amplitudes_ccsd public subroutine destruct_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: destruct_omega => destruct_omega_ccsd public subroutine destruct_omega_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: construct_perturbative_doubles => construct_perturbative_doubles_ccsd public subroutine construct_perturbative_doubles_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: calc_energy => calc_energy_ccsd public subroutine calc_energy_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: init => init_cc3 public subroutine init_cc3 (wf) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf procedure, public :: construct_omega => construct_omega_cc3 public interface construct_omega_cc3 () Arguments None procedure, public :: omega_integrals => omega_integrals_cc3 public interface omega_integrals_cc3 () Arguments None procedure, public :: calc_triples => calc_triples_cc3 public interface calc_triples_cc3 () Arguments None procedure, public :: omega_cc3_a1 => omega_cc3_a1_cc3 public interface omega_cc3_a1_cc3 () Arguments None procedure, public :: omega_cc3_a2 => omega_cc3_a2_cc3 public interface omega_cc3_a2_cc3 () Arguments None procedure, public :: omega_cc3_b2 => omega_cc3_b2_cc3 public interface omega_cc3_b2_cc3 () Arguments None","tags":"","loc":"type/cc3.html","title":"cc3 – The eT program "},{"text":"type, public, extends( ccs ) :: mlcc2 type~~mlcc2~~InheritsGraph type~mlcc2 mlcc2 type~core_excited_state_specs core_excited_state_specs type~core_excited_state_specs->type~mlcc2 core_excited_state_specifications type~ccs ccs type~core_excited_state_specs->type~ccs core_excited_state_specifications type~hf hf type~core_excited_state_specs->type~hf core_excited_state_specifications type~response_calc_specs response_calc_specs type~response_calc_specs->type~mlcc2 response_specifications type~response_calc_specs->type~ccs response_specifications type~response_calc_specs->type~hf response_specifications type~calc_tasks calc_tasks type~calc_tasks->type~mlcc2 tasks, implemented type~calc_tasks->type~ccs tasks, implemented type~calc_tasks->type~hf tasks, implemented type~memory_manager memory_manager type~memory_manager->type~mlcc2 mem type~memory_manager->type~ccs mem type~memory_manager->type~hf mem type~excited_state_specs excited_state_specs type~excited_state_specs->type~mlcc2 excited_state_specifications type~excited_state_specs->type~ccs excited_state_specifications type~excited_state_specs->type~hf excited_state_specifications type~mlcc_orbitals mlcc_orbitals type~mlcc_orbitals->type~mlcc2 CC2_orbitals type~calc_settings calc_settings type~calc_settings->type~mlcc2 settings type~calc_settings->type~ccs settings type~calc_settings->type~hf settings type~mlcc_calculation_settings mlcc_calculation_settings type~mlcc_calculation_settings->type~mlcc2 mlcc_settings type~ground_state_specs ground_state_specs type~ground_state_specs->type~mlcc2 ground_state_specifications type~ground_state_specs->type~ccs ground_state_specifications type~ground_state_specs->type~hf ground_state_specifications type~ccs->type~mlcc2 type~hf->type~ccs var pantypemlcc2InheritsGraph = svgPanZoom('#typemlcc2InheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Inherited By type~~mlcc2~~InheritedByGraph type~mlcc2 mlcc2 type~mlccsd mlccsd type~mlcc2->type~mlccsd Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented ground_state_specifications excited_state_specifications core_excited_state_specifications response_specifications mem n_t1am n_parameters t1am omega1 fock_ij fock_ia fock_ai fock_ab mlcc_settings n_CCS_o n_CCS_v first_CCS_o first_CCS_v n_CC2_o n_CC2_v first_CC2_o first_CC2_v CC2_orbitals n_x2am x2am Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky construct_ao_fock construct_ao_fock_new construct_density_matrices construct_density_matrix construct_density_matrix_v drv initialize_amplitudes initialize_omega ground_state_driver ground_state_solver ground_state_preparations ground_state_cleanup initialize_ground_state destruct_ground_state diis new_amplitudes calc_ampeqs calc_ampeqs_norm calc_quasi_Newton_singles excited_state_driver excited_state_solver excited_state_cleanup precondition_residual precondition_residual_valence print_excited_state_info analyze_single_excitation_vector initialize_trial_vectors initialize_trial_vectors_valence find_start_trial_indices trial_vectors_from_stored_solutions precondition_residual_core find_start_trial_indices_core find_core_mo initialize_trial_vectors_core solve_reduced_eigenvalue_equation construct_next_trial_vectors response_driver response_solver response_preparations initialize_response solve_reduced_response_equation construct_reduced_matrix construct_reduced_gradient construct_next_response_trial_vectors construct_gradient_vector general_specs_reader calculation_reader read_ground_state_specs read_excited_state_specs read_property_specs get_cholesky_ij get_cholesky_ia get_cholesky_ai get_cholesky_ab get_oo_oo get_oo_ov get_ov_oo get_oo_vo get_vo_oo get_oo_vv get_vv_oo get_ov_ov get_vo_vo get_ov_vo get_vo_ov get_ov_vv get_vv_ov get_vo_vv get_vv_vo get_vv_vv get_oo_oo_electronic_repulsion get_oo_ov_electronic_repulsion get_ov_oo_electronic_repulsion get_oo_vo_electronic_repulsion get_vo_oo_electronic_repulsion get_oo_vv_electronic_repulsion get_vv_oo_electronic_repulsion get_ov_ov_electronic_repulsion get_vo_vo_electronic_repulsion get_ov_vo_electronic_repulsion get_vo_ov_electronic_repulsion get_ov_vv_electronic_repulsion get_vv_ov_electronic_repulsion get_vo_vv_electronic_repulsion get_vv_vo_electronic_repulsion get_vv_vv_electronic_repulsion store_vv_vv_electronic_repulsion read_vv_vv_electronic_repulsion t1_transform_vv_vv store_t1_vv_vv_electronic_repulsion store_t1_vo_ov_electronic_repulsion store_t1_vv_vo_electronic_repulsion store_t1_vv_ov_electronic_repulsion read_t1_vv_vo_electronic_repulsion read_t1_vv_vv_electronic_repulsion read_t1_vo_ov_electronic_repulsion read_t1_vv_ov_electronic_repulsion initialize_fock_matrix construct_fock one_electron_t1 jacobian_ccs_transformation jacobian_ccs_a1 jacobian_ccs_b1 jacobi_test jacobian_transpose_ccs_transformation jacobian_transpose_ccs_a1 jacobian_transpose_ccs_b1 ionized_state_driver initialize_trial_vectors_core_ionization initialize_trial_vectors_valence_ionization precondition_residual_valence_ionization ionization_residual_projection ionization_rho_a_i_projection precondition_residual_core_ionization cvs_rho_a_i_projection omega_ccs_a1 construct_eta read_single_amplitudes destruct_amplitudes destruct_omega mlcc_reader read_orbital_info init orbital_partitioning cholesky_decomposition cholesky_localization_drv cholesky_orbitals cholesky_orbital_constructor cnto_orbital_drv cc2_cnto_lower_level_method cc2_cnto_orbitals print_orbital_info get_CC2_active_indices get_CC2_n_active save_amplitudes read_amplitudes read_cc2_double_amplitudes destruct_x2am omega_mlcc2_a1 omega_mlcc2_b1 construct_omega get_s2am calc_energy excited_state_preparations initialize_excited_states calculate_orbital_differences transform_trial_vectors cvs_residual_projection analyze_double_excitation_vector summary_excited_state_info print_excitation_vector jacobian_mlcc2_transformation cvs_rho_aibj_projection jacobian_mlcc2_a1 jacobian_mlcc2_b1 jacobian_mlcc2_a2 jacobian_mlcc2_b2 Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab type( mlcc_calculation_settings ), public :: mlcc_settings integer(kind=i15), public :: n_CCS_o = 0 integer(kind=i15), public :: n_CCS_v = 0 integer(kind=i15), public :: first_CCS_o = 0 integer(kind=i15), public :: first_CCS_v = 0 integer(kind=i15), public :: n_CC2_o = 0 integer(kind=i15), public :: n_CC2_v = 0 integer(kind=i15), public :: first_CC2_o = 0 integer(kind=i15), public :: first_CC2_v = 0 type( mlcc_orbitals ), public :: CC2_orbitals integer(kind=i15), public :: n_x2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: x2am Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public :: drv => drv_ccs public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_amplitudes => initialize_amplitudes_ccs public subroutine initialize_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_omega => initialize_omega_ccs public subroutine initialize_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: ground_state_driver => ground_state_driver_ccs public interface ground_state_driver_ccs () Arguments None procedure, public :: ground_state_solver => ground_state_solver_ccs public interface ground_state_solver_ccs () Arguments None procedure, public :: ground_state_preparations => ground_state_preparations_ccs public interface ground_state_preparations_ccs () Arguments None procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs public interface ground_state_cleanup_ccs () Arguments None procedure, public :: initialize_ground_state => initialize_ground_state_ccs public interface initialize_ground_state_ccs () Arguments None procedure, public :: destruct_ground_state => destruct_ground_state_ccs public interface destruct_ground_state_ccs () Arguments None procedure, public, non_overridable :: diis => diis_ccs public interface diis_ccs () Arguments None procedure, public :: new_amplitudes => new_amplitudes_ccs public interface new_amplitudes_ccs () Arguments None procedure, public :: calc_ampeqs => calc_ampeqs_ccs public interface calc_ampeqs_ccs () Arguments None procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccs public interface calc_ampeqs_norm_ccs () Arguments None procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs public interface calc_quasi_Newton_singles_ccs () Arguments None procedure, public :: excited_state_driver => excited_state_driver_ccs public interface excited_state_driver_ccs () Arguments None procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs public interface excited_state_solver_ccs () Arguments None procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs public interface excited_state_cleanup_ccs () Arguments None procedure, public :: precondition_residual => precondition_residual_ccs public interface precondition_residual_ccs () Arguments None procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs public interface precondition_residual_valence_ccs () Arguments None procedure, public :: print_excited_state_info => print_excited_state_info_ccs public interface print_excited_state_info_ccs () Arguments None procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs public interface analyze_single_excitation_vector_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs public interface initialize_trial_vectors_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs public interface initialize_trial_vectors_valence_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs public interface find_start_trial_indices_ccs () Arguments None procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs public interface trial_vectors_from_stored_solutions_ccs () Arguments None procedure, public :: precondition_residual_core => precondition_residual_core_ccs public interface precondition_residual_core_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs public interface find_start_trial_indices_core_ccs () Arguments None procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs public interface find_core_mo_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs public interface initialize_trial_vectors_core_ccs () Arguments None procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs public interface solve_reduced_eigenvalue_equation_ccs () Arguments None procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs public interface construct_next_trial_vectors_ccs () Arguments None procedure, public :: response_driver => response_driver_ccs public interface response_driver_ccs () Arguments None procedure, public :: response_solver => response_solver_ccs public interface response_solver_ccs () Arguments None procedure, public :: response_preparations => response_preparations_ccs public interface response_preparations_ccs () Arguments None procedure, public :: initialize_response => initialize_response_ccs public interface initialize_response_ccs () Arguments None procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs public interface solve_reduced_response_equation_ccs () Arguments None procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs public interface construct_reduced_matrix_ccs () Arguments None procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs public interface construct_reduced_gradient_ccs () Arguments None procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs public interface construct_next_response_trial_vectors_ccs () Arguments None procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs public interface construct_gradient_vector_ccs () Arguments None procedure, public :: general_specs_reader => general_specs_reader_ccs public interface general_specs_reader_ccs () Arguments None procedure, public :: calculation_reader => calculation_reader_ccs public interface calculation_reader_ccs () Arguments None procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs public interface read_ground_state_specs_ccs () Arguments None procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs public interface read_excited_state_specs_ccs () Arguments None procedure, public :: read_property_specs => read_property_specs_ccs public interface read_property_specs_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs public interface get_cholesky_ij_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs public interface get_cholesky_ia_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs public interface get_cholesky_ai_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs public interface get_cholesky_ab_ccs () Arguments None procedure, public :: get_oo_oo => get_oo_oo_ccs public interface get_oo_oo_ccs () Arguments None procedure, public :: get_oo_ov => get_oo_ov_ccs public interface get_oo_ov_ccs () Arguments None procedure, public :: get_ov_oo => get_ov_oo_ccs public interface get_ov_oo_ccs () Arguments None procedure, public :: get_oo_vo => get_oo_vo_ccs public interface get_oo_vo_ccs () Arguments None procedure, public :: get_vo_oo => get_vo_oo_ccs public interface get_vo_oo_ccs () Arguments None procedure, public :: get_oo_vv => get_oo_vv_ccs public interface get_oo_vv_ccs () Arguments None procedure, public :: get_vv_oo => get_vv_oo_ccs public interface get_vv_oo_ccs () Arguments None procedure, public :: get_ov_ov => get_ov_ov_ccs public interface get_ov_ov_ccs () Arguments None procedure, public :: get_vo_vo => get_vo_vo_ccs public interface get_vo_vo_ccs () Arguments None procedure, public :: get_ov_vo => get_ov_vo_ccs public interface get_ov_vo_ccs () Arguments None procedure, public :: get_vo_ov => get_vo_ov_ccs public interface get_vo_ov_ccs () Arguments None procedure, public :: get_ov_vv => get_ov_vv_ccs public interface get_ov_vv_ccs () Arguments None procedure, public :: get_vv_ov => get_vv_ov_ccs public interface get_vv_ov_ccs () Arguments None procedure, public :: get_vo_vv => get_vo_vv_ccs public interface get_vo_vv_ccs () Arguments None procedure, public :: get_vv_vo => get_vv_vo_ccs public interface get_vv_vo_ccs () Arguments None procedure, public :: get_vv_vv => get_vv_vv_ccs public interface get_vv_vv_ccs () Arguments None procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs public interface get_oo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs public interface get_oo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs public interface get_ov_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs public interface get_oo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs public interface get_vo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs public interface get_oo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs public interface get_vv_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs public interface get_ov_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs public interface get_vo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs public interface get_ov_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs public interface get_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs public interface get_ov_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs public interface get_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs public interface get_vo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs public interface get_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs public interface get_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs public interface store_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs public interface read_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs public interface t1_transform_vv_vv_ccs () Arguments None procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs public interface store_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs public interface store_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs public interface store_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs public interface store_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs public interface read_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs public interface read_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs public interface read_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs public interface read_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs public interface initialize_fock_matrix_ccs () Arguments None procedure, public, non_overridable :: construct_fock => construct_fock_ccs public interface construct_fock_ccs () Arguments None procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs public interface one_electron_t1_ccs () Arguments None procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs public interface jacobian_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs public interface jacobian_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs public interface jacobian_ccs_b1_ccs () Arguments None procedure, public :: jacobi_test => jacobi_test_ccs public subroutine jacobi_test_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs public interface jacobian_transpose_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs public interface jacobian_transpose_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs public interface jacobian_transpose_ccs_b1_ccs () Arguments None procedure, public :: ionized_state_driver => ionized_state_driver_ccs public interface ionized_state_driver_ccs () Arguments None procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs public interface initialize_trial_vectors_core_ionization_ccs () Arguments None procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs public interface initialize_trial_vectors_valence_ionization_ccs () Arguments None procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs public interface precondition_residual_valence_ionization_ccs () Arguments None procedure, public :: ionization_residual_projection => ionization_residual_projection_ccs public interface ionization_residual_projection_ccs () Arguments None procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs public interface ionization_rho_a_i_projection_ccs () Arguments None procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs public interface precondition_residual_core_ionization_ccs () Arguments None procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs public interface cvs_rho_a_i_projection_ccs () Arguments None procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs public subroutine omega_ccs_a1_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: construct_eta => construct_eta_ccs public subroutine construct_eta_ccs (wf, eta) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs public subroutine read_single_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: destruct_amplitudes => destruct_amplitudes_ccs public subroutine destruct_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: destruct_omega => destruct_omega_ccs public subroutine destruct_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: mlcc_reader => mlcc_reader_mlcc2 public interface mlcc_reader_mlcc2 () Arguments None procedure, public :: read_orbital_info => read_orbital_info_mlcc2 public interface read_orbital_info_mlcc2 () Arguments None procedure, public :: init => init_mlcc2 public subroutine init_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf procedure, public :: orbital_partitioning => orbital_partitioning_mlcc2 public interface orbital_partitioning_mlcc2 () Arguments None procedure, public :: cholesky_decomposition => cholesky_decomposition_mlcc2 public interface cholesky_decomposition_mlcc2 () Arguments None procedure, public :: cholesky_localization_drv => cholesky_localization_drv_mlcc2 public interface cholesky_localization_drv_mlcc2 () Arguments None procedure, public :: cholesky_orbitals => cholesky_orbitals_mlcc2 public interface cholesky_orbitals_mlcc2 () Arguments None procedure, public :: cholesky_orbital_constructor => cholesky_orbital_constructor_mlcc2 public interface cholesky_orbital_constructor_mlcc2 () Arguments None procedure, public :: cnto_orbital_drv => cnto_orbital_drv_mlcc2 public interface cnto_orbital_drv_mlcc2 () Arguments None procedure, public :: cc2_cnto_lower_level_method => cc2_cnto_lower_level_method_mlcc2 public interface cc2_cnto_lower_level_method_mlcc2 () Arguments None procedure, public :: cc2_cnto_orbitals => cc2_cnto_orbitals_mlcc2 public interface cc2_cnto_orbitals_mlcc2 () Arguments None procedure, public :: print_orbital_info => print_orbital_info_mlcc2 public interface print_orbital_info_mlcc2 () Arguments None procedure, public :: get_CC2_active_indices => get_CC2_active_indices_mlcc2 public subroutine get_CC2_active_indices_mlcc2 (wf, first_o, first_v) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: first_o integer(kind=i15) :: first_v procedure, public :: get_CC2_n_active => get_CC2_n_active_mlcc2 public subroutine get_CC2_n_active_mlcc2 (wf, n_active_o, n_active_v) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: n_active_o integer(kind=i15) :: n_active_v procedure, public :: save_amplitudes => save_amplitudes_mlcc2 public subroutine save_amplitudes_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf procedure, public :: read_amplitudes => read_amplitudes_mlcc2 public subroutine read_amplitudes_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf procedure, public :: read_cc2_double_amplitudes => read_cc2_double_amplitudes_mlcc2 public subroutine read_cc2_double_amplitudes_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf procedure, public :: destruct_x2am => destruct_x2am_mlcc2 public subroutine destruct_x2am_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf procedure, public :: omega_mlcc2_a1 => omega_mlcc2_a1_mlcc2 public interface omega_mlcc2_a1_mlcc2 () Arguments None procedure, public :: omega_mlcc2_b1 => omega_mlcc2_b1_mlcc2 public interface omega_mlcc2_b1_mlcc2 () Arguments None procedure, public :: construct_omega => construct_omega_mlcc2 public interface construct_omega_mlcc2 () Arguments None procedure, public :: get_s2am => get_s2am_mlcc2 public interface get_s2am_mlcc2 () Arguments None procedure, public :: calc_energy => calc_energy_mlcc2 public subroutine calc_energy_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf procedure, public :: excited_state_preparations => excited_state_preparations_mlcc2 public interface excited_state_preparations_mlcc2 () Arguments None procedure, public :: initialize_excited_states => initialize_excited_states_mlcc2 public interface initialize_excited_states_mlcc2 () Arguments None procedure, public :: calculate_orbital_differences => calculate_orbital_differences_mlcc2 public interface calculate_orbital_differences_mlcc2 () Arguments None procedure, public :: transform_trial_vectors => transform_trial_vectors_mlcc2 public interface transform_trial_vectors_mlcc2 () Arguments None procedure, public :: cvs_residual_projection => cvs_residual_projection_mlcc2 public interface cvs_residual_projection_mlcc2 () Arguments None procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_mlcc2 public interface analyze_double_excitation_vector_mlcc2 () Arguments None procedure, public :: summary_excited_state_info => summary_excited_state_info_mlcc2 public interface summary_excited_state_info_mlcc2 () Arguments None procedure, public :: print_excitation_vector => print_excitation_vector_mlcc2 public interface print_excitation_vector_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_transformation => jacobian_mlcc2_transformation_mlcc2 public interface jacobian_mlcc2_transformation_mlcc2 () Arguments None procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_mlcc2 public interface cvs_rho_aibj_projection_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_a1 => jacobian_mlcc2_a1_mlcc2 public interface jacobian_mlcc2_a1_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_b1 => jacobian_mlcc2_b1_mlcc2 public interface jacobian_mlcc2_b1_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_a2 => jacobian_mlcc2_a2_mlcc2 public interface jacobian_mlcc2_a2_mlcc2 () Arguments None procedure, public :: jacobian_mlcc2_b2 => jacobian_mlcc2_b2_mlcc2 public interface jacobian_mlcc2_b2_mlcc2 () Arguments None","tags":"","loc":"type/mlcc2.html","title":"mlcc2 – The eT program "},{"text":"type, public, extends( cc3 ) :: ccsdpt type~~ccsdpt~~InheritsGraph type~ccsdpt ccsdpt type~core_excited_state_specs core_excited_state_specs type~core_excited_state_specs->type~ccsdpt core_excited_state_specifications type~cc3 cc3 type~core_excited_state_specs->type~cc3 core_excited_state_specifications type~ccsd ccsd type~core_excited_state_specs->type~ccsd core_excited_state_specifications type~ccs ccs type~core_excited_state_specs->type~ccs core_excited_state_specifications type~hf hf type~core_excited_state_specs->type~hf core_excited_state_specifications type~response_calc_specs response_calc_specs type~response_calc_specs->type~ccsdpt response_specifications type~response_calc_specs->type~cc3 response_specifications type~response_calc_specs->type~ccsd response_specifications type~response_calc_specs->type~ccs response_specifications type~response_calc_specs->type~hf response_specifications type~calc_tasks calc_tasks type~calc_tasks->type~ccsdpt tasks, implemented type~calc_tasks->type~cc3 tasks, implemented type~calc_tasks->type~ccsd tasks, implemented type~calc_tasks->type~ccs tasks, implemented type~calc_tasks->type~hf tasks, implemented type~memory_manager memory_manager type~memory_manager->type~ccsdpt mem type~memory_manager->type~cc3 mem type~memory_manager->type~ccsd mem type~memory_manager->type~ccs mem type~memory_manager->type~hf mem type~excited_state_specs excited_state_specs type~excited_state_specs->type~ccsdpt excited_state_specifications type~excited_state_specs->type~cc3 excited_state_specifications type~excited_state_specs->type~ccsd excited_state_specifications type~excited_state_specs->type~ccs excited_state_specifications type~excited_state_specs->type~hf excited_state_specifications type~calc_settings calc_settings type~calc_settings->type~ccsdpt settings type~calc_settings->type~cc3 settings type~calc_settings->type~ccsd settings type~calc_settings->type~ccs settings type~calc_settings->type~hf settings type~ground_state_specs ground_state_specs type~ground_state_specs->type~ccsdpt ground_state_specifications type~ground_state_specs->type~cc3 ground_state_specifications type~ground_state_specs->type~ccsd ground_state_specifications type~ground_state_specs->type~ccs ground_state_specifications type~ground_state_specs->type~hf ground_state_specifications type~cc3->type~ccsdpt type~ccsd->type~cc3 type~ccs->type~ccsd type~hf->type~ccs var pantypeccsdptInheritsGraph = svgPanZoom('#typeccsdptInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented ground_state_specifications excited_state_specifications core_excited_state_specifications response_specifications mem n_t1am n_parameters t1am omega1 fock_ij fock_ia fock_ai fock_ab n_t2am t2am omega2 Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky construct_ao_fock construct_ao_fock_new construct_density_matrices construct_density_matrix construct_density_matrix_v drv ground_state_driver ground_state_solver ground_state_cleanup diis calc_ampeqs calc_quasi_Newton_singles excited_state_driver excited_state_solver excited_state_cleanup initialize_excited_states precondition_residual precondition_residual_valence print_excited_state_info analyze_single_excitation_vector initialize_trial_vectors initialize_trial_vectors_valence find_start_trial_indices trial_vectors_from_stored_solutions precondition_residual_core find_start_trial_indices_core find_core_mo initialize_trial_vectors_core solve_reduced_eigenvalue_equation construct_next_trial_vectors response_driver response_solver response_preparations initialize_response solve_reduced_response_equation construct_reduced_matrix construct_reduced_gradient construct_next_response_trial_vectors construct_gradient_vector general_specs_reader calculation_reader read_ground_state_specs read_excited_state_specs read_property_specs get_cholesky_ij get_cholesky_ia get_cholesky_ai get_cholesky_ab get_oo_oo get_oo_ov get_ov_oo get_oo_vo get_vo_oo get_oo_vv get_vv_oo get_ov_ov get_vo_vo get_ov_vo get_vo_ov get_ov_vv get_vv_ov get_vo_vv get_vv_vo get_vv_vv get_oo_oo_electronic_repulsion get_oo_ov_electronic_repulsion get_ov_oo_electronic_repulsion get_oo_vo_electronic_repulsion get_vo_oo_electronic_repulsion get_oo_vv_electronic_repulsion get_vv_oo_electronic_repulsion get_ov_ov_electronic_repulsion get_vo_vo_electronic_repulsion get_ov_vo_electronic_repulsion get_vo_ov_electronic_repulsion get_ov_vv_electronic_repulsion get_vv_ov_electronic_repulsion get_vo_vv_electronic_repulsion get_vv_vo_electronic_repulsion get_vv_vv_electronic_repulsion store_vv_vv_electronic_repulsion read_vv_vv_electronic_repulsion t1_transform_vv_vv store_t1_vv_vv_electronic_repulsion store_t1_vo_ov_electronic_repulsion store_t1_vv_vo_electronic_repulsion store_t1_vv_ov_electronic_repulsion read_t1_vv_vo_electronic_repulsion read_t1_vv_vv_electronic_repulsion read_t1_vo_ov_electronic_repulsion read_t1_vv_ov_electronic_repulsion initialize_fock_matrix construct_fock one_electron_t1 jacobian_ccs_transformation jacobian_ccs_a1 jacobian_ccs_b1 jacobian_transpose_ccs_transformation jacobian_transpose_ccs_a1 jacobian_transpose_ccs_b1 ionized_state_driver initialize_trial_vectors_core_ionization initialize_trial_vectors_valence_ionization precondition_residual_valence_ionization ionization_rho_a_i_projection precondition_residual_core_ionization cvs_rho_a_i_projection omega_ccs_a1 read_single_amplitudes initialize_amplitudes initialize_omega initialize_ground_state calc_ampeqs_norm new_amplitudes calc_quasi_Newton_doubles ground_state_preparations omega_ccsd_a1 omega_ccsd_b1 omega_ccsd_c1 omega_ccsd_a2 omega_ccsd_b2 omega_ccsd_c2 omega_ccsd_d2 omega_ccsd_e2 calculate_orbital_differences transform_trial_vectors print_excitation_vector analyze_double_excitation_vector summary_excited_state_info excited_state_preparations jacobian_ccsd_transformation jacobian_ccsd_a1 jacobian_ccsd_b1 jacobian_ccsd_c1 jacobian_ccsd_d1 jacobian_ccsd_a2 jacobian_ccsd_b2 jacobian_ccsd_c2 jacobian_ccsd_d2 jacobian_ccsd_e2 jacobian_ccsd_f2 jacobian_ccsd_g2 jacobian_ccsd_h2 jacobian_ccsd_i2 jacobian_ccsd_j2 jacobian_ccsd_k2 jacobi_test jacobian_transpose_ccsd_transformation jacobian_transpose_ccsd_a1 jacobian_transpose_ccsd_b1 jacobian_transpose_ccsd_c1 jacobian_transpose_ccsd_d1 jacobian_transpose_ccsd_e1 jacobian_transpose_ccsd_f1 jacobian_transpose_ccsd_g1 jacobian_transpose_ccsd_a2 jacobian_transpose_ccsd_b2 jacobian_transpose_ccsd_c2 jacobian_transpose_ccsd_d2 jacobian_transpose_ccsd_e2 jacobian_transpose_ccsd_f2 jacobian_transpose_ccsd_g2 jacobian_transpose_ccsd_h2 jacobian_transpose_ccsd_i2 ionization_residual_projection ionization_rho_aibj_projection cvs_rho_aibj_projection cvs_residual_projection construct_eta save_amplitudes read_amplitudes read_double_amplitudes destruct_amplitudes destruct_omega construct_perturbative_doubles calc_energy omega_integrals calc_triples omega_cc3_a1 omega_cc3_a2 omega_cc3_b2 init construct_omega calc_energy_correction destruct_ground_state Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v procedure, public :: drv => drv_ccs public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: ground_state_driver => ground_state_driver_ccs public interface ground_state_driver_ccs () Arguments None procedure, public :: ground_state_solver => ground_state_solver_ccs public interface ground_state_solver_ccs () Arguments None procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs public interface ground_state_cleanup_ccs () Arguments None procedure, public, non_overridable :: diis => diis_ccs public interface diis_ccs () Arguments None procedure, public :: calc_ampeqs => calc_ampeqs_ccs public interface calc_ampeqs_ccs () Arguments None procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs public interface calc_quasi_Newton_singles_ccs () Arguments None procedure, public :: excited_state_driver => excited_state_driver_ccs public interface excited_state_driver_ccs () Arguments None procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs public interface excited_state_solver_ccs () Arguments None procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs public interface excited_state_cleanup_ccs () Arguments None procedure, public :: initialize_excited_states => initialize_excited_states_ccs public interface initialize_excited_states_ccs () Arguments None procedure, public :: precondition_residual => precondition_residual_ccs public interface precondition_residual_ccs () Arguments None procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs public interface precondition_residual_valence_ccs () Arguments None procedure, public :: print_excited_state_info => print_excited_state_info_ccs public interface print_excited_state_info_ccs () Arguments None procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs public interface analyze_single_excitation_vector_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs public interface initialize_trial_vectors_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs public interface initialize_trial_vectors_valence_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs public interface find_start_trial_indices_ccs () Arguments None procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs public interface trial_vectors_from_stored_solutions_ccs () Arguments None procedure, public :: precondition_residual_core => precondition_residual_core_ccs public interface precondition_residual_core_ccs () Arguments None procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs public interface find_start_trial_indices_core_ccs () Arguments None procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs public interface find_core_mo_ccs () Arguments None procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs public interface initialize_trial_vectors_core_ccs () Arguments None procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs public interface solve_reduced_eigenvalue_equation_ccs () Arguments None procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs public interface construct_next_trial_vectors_ccs () Arguments None procedure, public :: response_driver => response_driver_ccs public interface response_driver_ccs () Arguments None procedure, public :: response_solver => response_solver_ccs public interface response_solver_ccs () Arguments None procedure, public :: response_preparations => response_preparations_ccs public interface response_preparations_ccs () Arguments None procedure, public :: initialize_response => initialize_response_ccs public interface initialize_response_ccs () Arguments None procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs public interface solve_reduced_response_equation_ccs () Arguments None procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs public interface construct_reduced_matrix_ccs () Arguments None procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs public interface construct_reduced_gradient_ccs () Arguments None procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs public interface construct_next_response_trial_vectors_ccs () Arguments None procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs public interface construct_gradient_vector_ccs () Arguments None procedure, public :: general_specs_reader => general_specs_reader_ccs public interface general_specs_reader_ccs () Arguments None procedure, public :: calculation_reader => calculation_reader_ccs public interface calculation_reader_ccs () Arguments None procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs public interface read_ground_state_specs_ccs () Arguments None procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs public interface read_excited_state_specs_ccs () Arguments None procedure, public :: read_property_specs => read_property_specs_ccs public interface read_property_specs_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs public interface get_cholesky_ij_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs public interface get_cholesky_ia_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs public interface get_cholesky_ai_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs public interface get_cholesky_ab_ccs () Arguments None procedure, public :: get_oo_oo => get_oo_oo_ccs public interface get_oo_oo_ccs () Arguments None procedure, public :: get_oo_ov => get_oo_ov_ccs public interface get_oo_ov_ccs () Arguments None procedure, public :: get_ov_oo => get_ov_oo_ccs public interface get_ov_oo_ccs () Arguments None procedure, public :: get_oo_vo => get_oo_vo_ccs public interface get_oo_vo_ccs () Arguments None procedure, public :: get_vo_oo => get_vo_oo_ccs public interface get_vo_oo_ccs () Arguments None procedure, public :: get_oo_vv => get_oo_vv_ccs public interface get_oo_vv_ccs () Arguments None procedure, public :: get_vv_oo => get_vv_oo_ccs public interface get_vv_oo_ccs () Arguments None procedure, public :: get_ov_ov => get_ov_ov_ccs public interface get_ov_ov_ccs () Arguments None procedure, public :: get_vo_vo => get_vo_vo_ccs public interface get_vo_vo_ccs () Arguments None procedure, public :: get_ov_vo => get_ov_vo_ccs public interface get_ov_vo_ccs () Arguments None procedure, public :: get_vo_ov => get_vo_ov_ccs public interface get_vo_ov_ccs () Arguments None procedure, public :: get_ov_vv => get_ov_vv_ccs public interface get_ov_vv_ccs () Arguments None procedure, public :: get_vv_ov => get_vv_ov_ccs public interface get_vv_ov_ccs () Arguments None procedure, public :: get_vo_vv => get_vo_vv_ccs public interface get_vo_vv_ccs () Arguments None procedure, public :: get_vv_vo => get_vv_vo_ccs public interface get_vv_vo_ccs () Arguments None procedure, public :: get_vv_vv => get_vv_vv_ccs public interface get_vv_vv_ccs () Arguments None procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs public interface get_oo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs public interface get_oo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs public interface get_ov_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs public interface get_oo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs public interface get_vo_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs public interface get_oo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs public interface get_vv_oo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs public interface get_ov_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs public interface get_vo_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs public interface get_ov_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs public interface get_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs public interface get_ov_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs public interface get_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs public interface get_vo_vv_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs public interface get_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs public interface get_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs public interface store_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs public interface read_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs public interface t1_transform_vv_vv_ccs () Arguments None procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs public interface store_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs public interface store_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs public interface store_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs public interface store_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs public interface read_t1_vv_vo_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs public interface read_t1_vv_vv_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs public interface read_t1_vo_ov_electronic_repulsion_ccs () Arguments None procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs public interface read_t1_vv_ov_electronic_repulsion_ccs () Arguments None procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs public interface initialize_fock_matrix_ccs () Arguments None procedure, public, non_overridable :: construct_fock => construct_fock_ccs public interface construct_fock_ccs () Arguments None procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs public interface one_electron_t1_ccs () Arguments None procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs public interface jacobian_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs public interface jacobian_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs public interface jacobian_ccs_b1_ccs () Arguments None procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs public interface jacobian_transpose_ccs_transformation_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs public interface jacobian_transpose_ccs_a1_ccs () Arguments None procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs public interface jacobian_transpose_ccs_b1_ccs () Arguments None procedure, public :: ionized_state_driver => ionized_state_driver_ccs public interface ionized_state_driver_ccs () Arguments None procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs public interface initialize_trial_vectors_core_ionization_ccs () Arguments None procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs public interface initialize_trial_vectors_valence_ionization_ccs () Arguments None procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs public interface precondition_residual_valence_ionization_ccs () Arguments None procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs public interface ionization_rho_a_i_projection_ccs () Arguments None procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs public interface precondition_residual_core_ionization_ccs () Arguments None procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs public interface cvs_rho_a_i_projection_ccs () Arguments None procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs public subroutine omega_ccs_a1_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs public subroutine read_single_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_amplitudes => initialize_amplitudes_ccsd public subroutine initialize_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: initialize_omega => initialize_omega_ccsd public interface initialize_omega_ccsd () Arguments None procedure, public :: initialize_ground_state => initialize_ground_state_ccsd public interface initialize_ground_state_ccsd () Arguments None procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd public interface calc_ampeqs_norm_ccsd () Arguments None procedure, public :: new_amplitudes => new_amplitudes_ccsd public interface new_amplitudes_ccsd () Arguments None procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd public interface calc_quasi_Newton_doubles_ccsd () Arguments None procedure, public :: ground_state_preparations => ground_state_preparations_ccsd public interface ground_state_preparations_ccsd () Arguments None procedure, public :: omega_ccsd_a1 => omega_ccsd_a1_ccsd public interface omega_ccsd_a1_ccsd () Arguments None procedure, public :: omega_ccsd_b1 => omega_ccsd_b1_ccsd public interface omega_ccsd_b1_ccsd () Arguments None procedure, public :: omega_ccsd_c1 => omega_ccsd_c1_ccsd public interface omega_ccsd_c1_ccsd () Arguments None procedure, public :: omega_ccsd_a2 => omega_ccsd_a2_ccsd public interface omega_ccsd_a2_ccsd () Arguments None procedure, public :: omega_ccsd_b2 => omega_ccsd_b2_ccsd public interface omega_ccsd_b2_ccsd () Arguments None procedure, public :: omega_ccsd_c2 => omega_ccsd_c2_ccsd public interface omega_ccsd_c2_ccsd () Arguments None procedure, public :: omega_ccsd_d2 => omega_ccsd_d2_ccsd public interface omega_ccsd_d2_ccsd () Arguments None procedure, public :: omega_ccsd_e2 => omega_ccsd_e2_ccsd public interface omega_ccsd_e2_ccsd () Arguments None procedure, public :: calculate_orbital_differences => calculate_orbital_differences_ccsd public interface calculate_orbital_differences_ccsd () Arguments None procedure, public :: transform_trial_vectors => transform_trial_vectors_ccsd public interface transform_trial_vectors_ccsd () Arguments None procedure, public :: print_excitation_vector => print_excitation_vector_ccsd public interface print_excitation_vector_ccsd () Arguments None procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_ccsd public interface analyze_double_excitation_vector_ccsd () Arguments None procedure, public :: summary_excited_state_info => summary_excited_state_info_ccsd public interface summary_excited_state_info_ccsd () Arguments None procedure, public :: excited_state_preparations => excited_state_preparations_ccsd public interface excited_state_preparations_ccsd () Arguments None procedure, public :: jacobian_ccsd_transformation => jacobian_ccsd_transformation_ccsd public interface jacobian_ccsd_transformation_ccsd () Arguments None procedure, public :: jacobian_ccsd_a1 => jacobian_ccsd_a1_ccsd public interface jacobian_ccsd_a1_ccsd () Arguments None procedure, public :: jacobian_ccsd_b1 => jacobian_ccsd_b1_ccsd public interface jacobian_ccsd_b1_ccsd () Arguments None procedure, public :: jacobian_ccsd_c1 => jacobian_ccsd_c1_ccsd public interface jacobian_ccsd_c1_ccsd () Arguments None procedure, public :: jacobian_ccsd_d1 => jacobian_ccsd_d1_ccsd public interface jacobian_ccsd_d1_ccsd () Arguments None procedure, public :: jacobian_ccsd_a2 => jacobian_ccsd_a2_ccsd public interface jacobian_ccsd_a2_ccsd () Arguments None procedure, public :: jacobian_ccsd_b2 => jacobian_ccsd_b2_ccsd public interface jacobian_ccsd_b2_ccsd () Arguments None procedure, public :: jacobian_ccsd_c2 => jacobian_ccsd_c2_ccsd public interface jacobian_ccsd_c2_ccsd () Arguments None procedure, public :: jacobian_ccsd_d2 => jacobian_ccsd_d2_ccsd public interface jacobian_ccsd_d2_ccsd () Arguments None procedure, public :: jacobian_ccsd_e2 => jacobian_ccsd_e2_ccsd public interface jacobian_ccsd_e2_ccsd () Arguments None procedure, public :: jacobian_ccsd_f2 => jacobian_ccsd_f2_ccsd public interface jacobian_ccsd_f2_ccsd () Arguments None procedure, public :: jacobian_ccsd_g2 => jacobian_ccsd_g2_ccsd public interface jacobian_ccsd_g2_ccsd () Arguments None procedure, public :: jacobian_ccsd_h2 => jacobian_ccsd_h2_ccsd public interface jacobian_ccsd_h2_ccsd () Arguments None procedure, public :: jacobian_ccsd_i2 => jacobian_ccsd_i2_ccsd public interface jacobian_ccsd_i2_ccsd () Arguments None procedure, public :: jacobian_ccsd_j2 => jacobian_ccsd_j2_ccsd public interface jacobian_ccsd_j2_ccsd () Arguments None procedure, public :: jacobian_ccsd_k2 => jacobian_ccsd_k2_ccsd public interface jacobian_ccsd_k2_ccsd () Arguments None procedure, public :: jacobi_test => jacobi_test_ccsd public subroutine jacobi_test_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: jacobian_transpose_ccsd_transformation => jacobian_transpose_ccsd_transformation_ccsd public interface jacobian_transpose_ccsd_transformation_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_a1 => jacobian_transpose_ccsd_a1_ccsd public interface jacobian_transpose_ccsd_a1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_b1 => jacobian_transpose_ccsd_b1_ccsd public interface jacobian_transpose_ccsd_b1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_c1 => jacobian_transpose_ccsd_c1_ccsd public interface jacobian_transpose_ccsd_c1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_d1 => jacobian_transpose_ccsd_d1_ccsd public interface jacobian_transpose_ccsd_d1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_e1 => jacobian_transpose_ccsd_e1_ccsd public interface jacobian_transpose_ccsd_e1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_f1 => jacobian_transpose_ccsd_f1_ccsd public interface jacobian_transpose_ccsd_f1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_g1 => jacobian_transpose_ccsd_g1_ccsd public interface jacobian_transpose_ccsd_g1_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_a2 => jacobian_transpose_ccsd_a2_ccsd public interface jacobian_transpose_ccsd_a2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_b2 => jacobian_transpose_ccsd_b2_ccsd public interface jacobian_transpose_ccsd_b2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_c2 => jacobian_transpose_ccsd_c2_ccsd public interface jacobian_transpose_ccsd_c2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_d2 => jacobian_transpose_ccsd_d2_ccsd public interface jacobian_transpose_ccsd_d2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_e2 => jacobian_transpose_ccsd_e2_ccsd public interface jacobian_transpose_ccsd_e2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_f2 => jacobian_transpose_ccsd_f2_ccsd public interface jacobian_transpose_ccsd_f2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_g2 => jacobian_transpose_ccsd_g2_ccsd public interface jacobian_transpose_ccsd_g2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_h2 => jacobian_transpose_ccsd_h2_ccsd public interface jacobian_transpose_ccsd_h2_ccsd () Arguments None procedure, public :: jacobian_transpose_ccsd_i2 => jacobian_transpose_ccsd_i2_ccsd public interface jacobian_transpose_ccsd_i2_ccsd () Arguments None procedure, public :: ionization_residual_projection => ionization_residual_projection_ccsd public interface ionization_residual_projection_ccsd () Arguments None procedure, public :: ionization_rho_aibj_projection => ionization_rho_aibj_projection_ccsd public interface ionization_rho_aibj_projection_ccsd () Arguments None procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_ccsd public interface cvs_rho_aibj_projection_ccsd () Arguments None procedure, public :: cvs_residual_projection => cvs_residual_projection_ccsd public interface cvs_residual_projection_ccsd () Arguments None procedure, public :: construct_eta => construct_eta_ccsd public subroutine construct_eta_ccsd (wf, eta) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta procedure, public :: save_amplitudes => save_amplitudes_ccsd public subroutine save_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: read_amplitudes => read_amplitudes_ccsd public subroutine read_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: read_double_amplitudes => read_double_amplitudes_ccsd public subroutine read_double_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: destruct_amplitudes => destruct_amplitudes_ccsd public subroutine destruct_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: destruct_omega => destruct_omega_ccsd public subroutine destruct_omega_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: construct_perturbative_doubles => construct_perturbative_doubles_ccsd public subroutine construct_perturbative_doubles_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: calc_energy => calc_energy_ccsd public subroutine calc_energy_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: omega_integrals => omega_integrals_cc3 public interface omega_integrals_cc3 () Arguments None procedure, public :: calc_triples => calc_triples_cc3 public interface calc_triples_cc3 () Arguments None procedure, public :: omega_cc3_a1 => omega_cc3_a1_cc3 public interface omega_cc3_a1_cc3 () Arguments None procedure, public :: omega_cc3_a2 => omega_cc3_a2_cc3 public interface omega_cc3_a2_cc3 () Arguments None procedure, public :: omega_cc3_b2 => omega_cc3_b2_cc3 public interface omega_cc3_b2_cc3 () Arguments None procedure, public :: init => init_ccsdpt public subroutine init_ccsdpt (wf) Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf procedure, public :: construct_omega => construct_omega_ccsdpt public interface construct_omega_ccsdpt () Arguments None procedure, public :: calc_energy_correction => calc_energy_correction_ccsdpt public subroutine calc_energy_correction_ccsdpt (wf) Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf procedure, public :: destruct_ground_state => destruct_ground_state_ccsdpt public interface destruct_ground_state_ccsdpt () Arguments None","tags":"","loc":"type/ccsdpt.html","title":"ccsdpt – The eT program "},{"text":"public function remove_preceding_blanks(line) Remove Preceding Blanks. \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017\n\nRemoves white spaces before text from line Arguments Type Intent Optional Attributes Name character(len=40) :: line Return Value character(len=40) Called By proc~~remove_preceding_blanks~~CalledByGraph proc~remove_preceding_blanks remove_preceding_blanks proc~method_reader method_reader proc~method_reader->proc~remove_preceding_blanks proc~orbital_reader_mlcc_orb orbital_reader_mlcc_orb proc~orbital_reader_mlcc_orb->proc~remove_preceding_blanks program~et_program eT_program program~et_program->proc~method_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/remove_preceding_blanks.html","title":"remove_preceding_blanks – The eT program"},{"text":"public subroutine method_reader(unit_input, method) Method Reader\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017 Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: unit_input character(len=40) :: method Calls proc~~method_reader~~CallsGraph proc~method_reader method_reader proc~remove_preceding_blanks remove_preceding_blanks proc~method_reader->proc~remove_preceding_blanks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~method_reader~~CalledByGraph proc~method_reader method_reader program~et_program eT_program program~et_program->proc~method_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/method_reader.html","title":"method_reader – The eT program"},{"text":"public function get_available() Arguments None Return Value integer Called By proc~~get_available~~CalledByGraph proc~get_available get_available proc~read_transform_cholesky_hf read_transform_cholesky_hf proc~read_transform_cholesky_hf->proc~get_available proc~calc_energy_mlcc2 calc_energy_mlcc2 proc~calc_energy_mlcc2->proc~get_available proc~calc_energy_cc2 calc_energy_cc2 proc~calc_energy_cc2->proc~get_available Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_available.html","title":"get_available – The eT program"},{"text":"public subroutine work_init() Arguments None","tags":"","loc":"proc/work_init.html","title":"work_init – The eT program"},{"text":"public subroutine allocator(elm, M, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N Called By proc~~allocator~~CalledByGraph proc~allocator allocator proc~check_orthogonality check_orthogonality proc~check_orthogonality->proc~allocator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/allocator.html","title":"allocator – The eT program"},{"text":"public subroutine deallocator(elm, M, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N Called By proc~~deallocator~~CalledByGraph proc~deallocator deallocator proc~check_orthogonality check_orthogonality proc~check_orthogonality->proc~deallocator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/deallocator.html","title":"deallocator – The eT program"},{"text":"public subroutine allocator_int(elm, M, N) Arguments Type Intent Optional Attributes Name integer, dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N","tags":"","loc":"proc/allocator_int.html","title":"allocator_int – The eT program"},{"text":"public subroutine deallocator_int(elm, M, N) Arguments Type Intent Optional Attributes Name integer, dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N","tags":"","loc":"proc/deallocator_int.html","title":"deallocator_int – The eT program"},{"text":"public function index_packed(i, j) Packed index    \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nCalculates the packed index of symetric matrix. Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j Return Value integer(kind=i15) Called By proc~~index_packed~~CalledByGraph proc~index_packed index_packed proc~calc_energy_ccsd calc_energy_ccsd proc~calc_energy_ccsd->proc~index_packed proc~squareup_to_compound squareup_to_compound proc~squareup_to_compound->proc~index_packed proc~save_amplitudes_mlccsd save_amplitudes_mlccsd proc~save_amplitudes_mlccsd->proc~index_packed proc~jacobi_test_ccsd jacobi_test_ccsd proc~jacobi_test_ccsd->proc~index_packed proc~construct_eta_ccsd construct_eta_ccsd proc~construct_eta_ccsd->proc~index_packed proc~read_cholesky_ab_hf read_cholesky_ab_hf proc~read_cholesky_ab_hf->proc~index_packed proc~construct_perturbative_doubles_ccsd construct_perturbative_doubles_ccsd proc~construct_perturbative_doubles_ccsd->proc~index_packed proc~read_cholesky_ij_hf read_cholesky_ij_hf proc~read_cholesky_ij_hf->proc~index_packed proc~calc_energy_cc2 calc_energy_cc2 proc~calc_energy_cc2->proc~index_packed proc~calc_energy_correction_ccsdpt calc_energy_correction_ccsdpt proc~calc_energy_correction_ccsdpt->proc~index_packed proc~save_amplitudes_cc2 save_amplitudes_cc2 proc~save_amplitudes_cc2->proc~index_packed proc~packin packin proc~packin->proc~index_packed proc~read_transform_cholesky_hf read_transform_cholesky_hf proc~read_transform_cholesky_hf->proc~index_packed proc~squareup squareup proc~read_transform_cholesky_hf->proc~squareup proc~construct_ao_fock_hf construct_ao_fock_hf proc~construct_ao_fock_hf->proc~index_packed proc~construct_ao_fock_hf->proc~squareup proc~save_amplitudes_mlcc2 save_amplitudes_mlcc2 proc~save_amplitudes_mlcc2->proc~index_packed proc~construct_perturbative_doubles_mlccsd construct_perturbative_doubles_mlccsd proc~construct_perturbative_doubles_mlccsd->proc~index_packed proc~squareup->proc~index_packed proc~construct_ao_fock_new_hf construct_ao_fock_new_hf proc~construct_ao_fock_new_hf->proc~squareup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/index_packed.html","title":"index_packed – The eT program"},{"text":"public function index_three(p, q, r, dim_p, dim_q) Three index compound\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nReturns the compound index (pqr) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: p integer(kind=i15), intent(in) :: q integer(kind=i15), intent(in) :: r integer(kind=i15), intent(in) :: dim_p integer(kind=i15), intent(in) :: dim_q Return Value integer(kind=i15)","tags":"","loc":"proc/index_three.html","title":"index_three – The eT program"},{"text":"public function index_two(p, q, dim_p) Two index compound\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nReturns the compound index (pq) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: p integer(kind=i15), intent(in) :: q integer(kind=i15), intent(in) :: dim_p Return Value integer(kind=i15) Called By proc~~index_two~~CalledByGraph proc~index_two index_two proc~calc_energy_ccsd calc_energy_ccsd proc~calc_energy_ccsd->proc~index_two proc~calc_energy_correction_ccsdpt calc_energy_correction_ccsdpt proc~calc_energy_correction_ccsdpt->proc~index_two proc~read_cholesky_ia_hf read_cholesky_ia_hf proc~read_cholesky_ia_hf->proc~index_two proc~save_amplitudes_mlcc2 save_amplitudes_mlcc2 proc~save_amplitudes_mlcc2->proc~index_two proc~calc_energy_mlccsd calc_energy_mlccsd proc~calc_energy_mlccsd->proc~index_two proc~construct_eta_ccsd construct_eta_ccsd proc~construct_eta_ccsd->proc~index_two proc~read_cholesky_ab_hf read_cholesky_ab_hf proc~read_cholesky_ab_hf->proc~index_two proc~save_amplitudes_mlccsd save_amplitudes_mlccsd proc~save_amplitudes_mlccsd->proc~index_two proc~construct_density_matrices_hf construct_density_matrices_hf proc~construct_density_matrices_hf->proc~index_two proc~calc_energy_cc2 calc_energy_cc2 proc~calc_energy_cc2->proc~index_two proc~read_cholesky_ij_hf read_cholesky_ij_hf proc~read_cholesky_ij_hf->proc~index_two proc~calc_energy_mp2 calc_energy_mp2 proc~calc_energy_mp2->proc~index_two proc~construct_eta_ccs construct_eta_ccs proc~construct_eta_ccs->proc~index_two proc~save_amplitudes_cc2 save_amplitudes_cc2 proc~save_amplitudes_cc2->proc~index_two proc~squareup_to_compound squareup_to_compound proc~squareup_to_compound->proc~index_two proc~construct_perturbative_doubles_ccsd construct_perturbative_doubles_ccsd proc~construct_perturbative_doubles_ccsd->proc~index_two proc~jacobi_test_ccsd jacobi_test_ccsd proc~jacobi_test_ccsd->proc~index_two proc~calc_energy_mlcc2 calc_energy_mlcc2 proc~calc_energy_mlcc2->proc~index_two proc~read_cholesky_ai_hf read_cholesky_ai_hf proc~read_cholesky_ai_hf->proc~index_two proc~construct_perturbative_doubles_mlccsd construct_perturbative_doubles_mlccsd proc~construct_perturbative_doubles_mlccsd->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/index_two.html","title":"index_two – The eT program"},{"text":"public function packed_size(N) Packed size    \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nReturns size of packed symmetric matrices\nof dimension N x N (triangular elements) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: N Return Value integer(kind=i15) Called By proc~~packed_size~~CalledByGraph proc~packed_size packed_size proc~read_transform_cholesky_hf read_transform_cholesky_hf proc~read_transform_cholesky_hf->proc~packed_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/packed_size.html","title":"packed_size – The eT program"},{"text":"public function check_orthogonality(A, M, N) Uses: workspace proc~~check_orthogonality~~UsesGraph proc~check_orthogonality check_orthogonality module~workspace workspace module~workspace->proc~check_orthogonality module~types types module~types->module~workspace module~input_output input_output module~types->module~input_output module~input_output->module~workspace Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Check orthogonality\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 Check if columns of A are orthogonal. A is (M x N) matrix.\nReturns logical. Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(M,N) :: A integer(kind=i15) :: M integer(kind=i15) :: N Return Value logical Calls proc~~check_orthogonality~~CallsGraph proc~check_orthogonality check_orthogonality proc~allocator allocator proc~check_orthogonality->proc~allocator proc~deallocator deallocator proc~check_orthogonality->proc~deallocator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/check_orthogonality.html","title":"check_orthogonality – The eT program"},{"text":"public subroutine squareup(packed, unpacked, N) Square up packed symmetric matrix\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nSquares up to full dimension (N x N) of packed matrices. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:,:) :: packed real(kind=dp), dimension(:,:) :: unpacked integer(kind=i15), intent(in) :: N Calls proc~~squareup~~CallsGraph proc~squareup squareup proc~index_packed index_packed proc~squareup->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~squareup~~CalledByGraph proc~squareup squareup proc~read_transform_cholesky_hf read_transform_cholesky_hf proc~read_transform_cholesky_hf->proc~squareup proc~construct_ao_fock_new_hf construct_ao_fock_new_hf proc~construct_ao_fock_new_hf->proc~squareup proc~construct_ao_fock_hf construct_ao_fock_hf proc~construct_ao_fock_hf->proc~squareup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/squareup.html","title":"squareup – The eT program"},{"text":"public subroutine squareup_to_compound(packed, unpacked, N, M) Square up packed symmetric matrix\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nSquares up to full dimension ((N x N), M) of packed matrices. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(N*(N+1)/2,M) :: packed real(kind=dp), dimension(N*N,M) :: unpacked integer(kind=i15), intent(in) :: N integer(kind=i15), intent(in) :: M Calls proc~~squareup_to_compound~~CallsGraph proc~squareup_to_compound squareup_to_compound proc~index_two index_two proc~squareup_to_compound->proc~index_two proc~index_packed index_packed proc~squareup_to_compound->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/squareup_to_compound.html","title":"squareup_to_compound – The eT program"},{"text":"public subroutine packin(packed, unpacked, N) Pack in symmetric matrix\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nPack down full square matrix of dimension N x N. Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:) :: packed real(kind=dp), intent(in), dimension(:,:) :: unpacked integer(kind=i15), intent(in) :: N Calls proc~~packin~~CallsGraph proc~packin packin proc~index_packed index_packed proc~packin->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/packin.html","title":"packin – The eT program"},{"text":"public subroutine num_batch(required, available, max_batch_length, n_batch, batch_dimension) Number of batches \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nCalculates number of batches\n\nBatching structure will be:\nWith rest:     (n_batch-1)*(max_batch_length) + rest = required\nWithout rest:  (n_batch)*(max_batch_length) = required Arguments Type Intent Optional Attributes Name integer(kind=i15) :: required integer(kind=i15), intent(in) :: available integer(kind=i15) :: max_batch_length integer(kind=i15) :: n_batch integer(kind=i15), intent(in) :: batch_dimension Called By proc~~num_batch~~CalledByGraph proc~num_batch num_batch proc~read_transform_cholesky_hf read_transform_cholesky_hf proc~read_transform_cholesky_hf->proc~num_batch proc~calc_energy_mlcc2 calc_energy_mlcc2 proc~calc_energy_mlcc2->proc~num_batch proc~calc_energy_cc2 calc_energy_cc2 proc~calc_energy_cc2->proc~num_batch Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/num_batch.html","title":"num_batch – The eT program"},{"text":"public subroutine num_two_batch(required, available, max_batch_length, n_batch, batch_dimension) Number of batches \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nCalculates number of batches when two batching variables are needed\n\nBatching structure will be:\nWith rest:     (n_batch-1)*(max_batch_length) + rest = required\nWithout rest:  (n_batch)*(max_batch_length) = required Arguments Type Intent Optional Attributes Name integer(kind=i15) :: required integer(kind=i15), intent(in) :: available integer(kind=i15) :: max_batch_length integer(kind=i15) :: n_batch integer(kind=i15), intent(in) :: batch_dimension","tags":"","loc":"proc/num_two_batch.html","title":"num_two_batch – The eT program"},{"text":"public subroutine batch_limits(first, last, batch_number, max_batch_length, batch_dimension) Batch limits \n Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\n Find batch limits (first and last)\n\n batch_number: the current batch (1,2,...,n_batch)\n max_batch_length: the length of each batch (except the last, which may be a rest, see n_one_batch routine)\n batch_dimension: the dimensionality of the batching variable (e.g., n_vir for a virtual index) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: first integer(kind=i15) :: last integer(kind=i15), intent(in) :: batch_number integer(kind=i15), intent(in) :: max_batch_length integer(kind=i15), intent(in) :: batch_dimension Called By proc~~batch_limits~~CalledByGraph proc~batch_limits batch_limits proc~read_transform_cholesky_hf read_transform_cholesky_hf proc~read_transform_cholesky_hf->proc~batch_limits proc~calc_energy_mlcc2 calc_energy_mlcc2 proc~calc_energy_mlcc2->proc~batch_limits proc~calc_energy_cc2 calc_energy_cc2 proc~calc_energy_cc2->proc~batch_limits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/batch_limits.html","title":"batch_limits – The eT program"},{"text":"public subroutine get_n_lowest(n, size, vec, sorted_short_vec, index_list) Get n lowest elements\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\nFinds the n lowest values of vec,\nsorts them, and returns them in sorted_short_vec \ntogether with an index list refering to the indices of the \nlowest elements in the original vector. Arguments Type Intent Optional Attributes Name integer(kind=i15) :: n integer(kind=i15) :: size real(kind=dp), dimension(size, 1) :: vec real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 1) :: index_list","tags":"","loc":"proc/get_n_lowest.html","title":"get_n_lowest – The eT program"},{"text":"public subroutine init_memory_manager(mem, total) Init (Memory Manager)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nInitializes the memory manager object by setting the \ntotal and initial available memory\n\nThis is only called if the user specifies a total memory \ndifferent from the standard Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem integer(kind=i15) :: total","tags":"","loc":"proc/init_memory_manager.html","title":"init_memory_manager – The eT program"},{"text":"public subroutine alloc_memory_manager(mem, array, M, N) Alloc (Memory Manager)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nAllocates a double precision array and updates the available \nmemory accordingly. Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem real(kind=dp), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N","tags":"","loc":"proc/alloc_memory_manager.html","title":"alloc_memory_manager – The eT program"},{"text":"public subroutine dealloc_memory_manager(mem, array, M, N) Dealloc (Memory Manager)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nDeallocates a double precision array and updates the available \nmemory accordingly. Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem real(kind=dp), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N","tags":"","loc":"proc/dealloc_memory_manager.html","title":"dealloc_memory_manager – The eT program"},{"text":"public subroutine alloc_int_memory_manager(mem, array, M, N) Alloc Int (Memory Manager)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nAllocates an integer array and updates the available \nmemory accordingly. Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem integer(kind=i15), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N","tags":"","loc":"proc/alloc_int_memory_manager.html","title":"alloc_int_memory_manager – The eT program"},{"text":"public subroutine dealloc_int_memory_manager(mem, array, M, N) Dealloc Int (Memory Manager)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nDeallocates an integer array and updates the available \nmemory accordingly. Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem integer(kind=i15), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N","tags":"","loc":"proc/dealloc_int_memory_manager.html","title":"dealloc_int_memory_manager – The eT program"},{"text":"public subroutine num_batch_memory_manager(mem, batch_p, required) Number of batches \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nGiven the required memory, this routine determines, for a one-index batching,\nthe maximum batch length and the number of batches in total. Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem class( batching_index ) :: batch_p integer(kind=i15) :: required","tags":"","loc":"proc/num_batch_memory_manager.html","title":"num_batch_memory_manager – The eT program"},{"text":"public subroutine num_two_batch_memory_manager(mem, batch_p, batch_q, required) Number of two-batches \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nGiven the required memory, this routine determines, for two-index batching,\nthe maximum batch length and the number of batches in total of both batching\nindices. Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem class( batching_index ) :: batch_p class( batching_index ) :: batch_q integer(kind=i15) :: required","tags":"","loc":"proc/num_two_batch_memory_manager.html","title":"num_two_batch_memory_manager – The eT program"},{"text":"public subroutine init_batching_index(batch_p, dimension) Init (batching index) \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nNote: every batching index must be initialized!\nThe 'dimension' variable specifies the total length of the \nbatching index, e.g. the number of virtuals for a virtual index. Arguments Type Intent Optional Attributes Name class( batching_index ) :: batch_p integer(kind=i15), intent(in) :: dimension","tags":"","loc":"proc/init_batching_index.html","title":"init_batching_index – The eT program"},{"text":"public subroutine determine_limits_batching_index(batch_p, batch_number) Determine limits \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017 Arguments Type Intent Optional Attributes Name class( batching_index ) :: batch_p integer(kind=i15), intent(in) :: batch_number","tags":"","loc":"proc/determine_limits_batching_index.html","title":"determine_limits_batching_index – The eT program"},{"text":"public subroutine generate_unit_identifier(unit_identifier) Generate unit identifier\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, April 2017\n\nReturns a valid unit identifier for opening file. Arguments Type Intent Optional Attributes Name integer(kind=i15) :: unit_identifier Called By proc~~generate_unit_identifier~~CalledByGraph proc~generate_unit_identifier generate_unit_identifier proc~read_cholesky_ij_hf read_cholesky_ij_hf proc~read_cholesky_ij_hf->proc~generate_unit_identifier proc~init_ccsdpt init_ccsdpt proc~init_ccsdpt->proc~generate_unit_identifier proc~construct_ao_fock_hf construct_ao_fock_hf proc~construct_ao_fock_hf->proc~generate_unit_identifier proc~read_cc2_double_amplitudes_cc2 read_cc2_double_amplitudes_cc2 proc~read_cc2_double_amplitudes_cc2->proc~generate_unit_identifier proc~read_double_amplitudes_ccsd read_double_amplitudes_ccsd proc~read_double_amplitudes_ccsd->proc~generate_unit_identifier proc~init_ccsd init_ccsd proc~init_ccsd->proc~generate_unit_identifier proc~read_cholesky_ia_hf read_cholesky_ia_hf proc~read_cholesky_ia_hf->proc~generate_unit_identifier proc~read_cholesky_ab_hf read_cholesky_ab_hf proc~read_cholesky_ab_hf->proc~generate_unit_identifier proc~init_ccs init_ccs proc~init_ccs->proc~generate_unit_identifier proc~init_cc3 init_cc3 proc~init_cc3->proc~generate_unit_identifier proc~init_mlccsd init_mlccsd proc~init_mlccsd->proc~generate_unit_identifier proc~save_amplitudes_ccs save_amplitudes_ccs proc~save_amplitudes_ccs->proc~generate_unit_identifier proc~read_center_info read_center_info proc~read_center_info->proc~generate_unit_identifier proc~read_transform_cholesky_hf read_transform_cholesky_hf proc~read_transform_cholesky_hf->proc~generate_unit_identifier program~et_program eT_program program~et_program->proc~generate_unit_identifier proc~read_hf_info_hf read_hf_info_hf proc~read_hf_info_hf->proc~generate_unit_identifier proc~init_cc2 init_cc2 proc~init_cc2->proc~generate_unit_identifier proc~read_single_amplitudes_ccs read_single_amplitudes_ccs proc~read_single_amplitudes_ccs->proc~generate_unit_identifier proc~save_amplitudes_mlcc2 save_amplitudes_mlcc2 proc~save_amplitudes_mlcc2->proc~generate_unit_identifier proc~construct_ao_fock_new_hf construct_ao_fock_new_hf proc~construct_ao_fock_new_hf->proc~generate_unit_identifier proc~save_amplitudes_mlccsd save_amplitudes_mlccsd proc~save_amplitudes_mlccsd->proc~generate_unit_identifier proc~save_amplitudes_ccsd save_amplitudes_ccsd proc~save_amplitudes_ccsd->proc~generate_unit_identifier proc~read_double_amplitudes_mlccsd read_double_amplitudes_mlccsd proc~read_double_amplitudes_mlccsd->proc~generate_unit_identifier proc~read_atom_info read_atom_info proc~read_atom_info->proc~generate_unit_identifier proc~init_mlcc2 init_mlcc2 proc~init_mlcc2->proc~generate_unit_identifier proc~save_amplitudes_cc2 save_amplitudes_cc2 proc~save_amplitudes_cc2->proc~generate_unit_identifier proc~read_cc2_double_amplitudes_mlcc2 read_cc2_double_amplitudes_mlcc2 proc~read_cc2_double_amplitudes_mlcc2->proc~generate_unit_identifier proc~read_mlccsd_double_amplitudes_mlccsd read_mlccsd_double_amplitudes_mlccsd proc~read_mlccsd_double_amplitudes_mlccsd->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/generate_unit_identifier.html","title":"generate_unit_identifier – The eT program"},{"text":"public subroutine vec_print(vec, dim_1, dim_2) Vector print\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, March 2017\n\nA vector is printed with a compound index (p q) of dimension (dim_1 x dim_2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(dim_1, dim_2) :: vec integer(kind=i15), intent(in) :: dim_1 integer(kind=i15), intent(in) :: dim_2","tags":"","loc":"proc/vec_print.html","title":"vec_print – The eT program"},{"text":"public subroutine vec_print_nonzero_elm(vec, dim_1, dim_2) Vector print\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, March 2017\n\nA vector is printed with a compound index (p q) of dimension (dim_1 x dim_2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(dim_1, dim_2) :: vec integer(kind=i15), intent(in) :: dim_1 integer(kind=i15), intent(in) :: dim_2","tags":"","loc":"proc/vec_print_nonzero_elm.html","title":"vec_print_nonzero_elm – The eT program"},{"text":"public subroutine orbital_reader_mlcc_orb(orbital_info, unit_input) Arguments Type Intent Optional Attributes Name class( mlcc_orbitals ) :: orbital_info integer(kind=i15) :: unit_input Calls proc~~orbital_reader_mlcc_orb~~CallsGraph proc~orbital_reader_mlcc_orb orbital_reader_mlcc_orb proc~remove_preceding_blanks remove_preceding_blanks proc~orbital_reader_mlcc_orb->proc~remove_preceding_blanks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/orbital_reader_mlcc_orb.html","title":"orbital_reader_mlcc_orb – The eT program"},{"text":"public subroutine init_hf(wf) Initialization of Hartree-Fock object\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nPerforms the following tasks:\n\n1. Sets HF orbital and energy information by reading from file\n2. Transforms AO Cholesky vectors to MO basis and saves to file Arguments Type Intent Optional Attributes Name class( hf ) :: wf","tags":"","loc":"proc/init_hf.html","title":"init_hf – The eT program"},{"text":"public subroutine drv_hf(wf) Driver (HF)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nLets the user know there is no driver for Hartree-Fock and exits\nthe program if called. The module reads Hartree-Fock information \nfrom files and contains no independent solver. Arguments Type Intent Optional Attributes Name class( hf ) :: wf","tags":"","loc":"proc/drv_hf.html","title":"drv_hf – The eT program"},{"text":"public subroutine read_hf_info_hf(wf) Read HF Info\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the file mlcc_hf_info and sets the following HF variables: \nn_o, n_v, n_mo, orbital_coef, and the fock_diagonal.\n\nThe file mlcc_hf_info is written in the mlcc_write_sirifc \nsubroutine, which is called from the wr_sirifc subroutine in\nthe siropt module of the DALTON suite. Arguments Type Intent Optional Attributes Name class( hf ) :: wf Calls proc~~read_hf_info_hf~~CallsGraph proc~read_hf_info_hf read_hf_info_hf proc~generate_unit_identifier generate_unit_identifier proc~read_hf_info_hf->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_hf_info_hf.html","title":"read_hf_info_hf – The eT program"},{"text":"public subroutine read_transform_cholesky_hf(wf) Read and Transform Cholesky\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, 20 Apr 2017\n\nReads the AO Cholesky vectors from file, transforms the vectors \nto the MO basis, and saves the MO vectors to file Arguments Type Intent Optional Attributes Name class( hf ) :: wf Calls proc~~read_transform_cholesky_hf~~CallsGraph proc~read_transform_cholesky_hf read_transform_cholesky_hf proc~batch_limits batch_limits proc~read_transform_cholesky_hf->proc~batch_limits proc~generate_unit_identifier generate_unit_identifier proc~read_transform_cholesky_hf->proc~generate_unit_identifier proc~packed_size packed_size proc~read_transform_cholesky_hf->proc~packed_size proc~num_batch num_batch proc~read_transform_cholesky_hf->proc~num_batch dgemm dgemm proc~read_transform_cholesky_hf->dgemm proc~get_available get_available proc~read_transform_cholesky_hf->proc~get_available proc~index_packed index_packed proc~read_transform_cholesky_hf->proc~index_packed proc~squareup squareup proc~read_transform_cholesky_hf->proc~squareup proc~squareup->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_transform_cholesky_hf.html","title":"read_transform_cholesky_hf – The eT program"},{"text":"public subroutine read_cholesky_ij_hf(wf, L_ij_J, i_first, i_last, j_first, j_last) Read Cholesky IJ \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky IJ (occ-occ) vectors from file and \nplaces them in the incoming L_ij_J matrix\n\nOptional arguments: i_first, i_last, j_first, j_last can be used in order to restrict indices Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last Calls proc~~read_cholesky_ij_hf~~CallsGraph proc~read_cholesky_ij_hf read_cholesky_ij_hf proc~index_packed index_packed proc~read_cholesky_ij_hf->proc~index_packed proc~generate_unit_identifier generate_unit_identifier proc~read_cholesky_ij_hf->proc~generate_unit_identifier proc~index_two index_two proc~read_cholesky_ij_hf->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_cholesky_ij_hf.html","title":"read_cholesky_ij_hf – The eT program"},{"text":"public subroutine read_cholesky_ia_hf(wf, L_ia_J, i_first, i_last, a_first, a_last) Read Cholesky IA \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky IA (occ-vir) vectors from file and\nplaces them in the incoming L_ia_J matrix\n\n\nOptional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last Calls proc~~read_cholesky_ia_hf~~CallsGraph proc~read_cholesky_ia_hf read_cholesky_ia_hf proc~index_two index_two proc~read_cholesky_ia_hf->proc~index_two proc~generate_unit_identifier generate_unit_identifier proc~read_cholesky_ia_hf->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_cholesky_ia_hf.html","title":"read_cholesky_ia_hf – The eT program"},{"text":"public subroutine read_cholesky_ai_hf(wf, L_ai_J, a_first, a_last, i_first, i_last) Read Cholesky AI \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky AI (vir-occ) vectors from file and\nplaces them in the incoming L_ai_J matrix\n\nOptional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last Calls proc~~read_cholesky_ai_hf~~CallsGraph proc~read_cholesky_ai_hf read_cholesky_ai_hf proc~index_two index_two proc~read_cholesky_ai_hf->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_cholesky_ai_hf.html","title":"read_cholesky_ai_hf – The eT program"},{"text":"public subroutine read_cholesky_ab_hf(wf, L_ab_J, a_first, a_last, b_first, b_last) Read Cholesky AB \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky AB (vir-vir) vectors from file and\nplaces them in the incoming L_ab_J matrix, with batching \nif necessary\n\nOptional arguments: b_first, b_last, a_first, a_last can be used in order to restrict indices Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last Calls proc~~read_cholesky_ab_hf~~CallsGraph proc~read_cholesky_ab_hf read_cholesky_ab_hf proc~index_packed index_packed proc~read_cholesky_ab_hf->proc~index_packed proc~generate_unit_identifier generate_unit_identifier proc~read_cholesky_ab_hf->proc~generate_unit_identifier proc~index_two index_two proc~read_cholesky_ab_hf->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_cholesky_ab_hf.html","title":"read_cholesky_ab_hf – The eT program"},{"text":"public subroutine construct_ao_fock_hf(wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock Calls proc~~construct_ao_fock_hf~~CallsGraph proc~construct_ao_fock_hf construct_ao_fock_hf dgemm dgemm proc~construct_ao_fock_hf->dgemm proc~index_packed index_packed proc~construct_ao_fock_hf->proc~index_packed proc~generate_unit_identifier generate_unit_identifier proc~construct_ao_fock_hf->proc~generate_unit_identifier proc~squareup squareup proc~construct_ao_fock_hf->proc~squareup proc~squareup->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct_ao_fock_hf.html","title":"construct_ao_fock_hf – The eT program"},{"text":"public subroutine construct_ao_fock_new_hf(wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock Calls proc~~construct_ao_fock_new_hf~~CallsGraph proc~construct_ao_fock_new_hf construct_ao_fock_new_hf dgemm dgemm proc~construct_ao_fock_new_hf->dgemm proc~generate_unit_identifier generate_unit_identifier proc~construct_ao_fock_new_hf->proc~generate_unit_identifier daxpy daxpy proc~construct_ao_fock_new_hf->daxpy proc~squareup squareup proc~construct_ao_fock_new_hf->proc~squareup proc~index_packed index_packed proc~squareup->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct_ao_fock_new_hf.html","title":"construct_ao_fock_new_hf – The eT program"},{"text":"public subroutine construct_density_matrices_hf(wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v Calls proc~~construct_density_matrices_hf~~CallsGraph proc~construct_density_matrices_hf construct_density_matrices_hf dgemm dgemm proc~construct_density_matrices_hf->dgemm proc~index_two index_two proc~construct_density_matrices_hf->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct_density_matrices_hf.html","title":"construct_density_matrices_hf – The eT program"},{"text":"public subroutine construct_density_matrix_hf(wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v Calls proc~~construct_density_matrix_hf~~CallsGraph proc~construct_density_matrix_hf construct_density_matrix_hf dgemm dgemm proc~construct_density_matrix_hf->dgemm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct_density_matrix_hf.html","title":"construct_density_matrix_hf – The eT program"},{"text":"public subroutine construct_density_matrix_v_hf(wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v Calls proc~~construct_density_matrix_v_hf~~CallsGraph proc~construct_density_matrix_v_hf construct_density_matrix_v_hf dgemm dgemm proc~construct_density_matrix_v_hf->dgemm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct_density_matrix_v_hf.html","title":"construct_density_matrix_v_hf – The eT program"},{"text":"public subroutine init_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Calls proc~~init_mlccsd~~CallsGraph proc~init_mlccsd init_mlccsd proc~generate_unit_identifier generate_unit_identifier proc~init_mlccsd->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_mlccsd.html","title":"init_mlccsd – The eT program"},{"text":"public subroutine initialize_amplitudes_mlccsd(wf) Initialize Amplitudes (MLCCSD)\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n Allocates the amplitudes, sets them to zero, and calculates\n the number of amplitudes. Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"proc/initialize_amplitudes_mlccsd.html","title":"initialize_amplitudes_mlccsd – The eT program"},{"text":"public subroutine construct_perturbative_doubles_mlccsd(wf) Construct Perturbative Doubles (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nSets the doubles amplitudes (t2am) to its MP2 estimate. This is\nthe initial guess used in the solver for the ground state amplitude \nequations. Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Calls proc~~construct_perturbative_doubles_mlccsd~~CallsGraph proc~construct_perturbative_doubles_mlccsd construct_perturbative_doubles_mlccsd dgemm dgemm proc~construct_perturbative_doubles_mlccsd->dgemm proc~index_packed index_packed proc~construct_perturbative_doubles_mlccsd->proc~index_packed proc~index_two index_two proc~construct_perturbative_doubles_mlccsd->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct_perturbative_doubles_mlccsd.html","title":"construct_perturbative_doubles_mlccsd – The eT program"},{"text":"public subroutine get_CCSD_active_indices_mlccsd(wf, first_o, first_v) Get CC2 active indices,\nWritten by Sarai D. Folkestad, June 2017\n\nReturns the first active occupied and virtual indices \nof the active space. Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: first_o integer(kind=i15) :: first_v","tags":"","loc":"proc/get_ccsd_active_indices_mlccsd.html","title":"get_CCSD_active_indices_mlccsd – The eT program"},{"text":"public subroutine get_CC2_active_indices_mlccsd(wf, first_o, first_v) Get CC2 active indices,\nWritten by Sarai D. Folkestad, June 2017\n\nReturns the first active occupied and virtual indices \nof the active space. Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: first_o integer(kind=i15) :: first_v","tags":"","loc":"proc/get_cc2_active_indices_mlccsd.html","title":"get_CC2_active_indices_mlccsd – The eT program"},{"text":"public subroutine get_CC2_n_active_mlccsd(wf, n_active_o, n_active_v) Get CC2 active indices,\nWritten by Sarai D. Folkestad, June 2017\n\nReturns the first active occupied and virtual indices \nof the active space. Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: n_active_o integer(kind=i15) :: n_active_v","tags":"","loc":"proc/get_cc2_n_active_mlccsd.html","title":"get_CC2_n_active_mlccsd – The eT program"},{"text":"public subroutine get_CCSD_n_active_mlccsd(wf, n_active_o, n_active_v) Get CC2 active indices,\nWritten by Sarai D. Folkestad, June 2017\n\nReturns the first active occupied and virtual indices \nof the active space. Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: n_active_o integer(kind=i15) :: n_active_v","tags":"","loc":"proc/get_ccsd_n_active_mlccsd.html","title":"get_CCSD_n_active_mlccsd – The eT program"},{"text":"public subroutine calc_energy_mlccsd(wf) Calculate Energy (MLCCSD)\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n Calculates the MLCCSD energy for the wavefunction's current amplitudes.\n\n   E = E_scf + sum_AIBJ (t&#94;A_I * t&#94;B_J)*L_IAJB\n             + sum aibj (s&#94;ab_ij + t&#94;ab_ij)L_ia_jb\n\n where lower case letters indicate indices restricted to the CC2+CCSD regions.\n\n s&#94;ab_ij is zero in the CCSD region, and t&#94;ab_ij is zero in the CC2 region. Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Calls proc~~calc_energy_mlccsd~~CallsGraph proc~calc_energy_mlccsd calc_energy_mlccsd dgemm dgemm proc~calc_energy_mlccsd->dgemm proc~index_two index_two proc~calc_energy_mlccsd->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/calc_energy_mlccsd.html","title":"calc_energy_mlccsd – The eT program"},{"text":"public subroutine construct_orbital_coef_CC2_CCS_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"proc/construct_orbital_coef_cc2_ccs_mlccsd.html","title":"construct_orbital_coef_CC2_CCS_mlccsd – The eT program"},{"text":"public subroutine destruct_orbital_coef_CC2_CCS_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"proc/destruct_orbital_coef_cc2_ccs_mlccsd.html","title":"destruct_orbital_coef_CC2_CCS_mlccsd – The eT program"},{"text":"public subroutine construct_orbital_energy_CC2_CCS_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"proc/construct_orbital_energy_cc2_ccs_mlccsd.html","title":"construct_orbital_energy_CC2_CCS_mlccsd – The eT program"},{"text":"public subroutine destruct_orbital_energy_CC2_CCS_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"proc/destruct_orbital_energy_cc2_ccs_mlccsd.html","title":"destruct_orbital_energy_CC2_CCS_mlccsd – The eT program"},{"text":"public subroutine destruct_double_amplitudes_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"proc/destruct_double_amplitudes_mlccsd.html","title":"destruct_double_amplitudes_mlccsd – The eT program"},{"text":"public subroutine destruct_amplitudes_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Calls proc~~destruct_amplitudes_mlccsd~~CallsGraph proc~destruct_amplitudes_mlccsd destruct_amplitudes_mlccsd destruct_amplitudes_ccs destruct_amplitudes_ccs proc~destruct_amplitudes_mlccsd->destruct_amplitudes_ccs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/destruct_amplitudes_mlccsd.html","title":"destruct_amplitudes_mlccsd – The eT program"},{"text":"public subroutine save_amplitudes_mlccsd(wf) Save Amplitudes (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nStore the amplitudes to disk (T1AM, T2AM) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Calls proc~~save_amplitudes_mlccsd~~CallsGraph proc~save_amplitudes_mlccsd save_amplitudes_mlccsd proc~index_two index_two proc~save_amplitudes_mlccsd->proc~index_two proc~generate_unit_identifier generate_unit_identifier proc~save_amplitudes_mlccsd->proc~generate_unit_identifier proc~index_packed index_packed proc~save_amplitudes_mlccsd->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/save_amplitudes_mlccsd.html","title":"save_amplitudes_mlccsd – The eT program"},{"text":"public subroutine read_amplitudes_mlccsd(wf) Read Amplitudes (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"proc/read_amplitudes_mlccsd.html","title":"read_amplitudes_mlccsd – The eT program"},{"text":"public subroutine read_mlccsd_double_amplitudes_mlccsd(wf) Read Amplitudes (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM, T2AM) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Calls proc~~read_mlccsd_double_amplitudes_mlccsd~~CallsGraph proc~read_mlccsd_double_amplitudes_mlccsd read_mlccsd_double_amplitudes_mlccsd proc~generate_unit_identifier generate_unit_identifier proc~read_mlccsd_double_amplitudes_mlccsd->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_mlccsd_double_amplitudes_mlccsd.html","title":"read_mlccsd_double_amplitudes_mlccsd – The eT program"},{"text":"public subroutine read_double_amplitudes_mlccsd(wf) Read Amplitudes (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM, T2AM) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Calls proc~~read_double_amplitudes_mlccsd~~CallsGraph proc~read_double_amplitudes_mlccsd read_double_amplitudes_mlccsd proc~generate_unit_identifier generate_unit_identifier proc~read_double_amplitudes_mlccsd->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_double_amplitudes_mlccsd.html","title":"read_double_amplitudes_mlccsd – The eT program"},{"text":"interface public subroutine mlcc_reader_mlccsd(wf, unit_input) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: unit_input","tags":"","loc":"interface/mlcc_reader_mlccsd.html","title":"mlcc_reader_mlccsd – The eT program"},{"text":"interface public module subroutine read_orbital_info_mlccsd(wf, unit_input) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: unit_input","tags":"","loc":"interface/read_orbital_info_mlccsd.html","title":"read_orbital_info_mlccsd – The eT program"},{"text":"interface public module subroutine orbital_partitioning_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Description Orbital partitioning,\n   Written by Sarai D. Folkestad, June 2017\n\n   Directs the partitioning for mlcc calculations.\n\n   So far only Cholesky decomposition is available.","tags":"","loc":"interface/orbital_partitioning_mlccsd.html","title":"orbital_partitioning_mlccsd – The eT program"},{"text":"interface public module subroutine cholesky_localization_drv_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Description Cholesky orbital localization driver,\n   Written by Sarai D. Folkestad, July 2017.\n\n   Driver for Cholesky density decomposition\n\n   - Collects atom and ao-basis information.\n   - Constructs occupied and vacant densities.\n   - Constructs AO Fock matrix.  (This is currently an N&#94;5 operation, should be optimized/removed)\n   - By looping over active spaces, the occupied and virtual densities are Cholesky decomposed\n     and the cholesky vectors are used to generate new localized MO's.\n   - New orbitals are tested for orthonormality (Not implemented yet, only need overlap matrix from DALTON)","tags":"","loc":"interface/cholesky_localization_drv_mlccsd.html","title":"cholesky_localization_drv_mlccsd – The eT program"},{"text":"interface public module subroutine cholesky_localization_CCSD_CC2_CCS_mlccsd(wf, ao_center_info, n_ao_on_center, ao_fock, n_nuclei, unit_cholesky_decomp) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15), dimension(wf%n_ao, 2) :: ao_center_info integer(kind=i15), dimension(n_nuclei, 1) :: n_ao_on_center real(kind=dp), dimension(:,:) :: ao_fock integer(kind=i15) :: n_nuclei integer(kind=i15) :: unit_cholesky_decomp Description Cholesky orbital localization CCS/CC2/CCSD,\n   Written by Sarai D. Folkestad, July 2017\n\n   Cholesky partitiining routine for CCS/CC2/CCSD calculation","tags":"","loc":"interface/cholesky_localization_ccsd_cc2_ccs_mlccsd.html","title":"cholesky_localization_CCSD_CC2_CCS_mlccsd – The eT program"},{"text":"interface public module subroutine cholesky_localization_CCSD_CCS_mlccsd(wf, ao_center_info, n_ao_on_center, ao_fock, n_nuclei, unit_cholesky_decomp) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15), dimension(wf%n_ao, 2) :: ao_center_info integer(kind=i15), dimension(n_nuclei, 1) :: n_ao_on_center real(kind=dp), dimension(:,:) :: ao_fock integer(kind=i15) :: n_nuclei integer(kind=i15) :: unit_cholesky_decomp Description Cholesky orbital localization CCS/CCSD,\n   Written by Sarai D. Folkestad, July 2017\n\n   Cholesky partitiining routine for CCS/CCSD calculation","tags":"","loc":"interface/cholesky_localization_ccsd_ccs_mlccsd.html","title":"cholesky_localization_CCSD_CCS_mlccsd – The eT program"},{"text":"interface public module subroutine cholesky_localization_CCSD_CC2_mlccsd(wf, ao_center_info, n_ao_on_center, ao_fock, n_nuclei, unit_cholesky_decomp) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15), dimension(wf%n_ao, 2) :: ao_center_info integer(kind=i15), dimension(n_nuclei, 1) :: n_ao_on_center real(kind=dp), dimension(:,:) :: ao_fock integer(kind=i15) :: n_nuclei integer(kind=i15) :: unit_cholesky_decomp Description Cholesky orbital localization CC2/CCSD\n   Written by Sarai D. Folkestad, July 2017\n\n   Cholesky partitiining routine for CC2/CCSD calculation","tags":"","loc":"interface/cholesky_localization_ccsd_cc2_mlccsd.html","title":"cholesky_localization_CCSD_CC2_mlccsd – The eT program"},{"text":"interface public module subroutine construct_MO_transformation_matrix_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Description Construct MO transformation matrix,\n   Written by Sarai D. Fokestad, July 2017\n\n   Constructs transformation matrix,\n\n      T = (C_CCSD)&#94;T * S * C_CC2\n\n   between CC2 basis and CCSD basis. \n   Needed for transforming s_ij_ab from CC2 to CCSD basis.","tags":"","loc":"interface/construct_mo_transformation_matrix_mlccsd.html","title":"construct_MO_transformation_matrix_mlccsd – The eT program"},{"text":"interface public module subroutine cnto_orbital_drv_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Description CNTO orbital driver,\n   Written by Sarai D. Folkestad, July 2017.\n\n   A CCS calculation ground state and excited states is performed.\n   The M and N matrices are then constructed,\n\n      M_ij = sum_a R1_ai*R1_aj + sum_a R2_ai*R2_aj + ...\n      N_ab = sum_i R1_ai*R1_bi + sum_a R2_ai*R2_bi + ...\n\n   where Ri_ai is the i'th single excitation vector obtained from the CCS calculation. \n   The transformation matrices for the occupied and virtual part\n   are constructed by diagonalizing M and N. The number of active occupied\n   and virtual orbitals are determined from δ_o and δ_v\n\n      1 - sum_i λ&#94;o_i < δ_o\n      1 - sum_i λ&#94;v_i < δ_v\n\n   Where the orbitals of highest eigenvalues λ&#94;o/λ&#94;v are selected first.\n\n   Fock matrix is block diagonalized in active and inactive blocks in order to obtain \n   the orbitals and orbital energies used in the CC2 calculation.","tags":"","loc":"interface/cnto_orbital_drv_mlccsd.html","title":"cnto_orbital_drv_mlccsd – The eT program"},{"text":"interface public module subroutine ccsd_cnto_lower_level_method_mlccsd(wf, cc2_n_parameters, cc2_n_x2am, n_CC2_o, n_CC2_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: cc2_n_parameters integer(kind=i15) :: cc2_n_x2am integer(kind=i15) :: n_CC2_o integer(kind=i15) :: n_CC2_v Description CNTO constructor (MLCCSD),\nWritten by Sarai D. Folkestad, Aug. 2017\n\nConstructs CNTOs and partitions orbital space","tags":"","loc":"interface/ccsd_cnto_lower_level_method_mlccsd.html","title":"ccsd_cnto_lower_level_method_mlccsd – The eT program"},{"text":"interface public module subroutine ccsd_cnto_orbitals_mlccsd(wf, cc2_n_parameters, cc2_n_x2am, n_CC2_o, n_CC2_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: cc2_n_parameters integer(kind=i15) :: cc2_n_x2am integer(kind=i15) :: n_CC2_o integer(kind=i15) :: n_CC2_v Description CNTO Oritals (MLCCSD),\n   Written by Sarai D. Folkestad Aug. 2017\n\n   Constructs the CNTO orbitals based on exitation vectors from lower level method","tags":"","loc":"interface/ccsd_cnto_orbitals_mlccsd.html","title":"ccsd_cnto_orbitals_mlccsd – The eT program"},{"text":"interface public module subroutine print_orbital_info_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Description Print CNTO info, \n   Written by Sarai D. Folkestad, Aug. 2017\n\n   Prints information on CNTO partitioning","tags":"","loc":"interface/print_orbital_info_mlccsd.html","title":"print_orbital_info_mlccsd – The eT program"},{"text":"interface public module subroutine read_transform_cholesky_for_CC2_amplitude_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"interface/read_transform_cholesky_for_cc2_amplitude_mlccsd.html","title":"read_transform_cholesky_for_CC2_amplitude_mlccsd – The eT program"},{"text":"interface public module subroutine read_cholesky_ai_for_cc2_amplitudes_mlccsd(wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: L_ai_J integer(kind=i15) :: a_first integer(kind=i15) :: a_last integer(kind=i15) :: i_first integer(kind=i15) :: i_last Description Read Cholesky IA \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Reads the MO Cholesky IA (occ-vir) vectors from file and\n   places them in the incoming L_ia_J matrix","tags":"","loc":"interface/read_cholesky_ai_for_cc2_amplitudes_mlccsd.html","title":"read_cholesky_ai_for_cc2_amplitudes_mlccsd – The eT program"},{"text":"interface public module subroutine get_cholesky_ai_for_cc2_amplitudes_mlccsd(wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: L_ai_J integer(kind=i15) :: a_first integer(kind=i15) :: a_last integer(kind=i15) :: i_first integer(kind=i15) :: i_last Description Get Cholesky AI\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Read and T1-transform Cholesky AI vectors:\n\n    L_ai_J_T1 = L_ia_J - sum_j  t_aj*L_ji_J \n                        + sum_b  t_bi*L_ab_J\n                        - sum_bj t_aj*t_bi*L_jb_J\n\n   Allocations in routine:\n\n   (1) n_J*(i_length)*(a_length) + 2*n_J*(a_length)*batch_length  ->  for L_ab_J contribution (batches of b)\n   (2) n_J*(i_length)*n_v + 2*n_J*n_o*(i_length)                  ->  for L_ij_J contribution\n   (3) 2*n_J*n_o*n_v                                              ->  for L_jb_J contribution\n\n   i_length = i_last - i_first + 1          \n   a_length = a_last - a_first + 1\n\n   (1) determines memory requirement.","tags":"","loc":"interface/get_cholesky_ai_for_cc2_amplitudes_mlccsd.html","title":"get_cholesky_ai_for_cc2_amplitudes_mlccsd – The eT program"},{"text":"interface public module subroutine read_cholesky_ab_for_cc2_amplitudes_mlccsd(wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last Description Read Cholesky AB \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky AB (vir-vir) vectors from file and\nplaces them in the incoming L_ab_J matrix, with batching \nif necessary\n\nOptional arguments: b_first, b_last, a_first, a_last can be used in order to restrict indices","tags":"","loc":"interface/read_cholesky_ab_for_cc2_amplitudes_mlccsd.html","title":"read_cholesky_ab_for_cc2_amplitudes_mlccsd – The eT program"},{"text":"interface public module subroutine read_cholesky_ia_for_cc2_amplitudes_mlccsd(wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15) :: i_first integer(kind=i15) :: i_last integer(kind=i15) :: a_first integer(kind=i15) :: a_last Description Read Cholesky IA \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky IA (occ-vir) vectors from file and\nplaces them in the incoming L_ia_J matrix\n\n\nOptional arguments: i_first, i_last, a_first, a_last can be used in order to restrict indices","tags":"","loc":"interface/read_cholesky_ia_for_cc2_amplitudes_mlccsd.html","title":"read_cholesky_ia_for_cc2_amplitudes_mlccsd – The eT program"},{"text":"interface public module subroutine read_cholesky_ij_for_cc2_amplitudes_mlccsd(wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15) :: i_first integer(kind=i15) :: i_last integer(kind=i15) :: j_first integer(kind=i15) :: j_last Description Read Cholesky IJ \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky IJ (occ-occ) vectors from file and \nplaces them in the incoming L_ij_J matrix\n\nOptional arguments: i_first, i_last, j_first, j_last can be used in order to restrict indices","tags":"","loc":"interface/read_cholesky_ij_for_cc2_amplitudes_mlccsd.html","title":"read_cholesky_ij_for_cc2_amplitudes_mlccsd – The eT program"},{"text":"interface public module subroutine initialize_omega_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"interface/initialize_omega_mlccsd.html","title":"initialize_omega_mlccsd – The eT program"},{"text":"interface public module subroutine construct_omega_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Description Construct Omega (MLCCSD)\n   Written by Eirik F. Kjønstad and Sarai Folkestad, Apr 2017\n\n   Constructs the MlCC2 omega.\n\n   s2-amplitudes are constructed on the fly, according to the CC2\n   expression for the doubles amplitudes.\n\n   Calculated by looping over active spaces, \n   Adding the omega contribution from each active space in turn.","tags":"","loc":"interface/construct_omega_mlccsd.html","title":"construct_omega_mlccsd – The eT program"},{"text":"interface public module subroutine get_mlccsd_x2am_mlccsd(wf, x_ia_jb) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_ia_jb","tags":"","loc":"interface/get_mlccsd_x2am_mlccsd.html","title":"get_mlccsd_x2am_mlccsd – The eT program"},{"text":"interface public module subroutine omega_mlccsd_a1_mlccsd(wf, x_ib_jc) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_ib_jc Description Omega A1\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\nCalculates the A1 term of omega for the active space,\n\nA1: sum_bcj g_Abjc * u_Ij&#94;bc,\n\nwhere upper case letters indicate CCS space, and \nlower case letters are the combined CC2/CCSD spaces.\n\nA1 is added to the projection vector (omega1) of\nthe wavefunction object wf.\n\nu_ij&#94;bc = 2*x_ij&#94;bc - x_ij&#94;cb\n\nBatching over A.","tags":"","loc":"interface/omega_mlccsd_a1_mlccsd.html","title":"omega_mlccsd_a1_mlccsd – The eT program"},{"text":"interface public module subroutine omega_mlccsd_b1_mlccsd(wf, x_ja_kb) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_ja_kb Description Omega B1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   Calculates the B1 term of omega,\n\n   B1: - sum_bjk u_jk&#94;ab*g_kbjI + sum_bj u_ij&#94;ab F_jb,\n\n   with u_ij&#94;ab = 2*x_ij&#94;ab - x_ij&#94;ba.","tags":"","loc":"interface/omega_mlccsd_b1_mlccsd.html","title":"omega_mlccsd_b1_mlccsd – The eT program"},{"text":"interface public module subroutine omega_mlccsd_a2_mlccsd(wf, x_IC_JD) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_IC_JD","tags":"","loc":"interface/omega_mlccsd_a2_mlccsd.html","title":"omega_mlccsd_a2_mlccsd – The eT program"},{"text":"interface public module subroutine omega_mlccsd_b2_mlccsd(wf, x_kc_ld) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_kc_ld Description Omega B2\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, 11 Mar 2017\n\n   Omega B2 = sum_(kl) x_ak_bl*(g_kilj + sum_(cd) x_ci_dj * g_kc_ld)\n\n   Structure: g_kilj is constructed first and reordered as g_kl_ij. \n   Then the contraction over cd is performed, and the results added to g_kl_ij.\n   x_ka_lb is then reordered as x_ab_kl and the contraction over kl is performed.","tags":"","loc":"interface/omega_mlccsd_b2_mlccsd.html","title":"omega_mlccsd_b2_mlccsd – The eT program"},{"text":"interface public module subroutine omega_mlccsd_c2_mlccsd(wf, x_lc_kd) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_lc_kd Description Omega C2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017\n\n   Z_ai_bj = - sum_(ck) x&#94;bc_kj*( g_ki,ac - 1/2 * sum_(dl) x&#94;ad_li*g_kd,cl )\n\n   Omega_ai_bj = P_ij&#94;ab (1/2 Z_ai_bj + Z_aj_bi) = 1/2 Z_ai_bj + 1/2 Z_bj_ai + Z_aj_bi+ Z_bi_aj","tags":"","loc":"interface/omega_mlccsd_c2_mlccsd.html","title":"omega_mlccsd_c2_mlccsd – The eT program"},{"text":"interface public module subroutine omega_mlccsd_d2_mlccsd(wf, x_KC_LD) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_KC_LD Description Omega D2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Calculates the D2 term,\n\n    D2: sum_ck u_jk&#94;bc g_aikc \n      - 1/2 * sum_ck u_jk&#94;bc g_acki \n      + 1/4 * sum_ck u_jk&#94;bc sum_dl L_ldkc u_il&#94;ad,\n\n   where\n\n      u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc,\n      L_ldkc  = 2 * g_ldkc  - g_lckd.\n\n   The first, second, and third terms are referred to as D2.1, D2.2, and D2.3, \n   and comes out ordered as (ai,bj). All terms are added to the omega vector of the \n   wavefunction object wf.","tags":"","loc":"interface/omega_mlccsd_d2_mlccsd.html","title":"omega_mlccsd_d2_mlccsd – The eT program"},{"text":"interface public module subroutine omega_mlccsd_e2_mlccsd(wf, x_kc_ld) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_kc_ld Description Omega E2\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n Calculates the E2 term,\n\n  E2: sum_c t_ij&#94;ac (F_bc - sum_dkl g_ldkc u_kl&#94;bd) \n    - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc),\n\n where\n\n    u_kl&#94;bc = 2 * t_kl&#94;bc - t_lk&#94;bc.\n\n The first term is referred to as the E2.1 term, and comes out ordered as (b,jai).\n The second term is referred to as the E2.2 term, and comes out ordered as (aib,j).\n\n Both are permuted added to the projection vector element omega2(ai,bj) of\n the wavefunction object wf.","tags":"","loc":"interface/omega_mlccsd_e2_mlccsd.html","title":"omega_mlccsd_e2_mlccsd – The eT program"},{"text":"interface public module subroutine calc_ampeqs_norm_mlccsd(wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp) :: ampeqs_norm","tags":"","loc":"interface/calc_ampeqs_norm_mlccsd.html","title":"calc_ampeqs_norm_mlccsd – The eT program"},{"text":"interface public module subroutine new_amplitudes_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"interface/new_amplitudes_mlccsd.html","title":"new_amplitudes_mlccsd – The eT program"},{"text":"interface public module subroutine calc_quasi_Newton_doubles_mlccsd(wf, dt) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: dt","tags":"","loc":"interface/calc_quasi_newton_doubles_mlccsd.html","title":"calc_quasi_Newton_doubles_mlccsd – The eT program"},{"text":"interface public module subroutine initialize_ground_state_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Description Initialize Ground State (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nInitializes the amplitudes and the projection vector for the ground\nstate solver.","tags":"","loc":"interface/initialize_ground_state_mlccsd.html","title":"initialize_ground_state_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_transformation_mlccsd(wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_x2am, 1) :: c_aibj Description Jacobian transformation (MLCC2)\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\nDirects the transformation by the CCSD Jacobi matrix,\n\n   A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >,\n\nwhere the basis employed for the brackets is biorthonormal. \nThe transformation is rho = A c, i.e.,\n\n   rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck \n              + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl).\n\nOn exit, c is overwritten by rho. That is, c_a_i = rho_a_i,\nand c_aibj = rho_aibj.","tags":"","loc":"interface/jacobian_mlccsd_transformation_mlccsd.html","title":"jacobian_mlccsd_transformation_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_b2_mlccsd(wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:, :) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian CCSD B2 \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nrho_ai_bj&#94;B2 = - sum_kc (F_kc t_ij&#94;ac c_bk + F_kc t_ik&#94;ab c_cj)\n\nThe term is added as rho_ai_bj(ai,bj) = rho_ai_bj(ai,bj) + rho_ai_bj&#94;B2,\nwhere c_a_i(a,i) = c_ai above.","tags":"","loc":"interface/jacobian_mlccsd_b2_mlccsd.html","title":"jacobian_mlccsd_b2_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_c2_mlccsd(wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian CCSD C2 \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Aug 2017\n\nrho_ai_bj&#94;C2 = sum_kcl (g_ljkc * t_ki&#94;ac * c_bl) + (g_ljkc * t_li&#94;bc * c_ak) \n                     + (g_ljkc * t_lk&#94;ba * c_ci) \n                     - (L_ljkc * t_ik&#94;ac * c_bl)- (L_ljkc * t_il&#94;ab * c_ck)","tags":"","loc":"interface/jacobian_mlccsd_c2_mlccsd.html","title":"jacobian_mlccsd_c2_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_d2_mlccsd(wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian CCSD D2 \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nrho_ai_bj&#94;D2 = - sum_kcd g_kcbd (x_ij&#94;cd c_ak + x_kj&#94;ad c_ci + x_ik&#94;ca c_dj)\n                   + sum_kcd L_kcbd (x_ik&#94;ac c_dj + x_ij&#94;ad c_ck)\n\nNote: the code is structured so that we batch over the index b,\n      where the integrals are made as g_kc_db = g_kcbd and held\n      in some ordering or other throughout a given batch (i.e.,\n      all five terms are constructed gradually in the batches).\n\nThe term is added as rho_ai_bj(ai,bj) = rho_ai_bj(ai,bj) + rho_ai_bj&#94;D2,\nwhere c_a_i(a,i) = c_ai above.","tags":"","loc":"interface/jacobian_mlccsd_d2_mlccsd.html","title":"jacobian_mlccsd_d2_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_e2_mlccsd(wf, rho_ai_bj, c_ai_ck) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_ck Description Jacobian MLCCSD E2 \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\nrho_ai_bj&#94;E2 = 2 sum_dlck x_bj,DL * L_KC,LD * c_ai,CK","tags":"","loc":"interface/jacobian_mlccsd_e2_mlccsd.html","title":"jacobian_mlccsd_e2_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_f2_mlccsd(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj Description Jacobian MLCCSD F2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   rho_ai_bj&#94;F2 =   - sum_(CKDL) x_ai,CK * L_KC,LD * c_bL,Dj \n                    - sum_(CKDL) x_ai,Dj * L_KC,LD * c_bL,CK\n                    - sum_(CKDL) x_ai_bL * L_KC,LD * c_CK,Dj","tags":"","loc":"interface/jacobian_mlccsd_f2_mlccsd.html","title":"jacobian_mlccsd_f2_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_g2_mlccsd(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj Description Jacobian MLCCSD G2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   rho_ai_bj&#94;G2 =  - sum_ckdl x_bL,Dj * L_KC,LD * c_ai,CK \n                   - sum_ckdl x_CK_bL * L_KC,LD * c_ai,Dj \n                   - sum_ckld x_CK,Dj * L_KC,LD * c_ai,bL","tags":"","loc":"interface/jacobian_mlccsd_g2_mlccsd.html","title":"jacobian_mlccsd_g2_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_h2_mlccsd(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj Description Jacobian MLCCSD H2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   rho_ai_bj&#94;H2 =  sum_CKDL x_Ci,aK * g_KC,LD * c_bL,Dj \n                 + sum_CKDL x_Cj,aL * g_KC,LD * c_bK,Di","tags":"","loc":"interface/jacobian_mlccsd_h2_mlccsd.html","title":"jacobian_mlccsd_h2_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_i2_mlccsd(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj Description Jacobian MLCCSD I2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   rho_ai_bj&#94;I2 =  sum_C F_bC * c_ai,Cj - sum_K F_jK * c_ai,bK\n                 + sum_ck L_bj,KC * c_ai,CK \n                 - sum_ck ( g_KC,bj * c_aK,Ci + g_Ki,bC * c_aK,Cj )\n\n   Batch over c to construct  g_ki_bC","tags":"","loc":"interface/jacobian_mlccsd_i2_mlccsd.html","title":"jacobian_mlccsd_i2_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_j2_mlccsd(wf, rho_ab_ij, c_ab_ij) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ab_ij real(kind=dp), dimension(:,:) :: c_ab_ij Description Jacobian CCSD J2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   rho_ab_ij&#94;J2 =    sum_ckld t_ci,dj * g_kc,ld * c_ak,bl \n                   + sum_ckdl t_ak,bl * g_kc,ld * c_ci,dj","tags":"","loc":"interface/jacobian_mlccsd_j2_mlccsd.html","title":"jacobian_mlccsd_j2_mlccsd – The eT program"},{"text":"interface public module subroutine jacobian_mlccsd_k2_mlccsd(wf, rho_ab_ij, c_ab_ij) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ab_ij real(kind=dp), dimension(:,:) :: c_ab_ij Description Jacobian MLCCSD K2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   rho_ab_ij&#94;K2 =    sum_kl g_Ki,Lj * c_aK,bL \n                   + sum_cd g_aC,bD * c_Ci,Dj\n\n   For the last term we batch over a and b and \n   add each batch to rho_ai_bj","tags":"","loc":"interface/jacobian_mlccsd_k2_mlccsd.html","title":"jacobian_mlccsd_k2_mlccsd – The eT program"},{"text":"interface public module subroutine transform_trial_vectors_mlccsd(wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial Description Transformation of Trial Vectors (MLCC2)\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\nEach trial vector in first_trial to last_trial is read from file and\ntransformed before the transformed vector is written to file.\n\nSingles and doubles part of the transformed vectors are written to \nthe same record in file transformed_vec, record length is n_parameters long.","tags":"","loc":"interface/transform_trial_vectors_mlccsd.html","title":"transform_trial_vectors_mlccsd – The eT program"},{"text":"interface public module subroutine initialize_excited_states_mlccsd(wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf Description Initialize excited states\n   Written by Sarai D. Folkestad, Aug 2017\n\n   Calculates and sets n_s2am, and updates n_parameters\n   for excited state calculation","tags":"","loc":"interface/initialize_excited_states_mlccsd.html","title":"initialize_excited_states_mlccsd – The eT program"},{"text":"interface public module subroutine print_excitation_vector_mlccsd(wf, vec, unit_id) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: vec integer(kind=i15) :: unit_id","tags":"","loc":"interface/print_excitation_vector_mlccsd.html","title":"print_excitation_vector_mlccsd – The eT program"},{"text":"interface public module subroutine summary_excited_state_info_mlccsd(wf, energies) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies","tags":"","loc":"interface/summary_excited_state_info_mlccsd.html","title":"summary_excited_state_info_mlccsd – The eT program"},{"text":"public subroutine init_ccsd(wf) Initialize CCSD object\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nPerforms the following tasks:\n\n- Sets HF orbital and energy information by reading from file (read_hf_info)\n- Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky)\n- Allocates the Fock matrix and sets it to zero\n- Initializes the amplitudes (sets their initial values and associated variables) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Calls proc~~init_ccsd~~CallsGraph proc~init_ccsd init_ccsd proc~generate_unit_identifier generate_unit_identifier proc~init_ccsd->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_ccsd.html","title":"init_ccsd – The eT program"},{"text":"public subroutine initialize_amplitudes_ccsd(wf) Initialize Amplitudes (CCSD)\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n Allocates the amplitudes, sets them to zero, and calculates\n the number of amplitudes. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"proc/initialize_amplitudes_ccsd.html","title":"initialize_amplitudes_ccsd – The eT program"},{"text":"public subroutine construct_perturbative_doubles_ccsd(wf) Construct Perturbative Doubles (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nSets the doubles amplitudes (t2am) to its MP2 estimate. This is\nthe initial guess used in the solver for the ground state amplitude \nequations. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Calls proc~~construct_perturbative_doubles_ccsd~~CallsGraph proc~construct_perturbative_doubles_ccsd construct_perturbative_doubles_ccsd dgemm dgemm proc~construct_perturbative_doubles_ccsd->dgemm proc~index_packed index_packed proc~construct_perturbative_doubles_ccsd->proc~index_packed proc~index_two index_two proc~construct_perturbative_doubles_ccsd->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct_perturbative_doubles_ccsd.html","title":"construct_perturbative_doubles_ccsd – The eT program"},{"text":"public subroutine calc_energy_ccsd(wf) Calculate Energy (CCSD)\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n Calculates the CCSD energy for the wavefunction's current amplitudes. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Calls proc~~calc_energy_ccsd~~CallsGraph proc~calc_energy_ccsd calc_energy_ccsd dgemm dgemm proc~calc_energy_ccsd->dgemm proc~index_packed index_packed proc~calc_energy_ccsd->proc~index_packed proc~index_two index_two proc~calc_energy_ccsd->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/calc_energy_ccsd.html","title":"calc_energy_ccsd – The eT program"},{"text":"public subroutine destruct_amplitudes_ccsd(wf) Destruct Amplitudes (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nDeallocates the (doubles) amplitudes. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"proc/destruct_amplitudes_ccsd.html","title":"destruct_amplitudes_ccsd – The eT program"},{"text":"public subroutine destruct_omega_ccsd(wf) Destruct Omega (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nDeallocates the projection vector. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"proc/destruct_omega_ccsd.html","title":"destruct_omega_ccsd – The eT program"},{"text":"public subroutine save_amplitudes_ccsd(wf) Save Amplitudes (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nStore the amplitudes to disk (T1AM, T2AM) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Calls proc~~save_amplitudes_ccsd~~CallsGraph proc~save_amplitudes_ccsd save_amplitudes_ccsd proc~generate_unit_identifier generate_unit_identifier proc~save_amplitudes_ccsd->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/save_amplitudes_ccsd.html","title":"save_amplitudes_ccsd – The eT program"},{"text":"public subroutine read_amplitudes_ccsd(wf) Read Amplitudes (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"proc/read_amplitudes_ccsd.html","title":"read_amplitudes_ccsd – The eT program"},{"text":"public subroutine read_double_amplitudes_ccsd(wf) Read Amplitudes (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM, T2AM) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Calls proc~~read_double_amplitudes_ccsd~~CallsGraph proc~read_double_amplitudes_ccsd read_double_amplitudes_ccsd proc~generate_unit_identifier generate_unit_identifier proc~read_double_amplitudes_ccsd->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_double_amplitudes_ccsd.html","title":"read_double_amplitudes_ccsd – The eT program"},{"text":"public subroutine jacobi_test_ccsd(wf) Jacobian test (CCSD)\nWritten by Eirik F. Kjønstad, June 2017\n\nCalculates the Jacobian matrix by numerically differentiating \nthe projection vector:\n\n   A_mu,nu = d Omega_mu / d t_nu.\n\nUsed to debug Jacobian transformation. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Calls proc~~jacobi_test_ccsd~~CallsGraph proc~jacobi_test_ccsd jacobi_test_ccsd proc~index_two index_two proc~jacobi_test_ccsd->proc~index_two proc~index_packed index_packed proc~jacobi_test_ccsd->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/jacobi_test_ccsd.html","title":"jacobi_test_ccsd – The eT program"},{"text":"public subroutine construct_eta_ccsd(wf, eta) Construct Eta (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017\n\nNote: the routine assumes that eta is initialized and that the Fock matrix\nhas been constructed. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta Calls proc~~construct_eta_ccsd~~CallsGraph proc~construct_eta_ccsd construct_eta_ccsd proc~index_two index_two proc~construct_eta_ccsd->proc~index_two proc~index_packed index_packed proc~construct_eta_ccsd->proc~index_packed dgemm dgemm proc~construct_eta_ccsd->dgemm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct_eta_ccsd.html","title":"construct_eta_ccsd – The eT program"},{"text":"interface public module subroutine calc_ampeqs_norm_ccsd(wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp) :: ampeqs_norm Description Calculate amplitude equations norm (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/calc_ampeqs_norm_ccsd.html","title":"calc_ampeqs_norm_ccsd – The eT program"},{"text":"interface public module subroutine new_amplitudes_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description New amplitudes (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/new_amplitudes_ccsd.html","title":"new_amplitudes_ccsd – The eT program"},{"text":"interface public module subroutine calc_quasi_Newton_doubles_ccsd(wf, dt) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: dt Description Calculate quasi-Newton estimate (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/calc_quasi_newton_doubles_ccsd.html","title":"calc_quasi_Newton_doubles_ccsd – The eT program"},{"text":"interface public module subroutine initialize_ground_state_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Initialize ground state (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/initialize_ground_state_ccsd.html","title":"initialize_ground_state_ccsd – The eT program"},{"text":"interface public module subroutine ground_state_preparations_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Ground state preparations (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/ground_state_preparations_ccsd.html","title":"ground_state_preparations_ccsd – The eT program"},{"text":"interface public module subroutine initialize_omega_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Initialize omega (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/initialize_omega_ccsd.html","title":"initialize_omega_ccsd – The eT program"},{"text":"interface public module subroutine construct_omega_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Construct omega (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/construct_omega_ccsd.html","title":"construct_omega_ccsd – The eT program"},{"text":"interface public module subroutine omega_ccsd_a1_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega CCSD A1 term\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/omega_ccsd_a1_ccsd.html","title":"omega_ccsd_a1_ccsd – The eT program"},{"text":"interface public module subroutine omega_ccsd_b1_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega CCSD B1\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/omega_ccsd_b1_ccsd.html","title":"omega_ccsd_b1_ccsd – The eT program"},{"text":"interface public module subroutine omega_ccsd_c1_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega CCSD C1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/omega_ccsd_c1_ccsd.html","title":"omega_ccsd_c1_ccsd – The eT program"},{"text":"interface public module subroutine omega_ccsd_a2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega CCSD A2\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017","tags":"","loc":"interface/omega_ccsd_a2_ccsd.html","title":"omega_ccsd_a2_ccsd – The eT program"},{"text":"interface public module subroutine omega_ccsd_b2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega CCSD B2\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017","tags":"","loc":"interface/omega_ccsd_b2_ccsd.html","title":"omega_ccsd_b2_ccsd – The eT program"},{"text":"interface public module subroutine omega_ccsd_c2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega CCSD C2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017","tags":"","loc":"interface/omega_ccsd_c2_ccsd.html","title":"omega_ccsd_c2_ccsd – The eT program"},{"text":"interface public module subroutine omega_ccsd_d2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega CCSD D2\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/omega_ccsd_d2_ccsd.html","title":"omega_ccsd_d2_ccsd – The eT program"},{"text":"interface public module subroutine omega_ccsd_e2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega E2\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/omega_ccsd_e2_ccsd.html","title":"omega_ccsd_e2_ccsd – The eT program"},{"text":"interface public module subroutine calculate_orbital_differences_ccsd(wf, orbital_diff) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: orbital_diff Description Calculate orbital differences (CCSD)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/calculate_orbital_differences_ccsd.html","title":"calculate_orbital_differences_ccsd – The eT program"},{"text":"interface public module subroutine transform_trial_vectors_ccsd(wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial Description Transformation trial vectors (CCSD)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/transform_trial_vectors_ccsd.html","title":"transform_trial_vectors_ccsd – The eT program"},{"text":"interface public module subroutine print_excitation_vector_ccsd(wf, vec, unit_id) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: vec integer(kind=i15) :: unit_id Description Print excitation vector \n   Written by Sarai D. Folkestad, Oct 2017","tags":"","loc":"interface/print_excitation_vector_ccsd.html","title":"print_excitation_vector_ccsd – The eT program"},{"text":"interface public module subroutine cvs_residual_projection_ccsd(wf, residual) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual Description CVS residual projection (CCSD) \n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/cvs_residual_projection_ccsd.html","title":"cvs_residual_projection_ccsd – The eT program"},{"text":"interface public module subroutine excited_state_preparations_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Excited State Preparations (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/excited_state_preparations_ccsd.html","title":"excited_state_preparations_ccsd – The eT program"},{"text":"interface public module subroutine analyze_double_excitation_vector_ccsd(wf, vec, n, sorted_short_vec, index_list) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_t2am, 1) :: vec integer(kind=i15) :: n real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 4) :: index_list Description Analyze double excitation vector \n   Written by Sarai D. Folkestad, Oct 2017","tags":"","loc":"interface/analyze_double_excitation_vector_ccsd.html","title":"analyze_double_excitation_vector_ccsd – The eT program"},{"text":"interface public module subroutine summary_excited_state_info_ccsd(wf, energies) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies Description Summary of excited state info \n   Written by Sarai D. Folkestad, Oct 2017","tags":"","loc":"interface/summary_excited_state_info_ccsd.html","title":"summary_excited_state_info_ccsd – The eT program"},{"text":"interface public module subroutine ionization_residual_projection_ccsd(wf, residual) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual Description Residual projection for CVS\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/ionization_residual_projection_ccsd.html","title":"ionization_residual_projection_ccsd – The eT program"},{"text":"interface public module subroutine ionization_rho_aibj_projection_ccsd(wf, rho_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_aibj Description Residual projection for CVS\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/ionization_rho_aibj_projection_ccsd.html","title":"ionization_rho_aibj_projection_ccsd – The eT program"},{"text":"interface public subroutine ionization_jacobian_ccsd_transformation_ccsd(wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: c_aibj Description Ionization Jacobian transformation (CCSD)\n  Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/ionization_jacobian_ccsd_transformation_ccsd.html","title":"ionization_jacobian_ccsd_transformation_ccsd – The eT program"},{"text":"interface public subroutine core_ionization_jacobian_ccsd_transformation_ccsd(wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: c_aibj Description Core ionization Jacobian transformation (CCSD)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/core_ionization_jacobian_ccsd_transformation_ccsd.html","title":"core_ionization_jacobian_ccsd_transformation_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_transformation_ccsd(wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: c_aibj Description Jacobian CCSD transformation\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_transformation_ccsd.html","title":"jacobian_ccsd_transformation_ccsd – The eT program"},{"text":"interface public subroutine cvs_jacobian_ccsd_transformation_ccsd(wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: c_aibj Description CVS Jacobian transformation (CCSD)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/cvs_jacobian_ccsd_transformation_ccsd.html","title":"cvs_jacobian_ccsd_transformation_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_a1_ccsd(wf, rho_a_i, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian CCSD A1\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/jacobian_ccsd_a1_ccsd.html","title":"jacobian_ccsd_a1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_b1_ccsd(wf, rho_a_i, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj Description Jacobian CCSD B1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_b1_ccsd.html","title":"jacobian_ccsd_b1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_c1_ccsd(wf, rho_a_i, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj Description Jacobian CCSD C1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_c1_ccsd.html","title":"jacobian_ccsd_c1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_d1_ccsd(wf, rho_a_i, c_bi_cj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_bi_cj Description Jacobian CCSD D1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_d1_ccsd.html","title":"jacobian_ccsd_d1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_a2_ccsd(wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian CCSD A2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/jacobian_ccsd_a2_ccsd.html","title":"jacobian_ccsd_a2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_b2_ccsd(wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian CCSD B2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/jacobian_ccsd_b2_ccsd.html","title":"jacobian_ccsd_b2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_c2_ccsd(wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian CCSD C2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/jacobian_ccsd_c2_ccsd.html","title":"jacobian_ccsd_c2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_d2_ccsd(wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian CCSD D2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/jacobian_ccsd_d2_ccsd.html","title":"jacobian_ccsd_d2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_e2_ccsd(wf, rho_ai_bj, c_ai_ck) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_ck Description Jacobian CCSD E2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_e2_ccsd.html","title":"jacobian_ccsd_e2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_f2_ccsd(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj Description Jacobian CCSD F2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_f2_ccsd.html","title":"jacobian_ccsd_f2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_g2_ccsd(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj Description Jacobian CCSD G2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_g2_ccsd.html","title":"jacobian_ccsd_g2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_h2_ccsd(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj Description Jacobian CCSD H2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_h2_ccsd.html","title":"jacobian_ccsd_h2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_i2_ccsd(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj Description Jacobian CCSD I2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_i2_ccsd.html","title":"jacobian_ccsd_i2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_j2_ccsd(wf, rho_ab_ij, c_ab_ij) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: rho_ab_ij real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: c_ab_ij Description Jacobian CCSD J2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_j2_ccsd.html","title":"jacobian_ccsd_j2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_ccsd_k2_ccsd(wf, rho_ab_ij, c_ab_ij) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: rho_ab_ij real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: c_ab_ij Description Jacobian CCSD K2 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccsd_k2_ccsd.html","title":"jacobian_ccsd_k2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_transformation_ccsd(wf, b_a_i, b_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: b_aibj Description Jacobian transpose transformation (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_transformation_ccsd.html","title":"jacobian_transpose_ccsd_transformation_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_a1_ccsd(wf, sigma_a_i, b_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i Description Jacobian transpose CCSD A1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_a1_ccsd.html","title":"jacobian_transpose_ccsd_a1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_b1_ccsd(wf, sigma_a_i, b_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i Description Jacobian transpose CCSD B1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_b1_ccsd.html","title":"jacobian_transpose_ccsd_b1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_c1_ccsd(wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD C1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_c1_ccsd.html","title":"jacobian_transpose_ccsd_c1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_d1_ccsd(wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD D1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_d1_ccsd.html","title":"jacobian_transpose_ccsd_d1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_e1_ccsd(wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD E1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_e1_ccsd.html","title":"jacobian_transpose_ccsd_e1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_f1_ccsd(wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD F1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_f1_ccsd.html","title":"jacobian_transpose_ccsd_f1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_g1_ccsd(wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD G1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_g1_ccsd.html","title":"jacobian_transpose_ccsd_g1_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_a2_ccsd(wf, sigma_ai_bj, b_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i Description Jacobian transpose CCSD A2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_a2_ccsd.html","title":"jacobian_transpose_ccsd_a2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_b2_ccsd(wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD B2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_b2_ccsd.html","title":"jacobian_transpose_ccsd_b2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_c2_ccsd(wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD C2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_c2_ccsd.html","title":"jacobian_transpose_ccsd_c2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_d2_ccsd(wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD D2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_d2_ccsd.html","title":"jacobian_transpose_ccsd_d2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_e2_ccsd(wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD E2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_e2_ccsd.html","title":"jacobian_transpose_ccsd_e2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_f2_ccsd(wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD F2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_f2_ccsd.html","title":"jacobian_transpose_ccsd_f2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_g2_ccsd(wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj Description Jacobian transpose CCSD G2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_g2_ccsd.html","title":"jacobian_transpose_ccsd_g2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_h2_ccsd(wf, sigma_ab_ij, b_ab_ij) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: sigma_ab_ij real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: b_ab_ij Description Jacobian transpose CCSD H2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_h2_ccsd.html","title":"jacobian_transpose_ccsd_h2_ccsd – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccsd_i2_ccsd(wf, sigma_ab_ij, b_ab_ij) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: sigma_ab_ij real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: b_ab_ij Description Jacobian transpose CCSD I2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccsd_i2_ccsd.html","title":"jacobian_transpose_ccsd_i2_ccsd – The eT program"},{"text":"interface public module subroutine cvs_rho_aibj_projection_ccsd(wf, vec_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(:, :) :: vec_aibj Description CVS Rho_aibj projection (CCSD)\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/cvs_rho_aibj_projection_ccsd.html","title":"cvs_rho_aibj_projection_ccsd – The eT program"},{"text":"public subroutine init_ccs(wf) Initialize CCS object\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nPerforms the following tasks\n\n- Sets HF orbital and energy information by reading from file\n- Transforms AO Cholesky vectors to MO basis and saves to file \n- Allocates the singles amplitudes and sets them to zero, and sets associated properties \n- Allocates the omega vector and sets it to zero\n- Initializes the Fock matrix and sets it to zero Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Calls proc~~init_ccs~~CallsGraph proc~init_ccs init_ccs proc~generate_unit_identifier generate_unit_identifier proc~init_ccs->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_ccs.html","title":"init_ccs – The eT program"},{"text":"public subroutine drv_ccs(wf) CCS Driver\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nThe driver for CCS is written so as to be inherited unaltered.\nIt finds which calculations are requested by the user, and controls\nthat the calculation can be done. If the method is implemented, it \ncalls the driver for that particular calculation (e.g., ground state\nenergy). Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/drv_ccs.html","title":"drv_ccs – The eT program"},{"text":"public subroutine initialize_amplitudes_ccs(wf) Initialize Amplitudes (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nAllocates the singles amplitudes, sets them to zero, and calculates\nthe number of singles amplitudes. Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/initialize_amplitudes_ccs.html","title":"initialize_amplitudes_ccs – The eT program"},{"text":"public subroutine initialize_omega_ccs(wf) Initialize Omega (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nAllocates and sets the projection vector to zero (which is\nalso its correct value, by Brillouin) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/initialize_omega_ccs.html","title":"initialize_omega_ccs – The eT program"},{"text":"public subroutine calc_energy_ccs(wf) Calculate Energy (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/calc_energy_ccs.html","title":"calc_energy_ccs – The eT program"},{"text":"public subroutine construct_omega_ccs(wf) Construct Omega (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/construct_omega_ccs.html","title":"construct_omega_ccs – The eT program"},{"text":"public subroutine omega_ccs_a1_ccs(wf) Omega D1\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, March 2017\n\nOmega_ai&#94;D1 = F_ai_T1 Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Calls proc~~omega_ccs_a1_ccs~~CallsGraph proc~omega_ccs_a1_ccs omega_ccs_a1_ccs daxpy daxpy proc~omega_ccs_a1_ccs->daxpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/omega_ccs_a1_ccs.html","title":"omega_ccs_a1_ccs – The eT program"},{"text":"public subroutine construct_eta_ccs(wf, eta) Construct Eta (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017\n\nNote: the routine assumes that the Fock matrix\nhas been constructed. Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta Calls proc~~construct_eta_ccs~~CallsGraph proc~construct_eta_ccs construct_eta_ccs proc~index_two index_two proc~construct_eta_ccs->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/construct_eta_ccs.html","title":"construct_eta_ccs – The eT program"},{"text":"public subroutine save_amplitudes_ccs(wf) Save Amplitudes (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nStore the amplitudes to disk (T1AM) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Calls proc~~save_amplitudes_ccs~~CallsGraph proc~save_amplitudes_ccs save_amplitudes_ccs proc~generate_unit_identifier generate_unit_identifier proc~save_amplitudes_ccs->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/save_amplitudes_ccs.html","title":"save_amplitudes_ccs – The eT program"},{"text":"public subroutine read_amplitudes_ccs(wf) Read Amplitudes (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/read_amplitudes_ccs.html","title":"read_amplitudes_ccs – The eT program"},{"text":"public subroutine read_single_amplitudes_ccs(wf) Read Amplitudes (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM, T2AM) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Calls proc~~read_single_amplitudes_ccs~~CallsGraph proc~read_single_amplitudes_ccs read_single_amplitudes_ccs proc~generate_unit_identifier generate_unit_identifier proc~read_single_amplitudes_ccs->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_single_amplitudes_ccs.html","title":"read_single_amplitudes_ccs – The eT program"},{"text":"public subroutine destruct_amplitudes_ccs(wf) Destruct Amplitudes (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nDeallocates the amplitudes. Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/destruct_amplitudes_ccs.html","title":"destruct_amplitudes_ccs – The eT program"},{"text":"public subroutine destruct_omega_ccs(wf) Destruct Omega (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nDeallocates the projection vector. Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/destruct_omega_ccs.html","title":"destruct_omega_ccs – The eT program"},{"text":"public subroutine jacobi_test_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/jacobi_test_ccs.html","title":"jacobi_test_ccs – The eT program"},{"text":"public subroutine read_atom_info(n_nuclei, n_ao) Read atom info,\nWritten by Sarai Dery Folkestad, June 2017.\n\nReads atom info from DALTON generated file:\nReads:\n   - Number of nuclei\n   - Number of AO's Arguments Type Intent Optional Attributes Name integer(kind=i15) :: n_nuclei integer(kind=i15) :: n_ao Calls proc~~read_atom_info~~CallsGraph proc~read_atom_info read_atom_info proc~generate_unit_identifier generate_unit_identifier proc~read_atom_info->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_atom_info.html","title":"read_atom_info – The eT program"},{"text":"public subroutine read_center_info(n_nuclei, n_ao, n_ao_on_center, ao_center_info) Read center info,\nWritten by Sarai Dery Folkestad, June 2017.\n\nReads atom info from DALTON generated file:\nReads:\n   - Information of which ao's belong to which nuclei Arguments Type Intent Optional Attributes Name integer(kind=i15) :: n_nuclei integer(kind=i15) :: n_ao integer, dimension(n_nuclei, 1) :: n_ao_on_center integer, dimension(n_ao, 2) :: ao_center_info Calls proc~~read_center_info~~CallsGraph proc~read_center_info read_center_info proc~generate_unit_identifier generate_unit_identifier proc~read_center_info->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_center_info.html","title":"read_center_info – The eT program"},{"text":"interface public module subroutine ground_state_driver_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Ground State Driver (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/ground_state_driver_ccs.html","title":"ground_state_driver_ccs – The eT program"},{"text":"interface public module subroutine ground_state_preparations_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Ground State Preparations (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/ground_state_preparations_ccs.html","title":"ground_state_preparations_ccs – The eT program"},{"text":"interface public module subroutine ground_state_cleanup_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Ground State Cleanup (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/ground_state_cleanup_ccs.html","title":"ground_state_cleanup_ccs – The eT program"},{"text":"interface public module subroutine ground_state_solver_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Ground State Solver \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/ground_state_solver_ccs.html","title":"ground_state_solver_ccs – The eT program"},{"text":"interface public module subroutine calc_ampeqs_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Calculate Amplitude Equations (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/calc_ampeqs_ccs.html","title":"calc_ampeqs_ccs – The eT program"},{"text":"interface public module subroutine calc_ampeqs_norm_ccs(wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp) :: ampeqs_norm Description Calculate Amplitude Equations Norm (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/calc_ampeqs_norm_ccs.html","title":"calc_ampeqs_norm_ccs – The eT program"},{"text":"interface public module subroutine new_amplitudes_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description New Amplitudes (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/new_amplitudes_ccs.html","title":"new_amplitudes_ccs – The eT program"},{"text":"interface public module subroutine calc_quasi_Newton_singles_ccs(wf, dt) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: dt Description Calculate quasi-Newton Singles (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/calc_quasi_newton_singles_ccs.html","title":"calc_quasi_Newton_singles_ccs – The eT program"},{"text":"interface public module subroutine diis_ccs(wf, dt, t_dt) Arguments Type Intent Optional Attributes Name class( ccs ), intent(in) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: dt real(kind=dp), dimension(wf%n_parameters, 1) :: t_dt Description DIIS (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/diis_ccs.html","title":"diis_ccs – The eT program"},{"text":"interface public module subroutine initialize_ground_state_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize Ground State (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/initialize_ground_state_ccs.html","title":"initialize_ground_state_ccs – The eT program"},{"text":"interface public module subroutine destruct_ground_state_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Destruct Ground State (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/destruct_ground_state_ccs.html","title":"destruct_ground_state_ccs – The eT program"},{"text":"interface public module subroutine initialize_trial_vectors_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize Trial Vectors (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/initialize_trial_vectors_ccs.html","title":"initialize_trial_vectors_ccs – The eT program"},{"text":"interface public module subroutine find_start_trial_indices_ccs(wf, index_list) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15), intent(inout), dimension(wf%excited_state_specifications%n_singlet_states,1) :: index_list Description Find Start Trial Indices (CCS) \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/find_start_trial_indices_ccs.html","title":"find_start_trial_indices_ccs – The eT program"},{"text":"interface public module subroutine transform_trial_vectors_ccs(wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial Description Transform trial vectors (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/transform_trial_vectors_ccs.html","title":"transform_trial_vectors_ccs – The eT program"},{"text":"interface public module subroutine excited_state_driver_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Excited state driver (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/excited_state_driver_ccs.html","title":"excited_state_driver_ccs – The eT program"},{"text":"interface public module subroutine excited_state_preparations_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Excited State Preparations (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/excited_state_preparations_ccs.html","title":"excited_state_preparations_ccs – The eT program"},{"text":"interface public module subroutine excited_state_cleanup_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Excited State Cleanup (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/excited_state_cleanup_ccs.html","title":"excited_state_cleanup_ccs – The eT program"},{"text":"interface public module subroutine excited_state_solver_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Excited State Solver\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/excited_state_solver_ccs.html","title":"excited_state_solver_ccs – The eT program"},{"text":"interface public module subroutine solve_reduced_eigenvalue_equation_ccs(wf, eigenvalues_Re, eigenvalues_Im, solution_vectors_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: eigenvalues_Re real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: eigenvalues_Im real(kind=dp), dimension(reduced_dim, wf%excited_state_specifications%n_singlet_states) :: solution_vectors_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials Description Solve Reduced Eigenvalue Equation\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/solve_reduced_eigenvalue_equation_ccs.html","title":"solve_reduced_eigenvalue_equation_ccs – The eT program"},{"text":"interface public module subroutine construct_next_trial_vectors_ccs(wf, eigenvalues_Re, eigenvalues_Im, solution_vectors_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: eigenvalues_Re real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: eigenvalues_Im real(kind=dp), dimension(reduced_dim, wf%excited_state_specifications%n_singlet_states) :: solution_vectors_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials Description Construct Next Trial Vectors    \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/construct_next_trial_vectors_ccs.html","title":"construct_next_trial_vectors_ccs – The eT program"},{"text":"interface public module subroutine initialize_trial_vectors_valence_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize Trial Vectors Valence\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/initialize_trial_vectors_valence_ccs.html","title":"initialize_trial_vectors_valence_ccs – The eT program"},{"text":"interface public module subroutine initialize_trial_vectors_core_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize trial vectors, for CVS calculation \n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/initialize_trial_vectors_core_ccs.html","title":"initialize_trial_vectors_core_ccs – The eT program"},{"text":"interface public module subroutine trial_vectors_from_stored_solutions_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Trial Vectors from Old Solutions\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017","tags":"","loc":"interface/trial_vectors_from_stored_solutions_ccs.html","title":"trial_vectors_from_stored_solutions_ccs – The eT program"},{"text":"interface public module subroutine find_start_trial_indices_core_ccs(wf, index_list) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15), intent(inout), dimension(wf%excited_state_specifications%n_singlet_states,1) :: index_list Description Find Start Trial Indices Core\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/find_start_trial_indices_core_ccs.html","title":"find_start_trial_indices_core_ccs – The eT program"},{"text":"interface public module subroutine find_core_mo_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Find Core MO\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/find_core_mo_ccs.html","title":"find_core_mo_ccs – The eT program"},{"text":"interface public module subroutine calculate_orbital_differences_ccs(wf, orbital_diff) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: orbital_diff Description Calculate Orbital Differences\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/calculate_orbital_differences_ccs.html","title":"calculate_orbital_differences_ccs – The eT program"},{"text":"interface public module subroutine initialize_excited_states_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize Excited States\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017","tags":"","loc":"interface/initialize_excited_states_ccs.html","title":"initialize_excited_states_ccs – The eT program"},{"text":"interface public module subroutine precondition_residual_ccs(wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual Description Precondition Residual\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/precondition_residual_ccs.html","title":"precondition_residual_ccs – The eT program"},{"text":"interface public module subroutine precondition_residual_valence_ccs(wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual Description Precondition Residual Valence\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/precondition_residual_valence_ccs.html","title":"precondition_residual_valence_ccs – The eT program"},{"text":"interface public module subroutine precondition_residual_core_ccs(wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual Description Precondition Residual Core\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/precondition_residual_core_ccs.html","title":"precondition_residual_core_ccs – The eT program"},{"text":"interface public module subroutine print_excited_state_info_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Print Excited State Information\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/print_excited_state_info_ccs.html","title":"print_excited_state_info_ccs – The eT program"},{"text":"interface public module subroutine print_excitation_vector_ccs(wf, vec, unit_id) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: vec integer(kind=i15) :: unit_id Description Print Excitation Vector\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/print_excitation_vector_ccs.html","title":"print_excitation_vector_ccs – The eT program"},{"text":"interface public module subroutine analyze_single_excitation_vector_ccs(wf, vec, n, sorted_short_vec, index_list) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_o*wf%n_v, 1) :: vec integer(kind=i15) :: n real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 2) :: index_list Description Analyze Single Excitation Vector (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov 2017","tags":"","loc":"interface/analyze_single_excitation_vector_ccs.html","title":"analyze_single_excitation_vector_ccs – The eT program"},{"text":"interface public module subroutine summary_excited_state_info_ccs(wf, energies) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies Description Summary Excited State Info (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov 2017","tags":"","loc":"interface/summary_excited_state_info_ccs.html","title":"summary_excited_state_info_ccs – The eT program"},{"text":"interface public module subroutine response_driver_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Response Driver (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/response_driver_ccs.html","title":"response_driver_ccs – The eT program"},{"text":"interface public module subroutine response_solver_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Response Solver (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/response_solver_ccs.html","title":"response_solver_ccs – The eT program"},{"text":"interface public module subroutine response_preparations_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Response calculation preparations (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Dec 2017","tags":"","loc":"interface/response_preparations_ccs.html","title":"response_preparations_ccs – The eT program"},{"text":"interface public module subroutine initialize_response_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize Response (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017","tags":"","loc":"interface/initialize_response_ccs.html","title":"initialize_response_ccs – The eT program"},{"text":"interface public module subroutine solve_reduced_response_equation_ccs(wf, solution_vector_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(reduced_dim, 1) :: solution_vector_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials Description Solve Reduced Response Equation\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017","tags":"","loc":"interface/solve_reduced_response_equation_ccs.html","title":"solve_reduced_response_equation_ccs – The eT program"},{"text":"interface public module subroutine construct_reduced_matrix_ccs(wf, A_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(reduced_dim, reduced_dim) :: A_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials Description Construct Reduced Matrix (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/construct_reduced_matrix_ccs.html","title":"construct_reduced_matrix_ccs – The eT program"},{"text":"interface public module subroutine construct_reduced_gradient_ccs(wf, F_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(reduced_dim, 1) :: F_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials Description Construct Reduced Gradient (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/construct_reduced_gradient_ccs.html","title":"construct_reduced_gradient_ccs – The eT program"},{"text":"interface public module subroutine construct_gradient_vector_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Construct Gradient Vector (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/construct_gradient_vector_ccs.html","title":"construct_gradient_vector_ccs – The eT program"},{"text":"interface public module subroutine construct_next_response_trial_vectors_ccs(wf, solution_vector_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(reduced_dim, 1) :: solution_vector_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials Description Construct Next Response Trial Vectors (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/construct_next_response_trial_vectors_ccs.html","title":"construct_next_response_trial_vectors_ccs – The eT program"},{"text":"interface public module subroutine general_specs_reader_ccs(wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15) :: unit_input Description General Specifications Reader\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017","tags":"","loc":"interface/general_specs_reader_ccs.html","title":"general_specs_reader_ccs – The eT program"},{"text":"interface public module subroutine calculation_reader_ccs(wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15) :: unit_input Description Calculation Reader\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017","tags":"","loc":"interface/calculation_reader_ccs.html","title":"calculation_reader_ccs – The eT program"},{"text":"interface public module subroutine read_ground_state_specs_ccs(wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer :: unit_input Description Read Ground State Specifications\n   Written by Eirik F. Kjønstad and Sarai Dery Folkestad, Nov. 2017","tags":"","loc":"interface/read_ground_state_specs_ccs.html","title":"read_ground_state_specs_ccs – The eT program"},{"text":"interface public module subroutine read_excited_state_specs_ccs(wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15) :: unit_input Description Read Excited State Specifications\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017","tags":"","loc":"interface/read_excited_state_specs_ccs.html","title":"read_excited_state_specs_ccs – The eT program"},{"text":"interface public module subroutine read_property_specs_ccs(wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15) :: unit_input Description Read Property Specifications\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Nov. 2017","tags":"","loc":"interface/read_property_specs_ccs.html","title":"read_property_specs_ccs – The eT program"},{"text":"interface public module subroutine get_cholesky_ij_ccs(wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last Description Get Cholesky IJ\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/get_cholesky_ij_ccs.html","title":"get_cholesky_ij_ccs – The eT program"},{"text":"interface public module subroutine get_cholesky_ia_ccs(wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last Description Get Cholesky IA\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/get_cholesky_ia_ccs.html","title":"get_cholesky_ia_ccs – The eT program"},{"text":"interface public module subroutine get_cholesky_ai_ccs(wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last Description Get Cholesky AI\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/get_cholesky_ai_ccs.html","title":"get_cholesky_ai_ccs – The eT program"},{"text":"interface public module subroutine get_cholesky_ab_ccs(wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(((b_last - b_first + 1)*(a_last - a_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last Description Get Cholesky AB\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/get_cholesky_ab_ccs.html","title":"get_cholesky_ab_ccs – The eT program"},{"text":"interface public module subroutine store_vv_vv_electronic_repulsion_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Store vvvv Electronic Repulsion \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/store_vv_vv_electronic_repulsion_ccs.html","title":"store_vv_vv_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine store_t1_vv_vv_electronic_repulsion_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Store t1 vvvv Electronic Repulsion Integrals \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/store_t1_vv_vv_electronic_repulsion_ccs.html","title":"store_t1_vv_vv_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine store_t1_vo_ov_electronic_repulsion_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Store t1 voov Electronic Repulsion Integrals \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/store_t1_vo_ov_electronic_repulsion_ccs.html","title":"store_t1_vo_ov_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine store_t1_vv_ov_electronic_repulsion_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Store t1 voov Electronic Repulsion Integrals \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/store_t1_vv_ov_electronic_repulsion_ccs.html","title":"store_t1_vv_ov_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine store_t1_vv_vo_electronic_repulsion_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Store t1 vvvo Electronic Repulsion Integrals \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/store_t1_vv_vo_electronic_repulsion_ccs.html","title":"store_t1_vv_vo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine read_vv_vv_electronic_repulsion_ccs(wf, x_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Read vvvv Electronic Repulsion \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/read_vv_vv_electronic_repulsion_ccs.html","title":"read_vv_vv_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine read_t1_vv_vv_electronic_repulsion_ccs(wf, x_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Read t1 vvvv Electronic Repulsion \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/read_t1_vv_vv_electronic_repulsion_ccs.html","title":"read_t1_vv_vv_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine read_t1_vo_ov_electronic_repulsion_ccs(wf, x_vo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vo_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Read t1 voov Electronic Repulsion \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/read_t1_vo_ov_electronic_repulsion_ccs.html","title":"read_t1_vo_ov_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine read_t1_vv_vo_electronic_repulsion_ccs(wf, x_vv_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Read t1 vvvo Electronic Repulsion Integrals \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/read_t1_vv_vo_electronic_repulsion_ccs.html","title":"read_t1_vv_vo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine read_t1_vv_ov_electronic_repulsion_ccs(wf, x_vv_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Read t1 vvov Electronic Repulsion Integrals \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017","tags":"","loc":"interface/read_t1_vv_ov_electronic_repulsion_ccs.html","title":"read_t1_vv_ov_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_oo_oo_ccs(wf, integral_type, x_oo_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:, :) :: x_oo_oo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_oo,oo integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_oo_oo_ccs.html","title":"get_oo_oo_ccs – The eT program"},{"text":"interface public module subroutine get_oo_ov_ccs(wf, integral_type, x_oo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_oo_ov integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_oo,ov integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_oo_ov_ccs.html","title":"get_oo_ov_ccs – The eT program"},{"text":"interface public module subroutine get_ov_oo_ccs(wf, integral_type, x_ov_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_ov_oo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_ov,oo integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_ov_oo_ccs.html","title":"get_ov_oo_ccs – The eT program"},{"text":"interface public module subroutine get_oo_vo_ccs(wf, integral_type, x_oo_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_oo_vo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_oo,vo integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_oo_vo_ccs.html","title":"get_oo_vo_ccs – The eT program"},{"text":"interface public module subroutine get_vo_oo_ccs(wf, integral_type, x_vo_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vo_oo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_vo,oo integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vo_oo_ccs.html","title":"get_vo_oo_ccs – The eT program"},{"text":"interface public module subroutine get_oo_vv_ccs(wf, integral_type, x_oo_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_oo_vv integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_oo,vv integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_oo_vv_ccs.html","title":"get_oo_vv_ccs – The eT program"},{"text":"interface public module subroutine get_vv_oo_ccs(wf, integral_type, x_vv_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vv_oo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_vv,oo integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vv_oo_ccs.html","title":"get_vv_oo_ccs – The eT program"},{"text":"interface public module subroutine get_ov_ov_ccs(wf, integral_type, x_ov_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_ov_ov integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_ov,ov integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_ov_ov_ccs.html","title":"get_ov_ov_ccs – The eT program"},{"text":"interface public module subroutine get_vo_vo_ccs(wf, integral_type, x_vo_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vo_vo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_vo,vo integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vo_vo_ccs.html","title":"get_vo_vo_ccs – The eT program"},{"text":"interface public module subroutine get_ov_vo_ccs(wf, integral_type, x_ov_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_ov_vo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_ov,vo integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_ov_vo_ccs.html","title":"get_ov_vo_ccs – The eT program"},{"text":"interface public module subroutine get_vo_ov_ccs(wf, integral_type, x_vo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vo_ov integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_vo,ov integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vo_ov_ccs.html","title":"get_vo_ov_ccs – The eT program"},{"text":"interface public module subroutine get_ov_vv_ccs(wf, integral_type, x_ov_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_ov_vv integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_ov,vv integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_ov_vv_ccs.html","title":"get_ov_vv_ccs – The eT program"},{"text":"interface public module subroutine get_vv_ov_ccs(wf, integral_type, x_vv_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vv_ov integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_vv,ov integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vv_ov_ccs.html","title":"get_vv_ov_ccs – The eT program"},{"text":"interface public module subroutine get_vo_vv_ccs(wf, integral_type, x_vo_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vo_vv integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_vo,vv integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vo_vv_ccs.html","title":"get_vo_vv_ccs – The eT program"},{"text":"interface public module subroutine get_vv_vo_ccs(wf, integral_type, x_vv_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vv_vo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_vv,vo integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vv_vo_ccs.html","title":"get_vv_vo_ccs – The eT program"},{"text":"interface public module subroutine get_vv_vv_ccs(wf, integral_type, x_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vv_vv integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last Description Get x_vv,vv integral (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vv_vv_ccs.html","title":"get_vv_vv_ccs – The eT program"},{"text":"interface public module subroutine get_oo_oo_electronic_repulsion_ccs(wf, x_oo_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_oo_oo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get oooo Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_oo_oo_electronic_repulsion_ccs.html","title":"get_oo_oo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_oo_ov_electronic_repulsion_ccs(wf, x_oo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_oo_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get ooov Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_oo_ov_electronic_repulsion_ccs.html","title":"get_oo_ov_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_ov_oo_electronic_repulsion_ccs(wf, x_ov_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_ov_oo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get ovoo Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_ov_oo_electronic_repulsion_ccs.html","title":"get_ov_oo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_oo_vo_electronic_repulsion_ccs(wf, x_oo_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_oo_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get oovo Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_oo_vo_electronic_repulsion_ccs.html","title":"get_oo_vo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_oo_vv_electronic_repulsion_ccs(wf, x_oo_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_oo_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get oovv Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_oo_vv_electronic_repulsion_ccs.html","title":"get_oo_vv_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_vv_oo_electronic_repulsion_ccs(wf, x_vv_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_vv_oo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get vvoo Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vv_oo_electronic_repulsion_ccs.html","title":"get_vv_oo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_ov_ov_electronic_repulsion_ccs(wf, x_ov_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_ov_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get ovov Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_ov_ov_electronic_repulsion_ccs.html","title":"get_ov_ov_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_vo_oo_electronic_repulsion_ccs(wf, x_vo_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_vo_oo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get vooo Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vo_oo_electronic_repulsion_ccs.html","title":"get_vo_oo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_vo_vo_electronic_repulsion_ccs(wf, x_vo_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vo_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get vovo Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vo_vo_electronic_repulsion_ccs.html","title":"get_vo_vo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_ov_vo_electronic_repulsion_ccs(wf, x_ov_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_ov_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get ovvo Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_ov_vo_electronic_repulsion_ccs.html","title":"get_ov_vo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_vo_ov_electronic_repulsion_ccs(wf, x_vo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vo_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get voov Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vo_ov_electronic_repulsion_ccs.html","title":"get_vo_ov_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_ov_vv_electronic_repulsion_ccs(wf, x_ov_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_ov_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get ovvv Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_ov_vv_electronic_repulsion_ccs.html","title":"get_ov_vv_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_vv_ov_electronic_repulsion_ccs(wf, x_vv_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get vvov Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vv_ov_electronic_repulsion_ccs.html","title":"get_vv_ov_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_vo_vv_electronic_repulsion_ccs(wf, x_vo_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vo_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get vovv Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vo_vv_electronic_repulsion_ccs.html","title":"get_vo_vv_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_vv_vo_electronic_repulsion_ccs(wf, x_vv_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get vvvo Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vv_vo_electronic_repulsion_ccs.html","title":"get_vv_vo_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine get_vv_vv_electronic_repulsion_ccs(wf, x_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description Get vvvv Electronic Repulsion (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017","tags":"","loc":"interface/get_vv_vv_electronic_repulsion_ccs.html","title":"get_vv_vv_electronic_repulsion_ccs – The eT program"},{"text":"interface public module subroutine t1_transform_vv_vv_ccs(wf, g_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: g_vv_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last Description T1 Transformation of g_vv_vv Integrals (CCS)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, Oct 2017.","tags":"","loc":"interface/t1_transform_vv_vv_ccs.html","title":"t1_transform_vv_vv_ccs – The eT program"},{"text":"interface public module subroutine initialize_fock_matrix_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize Fock Matrix\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/initialize_fock_matrix_ccs.html","title":"initialize_fock_matrix_ccs – The eT program"},{"text":"interface public module subroutine construct_fock_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Construct Fock \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/construct_fock_ccs.html","title":"construct_fock_ccs – The eT program"},{"text":"interface public module subroutine one_electron_t1_ccs(wf, h1, h1_T1) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_mo, wf%n_mo) :: h1 real(kind=dp), dimension(wf%n_mo, wf%n_mo) :: h1_T1 Description One-electron T1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"interface/one_electron_t1_ccs.html","title":"one_electron_t1_ccs – The eT program"},{"text":"interface public module subroutine ionized_state_driver_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Ionized State Driver (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/ionized_state_driver_ccs.html","title":"ionized_state_driver_ccs – The eT program"},{"text":"interface public module subroutine initialize_trial_vectors_valence_ionization_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize Trial Vectors for Valence Ionization\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017","tags":"","loc":"interface/initialize_trial_vectors_valence_ionization_ccs.html","title":"initialize_trial_vectors_valence_ionization_ccs – The eT program"},{"text":"interface public module subroutine initialize_trial_vectors_core_ionization_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize Trial Vectors for Core Ionization\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017","tags":"","loc":"interface/initialize_trial_vectors_core_ionization_ccs.html","title":"initialize_trial_vectors_core_ionization_ccs – The eT program"},{"text":"interface public module subroutine precondition_residual_valence_ionization_ccs(wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual Description Precondition Residual Valence\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/precondition_residual_valence_ionization_ccs.html","title":"precondition_residual_valence_ionization_ccs – The eT program"},{"text":"interface public module subroutine ionization_residual_projection_ccs(wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual Description Core Ionization Residual Projection (CCS)\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/ionization_residual_projection_ccs.html","title":"ionization_residual_projection_ccs – The eT program"},{"text":"interface public module subroutine ionization_rho_a_i_projection_ccs(wf, rho_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i Description Ionization rho_a_i Projection (CCS)\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/ionization_rho_a_i_projection_ccs.html","title":"ionization_rho_a_i_projection_ccs – The eT program"},{"text":"interface public module subroutine precondition_residual_core_ionization_ccs(wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual Description Precondition Residual Valence\n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/precondition_residual_core_ionization_ccs.html","title":"precondition_residual_core_ionization_ccs – The eT program"},{"text":"interface public module subroutine jacobian_ccs_transformation_ccs(wf, c_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian CCS transformation\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccs_transformation_ccs.html","title":"jacobian_ccs_transformation_ccs – The eT program"},{"text":"interface public module subroutine jacobian_ccs_a1_ccs(wf, rho, c1) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_o,wf%n_v) :: rho real(kind=dp), dimension(wf%n_o,wf%n_v) :: c1 Description Jacobian CCS A1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccs_a1_ccs.html","title":"jacobian_ccs_a1_ccs – The eT program"},{"text":"interface public module subroutine jacobian_ccs_b1_ccs(wf, rho, c1) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_o,wf%n_v) :: rho real(kind=dp), dimension(wf%n_o,wf%n_v) :: c1 Description Jacobian CCS B1 \n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017","tags":"","loc":"interface/jacobian_ccs_b1_ccs.html","title":"jacobian_ccs_b1_ccs – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccs_transformation_ccs(wf, b_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i Description Jacobian transpose transformation (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccs_transformation_ccs.html","title":"jacobian_transpose_ccs_transformation_ccs – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccs_a1_ccs(wf, sigma_a_i, b_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i Description Jacobian transpose A1 (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccs_a1_ccs.html","title":"jacobian_transpose_ccs_a1_ccs – The eT program"},{"text":"interface public module subroutine jacobian_transpose_ccs_b1_ccs(wf, sigma_a_i, b_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i Description Jacobian transpose B1 (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, June 2017","tags":"","loc":"interface/jacobian_transpose_ccs_b1_ccs.html","title":"jacobian_transpose_ccs_b1_ccs – The eT program"},{"text":"interface public module subroutine cvs_rho_a_i_projection_ccs(wf, vec_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_o,wf%n_v) :: vec_a_i Description CVS rho_a_i Projection \n   Written by Sarai D. Folkestad, Aug 2017","tags":"","loc":"interface/cvs_rho_a_i_projection_ccs.html","title":"cvs_rho_a_i_projection_ccs – The eT program"},{"text":"interface public module subroutine cvs_residual_projection_ccs(wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual Description CVS Residual Projection\n   Written by Sarai D. Folkestad, Aug. 2017","tags":"","loc":"interface/cvs_residual_projection_ccs.html","title":"cvs_residual_projection_ccs – The eT program"},{"text":"public subroutine init_mp2(wf) Initialize MP2 object\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nPerforms the following tasks\n\n- Sets HF orbital and energy information by reading from file\n- Transforms AO Cholesky vectors to MO basis and saves to file Arguments Type Intent Optional Attributes Name class( mp2 ) :: wf","tags":"","loc":"proc/init_mp2.html","title":"init_mp2 – The eT program"},{"text":"public subroutine drv_mp2(wf) MP2 Driver\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nThe driver for MP2 checks whether the ground state is requested,\nand if so, calls the calculation of the MP2 energy. Arguments Type Intent Optional Attributes Name class( mp2 ) :: wf","tags":"","loc":"proc/drv_mp2.html","title":"drv_mp2 – The eT program"},{"text":"public subroutine calc_energy_mp2(wf) Calculate Energy (MP2)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nCalculates the MP2 energy. Arguments Type Intent Optional Attributes Name class( mp2 ) :: wf Calls proc~~calc_energy_mp2~~CallsGraph proc~calc_energy_mp2 calc_energy_mp2 dgemm dgemm proc~calc_energy_mp2->dgemm proc~index_two index_two proc~calc_energy_mp2->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/calc_energy_mp2.html","title":"calc_energy_mp2 – The eT program"},{"text":"public subroutine init_cc2(wf) Initialize CC2 object\n Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n Performs the following tasks\n\n 1. Sets HF orbital and energy information by reading from file (read_hf_info)\n 2. Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky)\n 3. Allocates the Fock matrix and sets it to zero (note: the matrix is constructed in \n    the descendant classes) \n 4. Allocates the singles amplitudes and sets them to zero, and sets associated properties \n 5. Allocate Omega vector Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf Calls proc~~init_cc2~~CallsGraph proc~init_cc2 init_cc2 proc~generate_unit_identifier generate_unit_identifier proc~init_cc2->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_cc2.html","title":"init_cc2 – The eT program"},{"text":"public subroutine calc_energy_cc2(wf) Calculate Energy (CC2)\n\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\nCalculates the CC2 energy,\n\nE_CC2 = E_HF + sum_aibj L_iajb*(t_ij&#94;ab + t_i&#94;a*t_j&#94;b),\n\nwith t_ij&#94;ab = - g_aibj/(e_a + e_b - e_i - e_j) where \ng_aibj are T1-transformed integrals.\nBatching over a. Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf Calls proc~~calc_energy_cc2~~CallsGraph proc~calc_energy_cc2 calc_energy_cc2 proc~batch_limits batch_limits proc~calc_energy_cc2->proc~batch_limits dgemm dgemm proc~calc_energy_cc2->dgemm proc~num_batch num_batch proc~calc_energy_cc2->proc~num_batch proc~index_two index_two proc~calc_energy_cc2->proc~index_two proc~get_available get_available proc~calc_energy_cc2->proc~get_available proc~index_packed index_packed proc~calc_energy_cc2->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/calc_energy_cc2.html","title":"calc_energy_cc2 – The eT program"},{"text":"public subroutine save_amplitudes_cc2(wf) Save Amplitudes (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nStore the amplitudes to disk (T1AM) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf Calls proc~~save_amplitudes_cc2~~CallsGraph proc~save_amplitudes_cc2 save_amplitudes_cc2 proc~index_two index_two proc~save_amplitudes_cc2->proc~index_two proc~generate_unit_identifier generate_unit_identifier proc~save_amplitudes_cc2->proc~generate_unit_identifier proc~index_packed index_packed proc~save_amplitudes_cc2->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/save_amplitudes_cc2.html","title":"save_amplitudes_cc2 – The eT program"},{"text":"public subroutine destruct_s2am_cc2(wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf","tags":"","loc":"proc/destruct_s2am_cc2.html","title":"destruct_s2am_cc2 – The eT program"},{"text":"public subroutine read_amplitudes_cc2(wf) Read Amplitudes (CC2)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf","tags":"","loc":"proc/read_amplitudes_cc2.html","title":"read_amplitudes_cc2 – The eT program"},{"text":"public subroutine read_cc2_double_amplitudes_cc2(wf) Read Amplitudes (CC2)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM, S2AM) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf Calls proc~~read_cc2_double_amplitudes_cc2~~CallsGraph proc~read_cc2_double_amplitudes_cc2 read_cc2_double_amplitudes_cc2 proc~generate_unit_identifier generate_unit_identifier proc~read_cc2_double_amplitudes_cc2->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_cc2_double_amplitudes_cc2.html","title":"read_cc2_double_amplitudes_cc2 – The eT program"},{"text":"interface public module subroutine construct_omega_cc2(wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf Description Construct Omega \n    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n    Directs the construction of the projection vector < mu | exp(-T) H exp(T) | R >\n    for the current amplitudes of the object wf","tags":"","loc":"interface/construct_omega_cc2.html","title":"construct_omega_cc2 – The eT program"},{"text":"interface public module subroutine omega_cc2_a1_cc2(wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf Description Omega A1\n    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n    Calculates the A1 term of omega,\n\n    A1: sum_ckd g_adkc * u_ki&#94;cd,\n\n    and adds it to the projection vector (omega1) of\n    the wavefunction object wf\n\n    u_ki&#94;cd = 2*t_ki&#94;cd - t_ik&#94;cd","tags":"","loc":"interface/omega_cc2_a1_cc2.html","title":"omega_cc2_a1_cc2 – The eT program"},{"text":"interface public module subroutine omega_cc2_b1_cc2(wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf Description Omega B1\n    Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n    Calculates the B1 term of omega,\n\n    B1: - sum_ckl u_kl&#94;ac * g_kilc,\n\n    and adds it to the projection vector (omeg1) of\n    the wavefunction object wf\n\n    u_kl&#94;ac = 2*t_kl&#94;ac - t_lk&#94;ac","tags":"","loc":"interface/omega_cc2_b1_cc2.html","title":"omega_cc2_b1_cc2 – The eT program"},{"text":"interface public module subroutine get_s2am_cc2(wf, s_ia_jb, b_first, b_length) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), b_length*(wf%n_o)) :: s_ia_jb integer(kind=i15) :: b_first integer(kind=i15) :: b_length Description Get S_2 amplitudes, \n   Written by Sarai D. Folkestad, July 2017\n\n   Construct\n\n      s_ai_bj = - 1/ε_ij&#94;ab * g_aibj,\n\n   while batching over b.","tags":"","loc":"interface/get_s2am_cc2.html","title":"get_s2am_cc2 – The eT program"},{"text":"interface public module subroutine jacobian_cc2_transformation_cc2(wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_s2am, 1) :: c_aibj Description Jacobian transformation (CC2)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Directs the transformation by the CC2 Jacobi matrix,\n\n      A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >,\n\n   where the basis employed for the brackets is biorthonormal. \n   The transformation is rho = A c, i.e.,\n\n      rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck \n              + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl).\n\n   On exit, c is overwritten by rho. That is, c_a_i = rho_a_i,\n   and c_aibj = rho_aibj.","tags":"","loc":"interface/jacobian_cc2_transformation_cc2.html","title":"jacobian_cc2_transformation_cc2 – The eT program"},{"text":"interface public module subroutine jacobian_cc2_a1_cc2(wf, rho_a_i, c_a_i) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian tem A1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Calculates the A1 contribution to the jacobi transformation,\n\n      A1: 2*sum_BJck u_ik&#94;ac*g_kc,JB*c_BJ - sum_Bjck u_kj&#94;ca*g_kc,jB*c_BI\n        - sum_BJck u_ik&#94;ac*g_kB,Jc*c_BJ - sum_bJck u_ki&#94;cb*g_kc,Jb*c_AJ,\n\n   with,\n\n   u_ik&#94;ac = 2*s_ik&#94;ac - 2*s_ik&#94;ca,\n\n   which is constructed while batching over c","tags":"","loc":"interface/jacobian_cc2_a1_cc2.html","title":"jacobian_cc2_a1_cc2 – The eT program"},{"text":"interface public module subroutine jacobian_cc2_b1_cc2(wf, rho_a_i, c_ai_bj) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(:,:) :: c_ai_bj Description Jacobian tem B1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Calculates the B1 contribution to the jacobi transformation,\n\n   B1:   sum_ck F_kc*(2c_ai,ck - c_ak,ci) \n       - sum_ckj L_jIkc * c_aj,ck + sum_cbk L_Abkc * c_bi,ck\n\n\n   L_Abkc is constructed while batching over A.","tags":"","loc":"interface/jacobian_cc2_b1_cc2.html","title":"jacobian_cc2_b1_cc2 – The eT program"},{"text":"interface public module subroutine jacobian_cc2_a2_cc2(wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian tem A2\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Calculates the A2 contribution to the jacobi transformation,\n\n      A2:   sum_C g_ai,bC * c_Cj - sum_K g_ai,Kj * C_bK.\n\n   g_ai,bC is constructed in batches of C.","tags":"","loc":"interface/jacobian_cc2_a2_cc2.html","title":"jacobian_cc2_a2_cc2 – The eT program"},{"text":"interface public module subroutine jacobian_cc2_b2_cc2(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj Description Jacobian tem B2\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Calculates the B2 contribution to the jacobi transformation,\n\n      B2:   ε_ij&#94;ab*c_ai,bj.","tags":"","loc":"interface/jacobian_cc2_b2_cc2.html","title":"jacobian_cc2_b2_cc2 – The eT program"},{"text":"interface public module subroutine cvs_rho_aibj_projection_cc2(wf, vec_aibj) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(:, :) :: vec_aibj Description Rho projection for CVS (CC2),\n   Written by Sarai D. Folkestad, Aug. 2017","tags":"","loc":"interface/cvs_rho_aibj_projection_cc2.html","title":"cvs_rho_aibj_projection_cc2 – The eT program"},{"text":"interface public module subroutine initialize_excited_states_cc2(wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf Description Initialize excited states\n   Written by Sarai D. Folkestad, June 2017\n\n   Calculates and sets n_s2am, and updates n_parameters\n   for excited state calculation","tags":"","loc":"interface/initialize_excited_states_cc2.html","title":"initialize_excited_states_cc2 – The eT program"},{"text":"interface public module subroutine calculate_orbital_differences_cc2(wf, orbital_diff) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: orbital_diff Description Calculate Orbital Differences (CC2)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad May 2017\n\n   Calculates orbital differences\n\n      1) ε_I&#94;A = ε_A - ε_I\n      2) ε_ij&#94;ab = ε_a + ε_b - ε_i - ε_j (for active spaces only)\n\n   and puts them in orbital_diff, which is a vector of length n_parameters.","tags":"","loc":"interface/calculate_orbital_differences_cc2.html","title":"calculate_orbital_differences_cc2 – The eT program"},{"text":"interface public module subroutine transform_trial_vectors_cc2(wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial Description Transformation Trial Vectors (CC2)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   Each trial vector in first_trial to last_trial is read from file and\n   transformed before the transformed vector is written to file.\n\n   Singles and doubles part of the transformed vectors are written to \n   the same record in file transformed_vec, record length is n_parameters long.","tags":"","loc":"interface/transform_trial_vectors_cc2.html","title":"transform_trial_vectors_cc2 – The eT program"},{"text":"interface public module subroutine cvs_residual_projection_cc2(wf, residual) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual Description Residual projection (CC2), \n   Written by Sarai D. Folkestad Aug. 2017","tags":"","loc":"interface/cvs_residual_projection_cc2.html","title":"cvs_residual_projection_cc2 – The eT program"},{"text":"interface public module subroutine excited_state_preparations_cc2(wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf Description Excited State Preparations (CC2)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017\n\n   A routine for preparation tasks (if any). Can be overwritten\n   in descendants if other preparations prove necessary.","tags":"","loc":"interface/excited_state_preparations_cc2.html","title":"excited_state_preparations_cc2 – The eT program"},{"text":"interface public module subroutine analyze_double_excitation_vector_cc2(wf, vec, n, sorted_short_vec, index_list) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_s2am, 1) :: vec integer(kind=i15) :: n real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 4) :: index_list","tags":"","loc":"interface/analyze_double_excitation_vector_cc2.html","title":"analyze_double_excitation_vector_cc2 – The eT program"},{"text":"interface public module subroutine summary_excited_state_info_cc2(wf, energies) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies","tags":"","loc":"interface/summary_excited_state_info_cc2.html","title":"summary_excited_state_info_cc2 – The eT program"},{"text":"public subroutine init_cc3(wf) Initialize CC3 object\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nPerforms the following tasks:\n\n   1. Sets HF orbital and energy information by reading from file (read_hf_info)\n   2. Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky)\n   3. Allocates the Fock matrix and sets it to zero\n   4. Initializes the amplitudes (sets their initial values and associated variables)\n\nNote: this routine does not calculate the energy, which is postponed until the wavefunction\nis passed to the ground-state solver. Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf Calls proc~~init_cc3~~CallsGraph proc~init_cc3 init_cc3 proc~generate_unit_identifier generate_unit_identifier proc~init_cc3->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_cc3.html","title":"init_cc3 – The eT program"},{"text":"interface public module subroutine construct_omega_cc3(wf) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf Description Construct Omega (CC3)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Directs the calculation of the projection vector (omega1, omega2)\n   for the CC3 level of theory.","tags":"","loc":"interface/construct_omega_cc3.html","title":"construct_omega_cc3 – The eT program"},{"text":"interface public module subroutine omega_integrals_cc3(wf) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf Description Omega Integrals (CC3)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Calculates g_bdck and saves to disk in the order bcd, k (one record per d and k)\n   Calculates g_ljck and saves to disk in the order lc, jk (one record per j and k)\n   Calculates g_jbkc and saves to disk in the order bc, kj (one record per k and j)\n   Calculates g_ilkc and saves to disk in the order cl, ik (one record per i and k)\n   Calculates g_dbkc and saves to disk in the order bcd, k (one record per d and k)","tags":"","loc":"interface/omega_integrals_cc3.html","title":"omega_integrals_cc3 – The eT program"},{"text":"interface public module subroutine calc_triples_cc3(wf, w_abc, i, j, k) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf real(kind=dp), dimension((wf%n_v)**3, 1) :: w_abc integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j integer(kind=i15), intent(in) :: k Description Calculate Triples (CC3)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Calculate W_abc = P_ijk&#94;abc ( sum_d t_ij&#94;ad g_bdck - sum_l t_il&#94;ab g_ljck )\n   and divide by orbital energy difference, t_abc = - W_abc / e_abc. On exit,\n   w_abc = t_abc, the CC3 triples amplitude t_ijk&#94;abc for a given set of occupied\n   indices i, j, and k.","tags":"","loc":"interface/calc_triples_cc3.html","title":"calc_triples_cc3 – The eT program"},{"text":"interface public module subroutine omega_cc3_a1_cc3(wf, t_abc, i, j, k) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf real(kind=dp), dimension((wf%n_v)**3, 1) :: t_abc integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j integer(kind=i15), intent(in) :: k Description Omega A1 (CC3)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Calculates the A1 term,\n\n      sum_bc (t_ijk&#94;abc - t_ijk&#94;cba) L_jbkc,\n\n   for a given set of i, j, and k, and adds the contribution to \n   the singles projection vector (omega1).","tags":"","loc":"interface/omega_cc3_a1_cc3.html","title":"omega_cc3_a1_cc3 – The eT program"},{"text":"interface public module subroutine omega_cc3_a2_cc3(wf, omega_ai_bj, t_abc, i, j, k) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: omega_ai_bj real(kind=dp), dimension((wf%n_v)**3, 1) :: t_abc integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j integer(kind=i15), intent(in) :: k Description Omega A2 (CC3)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Calculates the A2 term,\n\n      sum_c (t_ijk&#94;abc - t_ijk&#94;cba) F_kc,\n\n   for a given set of i, j, and k, and adds the contribution to \n   the doubles projection vector (omega2), element ai_bj.","tags":"","loc":"interface/omega_cc3_a2_cc3.html","title":"omega_cc3_a2_cc3 – The eT program"},{"text":"interface public module subroutine omega_cc3_b2_cc3(wf, omega_ai_bj, t_abc, i, j, k) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: omega_ai_bj real(kind=dp), dimension((wf%n_v)**3, 1) :: t_abc integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j integer(kind=i15), intent(in) :: k Description Omega B2 (CC3)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Calculates the B2 term,\n\n      omega(al,bj) = - sum_c  (2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb) g_ilkc\n      omega(ai,dj) = + sum_bc (2 t_ijk&#94;abc - t_ijk&#94;cba - t_ijk&#94;acb) g_dbkc\n\n   for a given set of i, j, and k, and adds the contribution to \n   the doubles projection vector (omega2).","tags":"","loc":"interface/omega_cc3_b2_cc3.html","title":"omega_cc3_b2_cc3 – The eT program"},{"text":"public subroutine init_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Calls proc~~init_mlcc2~~CallsGraph proc~init_mlcc2 init_mlcc2 proc~generate_unit_identifier generate_unit_identifier proc~init_mlcc2->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_mlcc2.html","title":"init_mlcc2 – The eT program"},{"text":"public subroutine calc_energy_mlcc2(wf) Calculate Energy (MLCC2)\n\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\nCalculates the MLCC2 energy,\n\nE_CC2 = E_HF + sum_aibj L_iajb*(s_ij&#94;ab + t_i&#94;a*t_j&#94;b),\n\nwith s_ij&#94;ab = - g_aibj/(e_a + e_b - e_i - e_j) where \ng_aibj are T1-transformed integrals.\nBatching over a. Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Calls proc~~calc_energy_mlcc2~~CallsGraph proc~calc_energy_mlcc2 calc_energy_mlcc2 proc~num_batch num_batch proc~calc_energy_mlcc2->proc~num_batch dgemm dgemm proc~calc_energy_mlcc2->dgemm proc~get_available get_available proc~calc_energy_mlcc2->proc~get_available proc~batch_limits batch_limits proc~calc_energy_mlcc2->proc~batch_limits proc~index_two index_two proc~calc_energy_mlcc2->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/calc_energy_mlcc2.html","title":"calc_energy_mlcc2 – The eT program"},{"text":"public subroutine get_CC2_active_indices_mlcc2(wf, first_o, first_v) Get CC2 active indices,\nWritten by Sarai D. Folkestad, June 2017\n\nReturns the first active occupied and virtual indices \nof the active space. Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: first_o integer(kind=i15) :: first_v","tags":"","loc":"proc/get_cc2_active_indices_mlcc2.html","title":"get_CC2_active_indices_mlcc2 – The eT program"},{"text":"public subroutine get_CC2_n_active_mlcc2(wf, n_active_o, n_active_v) Get CC2 active indices,\nWritten by Sarai D. Folkestad, June 2017\n\nReturns the first active occupied and virtual indices \nof the active space. Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: n_active_o integer(kind=i15) :: n_active_v","tags":"","loc":"proc/get_cc2_n_active_mlcc2.html","title":"get_CC2_n_active_mlcc2 – The eT program"},{"text":"public subroutine save_amplitudes_mlcc2(wf) Save Amplitudes (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nStore the amplitudes to disk (T1AM) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Calls proc~~save_amplitudes_mlcc2~~CallsGraph proc~save_amplitudes_mlcc2 save_amplitudes_mlcc2 proc~index_two index_two proc~save_amplitudes_mlcc2->proc~index_two proc~generate_unit_identifier generate_unit_identifier proc~save_amplitudes_mlcc2->proc~generate_unit_identifier proc~index_packed index_packed proc~save_amplitudes_mlcc2->proc~index_packed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/save_amplitudes_mlcc2.html","title":"save_amplitudes_mlcc2 – The eT program"},{"text":"public subroutine read_amplitudes_mlcc2(wf) Read Amplitudes (MLCC2)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf","tags":"","loc":"proc/read_amplitudes_mlcc2.html","title":"read_amplitudes_mlcc2 – The eT program"},{"text":"public subroutine read_cc2_double_amplitudes_mlcc2(wf) Read Amplitudes (MLCC2)\nWritten by Sarai D. Folkestad and Eirik F. Kjøsntad, May 2017\n\nReads the amplitudes from disk (T1AM, S2AM) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Calls proc~~read_cc2_double_amplitudes_mlcc2~~CallsGraph proc~read_cc2_double_amplitudes_mlcc2 read_cc2_double_amplitudes_mlcc2 proc~generate_unit_identifier generate_unit_identifier proc~read_cc2_double_amplitudes_mlcc2->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_cc2_double_amplitudes_mlcc2.html","title":"read_cc2_double_amplitudes_mlcc2 – The eT program"},{"text":"public subroutine destruct_x2am_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf","tags":"","loc":"proc/destruct_x2am_mlcc2.html","title":"destruct_x2am_mlcc2 – The eT program"},{"text":"interface public subroutine mlcc_reader_mlcc2(wf, unit_input) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: unit_input","tags":"","loc":"interface/mlcc_reader_mlcc2.html","title":"mlcc_reader_mlcc2 – The eT program"},{"text":"interface public module subroutine read_orbital_info_mlcc2(wf, unit_input) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: unit_input","tags":"","loc":"interface/read_orbital_info_mlcc2.html","title":"read_orbital_info_mlcc2 – The eT program"},{"text":"interface public module subroutine orbital_partitioning_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description Orbital partitioning,\n   Written by Sarai D. Folkestad, June 2017\n\n   Directs the partitioning for mlcc calculations.\n\n   So far only Cholesky decomposition is available.","tags":"","loc":"interface/orbital_partitioning_mlcc2.html","title":"orbital_partitioning_mlcc2 – The eT program"},{"text":"interface public module subroutine cholesky_localization_drv_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description Cholesky orbital localization. driver,\n   Written by Sarai D. Folkestad, June 2017\n\n   Driver for Cholesky density decomposition.\n\n   - Collects atom and ao-basis information.\n   - Constructs occupied and vacant densities.\n   - Constructs AO Fock matrix.  (This is currently an N&#94;5 operation, should be optimized/removed)\n   - By looping over active spaces, the occupied and virtual densities are Cholesky decomposed\n     and the cholesky vectors are used to generate new localized MO's.\n   - New orbitals are tested for orthonormality (Not implemented yet, only need overlap matrix from DALTON)","tags":"","loc":"interface/cholesky_localization_drv_mlcc2.html","title":"cholesky_localization_drv_mlcc2 – The eT program"},{"text":"interface public module subroutine cholesky_decomposition_mlcc2(wf, density, cholesky_vectors, n_vectors, selection, n_active_aos, active_ao_index_list) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_ao,wf%n_ao) :: density real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: cholesky_vectors integer(kind=i15) :: n_vectors logical :: selection integer(kind=i15) :: n_active_aos integer(kind=i15), optional dimension( n_active_aos,1) :: active_ao_index_list Description Cholesky decomposition, \n   Written by Sarai dery Folkestad, June 2017.\n\n   Cholesky decomposes the density (occupied/virtual).\n   Pivoting elements are chosen according to the active ao-list if it is pressent.\n   If not, maximum diagonal elements are chosen as pivoting elements.\n\n   The Cholesky vectors are subtracted from the incoming density matrix, and the returned density can be furteh decomposed\n   for inactive region.","tags":"","loc":"interface/cholesky_decomposition_mlcc2.html","title":"cholesky_decomposition_mlcc2 – The eT program"},{"text":"interface public module subroutine cholesky_orbitals_mlcc2(wf, cholesky_vectors, n_vectors, orbitals, orbital_energies, ao_fock) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: cholesky_vectors integer(kind=i15) :: n_vectors real(kind=dp), dimension(wf%n_ao, n_vectors) :: orbitals real(kind=dp), dimension(n_vectors, 1) :: orbital_energies real(kind=dp), dimension(wf%n_ao,wf%n_ao) :: ao_fock Description Cholesky orbitals,\n   Written by Sarai Dery Folkestad, June 2017\n\n   Makes the new MO's fromthe Cholesky vectors   \n   - Transforms the AO fock matrix by the Cholesky vectors\n   - Diagonalize the MO fock to get orbital energies and new orbitals.","tags":"","loc":"interface/cholesky_orbitals_mlcc2.html","title":"cholesky_orbitals_mlcc2 – The eT program"},{"text":"interface public module subroutine cholesky_orbital_constructor_mlcc2(wf, orbitals, orbital_energies, offset, ao_fock, density, n_vectors, selection, n_active_aos, active_ao_index_list) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_mo) :: orbitals real(kind=dp), dimension(wf%n_mo, 1) :: orbital_energies integer(kind=i15) :: offset real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock real(kind=dp), dimension(wf%n_ao,wf%n_ao) :: density integer(kind=i15) :: n_vectors logical :: selection integer(kind=i15) :: n_active_aos integer(kind=i15), optional dimension( n_active_aos,1) :: active_ao_index_list Description Cholesky orbital constructor,\n   Written by Sarai Dery Folkestad, June 2017\n\n   Constructs new localized orbitals (occupied/virtual) by \n   - Decomposing the density (occupied/virual)\n   - Transforming Fock matrix with Cholesky vectors, and diagonalizing it.\n     New orbitals are eigenvectors, orbital energies are eigenvectors.","tags":"","loc":"interface/cholesky_orbital_constructor_mlcc2.html","title":"cholesky_orbital_constructor_mlcc2 – The eT program"},{"text":"interface public module subroutine construct_active_ao_index_list(active_ao_index_list, n_active_aos, active_atoms, n_active_atoms, ao_center_info, n_ao) Arguments Type Intent Optional Attributes Name integer(kind=i15), dimension(n_active_aos, 1) :: active_ao_index_list integer(kind=i15) :: n_active_aos integer(kind=i15), dimension(n_active_atoms, 1) :: active_atoms integer(kind=i15) :: n_active_atoms integer(kind=i15), dimension(n_ao, 2) :: ao_center_info integer(kind=i15) :: n_ao Description Construct active ao index list,\n   Written by Sarai Dery Folkestad, June 2017.\n\n   Constructs list of active ao's for cholesky decomposition.","tags":"","loc":"interface/construct_active_ao_index_list.html","title":"construct_active_ao_index_list – The eT program"},{"text":"interface public module subroutine cnto_orbital_drv_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description CNTO orbital driver,\n   Written by Sarai D. Folkestad, June 2017.\n\n   Directs the construction of CNTOs and the selection of the active space\n   A CCS calculation ground state and excited states is performed.\n   The M and N matrices are then constructed,\n\n      M_ij = 1/n sum_{k=1,n} (sum_a R&#94;k_ai*R1_aj)\n      N_ab = 1/n sum_{k=1,n} (sum_i R&#94;k_ai*R1_bi)\n\n   where n > 1.\n\n   Ri_ai is the i'th single excitation vector obtained from the CCS calculation. \n   The transformation matrices for the occupied and virtual part\n   are constructed by diagonalizing M and N. The number of active occupied\n   and virtual orbitals are determined from δ_o and δ_v\n\n      1 - sum_i λ&#94;o_i < δ_o\n      1 - sum_i λ&#94;v_i < δ_v\n\n   Where the orbitals of highest eigenvalues λ&#94;o/λ&#94;v are selected first.\n\n   Fock matrix is block diagonalized in active and inactive blocks in order to obtain \n   the orbitals and orbital energies used in the CC2 calculation.","tags":"","loc":"interface/cnto_orbital_drv_mlcc2.html","title":"cnto_orbital_drv_mlcc2 – The eT program"},{"text":"interface public module subroutine cc2_cnto_lower_level_method_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description CNTO lower level calculation (MLCC2),\n   Written by Sarai D. Folkestad, June 2017.\n\n   Runs lower level method for CNTOs","tags":"","loc":"interface/cc2_cnto_lower_level_method_mlcc2.html","title":"cc2_cnto_lower_level_method_mlcc2 – The eT program"},{"text":"interface public module subroutine cc2_cnto_orbitals_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description CNTO Oritals (MLCC2),\n   Written by Sarai D. Folkestad Aug. 2017\n\n   Constructs the CNTO orbitals based on exitation vectors from lower level method","tags":"","loc":"interface/cc2_cnto_orbitals_mlcc2.html","title":"cc2_cnto_orbitals_mlcc2 – The eT program"},{"text":"interface public module subroutine print_orbital_info_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description Print CNTO info, \n   Written by Sarai D. Folkestad, Aug. 2017\n\n   Prints information on CNTO partitioning","tags":"","loc":"interface/print_orbital_info_mlcc2.html","title":"print_orbital_info_mlcc2 – The eT program"},{"text":"interface public module subroutine omega_mlcc2_a1_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description Omega A1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   Calculates the A1 term of omega,\n\n   A1: sum_ckd g_adkc * u_ki&#94;cd,\n\n   and adds it to the projection vector (omega1) of\n   the wavefunction object wf\n\n   u_ki&#94;cd = 2*s_ki&#94;cd - s_ik&#94;cd","tags":"","loc":"interface/omega_mlcc2_a1_mlcc2.html","title":"omega_mlcc2_a1_mlcc2 – The eT program"},{"text":"interface public module subroutine omega_mlcc2_b1_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description Omega B1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   Calculates the B1 term of omega,\n\n   B1: - sum_bjk u_jk&#94;ab*g_jikb","tags":"","loc":"interface/omega_mlcc2_b1_mlcc2.html","title":"omega_mlcc2_b1_mlcc2 – The eT program"},{"text":"interface public module subroutine construct_omega_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description Construct Omega (CC2)\n   Written by Eirik F. Kjønstad and Sarai Folkestad, Apr 2017\n\n   Constructs t2-amplitudes on the fly, according to the CC2\n   expression for the doubles amplitudes,\n\n   t_ij&#94;ab = - g_ai_bj / (e_a + e_b - e_i - e_j),\n\n   where g_ai_bj are T1-transformed two-electron integrals \n   and e_x is the orbital enegy of orbital x.\n\n   The routine also sets up timing variables.","tags":"","loc":"interface/construct_omega_mlcc2.html","title":"construct_omega_mlcc2 – The eT program"},{"text":"interface public module subroutine get_s2am_mlcc2(wf, s_ai_bj, b_first, b_length) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension((wf%n_CC2_v)*(wf%n_CC2_o), b_length*(wf%n_CC2_o)) :: s_ai_bj integer(kind=i15) :: b_first integer(kind=i15) :: b_length Description Get S_2 amplitudes, \n   Written by Sarai D. Folkestad, July 2017\n\n   Construct\n\n      s_ai_bj = - 1/ε_ij&#94;ab * g_aibj,\n\n   while batching over b.","tags":"","loc":"interface/get_s2am_mlcc2.html","title":"get_s2am_mlcc2 – The eT program"},{"text":"interface public module subroutine excited_state_preparations_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description Excited State Preparations (MLCC2)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Oct 2017\n\n   A routine for preparation tasks (if any). Can be overwritten\n   in descendants if other preparations prove necessary.","tags":"","loc":"interface/excited_state_preparations_mlcc2.html","title":"excited_state_preparations_mlcc2 – The eT program"},{"text":"interface public module subroutine initialize_excited_states_mlcc2(wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf Description Initialize excited states\n   Written by Sarai D. Folkestad, June 2017\n\n   Calculates and sets n_s2am, and updates n_parameters\n   for excited state calculation","tags":"","loc":"interface/initialize_excited_states_mlcc2.html","title":"initialize_excited_states_mlcc2 – The eT program"},{"text":"interface public module subroutine calculate_orbital_differences_mlcc2(wf, orbital_diff) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: orbital_diff Description Calculate Orbital Differences (CCSD)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad May 2017\n\n   Calculates orbital differences\n\n      1) ε_I&#94;A = ε_A - ε_I\n      2) ε_ij&#94;ab = ε_a + ε_b - ε_i - ε_j (for active spaces only)\n\n   and puts them in orbital_diff, which is a vector of length n_parameters.","tags":"","loc":"interface/calculate_orbital_differences_mlcc2.html","title":"calculate_orbital_differences_mlcc2 – The eT program"},{"text":"interface public module subroutine transform_trial_vectors_mlcc2(wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial Description Transformation Trial Vectors (MLCC2)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n   Each trial vector in first_trial to last_trial is read from file and\n   transformed before the transformed vector is written to file.\n\n   Singles and doubles part of the transformed vectors are written to \n   the same record in file transformed_vec, record length is n_parameters long.","tags":"","loc":"interface/transform_trial_vectors_mlcc2.html","title":"transform_trial_vectors_mlcc2 – The eT program"},{"text":"interface public module subroutine cvs_residual_projection_mlcc2(wf, residual) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual Description Residual projection (MLCC2), \n   Written by Sarai D. Folkestad Aug. 2017","tags":"","loc":"interface/cvs_residual_projection_mlcc2.html","title":"cvs_residual_projection_mlcc2 – The eT program"},{"text":"interface public module subroutine print_excitation_vector_mlcc2(wf, vec, unit_id) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: vec integer(kind=i15) :: unit_id","tags":"","loc":"interface/print_excitation_vector_mlcc2.html","title":"print_excitation_vector_mlcc2 – The eT program"},{"text":"interface public module subroutine analyze_double_excitation_vector_mlcc2(wf, vec, n, sorted_short_vec, index_list) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_x2am, 1) :: vec integer(kind=i15) :: n real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 4) :: index_list","tags":"","loc":"interface/analyze_double_excitation_vector_mlcc2.html","title":"analyze_double_excitation_vector_mlcc2 – The eT program"},{"text":"interface public module subroutine summary_excited_state_info_mlcc2(wf, energies) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies","tags":"","loc":"interface/summary_excited_state_info_mlcc2.html","title":"summary_excited_state_info_mlcc2 – The eT program"},{"text":"interface public module subroutine jacobian_mlcc2_transformation_mlcc2(wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_x2am, 1) :: c_aibj Description Jacobian transformation (MLCC2)\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Directs the transformation by the CCSD Jacobi matrix,\n\n      A_mu,nu = < mu | exp(-T) [H, tau_nu] exp(T) | nu >,\n\n   where the basis employed for the brackets is biorthonormal. \n   The transformation is rho = A c, i.e.,\n\n      rho_mu = (A c)_mu = sum_ck A_mu,ck c_ck \n              + 1/2 sum_ckdl A_mu,ckdl c_ckdl (1 + delta_ck,dl).\n\n   On exit, c is overwritten by rho. That is, c_a_i = rho_a_i,\n   and c_aibj = rho_aibj.","tags":"","loc":"interface/jacobian_mlcc2_transformation_mlcc2.html","title":"jacobian_mlcc2_transformation_mlcc2 – The eT program"},{"text":"interface public module subroutine jacobian_mlcc2_a1_mlcc2(wf, rho_a_i, c_a_i) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian tem A1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Calculates the A1 contribution to the jacobi transformation,\n\n      A1: 2*sum_BJck u_ik&#94;ac*g_kc,JB*c_BJ - sum_Bjck u_kj&#94;ca*g_kc,jB*c_BI\n        - sum_BJck u_ik&#94;ac*g_kB,Jc*c_BJ - sum_bJck u_ki&#94;cb*g_kc,Jb*c_AJ,\n\n   with,\n\n   u_ik&#94;ac = 2*s_ik&#94;ac - 2*s_ik&#94;ca,\n\n   which is constructed while batching over c","tags":"","loc":"interface/jacobian_mlcc2_a1_mlcc2.html","title":"jacobian_mlcc2_a1_mlcc2 – The eT program"},{"text":"interface public module subroutine jacobian_mlcc2_b1_mlcc2(wf, rho_a_i, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(:,:) :: c_ai_bj Description Jacobian tem B1\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Calculates the B1 contribution to the jacobi transformation,\n\n   B1:   sum_ck F_kc*(2c_ai,ck - c_ak,ci) \n       - sum_ckj L_jIkc * c_aj,ck + sum_cbk L_Abkc * c_bi,ck\n\n\n   L_Abkc is constructed while batching over A.","tags":"","loc":"interface/jacobian_mlcc2_b1_mlcc2.html","title":"jacobian_mlcc2_b1_mlcc2 – The eT program"},{"text":"interface public module subroutine jacobian_mlcc2_a2_mlcc2(wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i Description Jacobian tem A2\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Calculates the A2 contribution to the jacobi transformation,\n\n      A2:   sum_C g_ai,bC * c_Cj - sum_K g_ai,Kj * C_bK.\n\n   g_ai,bC is constructed in batches of C.","tags":"","loc":"interface/jacobian_mlcc2_a2_mlcc2.html","title":"jacobian_mlcc2_a2_mlcc2 – The eT program"},{"text":"interface public module subroutine jacobian_mlcc2_b2_mlcc2(wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj Description Jacobian tem B2\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\n   Calculates the B2 contribution to the jacobi transformation,\n\n      B2:   ε_ij&#94;ab*c_ai,bj.","tags":"","loc":"interface/jacobian_mlcc2_b2_mlcc2.html","title":"jacobian_mlcc2_b2_mlcc2 – The eT program"},{"text":"interface public module subroutine cvs_rho_aibj_projection_mlcc2(wf, vec_aibj) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(:, :) :: vec_aibj Description Rho projection for CVS (MLCC2),\n   Written by Sarai D. Folkestad, Aug. 2017","tags":"","loc":"interface/cvs_rho_aibj_projection_mlcc2.html","title":"cvs_rho_aibj_projection_mlcc2 – The eT program"},{"text":"public subroutine init_ccsdpt(wf) Initialize CCSD(T) object\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nPerforms the following tasks:\n\n   1. Sets HF orbital and energy information by reading from file (read_hf_info)\n   2. Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky)\n   3. Allocates the Fock matrix and sets it to zero\n   4. Initializes the amplitudes (sets their initial values and associated variables)\n\nNote: this routine does not calculate the energy, which is postponed until the wavefunction\nis passed to the ground-state solver. Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf Calls proc~~init_ccsdpt~~CallsGraph proc~init_ccsdpt init_ccsdpt proc~generate_unit_identifier generate_unit_identifier proc~init_ccsdpt->proc~generate_unit_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/init_ccsdpt.html","title":"init_ccsdpt – The eT program"},{"text":"public subroutine calc_energy_correction_ccsdpt(wf) Calculate Energy Correction (CCSD(T))\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nCalculates the CCSD(T) correction to the CCSD energy:\n\n   E(CCSD(T)) = E(CCSD) + sum_ai u_ai v_ai + sum_aibj u_ai_bj v_ai_bj,\n\nwhere\n\n   v_ai    = sum_cdkl (t_ikl&#94;acd - t_lki&#94;acd) L_kcld \n   v_ai_bj = sum_cdk (t_ijk&#94;acd L_bckd - t_kji&#94;acd g_kdbc) -\n             sum_ckl (t_ikl&#94;abc L_kjlc - t_lki&#94;abc g_kjlc)\n\nand\n\n   u_ai    = 2 * t_i&#94;a \n   u_ai_bj = 4 t_ij&#94;ab - 2 t_ji&#94;ab.\n\nNote: the vector v is similar to the CC3 omega vector. The \nroutine therefore relies heavily on the omega routines of \nthe parent CC3 class.\n\nNote: as is the case for CC3 omega, this routine (in particular\nthe i >= j >= k saving) is not optimized. Both CC3 and CCSD(T)\nshould be optimized simultaneously. Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf Calls proc~~calc_energy_correction_ccsdpt~~CallsGraph proc~calc_energy_correction_ccsdpt calc_energy_correction_ccsdpt daxpy daxpy proc~calc_energy_correction_ccsdpt->daxpy proc~index_packed index_packed proc~calc_energy_correction_ccsdpt->proc~index_packed dcopy dcopy proc~calc_energy_correction_ccsdpt->dcopy proc~index_two index_two proc~calc_energy_correction_ccsdpt->proc~index_two Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/calc_energy_correction_ccsdpt.html","title":"calc_energy_correction_ccsdpt – The eT program"},{"text":"interface public module subroutine construct_omega_ccsdpt(wf) Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf Description Construct Omega (CCSD(T))\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Directs the calculation of the projection vector (omega1, omega2)\n   for the CCSD(T) level of theory. This is simply the calculation of \n   the CCSD omega vector.","tags":"","loc":"interface/construct_omega_ccsdpt.html","title":"construct_omega_ccsdpt – The eT program"},{"text":"interface public module subroutine destruct_ground_state_ccsdpt(wf) Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf Description Destruct Ground State (CCSD(T))\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Calculates the CCSD(T) energy correction to the CCSD\n   energy, thereafter deallocating the amplitudes and the \n   projection vector.","tags":"","loc":"interface/destruct_ground_state_ccsdpt.html","title":"destruct_ground_state_ccsdpt – The eT program"},{"text":"Uses: types workspace input_output module~~input_reader~~UsesGraph module~input_reader input_reader module~workspace workspace module~workspace->module~input_reader module~types types module~types->module~input_reader module~types->module~workspace module~input_output input_output module~types->module~input_output module~input_output->module~input_reader module~input_output->module~workspace Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Input reader module                                 \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Used By module~~input_reader~~UsedByGraph module~input_reader input_reader module~input_reader~4 input_reader module~input_reader->module~input_reader~4 module~input_reader~3 input_reader module~input_reader->module~input_reader~3 module~mlccsd_class mlccsd_class module~input_reader->module~mlccsd_class module~input_reader~2 input_reader module~input_reader->module~input_reader~2 module~mlcc2_class mlcc2_class module~input_reader->module~mlcc2_class module~mlcc_orbitals_class mlcc_orbitals_class module~input_reader->module~mlcc_orbitals_class program~et_program eT_program module~input_reader->program~et_program module~mlccsd_class->module~input_reader~4 module~mlccsd_class->program~et_program module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~mlcc2_class->module~input_reader~3 module~mlcc2_class->module~mlccsd_class module~mlcc2_class->program~et_program module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~mlcc_orbitals_class->module~mlcc2_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions remove_preceding_blanks Subroutines method_reader Functions public function remove_preceding_blanks (line) Arguments Type Intent Optional Attributes Name character(len=40) :: line Return Value character(len=40) Subroutines public subroutine method_reader (unit_input, method) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: unit_input character(len=40) :: method","tags":"","loc":"module/input_reader.html","title":"input_reader – The eT program"},{"text":"Uses: types input_output module~~workspace~~UsesGraph module~workspace workspace module~types types module~types->module~workspace module~input_output input_output module~types->module~input_output module~input_output->module~workspace Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Workspace module\nWritten by Henrik Koch, Rolf H. Myhre, Eirik Kjønstad and Sarai Folkestad, Jan 2017\n\nNB! THIS IS BEING PHASED OUT & HAS BEEN REPLACED BY THE MEMORY MANAGER OBJECT.\n    THE MANY CALLS TO \"GET_AVAILABLE\" MEANS THAT WE CANNOT REMOVE IT JUST YET.\n\nManages program memory usage and contains:\n\nwork_init:       Initializes the memory management variables.\n\nallocator:       Allocation of double precission array of two dimmensions (M,N). \n                 Updates memory management variables.\n\ndeallocator:     Deallocation of double precission array of two dimmensions (M,N).\n                 Updates memory management variables.\n\nallocator_int:   Allocation of integer array of two dimmensions (M,N). \n                 Updates memory management variables.\n\ndeallocator_int: Deallocation of integer array of two dimmensions (M,N)\n                 Updates memory management variables.\n\nget_available:   Returns available memory. Used By module~~workspace~~UsedByGraph module~workspace workspace module~cc2_class cc2_class module~workspace->module~cc2_class module~ccs_class ccs_class module~workspace->module~ccs_class module~cc3_class cc3_class module~workspace->module~cc3_class module~mlccsd_class mlccsd_class module~workspace->module~mlccsd_class module~mp2_class mp2_class module~workspace->module~mp2_class module~input_reader input_reader module~workspace->module~input_reader module~ccsd_class ccsd_class module~workspace->module~ccsd_class module~mlcc2_class mlcc2_class module~workspace->module~mlcc2_class module~ccsdpt_class ccsdpt_class module~workspace->module~ccsdpt_class proc~check_orthogonality check_orthogonality module~workspace->proc~check_orthogonality module~hf_class hf_class module~workspace->module~hf_class program~et_program eT_program module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~ccs_class->module~cc2_class module~ccs_class->module~ccsd_class module~ccs_class->module~mlcc2_class module~ccs_class->program~et_program module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~cc3_class->module~ccsdpt_class module~cc3_class->program~et_program module~omega~4 omega module~cc3_class->module~omega~4 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~mp2_class->program~et_program module~input_reader->module~mlccsd_class module~input_reader->module~mlcc2_class module~input_reader->program~et_program module~input_reader->module~input_reader~2 module~input_reader->module~input_reader~4 module~input_reader~3 input_reader module~input_reader->module~input_reader~3 module~mlcc_orbitals_class mlcc_orbitals_class module~input_reader->module~mlcc_orbitals_class module~ccsd_class->module~cc3_class module~ccsd_class->program~et_program module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~mlcc2_class->module~mlccsd_class module~mlcc2_class->program~et_program module~mlcc2_class->module~input_reader~3 module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 module~hf_class->module~ccs_class module~hf_class->module~mp2_class module~hf_class->program~et_program module~mlcc_orbitals_class->module~mlcc2_class var panmoduleworkspaceUsedByGraph = svgPanZoom('#moduleworkspaceUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables mem Functions get_available Subroutines work_init allocator deallocator allocator_int deallocator_int Variables Type Visibility Attributes Name Initial integer(kind=i15), public :: mem = 4000000000 Functions public function get_available () Arguments None Return Value integer Subroutines public subroutine work_init () Arguments None public subroutine allocator (elm, M, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N public subroutine deallocator (elm, M, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N public subroutine allocator_int (elm, M, N) Arguments Type Intent Optional Attributes Name integer, dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N public subroutine deallocator_int (elm, M, N) Arguments Type Intent Optional Attributes Name integer, dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N","tags":"","loc":"module/workspace.html","title":"workspace – The eT program"},{"text":"Uses: input_output types module~~utils~~UsesGraph module~utils utils module~input_output input_output module~input_output->module~utils module~types types module~types->module~utils module~types->module~input_output Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Utilities module \nWritten by Sarai D. Folkstad and Eirik F. Kjønstad, 28 Feb 2017\n\nContains:\n\nIndex functions:\n   index_packed: Calculates the packed index of symetric matrix\n   index_two:    Calculates the compound index of two indices\n   index_three   Calculates the compound index given by three indices\n\nMatrix utilities:\n   packin:      packs in symetric matrix\n   packed_size: Returns size of packed matrix\n   squeareup:   squares up symmetric matrix\n\nBatching subroutines:\n    num_batch:     Calculates the number of batches needed.\n    num_two_batch: Calculates the number of batches needed \n                   for to batching variables with equal number of batches. \n    batch_limits:  Returns batch start index and batch end index. Used By module~~utils~~UsedByGraph module~utils utils module~ccs_class ccs_class module~utils->module~ccs_class module~mp2_class mp2_class module~utils->module~mp2_class module~mlccsd_class mlccsd_class module~utils->module~mlccsd_class module~cc2_class cc2_class module~utils->module~cc2_class module~ccsd_class ccsd_class module~utils->module~ccsd_class module~mlcc2_class mlcc2_class module~utils->module~mlcc2_class module~ccsdpt_class ccsdpt_class module~utils->module~ccsdpt_class module~cc3_class cc3_class module~utils->module~cc3_class module~hf_class hf_class module~utils->module~hf_class module~ccs_class->module~cc2_class module~ccs_class->module~ccsd_class module~ccs_class->module~mlcc2_class program~et_program eT_program module~ccs_class->program~et_program module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~ccsd_class->module~cc3_class module~ccsd_class->program~et_program module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~mlcc2_class->module~mlccsd_class module~mlcc2_class->program~et_program module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 module~cc3_class->module~ccsdpt_class module~cc3_class->program~et_program module~omega~4 omega module~cc3_class->module~omega~4 module~hf_class->module~ccs_class module~hf_class->module~mp2_class module~hf_class->program~et_program var panmoduleutilsUsedByGraph = svgPanZoom('#moduleutilsUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions index_packed index_three index_two packed_size check_orthogonality Subroutines squareup squareup_to_compound packin num_batch num_two_batch batch_limits get_n_lowest Functions public function index_packed (i, j) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j Return Value integer(kind=i15) public function index_three (p, q, r, dim_p, dim_q) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: p integer(kind=i15), intent(in) :: q integer(kind=i15), intent(in) :: r integer(kind=i15), intent(in) :: dim_p integer(kind=i15), intent(in) :: dim_q Return Value integer(kind=i15) public function index_two (p, q, dim_p) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: p integer(kind=i15), intent(in) :: q integer(kind=i15), intent(in) :: dim_p Return Value integer(kind=i15) public function packed_size (N) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: N Return Value integer(kind=i15) public function check_orthogonality (A, M, N) Check orthogonality\n   Written by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017 Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(M,N) :: A integer(kind=i15) :: M integer(kind=i15) :: N Return Value logical Subroutines public subroutine squareup (packed, unpacked, N) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:,:) :: packed real(kind=dp), dimension(:,:) :: unpacked integer(kind=i15), intent(in) :: N public subroutine squareup_to_compound (packed, unpacked, N, M) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(N*(N+1)/2,M) :: packed real(kind=dp), dimension(N*N,M) :: unpacked integer(kind=i15), intent(in) :: N integer(kind=i15), intent(in) :: M public subroutine packin (packed, unpacked, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:) :: packed real(kind=dp), intent(in), dimension(:,:) :: unpacked integer(kind=i15), intent(in) :: N public subroutine num_batch (required, available, max_batch_length, n_batch, batch_dimension) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: required integer(kind=i15), intent(in) :: available integer(kind=i15) :: max_batch_length integer(kind=i15) :: n_batch integer(kind=i15), intent(in) :: batch_dimension public subroutine num_two_batch (required, available, max_batch_length, n_batch, batch_dimension) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: required integer(kind=i15), intent(in) :: available integer(kind=i15) :: max_batch_length integer(kind=i15) :: n_batch integer(kind=i15), intent(in) :: batch_dimension public subroutine batch_limits (first, last, batch_number, max_batch_length, batch_dimension) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: first integer(kind=i15) :: last integer(kind=i15), intent(in) :: batch_number integer(kind=i15), intent(in) :: max_batch_length integer(kind=i15), intent(in) :: batch_dimension public subroutine get_n_lowest (n, size, vec, sorted_short_vec, index_list) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: n integer(kind=i15) :: size real(kind=dp), dimension(size, 1) :: vec real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 1) :: index_list","tags":"","loc":"module/utils.html","title":"utils – The eT program"},{"text":"Types module\n  Written by Sarai D. Folkestad and Eirik F. Kjønstad, April 2017 Defines the real and integer types used throughout the module Used By module~~types~~UsedByGraph module~types types module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~hf_class hf_class module~types->module~hf_class module~mlccsd_class mlccsd_class module~types->module~mlccsd_class module~ccsd_class ccsd_class module~types->module~ccsd_class module~mlcc2_class mlcc2_class module~types->module~mlcc2_class module~input_output input_output module~types->module~input_output module~ccs_class ccs_class module~types->module~ccs_class module~mp2_class mp2_class module~types->module~mp2_class module~input_reader input_reader module~types->module~input_reader module~cc2_class cc2_class module~types->module~cc2_class module~utils utils module~types->module~utils module~cc3_class cc3_class module~types->module~cc3_class module~memory_manager_class memory_manager_class module~types->module~memory_manager_class module~ccsdpt_class ccsdpt_class module~types->module~ccsdpt_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~batching_index_class batching_index_class module~types->module~batching_index_class module~mlcc_calculation_settings_class mlcc_calculation_settings_class module~types->module~mlcc_calculation_settings_class module~workspace workspace module~types->module~workspace module~mlcc_orbitals_class mlcc_orbitals_class module~types->module~mlcc_orbitals_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~calc_tasks_class calc_tasks_class module~types->module~calc_tasks_class module~response_calc_specs_class->module~hf_class module~hf_class->module~ccs_class module~hf_class->module~mp2_class program~et_program eT_program module~hf_class->program~et_program module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~ccsd_class->module~cc3_class module~ccsd_class->program~et_program module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~mlcc2_class->module~mlccsd_class module~mlcc2_class->program~et_program module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~input_output->module~hf_class module~input_output->module~mlccsd_class module~input_output->module~ccsd_class module~input_output->module~mlcc2_class module~input_output->module~ccs_class module~input_output->module~mp2_class module~input_output->module~input_reader module~input_output->module~cc2_class module~input_output->module~utils module~input_output->module~cc3_class module~input_output->module~memory_manager_class module~input_output->module~ccsdpt_class module~input_output->module~batching_index_class module~input_output->module~workspace module~input_output->program~et_program module~ccs_class->module~ccsd_class module~ccs_class->module~mlcc2_class module~ccs_class->module~cc2_class module~ccs_class->program~et_program module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~input_reader->module~mlccsd_class module~input_reader->module~mlcc2_class module~input_reader->module~mlcc_orbitals_class module~input_reader->program~et_program module~input_reader->module~input_reader~4 module~input_reader->module~input_reader~3 module~input_reader->module~input_reader~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~utils->module~hf_class module~utils->module~mlccsd_class module~utils->module~ccsd_class module~utils->module~mlcc2_class module~utils->module~ccs_class module~utils->module~mp2_class module~utils->module~cc2_class module~utils->module~cc3_class module~utils->module~ccsdpt_class module~cc3_class->module~ccsdpt_class module~cc3_class->program~et_program module~omega~4 omega module~cc3_class->module~omega~4 module~memory_manager_class->module~hf_class module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 module~excited_state_specs_class->module~hf_class module~batching_index_class->module~memory_manager_class module~batching_index_class->module~omega~3 module~mlcc_calculation_settings_class->module~mlcc2_class module~workspace->module~hf_class module~workspace->module~mlccsd_class module~workspace->module~ccsd_class module~workspace->module~mlcc2_class module~workspace->module~ccs_class module~workspace->module~mp2_class module~workspace->module~input_reader module~workspace->module~cc2_class module~workspace->module~cc3_class module~workspace->module~ccsdpt_class proc~check_orthogonality check_orthogonality module~workspace->proc~check_orthogonality module~mlcc_orbitals_class->module~mlcc2_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class var panmoduletypesUsedByGraph = svgPanZoom('#moduletypesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables sp dp qp i15 zero one two half three four five six Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = selected_real_kind(6, 37) integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: qp = selected_real_kind(33, 4931) integer, public, parameter :: i15 = selected_int_kind(15) real(kind=dp), public, parameter :: zero = 0.0D0 real(kind=dp), public, parameter :: one = 1.0D0 real(kind=dp), public, parameter :: two = 2.0D0 real(kind=dp), public, parameter :: half = 0.5D0 real(kind=dp), public, parameter :: three = 3.0D0 real(kind=dp), public, parameter :: four = 4.0D0 real(kind=dp), public, parameter :: five = 5.0D0 real(kind=dp), public, parameter :: six = 6.0D0","tags":"","loc":"module/types.html","title":"types – The eT program"},{"text":"Uses: types input_output batching_index_class module~~memory_manager_class~~UsesGraph module~memory_manager_class memory_manager_class module~types types module~types->module~memory_manager_class module~batching_index_class batching_index_class module~types->module~batching_index_class module~input_output input_output module~types->module~input_output module~batching_index_class->module~memory_manager_class module~input_output->module~memory_manager_class module~input_output->module~batching_index_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Memory manager class module                                 \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nThe memory manager class handles the memory used by the model calculation,\nand there is an object called 'mem' in the wavefunction object of this class.\n\nNote: large arrays must always be allocated using the memory manager object. Small arrays,\n      integers, strings, etc., which use a negligible amount of memory, are not considered \n      by the memory manager. Used By module~~memory_manager_class~~UsedByGraph module~memory_manager_class memory_manager_class module~hf_class hf_class module~memory_manager_class->module~hf_class program~et_program eT_program module~hf_class->program~et_program module~ccs_class ccs_class module~hf_class->module~ccs_class module~mp2_class mp2_class module~hf_class->module~mp2_class module~ccs_class->program~et_program module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 var panmodulememory_manager_classUsedByGraph = svgPanZoom('#modulememory_manager_classUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types memory_manager Subroutines init_memory_manager alloc_memory_manager dealloc_memory_manager alloc_int_memory_manager dealloc_int_memory_manager num_batch_memory_manager num_two_batch_memory_manager Derived Types type, public :: memory_manager Components Type Visibility Attributes Name Initial integer(kind=i15), public :: total = 30000000000 integer(kind=i15), public :: available = 30000000000 integer(kind=i15), public :: buffer = 10 Type-Bound Procedures procedure, public :: init => init_memory_manager procedure, public :: alloc => alloc_memory_manager procedure, public :: dealloc => dealloc_memory_manager procedure, public :: alloc_int => alloc_int_memory_manager procedure, public :: dealloc_int => dealloc_int_memory_manager procedure, public :: num_batch => num_batch_memory_manager procedure, public :: num_two_batch => num_two_batch_memory_manager Subroutines public subroutine init_memory_manager (mem, total) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem integer(kind=i15) :: total public subroutine alloc_memory_manager (mem, array, M, N) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem real(kind=dp), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N public subroutine dealloc_memory_manager (mem, array, M, N) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem real(kind=dp), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N public subroutine alloc_int_memory_manager (mem, array, M, N) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem integer(kind=i15), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N public subroutine dealloc_int_memory_manager (mem, array, M, N) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem integer(kind=i15), dimension(:,:), allocatable :: array integer(kind=i15), intent(in) :: M integer(kind=i15), intent(in) :: N public subroutine num_batch_memory_manager (mem, batch_p, required) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem class( batching_index ) :: batch_p integer(kind=i15) :: required public subroutine num_two_batch_memory_manager (mem, batch_p, batch_q, required) Arguments Type Intent Optional Attributes Name class( memory_manager ) :: mem class( batching_index ) :: batch_p class( batching_index ) :: batch_q integer(kind=i15) :: required","tags":"","loc":"module/memory_manager_class.html","title":"memory_manager_class – The eT program"},{"text":"Uses: types input_output module~~batching_index_class~~UsesGraph module~batching_index_class batching_index_class module~types types module~types->module~batching_index_class module~input_output input_output module~types->module~input_output module~input_output->module~batching_index_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Batching index class module                                 \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Dec 2017\n\nThe batching index class represents a single index (e.g. a in g_abcd)\nthat is being batched over. It contains information relevant to the \nrestriction of that index. Used By module~~batching_index_class~~UsedByGraph module~batching_index_class batching_index_class module~memory_manager_class memory_manager_class module~batching_index_class->module~memory_manager_class module~omega~3 omega module~batching_index_class->module~omega~3 module~hf_class hf_class module~memory_manager_class->module~hf_class program~et_program eT_program module~hf_class->program~et_program module~ccs_class ccs_class module~hf_class->module~ccs_class module~mp2_class mp2_class module~hf_class->module~mp2_class module~ccs_class->program~et_program module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->module~omega~3 module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 var panmodulebatching_index_classUsedByGraph = svgPanZoom('#modulebatching_index_classUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types batching_index Subroutines init_batching_index determine_limits_batching_index Derived Types type, public :: batching_index Components Type Visibility Attributes Name Initial integer(kind=i15), public :: first = 0 integer(kind=i15), public :: last = 0 integer(kind=i15), public :: length = 0 integer(kind=i15), public :: max_length = 0 integer(kind=i15), public :: num_batches = 0 integer(kind=i15), public :: index_dimension = 0 logical, public :: initialized = .false. Type-Bound Procedures procedure, public :: init => init_batching_index procedure, public :: determine_limits => determine_limits_batching_index Subroutines public subroutine init_batching_index (batch_p, dimension) Arguments Type Intent Optional Attributes Name class( batching_index ) :: batch_p integer(kind=i15), intent(in) :: dimension public subroutine determine_limits_batching_index (batch_p, batch_number) Arguments Type Intent Optional Attributes Name class( batching_index ) :: batch_p integer(kind=i15), intent(in) :: batch_number","tags":"","loc":"module/batching_index_class.html","title":"batching_index_class – The eT program"},{"text":"Uses: types module~~input_output~~UsesGraph module~input_output input_output module~types types module~types->module~input_output Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Input_output module\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, April 2017\n\nHandles input and output and contains:\n\ngenerate_unit_identifier: Returns a free unit_identifier which can be assigned to a file that is opened. \nvec_print:                Prints vector in compound index order. Used By module~~input_output~~UsedByGraph module~input_output input_output module~memory_manager_class memory_manager_class module~input_output->module~memory_manager_class module~cc2_class cc2_class module~input_output->module~cc2_class module~hf_class hf_class module~input_output->module~hf_class module~mp2_class mp2_class module~input_output->module~mp2_class program~et_program eT_program module~input_output->program~et_program module~batching_index_class batching_index_class module~input_output->module~batching_index_class module~mlccsd_class mlccsd_class module~input_output->module~mlccsd_class module~mlcc2_class mlcc2_class module~input_output->module~mlcc2_class module~input_reader input_reader module~input_output->module~input_reader module~ccsd_class ccsd_class module~input_output->module~ccsd_class module~utils utils module~input_output->module~utils module~workspace workspace module~input_output->module~workspace module~ccsdpt_class ccsdpt_class module~input_output->module~ccsdpt_class module~cc3_class cc3_class module~input_output->module~cc3_class module~ccs_class ccs_class module~input_output->module~ccs_class module~memory_manager_class->module~hf_class module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~hf_class->module~mp2_class module~hf_class->program~et_program module~hf_class->module~ccs_class module~mp2_class->program~et_program module~batching_index_class->module~memory_manager_class module~omega~3 omega module~batching_index_class->module~omega~3 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~mlcc2_class->program~et_program module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~input_reader->program~et_program module~input_reader->module~mlccsd_class module~input_reader->module~mlcc2_class module~input_reader->module~input_reader~4 module~input_reader->module~input_reader~3 module~input_reader~2 input_reader module~input_reader->module~input_reader~2 module~mlcc_orbitals_class mlcc_orbitals_class module~input_reader->module~mlcc_orbitals_class module~ccsd_class->program~et_program module~ccsd_class->module~cc3_class module~ccsd_class->module~omega~3 module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~utils->module~cc2_class module~utils->module~hf_class module~utils->module~mp2_class module~utils->module~mlccsd_class module~utils->module~mlcc2_class module~utils->module~ccsd_class module~utils->module~ccsdpt_class module~utils->module~cc3_class module~utils->module~ccs_class module~workspace->module~cc2_class module~workspace->module~hf_class module~workspace->module~mp2_class module~workspace->module~mlccsd_class module~workspace->module~mlcc2_class module~workspace->module~input_reader module~workspace->module~ccsd_class module~workspace->module~ccsdpt_class module~workspace->module~cc3_class module~workspace->module~ccs_class proc~check_orthogonality check_orthogonality module~workspace->proc~check_orthogonality module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 module~cc3_class->program~et_program module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccs_class->module~cc2_class module~ccs_class->program~et_program module~ccs_class->module~mlcc2_class module~ccs_class->module~ccsd_class module~ccs_class->module~input_reader~2 module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mlcc_orbitals_class->module~mlcc2_class var panmoduleinput_outputUsedByGraph = svgPanZoom('#moduleinput_outputUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables unit_output Subroutines generate_unit_identifier vec_print vec_print_nonzero_elm Variables Type Visibility Attributes Name Initial integer(kind=i15), public :: unit_output = 0 Subroutines public subroutine generate_unit_identifier (unit_identifier) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: unit_identifier public subroutine vec_print (vec, dim_1, dim_2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(dim_1, dim_2) :: vec integer(kind=i15), intent(in) :: dim_1 integer(kind=i15), intent(in) :: dim_2 public subroutine vec_print_nonzero_elm (vec, dim_1, dim_2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(dim_1, dim_2) :: vec integer(kind=i15), intent(in) :: dim_1 integer(kind=i15), intent(in) :: dim_2","tags":"","loc":"module/input_output.html","title":"input_output – The eT program"},{"text":"Uses: types module~~excited_state_specs_class~~UsesGraph module~excited_state_specs_class excited_state_specs_class module~types types module~types->module~excited_state_specs_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Excited State Specifictions class module                                 \n        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017\n\nThe class contains specifications for the excited state calculation, and necesary variables provided by user. Used By module~~excited_state_specs_class~~UsedByGraph module~excited_state_specs_class excited_state_specs_class module~hf_class hf_class module~excited_state_specs_class->module~hf_class program~et_program eT_program module~hf_class->program~et_program module~ccs_class ccs_class module~hf_class->module~ccs_class module~mp2_class mp2_class module~hf_class->module~mp2_class module~ccs_class->program~et_program module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 var panmoduleexcited_state_specs_classUsedByGraph = svgPanZoom('#moduleexcited_state_specs_classUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types excited_state_specs Derived Types type, public :: excited_state_specs Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy_threshold = 1.0D-06 real(kind=dp), public :: residual_threshold = 1.0D-06 integer(kind=i15), public :: max_iterations = 50 logical, public :: restart = .false. logical, public :: user_specified_start_vector = .false. integer(kind=i15), public, dimension(:,:), allocatable :: start_vectors integer(kind=i15), public :: n_singlet_states = 0 integer(kind=i15), public :: n_triplet_states = 0 logical, public :: right = .true. logical, public :: left = .false. character(len=40), public :: solution_file = 'right_valence'","tags":"","loc":"module/excited_state_specs_class.html","title":"excited_state_specs_class – The eT program"},{"text":"Uses: types module~~mlcc_calculation_settings_class~~UsesGraph module~mlcc_calculation_settings_class mlcc_calculation_settings_class module~types types module~types->module~mlcc_calculation_settings_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~mlcc_calculation_settings_class~~UsedByGraph module~mlcc_calculation_settings_class mlcc_calculation_settings_class module~mlcc2_class mlcc2_class module~mlcc_calculation_settings_class->module~mlcc2_class module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class program~et_program eT_program module~mlcc2_class->program~et_program module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types mlcc_calculation_settings Derived Types type, public :: mlcc_calculation_settings Components Type Visibility Attributes Name Initial logical, public :: CCS = .false. logical, public :: CC2 = .false. logical, public :: CCSD = .false. logical, public :: CC3 = .false.","tags":"","loc":"module/mlcc_calculation_settings_class.html","title":"mlcc_calculation_settings_class – The eT program"},{"text":"Uses: types input_reader module~~mlcc_orbitals_class~~UsesGraph module~mlcc_orbitals_class mlcc_orbitals_class module~input_reader input_reader module~input_reader->module~mlcc_orbitals_class module~types types module~types->module~mlcc_orbitals_class module~types->module~input_reader module~workspace workspace module~types->module~workspace module~input_output input_output module~types->module~input_output module~workspace->module~input_reader module~input_output->module~input_reader module~input_output->module~workspace Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Used By module~~mlcc_orbitals_class~~UsedByGraph module~mlcc_orbitals_class mlcc_orbitals_class module~mlcc2_class mlcc2_class module~mlcc_orbitals_class->module~mlcc2_class module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class program~et_program eT_program module~mlcc2_class->program~et_program module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types mlcc_orbitals Subroutines orbital_reader_mlcc_orb Derived Types type, public :: mlcc_orbitals Components Type Visibility Attributes Name Initial logical, public :: cholesky = .false. logical, public :: cnto = .true. real(kind=dp), public :: delta_o = 1.0D-06 real(kind=dp), public :: delta_v = 1.0D-06 integer(kind=i15), public :: n_active_atoms integer(kind=i15), public, dimension(:,:), allocatable :: active_atoms Type-Bound Procedures procedure, public :: orbital_reader => orbital_reader_mlcc_orb Subroutines public subroutine orbital_reader_mlcc_orb (orbital_info, unit_input) Arguments Type Intent Optional Attributes Name class( mlcc_orbitals ) :: orbital_info integer(kind=i15) :: unit_input","tags":"","loc":"module/mlcc_orbitals_class.html","title":"mlcc_orbitals_class – The eT program"},{"text":"Uses: types module~~ground_state_specs_class~~UsesGraph module~ground_state_specs_class ground_state_specs_class module~types types module~types->module~ground_state_specs_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Ground State Specifictions class module                                 \n        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017\n\nThe class contains specifications for the ground state calculation. Used By module~~ground_state_specs_class~~UsedByGraph module~ground_state_specs_class ground_state_specs_class module~hf_class hf_class module~ground_state_specs_class->module~hf_class program~et_program eT_program module~hf_class->program~et_program module~ccs_class ccs_class module~hf_class->module~ccs_class module~mp2_class mp2_class module~hf_class->module~mp2_class module~ccs_class->program~et_program module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 var panmoduleground_state_specs_classUsedByGraph = svgPanZoom('#moduleground_state_specs_classUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types ground_state_specs Derived Types type, public :: ground_state_specs Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy_threshold = 1.0D-06 real(kind=dp), public :: residual_threshold = 1.0D-06 integer(kind=i15), public :: max_iterations = 50 logical, public :: restart = .false.","tags":"","loc":"module/ground_state_specs_class.html","title":"ground_state_specs_class – The eT program"},{"text":"Uses: types module~~calc_settings_class~~UsesGraph module~calc_settings_class calc_settings_class module~types types module~types->module~calc_settings_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calculation settings class module                                 \n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Used By module~~calc_settings_class~~UsedByGraph module~calc_settings_class calc_settings_class module~hf_class hf_class module~calc_settings_class->module~hf_class program~et_program eT_program module~hf_class->program~et_program module~ccs_class ccs_class module~hf_class->module~ccs_class module~mp2_class mp2_class module~hf_class->module~mp2_class module~ccs_class->program~et_program module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 var panmodulecalc_settings_classUsedByGraph = svgPanZoom('#modulecalc_settings_classUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types calc_settings Derived Types type, public :: calc_settings Components Type Visibility Attributes Name Initial real(kind=dp), public :: disk_space = 100D0 character(len=40), public :: print_level = 'developer'","tags":"","loc":"module/calc_settings_class.html","title":"calc_settings_class – The eT program"},{"text":"Uses: types module~~calc_tasks_class~2~~UsesGraph module~calc_tasks_class~2 calc_tasks_class module~types types module~types->module~calc_tasks_class~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calculation tasks class module                                 \n        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017\n\nThe procedures class is used for two purposes. Wavefunctions possess \n\"implemented\" and \"tasks\" objects, which are both instances of the class \ncalculation procedures. If one of the tasks requested is not implemented\nfor the wavefunction in question, the program stops, letting the user know\nthat the requested functionality is not a part of eT (yet).\n\nTasks are determined during the read of the input (see the main program).\nImplemented are set by the wavefunction's initialization routine. Used By module~~calc_tasks_class~2~~UsedByGraph module~calc_tasks_class~2 calc_tasks_class module~hf_class hf_class module~calc_tasks_class~2->module~hf_class program~et_program eT_program module~hf_class->program~et_program module~ccs_class ccs_class module~hf_class->module~ccs_class module~mp2_class mp2_class module~hf_class->module~mp2_class module~ccs_class->program~et_program module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 var panmodulecalc_tasks_class2UsedByGraph = svgPanZoom('#modulecalc_tasks_class2UsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types calc_tasks Derived Types type, public :: calc_tasks Components Type Visibility Attributes Name Initial logical, public :: ground_state = .false. logical, public :: excited_state = .false. logical, public :: core_excited_state = .false. logical, public :: ionized_state = .false. logical, public :: core_ionized_state = .false. logical, public :: multipliers = .false. character(len=40), public :: current = 'ground_state'","tags":"","loc":"module/calc_tasks_class~2.html","title":"calc_tasks_class – The eT program"},{"text":"Uses: types module~~core_excited_state_specs_class~~UsesGraph module~core_excited_state_specs_class core_excited_state_specs_class module~types types module~types->module~core_excited_state_specs_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Core Excited State Specifictions class module                                 \n        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017\n\nThe class contains specifications for the core excited state calculation, and necesary variables provided by user. Used By module~~core_excited_state_specs_class~~UsedByGraph module~core_excited_state_specs_class core_excited_state_specs_class module~hf_class hf_class module~core_excited_state_specs_class->module~hf_class program~et_program eT_program module~hf_class->program~et_program module~ccs_class ccs_class module~hf_class->module~ccs_class module~mp2_class mp2_class module~hf_class->module~mp2_class module~ccs_class->program~et_program module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 var panmodulecore_excited_state_specs_classUsedByGraph = svgPanZoom('#modulecore_excited_state_specs_classUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types core_excited_state_specs Derived Types type, public :: core_excited_state_specs Components Type Visibility Attributes Name Initial integer(kind=i15), public :: n_equivalent_cores integer(kind=i15), public, dimension(:,:), allocatable :: cores integer(kind=i15), public, dimension(:,:), allocatable :: index_core_mo","tags":"","loc":"module/core_excited_state_specs_class.html","title":"core_excited_state_specs_class – The eT program"},{"text":"Uses: types module~~calc_tasks_class~~UsesGraph module~calc_tasks_class calc_tasks_class module~types types module~types->module~calc_tasks_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Calculation tasks class module                                 \n        Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nThe procedures class is used for two purposes. Wavefunctions possess \n\"implemented\" and \"tasks\" objects, which are both instances of the class \ncalculation procedures. If one of the tasks requested is not implemented\nfor the wavefunction in question, the program stops, letting the user know\nthat the requested functionality is not a part of eT (yet).\n\nTasks are determined during the read of the input (see the main program).\nImplemented are set by the wavefunction's initialization routine. Derived Types calc_tasks Derived Types type, public :: calc_tasks Components Type Visibility Attributes Name Initial logical, public :: ground_state = .false. logical, public :: excited_state = .false. logical, public :: core_excited_state = .false. logical, public :: ionized_state = .false. logical, public :: core_ionized_state = .false. logical, public :: properties = .false. character(len=40), public :: current = 'ground_state'","tags":"","loc":"module/calc_tasks_class.html","title":"calc_tasks_class – The eT program"},{"text":"Uses: types module~~response_calc_specs_class~~UsesGraph module~response_calc_specs_class response_calc_specs_class module~types types module~types->module~response_calc_specs_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Response Calculation Specifictions class module                                 \n        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Nov 2017\n\nThe class contains specifications for the excited state calculation, and necesary variables provided by user. Used By module~~response_calc_specs_class~~UsedByGraph module~response_calc_specs_class response_calc_specs_class module~hf_class hf_class module~response_calc_specs_class->module~hf_class program~et_program eT_program module~hf_class->program~et_program module~ccs_class ccs_class module~hf_class->module~ccs_class module~mp2_class mp2_class module~hf_class->module~mp2_class module~ccs_class->program~et_program module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 var panmoduleresponse_calc_specs_classUsedByGraph = svgPanZoom('#moduleresponse_calc_specs_classUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types response_calc_specs Derived Types type, public :: response_calc_specs Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy_threshold = 1.0D-06 real(kind=dp), public :: residual_threshold = 1.0D-06 integer(kind=i15), public :: max_iterations = 50 logical, public :: restart = .false.","tags":"","loc":"module/response_calc_specs_class.html","title":"response_calc_specs_class – The eT program"},{"text":"Uses: types utils workspace input_output calc_tasks_class calc_settings_class ground_state_specs_class excited_state_specs_class core_excited_state_specs_class response_calc_specs_class memory_manager_class module~~hf_class~~UsesGraph module~hf_class hf_class module~ground_state_specs_class ground_state_specs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class calc_settings_class module~calc_settings_class->module~hf_class module~response_calc_specs_class response_calc_specs_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class excited_state_specs_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2 calc_tasks_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class core_excited_state_specs_class module~core_excited_state_specs_class->module~hf_class module~workspace workspace module~workspace->module~hf_class module~utils utils module~utils->module~hf_class module~input_output input_output module~input_output->module~hf_class module~input_output->module~workspace module~input_output->module~utils module~memory_manager_class memory_manager_class module~input_output->module~memory_manager_class module~batching_index_class batching_index_class module~input_output->module~batching_index_class module~memory_manager_class->module~hf_class module~types types module~types->module~hf_class module~types->module~ground_state_specs_class module~types->module~calc_settings_class module~types->module~response_calc_specs_class module~types->module~excited_state_specs_class module~types->module~calc_tasks_class~2 module~types->module~core_excited_state_specs_class module~types->module~workspace module~types->module~utils module~types->module~input_output module~types->module~memory_manager_class module~types->module~batching_index_class module~batching_index_class->module~memory_manager_class var panmodulehf_classUsesGraph = svgPanZoom('#modulehf_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Hartree-Fock (HF) class module                                 \n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 Used By module~~hf_class~~UsedByGraph module~hf_class hf_class program~et_program eT_program module~hf_class->program~et_program module~ccs_class ccs_class module~hf_class->module~ccs_class module~mp2_class mp2_class module~hf_class->module~mp2_class module~ccs_class->program~et_program module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mp2_class->program~et_program module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 var panmodulehf_classUsedByGraph = svgPanZoom('#modulehf_classUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types hf Subroutines init_hf drv_hf read_hf_info_hf read_transform_cholesky_hf read_cholesky_ij_hf read_cholesky_ia_hf read_cholesky_ai_hf read_cholesky_ab_hf construct_ao_fock_hf construct_ao_fock_new_hf construct_density_matrices_hf construct_density_matrix_hf construct_density_matrix_v_hf Derived Types type, public :: hf Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem Type-Bound Procedures procedure, public :: init => init_hf procedure, public :: drv => drv_hf procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf Subroutines public subroutine init_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf public subroutine drv_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf public subroutine read_cholesky_ij_hf (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last public subroutine read_cholesky_ia_hf (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last public subroutine read_cholesky_ai_hf (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(:, :) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last public subroutine read_cholesky_ab_hf (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last public subroutine construct_ao_fock_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock public subroutine construct_ao_fock_new_hf (wf, ao_fock) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock public subroutine construct_density_matrices_hf (wf, density_o, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v public subroutine construct_density_matrix_hf (wf, density_o, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_o real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v public subroutine construct_density_matrix_v_hf (wf, density_v, C_matrix, n_o, n_v) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: density_v real(kind=dp), dimension(wf%n_ao, n_o + n_v) :: C_matrix integer(kind=i15) :: n_o integer(kind=i15) :: n_v","tags":"","loc":"module/hf_class.html","title":"hf_class – The eT program"},{"text":"Uses: types utils workspace input_output input_reader mlcc2_class module~~mlccsd_class~~UsesGraph module~mlccsd_class mlccsd_class module~types types module~types->module~mlccsd_class module~input_reader input_reader module~types->module~input_reader module~workspace workspace module~types->module~workspace module~utils utils module~types->module~utils module~mlcc2_class mlcc2_class module~types->module~mlcc2_class module~input_output input_output module~types->module~input_output module~ccs_class ccs_class module~types->module~ccs_class module~mlcc_orbitals_class mlcc_orbitals_class module~types->module~mlcc_orbitals_class module~mlcc_calculation_settings_class mlcc_calculation_settings_class module~types->module~mlcc_calculation_settings_class module~hf_class hf_class module~types->module~hf_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~memory_manager_class memory_manager_class module~types->module~memory_manager_class module~batching_index_class batching_index_class module~types->module~batching_index_class module~input_reader->module~mlccsd_class module~input_reader->module~mlcc2_class module~input_reader->module~mlcc_orbitals_class module~workspace->module~mlccsd_class module~workspace->module~input_reader module~workspace->module~mlcc2_class module~workspace->module~ccs_class module~workspace->module~hf_class module~utils->module~mlccsd_class module~utils->module~mlcc2_class module~utils->module~ccs_class module~utils->module~hf_class module~mlcc2_class->module~mlccsd_class module~input_output->module~mlccsd_class module~input_output->module~input_reader module~input_output->module~workspace module~input_output->module~utils module~input_output->module~mlcc2_class module~input_output->module~ccs_class module~input_output->module~hf_class module~input_output->module~memory_manager_class module~input_output->module~batching_index_class module~ccs_class->module~mlcc2_class module~mlcc_orbitals_class->module~mlcc2_class module~mlcc_calculation_settings_class->module~mlcc2_class module~hf_class->module~ccs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmodulemlccsd_classUsesGraph = svgPanZoom('#modulemlccsd_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Descendants: cholesky excited_state ground_state input_reader jacobian omega orbital_partitioning Multi-level CCSD (MLCCSD) class module                                \n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 Used By module~~mlccsd_class~~UsedByGraph module~mlccsd_class mlccsd_class program~et_program eT_program module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces mlcc_reader_mlccsd read_orbital_info_mlccsd orbital_partitioning_mlccsd cholesky_localization_drv_mlccsd cholesky_localization_CCSD_CC2_CCS_mlccsd cholesky_localization_CCSD_CCS_mlccsd cholesky_localization_CCSD_CC2_mlccsd construct_MO_transformation_matrix_mlccsd cnto_orbital_drv_mlccsd ccsd_cnto_lower_level_method_mlccsd ccsd_cnto_orbitals_mlccsd print_orbital_info_mlccsd read_transform_cholesky_for_CC2_amplitude_mlccsd read_cholesky_ai_for_cc2_amplitudes_mlccsd get_cholesky_ai_for_cc2_amplitudes_mlccsd read_cholesky_ab_for_cc2_amplitudes_mlccsd read_cholesky_ia_for_cc2_amplitudes_mlccsd read_cholesky_ij_for_cc2_amplitudes_mlccsd initialize_omega_mlccsd construct_omega_mlccsd get_mlccsd_x2am_mlccsd omega_mlccsd_a1_mlccsd omega_mlccsd_b1_mlccsd omega_mlccsd_a2_mlccsd omega_mlccsd_b2_mlccsd omega_mlccsd_c2_mlccsd omega_mlccsd_d2_mlccsd omega_mlccsd_e2_mlccsd calc_ampeqs_norm_mlccsd new_amplitudes_mlccsd calc_quasi_Newton_doubles_mlccsd initialize_ground_state_mlccsd jacobian_mlccsd_transformation_mlccsd jacobian_mlccsd_b2_mlccsd jacobian_mlccsd_c2_mlccsd jacobian_mlccsd_d2_mlccsd jacobian_mlccsd_e2_mlccsd jacobian_mlccsd_f2_mlccsd jacobian_mlccsd_g2_mlccsd jacobian_mlccsd_h2_mlccsd jacobian_mlccsd_i2_mlccsd jacobian_mlccsd_j2_mlccsd jacobian_mlccsd_k2_mlccsd transform_trial_vectors_mlccsd initialize_excited_states_mlccsd print_excitation_vector_mlccsd summary_excited_state_info_mlccsd Derived Types mlccsd Subroutines init_mlccsd initialize_amplitudes_mlccsd construct_perturbative_doubles_mlccsd get_CCSD_active_indices_mlccsd get_CC2_active_indices_mlccsd get_CC2_n_active_mlccsd get_CCSD_n_active_mlccsd calc_energy_mlccsd construct_orbital_coef_CC2_CCS_mlccsd destruct_orbital_coef_CC2_CCS_mlccsd construct_orbital_energy_CC2_CCS_mlccsd destruct_orbital_energy_CC2_CCS_mlccsd destruct_double_amplitudes_mlccsd destruct_amplitudes_mlccsd save_amplitudes_mlccsd read_amplitudes_mlccsd read_mlccsd_double_amplitudes_mlccsd read_double_amplitudes_mlccsd Interfaces interface public subroutine mlcc_reader_mlccsd (wf, unit_input) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: unit_input interface public module subroutine read_orbital_info_mlccsd (wf, unit_input) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: unit_input interface public module subroutine orbital_partitioning_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine cholesky_localization_drv_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine cholesky_localization_CCSD_CC2_CCS_mlccsd (wf, ao_center_info, n_ao_on_center, ao_fock, n_nuclei, unit_cholesky_decomp) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15), dimension(wf%n_ao, 2) :: ao_center_info integer(kind=i15), dimension(n_nuclei, 1) :: n_ao_on_center real(kind=dp), dimension(:,:) :: ao_fock integer(kind=i15) :: n_nuclei integer(kind=i15) :: unit_cholesky_decomp interface public module subroutine cholesky_localization_CCSD_CCS_mlccsd (wf, ao_center_info, n_ao_on_center, ao_fock, n_nuclei, unit_cholesky_decomp) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15), dimension(wf%n_ao, 2) :: ao_center_info integer(kind=i15), dimension(n_nuclei, 1) :: n_ao_on_center real(kind=dp), dimension(:,:) :: ao_fock integer(kind=i15) :: n_nuclei integer(kind=i15) :: unit_cholesky_decomp interface public module subroutine cholesky_localization_CCSD_CC2_mlccsd (wf, ao_center_info, n_ao_on_center, ao_fock, n_nuclei, unit_cholesky_decomp) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15), dimension(wf%n_ao, 2) :: ao_center_info integer(kind=i15), dimension(n_nuclei, 1) :: n_ao_on_center real(kind=dp), dimension(:,:) :: ao_fock integer(kind=i15) :: n_nuclei integer(kind=i15) :: unit_cholesky_decomp interface public module subroutine construct_MO_transformation_matrix_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine cnto_orbital_drv_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine ccsd_cnto_lower_level_method_mlccsd (wf, cc2_n_parameters, cc2_n_x2am, n_CC2_o, n_CC2_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: cc2_n_parameters integer(kind=i15) :: cc2_n_x2am integer(kind=i15) :: n_CC2_o integer(kind=i15) :: n_CC2_v interface public module subroutine ccsd_cnto_orbitals_mlccsd (wf, cc2_n_parameters, cc2_n_x2am, n_CC2_o, n_CC2_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: cc2_n_parameters integer(kind=i15) :: cc2_n_x2am integer(kind=i15) :: n_CC2_o integer(kind=i15) :: n_CC2_v interface public module subroutine print_orbital_info_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine read_transform_cholesky_for_CC2_amplitude_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine read_cholesky_ai_for_cc2_amplitudes_mlccsd (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: L_ai_J integer(kind=i15) :: a_first integer(kind=i15) :: a_last integer(kind=i15) :: i_first integer(kind=i15) :: i_last interface public module subroutine get_cholesky_ai_for_cc2_amplitudes_mlccsd (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: L_ai_J integer(kind=i15) :: a_first integer(kind=i15) :: a_last integer(kind=i15) :: i_first integer(kind=i15) :: i_last interface public module subroutine read_cholesky_ab_for_cc2_amplitudes_mlccsd (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(((a_last - a_first + 1)*(b_last - b_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last interface public module subroutine read_cholesky_ia_for_cc2_amplitudes_mlccsd (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15) :: i_first integer(kind=i15) :: i_last integer(kind=i15) :: a_first integer(kind=i15) :: a_last interface public module subroutine read_cholesky_ij_for_cc2_amplitudes_mlccsd (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15) :: i_first integer(kind=i15) :: i_last integer(kind=i15) :: j_first integer(kind=i15) :: j_last interface public module subroutine initialize_omega_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine construct_omega_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine get_mlccsd_x2am_mlccsd (wf, x_ia_jb) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_ia_jb interface public module subroutine omega_mlccsd_a1_mlccsd (wf, x_ib_jc) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_ib_jc interface public module subroutine omega_mlccsd_b1_mlccsd (wf, x_ja_kb) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_ja_kb interface public module subroutine omega_mlccsd_a2_mlccsd (wf, x_IC_JD) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_IC_JD interface public module subroutine omega_mlccsd_b2_mlccsd (wf, x_kc_ld) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_kc_ld interface public module subroutine omega_mlccsd_c2_mlccsd (wf, x_lc_kd) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_lc_kd interface public module subroutine omega_mlccsd_d2_mlccsd (wf, x_KC_LD) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_KC_LD interface public module subroutine omega_mlccsd_e2_mlccsd (wf, x_kc_ld) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: x_kc_ld interface public module subroutine calc_ampeqs_norm_mlccsd (wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp) :: ampeqs_norm interface public module subroutine new_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine calc_quasi_Newton_doubles_mlccsd (wf, dt) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: dt interface public module subroutine initialize_ground_state_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine jacobian_mlccsd_transformation_mlccsd (wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_x2am, 1) :: c_aibj interface public module subroutine jacobian_mlccsd_b2_mlccsd (wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:, :) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_mlccsd_c2_mlccsd (wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_mlccsd_d2_mlccsd (wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_mlccsd_e2_mlccsd (wf, rho_ai_bj, c_ai_ck) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_ck interface public module subroutine jacobian_mlccsd_f2_mlccsd (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj interface public module subroutine jacobian_mlccsd_g2_mlccsd (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj interface public module subroutine jacobian_mlccsd_h2_mlccsd (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj interface public module subroutine jacobian_mlccsd_i2_mlccsd (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj interface public module subroutine jacobian_mlccsd_j2_mlccsd (wf, rho_ab_ij, c_ab_ij) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ab_ij real(kind=dp), dimension(:,:) :: c_ab_ij interface public module subroutine jacobian_mlccsd_k2_mlccsd (wf, rho_ab_ij, c_ab_ij) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_ab_ij real(kind=dp), dimension(:,:) :: c_ab_ij interface public module subroutine transform_trial_vectors_mlccsd (wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial interface public module subroutine initialize_excited_states_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf interface public module subroutine print_excitation_vector_mlccsd (wf, vec, unit_id) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: vec integer(kind=i15) :: unit_id interface public module subroutine summary_excited_state_info_mlccsd (wf, energies) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies Derived Types type, public, extends( mlcc2 ) :: mlccsd Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab type( mlcc_calculation_settings ), public :: mlcc_settings integer(kind=i15), public :: n_CCS_o = 0 integer(kind=i15), public :: n_CCS_v = 0 integer(kind=i15), public :: first_CCS_o = 0 integer(kind=i15), public :: first_CCS_v = 0 integer(kind=i15), public :: n_CC2_o = 0 integer(kind=i15), public :: n_CC2_v = 0 integer(kind=i15), public :: first_CC2_o = 0 integer(kind=i15), public :: first_CC2_v = 0 type( mlcc_orbitals ), public :: CC2_orbitals integer(kind=i15), public :: n_x2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: x2am integer(kind=i15), public :: n_CCSD_o = 0 integer(kind=i15), public :: n_CCSD_v = 0 integer(kind=i15), public :: first_CCSD_o = 0 integer(kind=i15), public :: first_CCSD_v = 0 type(mlcc_orbitals), public :: CCSD_orbitals real(kind=dp), public, dimension(:,:), allocatable :: mo_coef_cc2_ccs real(kind=dp), public, dimension(:,:), allocatable :: T_o real(kind=dp), public, dimension(:,:), allocatable :: T_v real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal_cc2_ccs integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf procedure, public :: drv => drv_ccs procedure, public :: ground_state_driver => ground_state_driver_ccs procedure, public :: ground_state_solver => ground_state_solver_ccs procedure, public :: ground_state_preparations => ground_state_preparations_ccs procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs procedure, public :: destruct_ground_state => destruct_ground_state_ccs procedure, public, non_overridable :: diis => diis_ccs procedure, public :: calc_ampeqs => calc_ampeqs_ccs procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs procedure, public :: excited_state_driver => excited_state_driver_ccs procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs procedure, public :: precondition_residual => precondition_residual_ccs procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs procedure, public :: print_excited_state_info => print_excited_state_info_ccs procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs procedure, public :: precondition_residual_core => precondition_residual_core_ccs procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs procedure, public :: response_driver => response_driver_ccs procedure, public :: response_solver => response_solver_ccs procedure, public :: response_preparations => response_preparations_ccs procedure, public :: initialize_response => initialize_response_ccs procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs procedure, public :: general_specs_reader => general_specs_reader_ccs procedure, public :: calculation_reader => calculation_reader_ccs procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs procedure, public :: read_property_specs => read_property_specs_ccs procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs procedure, public :: get_oo_oo => get_oo_oo_ccs procedure, public :: get_oo_ov => get_oo_ov_ccs procedure, public :: get_ov_oo => get_ov_oo_ccs procedure, public :: get_oo_vo => get_oo_vo_ccs procedure, public :: get_vo_oo => get_vo_oo_ccs procedure, public :: get_oo_vv => get_oo_vv_ccs procedure, public :: get_vv_oo => get_vv_oo_ccs procedure, public :: get_ov_ov => get_ov_ov_ccs procedure, public :: get_vo_vo => get_vo_vo_ccs procedure, public :: get_ov_vo => get_ov_vo_ccs procedure, public :: get_vo_ov => get_vo_ov_ccs procedure, public :: get_ov_vv => get_ov_vv_ccs procedure, public :: get_vv_ov => get_vv_ov_ccs procedure, public :: get_vo_vv => get_vo_vv_ccs procedure, public :: get_vv_vo => get_vv_vo_ccs procedure, public :: get_vv_vv => get_vv_vv_ccs procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure, public, non_overridable :: construct_fock => construct_fock_ccs procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs procedure, public :: jacobi_test => jacobi_test_ccs procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs procedure, public :: ionized_state_driver => ionized_state_driver_ccs procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs procedure, public :: ionization_residual_projection => ionization_residual_projection_ccs procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs procedure, public :: construct_eta => construct_eta_ccs procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs procedure, public :: destruct_omega => destruct_omega_ccs procedure, public :: cholesky_decomposition => cholesky_decomposition_mlcc2 procedure, public :: cholesky_orbitals => cholesky_orbitals_mlcc2 procedure, public :: cholesky_orbital_constructor => cholesky_orbital_constructor_mlcc2 procedure, public :: cc2_cnto_lower_level_method => cc2_cnto_lower_level_method_mlcc2 procedure, public :: cc2_cnto_orbitals => cc2_cnto_orbitals_mlcc2 procedure, public :: read_cc2_double_amplitudes => read_cc2_double_amplitudes_mlcc2 procedure, public :: destruct_x2am => destruct_x2am_mlcc2 procedure, public :: omega_mlcc2_a1 => omega_mlcc2_a1_mlcc2 procedure, public :: omega_mlcc2_b1 => omega_mlcc2_b1_mlcc2 procedure, public :: get_s2am => get_s2am_mlcc2 procedure, public :: excited_state_preparations => excited_state_preparations_mlcc2 procedure, public :: calculate_orbital_differences => calculate_orbital_differences_mlcc2 procedure, public :: cvs_residual_projection => cvs_residual_projection_mlcc2 procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_mlcc2 procedure, public :: jacobian_mlcc2_transformation => jacobian_mlcc2_transformation_mlcc2 procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_mlcc2 procedure, public :: jacobian_mlcc2_a1 => jacobian_mlcc2_a1_mlcc2 procedure, public :: jacobian_mlcc2_b1 => jacobian_mlcc2_b1_mlcc2 procedure, public :: jacobian_mlcc2_a2 => jacobian_mlcc2_a2_mlcc2 procedure, public :: jacobian_mlcc2_b2 => jacobian_mlcc2_b2_mlcc2 procedure, public :: mlcc_reader => mlcc_reader_mlccsd procedure, public :: read_orbital_info => read_orbital_info_mlccsd procedure, public :: init => init_mlccsd procedure, public :: initialize_amplitudes => initialize_amplitudes_mlccsd procedure, public :: initialize_omega => initialize_omega_mlccsd procedure, public :: calc_energy => calc_energy_mlccsd procedure, public :: orbital_partitioning => orbital_partitioning_mlccsd procedure, public :: cholesky_localization_drv => cholesky_localization_drv_mlccsd procedure, public :: cholesky_localization_CCSD_CC2_CCS => cholesky_localization_CCSD_CC2_CCS_mlccsd procedure, public :: cholesky_localization_CCSD_CCS => cholesky_localization_CCSD_CCS_mlccsd procedure, public :: cholesky_localization_CCSD_CC2 => cholesky_localization_CCSD_CC2_mlccsd procedure, public :: construct_perturbative_doubles => construct_perturbative_doubles_mlccsd procedure, public :: construct_MO_transformation_matrix => construct_MO_transformation_matrix_mlccsd procedure, public :: cnto_orbital_drv => cnto_orbital_drv_mlccsd procedure, public :: ccsd_cnto_lower_level_method => ccsd_cnto_lower_level_method_mlccsd procedure, public :: ccsd_cnto_orbitals => ccsd_cnto_orbitals_mlccsd procedure, public :: print_orbital_info => print_orbital_info_mlccsd procedure, public :: read_transform_cholesky_for_CC2_amplitude => read_transform_cholesky_for_CC2_amplitude_mlccsd procedure, public :: read_cholesky_ai_for_cc2_amplitudes => read_cholesky_ai_for_cc2_amplitudes_mlccsd procedure, public :: read_cholesky_ia_for_cc2_amplitudes => read_cholesky_ia_for_cc2_amplitudes_mlccsd procedure, public :: read_cholesky_ij_for_cc2_amplitudes => read_cholesky_ij_for_cc2_amplitudes_mlccsd procedure, public :: read_cholesky_ab_for_cc2_amplitudes => read_cholesky_ab_for_cc2_amplitudes_mlccsd procedure, public :: get_cholesky_ai_for_cc2_amplitudes => get_cholesky_ai_for_cc2_amplitudes_mlccsd procedure, public :: get_CC2_active_indices => get_CC2_active_indices_mlccsd procedure, public :: get_CC2_n_active => get_CC2_n_active_mlccsd procedure, public :: get_CCSD_active_indices => get_CCSD_active_indices_mlccsd procedure, public :: get_CCSD_n_active => get_CCSD_n_active_mlccsd procedure, public :: construct_omega => construct_omega_mlccsd procedure, public :: omega_mlccsd_a1 => omega_mlccsd_a1_mlccsd procedure, public :: omega_mlccsd_b1 => omega_mlccsd_b1_mlccsd procedure, public :: get_mlccsd_x2am => get_mlccsd_x2am_mlccsd procedure, public :: omega_mlccsd_a2 => omega_mlccsd_a2_mlccsd procedure, public :: omega_mlccsd_b2 => omega_mlccsd_b2_mlccsd procedure, public :: omega_mlccsd_c2 => omega_mlccsd_c2_mlccsd procedure, public :: omega_mlccsd_d2 => omega_mlccsd_d2_mlccsd procedure, public :: omega_mlccsd_e2 => omega_mlccsd_e2_mlccsd procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_mlccsd procedure, public :: new_amplitudes => new_amplitudes_mlccsd procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_mlccsd procedure, public :: initialize_ground_state => initialize_ground_state_mlccsd procedure, public :: construct_orbital_coef_CC2_CCS => construct_orbital_coef_CC2_CCS_mlccsd procedure, public :: construct_orbital_energy_CC2_CCS => construct_orbital_energy_CC2_CCS_mlccsd procedure, public :: destruct_orbital_coef_CC2_CCS => destruct_orbital_coef_CC2_CCS_mlccsd procedure, public :: destruct_orbital_energy_CC2_CCS => destruct_orbital_energy_CC2_CCS_mlccsd procedure, public :: destruct_amplitudes => destruct_amplitudes_mlccsd procedure, public :: destruct_double_amplitudes => destruct_double_amplitudes_mlccsd procedure, public :: save_amplitudes => save_amplitudes_mlccsd procedure, public :: read_amplitudes => read_amplitudes_mlccsd procedure, public :: read_mlccsd_double_amplitudes => read_mlccsd_double_amplitudes_mlccsd procedure, public :: read_double_amplitudes => read_double_amplitudes_mlccsd procedure, public :: jacobian_mlccsd_transformation => jacobian_mlccsd_transformation_mlccsd procedure, public :: jacobian_mlccsd_b2 => jacobian_mlccsd_b2_mlccsd procedure, public :: jacobian_mlccsd_c2 => jacobian_mlccsd_c2_mlccsd procedure, public :: jacobian_mlccsd_d2 => jacobian_mlccsd_d2_mlccsd procedure, public :: jacobian_mlccsd_e2 => jacobian_mlccsd_e2_mlccsd procedure, public :: jacobian_mlccsd_f2 => jacobian_mlccsd_f2_mlccsd procedure, public :: jacobian_mlccsd_g2 => jacobian_mlccsd_g2_mlccsd procedure, public :: jacobian_mlccsd_h2 => jacobian_mlccsd_h2_mlccsd procedure, public :: jacobian_mlccsd_i2 => jacobian_mlccsd_i2_mlccsd procedure, public :: jacobian_mlccsd_j2 => jacobian_mlccsd_j2_mlccsd procedure, public :: jacobian_mlccsd_k2 => jacobian_mlccsd_k2_mlccsd procedure, public :: transform_trial_vectors => transform_trial_vectors_mlccsd procedure, public :: initialize_excited_states => initialize_excited_states_mlccsd procedure, public :: print_excitation_vector => print_excitation_vector_mlccsd procedure, public :: summary_excited_state_info => summary_excited_state_info_mlccsd Subroutines public subroutine init_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine initialize_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine construct_perturbative_doubles_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine get_CCSD_active_indices_mlccsd (wf, first_o, first_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: first_o integer(kind=i15) :: first_v public subroutine get_CC2_active_indices_mlccsd (wf, first_o, first_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: first_o integer(kind=i15) :: first_v public subroutine get_CC2_n_active_mlccsd (wf, n_active_o, n_active_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: n_active_o integer(kind=i15) :: n_active_v public subroutine get_CCSD_n_active_mlccsd (wf, n_active_o, n_active_v) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf integer(kind=i15) :: n_active_o integer(kind=i15) :: n_active_v public subroutine calc_energy_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine construct_orbital_coef_CC2_CCS_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine destruct_orbital_coef_CC2_CCS_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine construct_orbital_energy_CC2_CCS_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine destruct_orbital_energy_CC2_CCS_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine destruct_double_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine destruct_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine save_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine read_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine read_mlccsd_double_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf public subroutine read_double_amplitudes_mlccsd (wf) Arguments Type Intent Optional Attributes Name class( mlccsd ) :: wf","tags":"","loc":"module/mlccsd_class.html","title":"mlccsd_class – The eT program"},{"text":"Uses: types utils workspace input_output ccs_class module~~ccsd_class~~UsesGraph module~ccsd_class ccsd_class module~utils utils module~utils->module~ccsd_class module~ccs_class ccs_class module~utils->module~ccs_class module~hf_class hf_class module~utils->module~hf_class module~ccs_class->module~ccsd_class module~input_output input_output module~input_output->module~ccsd_class module~input_output->module~utils module~input_output->module~ccs_class module~workspace workspace module~input_output->module~workspace module~input_output->module~hf_class module~memory_manager_class memory_manager_class module~input_output->module~memory_manager_class module~batching_index_class batching_index_class module~input_output->module~batching_index_class module~types types module~types->module~ccsd_class module~types->module~utils module~types->module~ccs_class module~types->module~input_output module~types->module~workspace module~types->module~hf_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~types->module~memory_manager_class module~types->module~batching_index_class module~workspace->module~ccsd_class module~workspace->module~ccs_class module~workspace->module~hf_class module~hf_class->module~ccs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmoduleccsd_classUsesGraph = svgPanZoom('#moduleccsd_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Descendants: cvs excited_state ground_state ionized_state jacobian_transpose jacobian omega Coupled cluster singles and doubles (CCSD) class module                                 \n          Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n\n\nThis module contains the definition of the coupled cluster singles\nand doubles (CCSD) wavefunction class. It is structured into four sections:\n\n   1. Modules used by the class:\n\n         Basic utilities and the ancestor class (CCS)\n\n   2. Definition of the class:\n\n         Non-inherited variables, followed by non-inherited or overridden procedures\n\n   3. Interfaces to submodules:\n\n         The procedures in the class are grouped according to functionality, with\n         detailed definitions given in the following class submodules:\n\n            - Ground state\n            - Omega \n            - Excited state \n            - Jacobian (right transformation)\n            - Jacobian Transpose (left transformation)\n            - Ionized State\n            - CVS\n\n         The interfaces shows incoming variables and their type, but contains \n         no information of the procedure itself. The procedure is shown in full \n         in the corresponding submodule.\n\n   4. Class module routines (i.e., non-submodule procedures). These include\n      the initialization and driver routines of the class, along with procedures that\n      are not (yet, at least) easily gathered in a submodule. Used By module~~ccsd_class~~UsedByGraph module~ccsd_class ccsd_class module~cc3_class cc3_class module~ccsd_class->module~cc3_class program~et_program eT_program module~ccsd_class->program~et_program module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces calc_ampeqs_norm_ccsd new_amplitudes_ccsd calc_quasi_Newton_doubles_ccsd initialize_ground_state_ccsd ground_state_preparations_ccsd initialize_omega_ccsd construct_omega_ccsd omega_ccsd_a1_ccsd omega_ccsd_b1_ccsd omega_ccsd_c1_ccsd omega_ccsd_a2_ccsd omega_ccsd_b2_ccsd omega_ccsd_c2_ccsd omega_ccsd_d2_ccsd omega_ccsd_e2_ccsd calculate_orbital_differences_ccsd transform_trial_vectors_ccsd print_excitation_vector_ccsd cvs_residual_projection_ccsd excited_state_preparations_ccsd analyze_double_excitation_vector_ccsd summary_excited_state_info_ccsd ionization_residual_projection_ccsd ionization_rho_aibj_projection_ccsd ionization_jacobian_ccsd_transformation_ccsd core_ionization_jacobian_ccsd_transformation_ccsd jacobian_ccsd_transformation_ccsd cvs_jacobian_ccsd_transformation_ccsd jacobian_ccsd_a1_ccsd jacobian_ccsd_b1_ccsd jacobian_ccsd_c1_ccsd jacobian_ccsd_d1_ccsd jacobian_ccsd_a2_ccsd jacobian_ccsd_b2_ccsd jacobian_ccsd_c2_ccsd jacobian_ccsd_d2_ccsd jacobian_ccsd_e2_ccsd jacobian_ccsd_f2_ccsd jacobian_ccsd_g2_ccsd jacobian_ccsd_h2_ccsd jacobian_ccsd_i2_ccsd jacobian_ccsd_j2_ccsd jacobian_ccsd_k2_ccsd jacobian_transpose_ccsd_transformation_ccsd jacobian_transpose_ccsd_a1_ccsd jacobian_transpose_ccsd_b1_ccsd jacobian_transpose_ccsd_c1_ccsd jacobian_transpose_ccsd_d1_ccsd jacobian_transpose_ccsd_e1_ccsd jacobian_transpose_ccsd_f1_ccsd jacobian_transpose_ccsd_g1_ccsd jacobian_transpose_ccsd_a2_ccsd jacobian_transpose_ccsd_b2_ccsd jacobian_transpose_ccsd_c2_ccsd jacobian_transpose_ccsd_d2_ccsd jacobian_transpose_ccsd_e2_ccsd jacobian_transpose_ccsd_f2_ccsd jacobian_transpose_ccsd_g2_ccsd jacobian_transpose_ccsd_h2_ccsd jacobian_transpose_ccsd_i2_ccsd cvs_rho_aibj_projection_ccsd Derived Types ccsd Subroutines init_ccsd initialize_amplitudes_ccsd construct_perturbative_doubles_ccsd calc_energy_ccsd destruct_amplitudes_ccsd destruct_omega_ccsd save_amplitudes_ccsd read_amplitudes_ccsd read_double_amplitudes_ccsd jacobi_test_ccsd construct_eta_ccsd Interfaces interface public module subroutine calc_ampeqs_norm_ccsd (wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp) :: ampeqs_norm interface public module subroutine new_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine calc_quasi_Newton_doubles_ccsd (wf, dt) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: dt interface public module subroutine initialize_ground_state_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine ground_state_preparations_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine initialize_omega_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine construct_omega_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_ccsd_a1_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_ccsd_b1_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_ccsd_c1_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_ccsd_a2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_ccsd_b2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_ccsd_c2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_ccsd_d2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_ccsd_e2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine calculate_orbital_differences_ccsd (wf, orbital_diff) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: orbital_diff interface public module subroutine transform_trial_vectors_ccsd (wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial interface public module subroutine print_excitation_vector_ccsd (wf, vec, unit_id) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: vec integer(kind=i15) :: unit_id interface public module subroutine cvs_residual_projection_ccsd (wf, residual) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual interface public module subroutine excited_state_preparations_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine analyze_double_excitation_vector_ccsd (wf, vec, n, sorted_short_vec, index_list) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_t2am, 1) :: vec integer(kind=i15) :: n real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 4) :: index_list interface public module subroutine summary_excited_state_info_ccsd (wf, energies) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies interface public module subroutine ionization_residual_projection_ccsd (wf, residual) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual interface public module subroutine ionization_rho_aibj_projection_ccsd (wf, rho_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(:,:) :: rho_aibj interface public subroutine ionization_jacobian_ccsd_transformation_ccsd (wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: c_aibj interface public subroutine core_ionization_jacobian_ccsd_transformation_ccsd (wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: c_aibj interface public module subroutine jacobian_ccsd_transformation_ccsd (wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: c_aibj interface public subroutine cvs_jacobian_ccsd_transformation_ccsd (wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: c_aibj interface public module subroutine jacobian_ccsd_a1_ccsd (wf, rho_a_i, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_ccsd_b1_ccsd (wf, rho_a_i, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj interface public module subroutine jacobian_ccsd_c1_ccsd (wf, rho_a_i, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj interface public module subroutine jacobian_ccsd_d1_ccsd (wf, rho_a_i, c_bi_cj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_bi_cj interface public module subroutine jacobian_ccsd_a2_ccsd (wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_ccsd_b2_ccsd (wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_ccsd_c2_ccsd (wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_ccsd_d2_ccsd (wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_ccsd_e2_ccsd (wf, rho_ai_bj, c_ai_ck) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_ck interface public module subroutine jacobian_ccsd_f2_ccsd (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj interface public module subroutine jacobian_ccsd_g2_ccsd (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj interface public module subroutine jacobian_ccsd_h2_ccsd (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj interface public module subroutine jacobian_ccsd_i2_ccsd (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: rho_ai_bj real(kind=dp), dimension((wf%n_o)*(wf%n_v), (wf%n_o)*(wf%n_v)) :: c_ai_bj interface public module subroutine jacobian_ccsd_j2_ccsd (wf, rho_ab_ij, c_ab_ij) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: rho_ab_ij real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: c_ab_ij interface public module subroutine jacobian_ccsd_k2_ccsd (wf, rho_ab_ij, c_ab_ij) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: rho_ab_ij real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: c_ab_ij interface public module subroutine jacobian_transpose_ccsd_transformation_ccsd (wf, b_a_i, b_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i real(kind=dp), dimension(wf%n_t2am, 1) :: b_aibj interface public module subroutine jacobian_transpose_ccsd_a1_ccsd (wf, sigma_a_i, b_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i interface public module subroutine jacobian_transpose_ccsd_b1_ccsd (wf, sigma_a_i, b_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i interface public module subroutine jacobian_transpose_ccsd_c1_ccsd (wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_d1_ccsd (wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_e1_ccsd (wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_f1_ccsd (wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_g1_ccsd (wf, sigma_a_i, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_a2_ccsd (wf, sigma_ai_bj, b_a_i) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i interface public module subroutine jacobian_transpose_ccsd_b2_ccsd (wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_c2_ccsd (wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_d2_ccsd (wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_e2_ccsd (wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_f2_ccsd (wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_g2_ccsd (wf, sigma_ai_bj, b_ai_bj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: sigma_ai_bj real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: b_ai_bj interface public module subroutine jacobian_transpose_ccsd_h2_ccsd (wf, sigma_ab_ij, b_ab_ij) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: sigma_ab_ij real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: b_ab_ij interface public module subroutine jacobian_transpose_ccsd_i2_ccsd (wf, sigma_ab_ij, b_ab_ij) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: sigma_ab_ij real(kind=dp), dimension((wf%n_v)**2, (wf%n_o)**2) :: b_ab_ij interface public module subroutine cvs_rho_aibj_projection_ccsd (wf, vec_aibj) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(:, :) :: vec_aibj Derived Types type, public, extends( ccs ) :: ccsd Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf procedure, public :: drv => drv_ccs procedure, public :: ground_state_driver => ground_state_driver_ccs procedure, public :: ground_state_solver => ground_state_solver_ccs procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs procedure, public :: destruct_ground_state => destruct_ground_state_ccs procedure, public, non_overridable :: diis => diis_ccs procedure, public :: calc_ampeqs => calc_ampeqs_ccs procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs procedure, public :: excited_state_driver => excited_state_driver_ccs procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs procedure, public :: initialize_excited_states => initialize_excited_states_ccs procedure, public :: precondition_residual => precondition_residual_ccs procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs procedure, public :: print_excited_state_info => print_excited_state_info_ccs procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs procedure, public :: precondition_residual_core => precondition_residual_core_ccs procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs procedure, public :: response_driver => response_driver_ccs procedure, public :: response_solver => response_solver_ccs procedure, public :: response_preparations => response_preparations_ccs procedure, public :: initialize_response => initialize_response_ccs procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs procedure, public :: general_specs_reader => general_specs_reader_ccs procedure, public :: calculation_reader => calculation_reader_ccs procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs procedure, public :: read_property_specs => read_property_specs_ccs procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs procedure, public :: get_oo_oo => get_oo_oo_ccs procedure, public :: get_oo_ov => get_oo_ov_ccs procedure, public :: get_ov_oo => get_ov_oo_ccs procedure, public :: get_oo_vo => get_oo_vo_ccs procedure, public :: get_vo_oo => get_vo_oo_ccs procedure, public :: get_oo_vv => get_oo_vv_ccs procedure, public :: get_vv_oo => get_vv_oo_ccs procedure, public :: get_ov_ov => get_ov_ov_ccs procedure, public :: get_vo_vo => get_vo_vo_ccs procedure, public :: get_ov_vo => get_ov_vo_ccs procedure, public :: get_vo_ov => get_vo_ov_ccs procedure, public :: get_ov_vv => get_ov_vv_ccs procedure, public :: get_vv_ov => get_vv_ov_ccs procedure, public :: get_vo_vv => get_vo_vv_ccs procedure, public :: get_vv_vo => get_vv_vo_ccs procedure, public :: get_vv_vv => get_vv_vv_ccs procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure, public, non_overridable :: construct_fock => construct_fock_ccs procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs procedure, public :: ionized_state_driver => ionized_state_driver_ccs procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs procedure, public :: init => init_ccsd procedure, public :: initialize_amplitudes => initialize_amplitudes_ccsd procedure, public :: initialize_omega => initialize_omega_ccsd procedure, public :: initialize_ground_state => initialize_ground_state_ccsd procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd procedure, public :: new_amplitudes => new_amplitudes_ccsd procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd procedure, public :: ground_state_preparations => ground_state_preparations_ccsd procedure, public :: construct_omega => construct_omega_ccsd procedure, public :: omega_ccsd_a1 => omega_ccsd_a1_ccsd procedure, public :: omega_ccsd_b1 => omega_ccsd_b1_ccsd procedure, public :: omega_ccsd_c1 => omega_ccsd_c1_ccsd procedure, public :: omega_ccsd_a2 => omega_ccsd_a2_ccsd procedure, public :: omega_ccsd_b2 => omega_ccsd_b2_ccsd procedure, public :: omega_ccsd_c2 => omega_ccsd_c2_ccsd procedure, public :: omega_ccsd_d2 => omega_ccsd_d2_ccsd procedure, public :: omega_ccsd_e2 => omega_ccsd_e2_ccsd procedure, public :: calculate_orbital_differences => calculate_orbital_differences_ccsd procedure, public :: transform_trial_vectors => transform_trial_vectors_ccsd procedure, public :: print_excitation_vector => print_excitation_vector_ccsd procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_ccsd procedure, public :: summary_excited_state_info => summary_excited_state_info_ccsd procedure, public :: excited_state_preparations => excited_state_preparations_ccsd procedure, public :: jacobian_ccsd_transformation => jacobian_ccsd_transformation_ccsd procedure, public :: jacobian_ccsd_a1 => jacobian_ccsd_a1_ccsd procedure, public :: jacobian_ccsd_b1 => jacobian_ccsd_b1_ccsd procedure, public :: jacobian_ccsd_c1 => jacobian_ccsd_c1_ccsd procedure, public :: jacobian_ccsd_d1 => jacobian_ccsd_d1_ccsd procedure, public :: jacobian_ccsd_a2 => jacobian_ccsd_a2_ccsd procedure, public :: jacobian_ccsd_b2 => jacobian_ccsd_b2_ccsd procedure, public :: jacobian_ccsd_c2 => jacobian_ccsd_c2_ccsd procedure, public :: jacobian_ccsd_d2 => jacobian_ccsd_d2_ccsd procedure, public :: jacobian_ccsd_e2 => jacobian_ccsd_e2_ccsd procedure, public :: jacobian_ccsd_f2 => jacobian_ccsd_f2_ccsd procedure, public :: jacobian_ccsd_g2 => jacobian_ccsd_g2_ccsd procedure, public :: jacobian_ccsd_h2 => jacobian_ccsd_h2_ccsd procedure, public :: jacobian_ccsd_i2 => jacobian_ccsd_i2_ccsd procedure, public :: jacobian_ccsd_j2 => jacobian_ccsd_j2_ccsd procedure, public :: jacobian_ccsd_k2 => jacobian_ccsd_k2_ccsd procedure, public :: jacobi_test => jacobi_test_ccsd procedure, public :: jacobian_transpose_ccsd_transformation => jacobian_transpose_ccsd_transformation_ccsd procedure, public :: jacobian_transpose_ccsd_a1 => jacobian_transpose_ccsd_a1_ccsd procedure, public :: jacobian_transpose_ccsd_b1 => jacobian_transpose_ccsd_b1_ccsd procedure, public :: jacobian_transpose_ccsd_c1 => jacobian_transpose_ccsd_c1_ccsd procedure, public :: jacobian_transpose_ccsd_d1 => jacobian_transpose_ccsd_d1_ccsd procedure, public :: jacobian_transpose_ccsd_e1 => jacobian_transpose_ccsd_e1_ccsd procedure, public :: jacobian_transpose_ccsd_f1 => jacobian_transpose_ccsd_f1_ccsd procedure, public :: jacobian_transpose_ccsd_g1 => jacobian_transpose_ccsd_g1_ccsd procedure, public :: jacobian_transpose_ccsd_a2 => jacobian_transpose_ccsd_a2_ccsd procedure, public :: jacobian_transpose_ccsd_b2 => jacobian_transpose_ccsd_b2_ccsd procedure, public :: jacobian_transpose_ccsd_c2 => jacobian_transpose_ccsd_c2_ccsd procedure, public :: jacobian_transpose_ccsd_d2 => jacobian_transpose_ccsd_d2_ccsd procedure, public :: jacobian_transpose_ccsd_e2 => jacobian_transpose_ccsd_e2_ccsd procedure, public :: jacobian_transpose_ccsd_f2 => jacobian_transpose_ccsd_f2_ccsd procedure, public :: jacobian_transpose_ccsd_g2 => jacobian_transpose_ccsd_g2_ccsd procedure, public :: jacobian_transpose_ccsd_h2 => jacobian_transpose_ccsd_h2_ccsd procedure, public :: jacobian_transpose_ccsd_i2 => jacobian_transpose_ccsd_i2_ccsd procedure, public :: ionization_residual_projection => ionization_residual_projection_ccsd procedure, public :: ionization_rho_aibj_projection => ionization_rho_aibj_projection_ccsd procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_ccsd procedure, public :: cvs_residual_projection => cvs_residual_projection_ccsd procedure, public :: construct_eta => construct_eta_ccsd procedure, public :: save_amplitudes => save_amplitudes_ccsd procedure, public :: read_amplitudes => read_amplitudes_ccsd procedure, public :: read_double_amplitudes => read_double_amplitudes_ccsd procedure, public :: destruct_amplitudes => destruct_amplitudes_ccsd procedure, public :: destruct_omega => destruct_omega_ccsd procedure, public :: construct_perturbative_doubles => construct_perturbative_doubles_ccsd procedure, public :: calc_energy => calc_energy_ccsd Subroutines public subroutine init_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine initialize_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine construct_perturbative_doubles_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine calc_energy_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine destruct_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine destruct_omega_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine save_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine read_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine read_double_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine jacobi_test_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine construct_eta_ccsd (wf, eta) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta","tags":"","loc":"module/ccsd_class.html","title":"ccsd_class – The eT program"},{"text":"Uses: types utils workspace input_output hf_class module~~ccs_class~~UsesGraph module~ccs_class ccs_class module~hf_class hf_class module~hf_class->module~ccs_class module~utils utils module~utils->module~ccs_class module~utils->module~hf_class module~input_output input_output module~input_output->module~ccs_class module~input_output->module~hf_class module~input_output->module~utils module~workspace workspace module~input_output->module~workspace module~memory_manager_class memory_manager_class module~input_output->module~memory_manager_class module~batching_index_class batching_index_class module~input_output->module~batching_index_class module~types types module~types->module~ccs_class module~types->module~hf_class module~types->module~utils module~types->module~input_output module~types->module~workspace module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~types->module~memory_manager_class module~types->module~batching_index_class module~workspace->module~ccs_class module~workspace->module~hf_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmoduleccs_classUsesGraph = svgPanZoom('#moduleccs_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Descendants: cholesky cvs excited_state fock ground_state input_reader integrals ionized_state jacobian jacobian_transpose response Coupled cluster singles (CCS) class module                                 \n            Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n\n\nThis module contains the definition of the coupled cluster singles (CCS)\nwavefunction class. It is structured into four sections:\n\n   1. Modules used by the class:\n\n         Basic utilities and the ancestor class (HF)\n\n   2. Definition of the class:\n\n         Non-inherited variables, followed by non-inherited or overridden procedures\n\n   3. Interfaces to submodules:\n\n         The procedures in the class are grouped according to functionality, with\n         detailed definitions given in the following class submodules:\n\n            - Ground state\n            - Excited state \n            - Response \n            - Input Reader \n            - Cholesky\n            - Integrals \n            - Fock \n            - Jacobian (right transformation)\n            - Jacobian Transpose (left transformation)\n            - Ionized State\n            - CVS\n\n         The interfaces shows incoming variables and their type, but contains \n         no information of the procedure itself. The procedure is shown in full \n         in the corresponding submodule.\n\n   4. Class module routines (i.e., non-submodule procedures). These include\n      the initialization and driver routines of the class, along with procedures that\n      are not (yet, at least) easily gathered in a submodule. Used By module~~ccs_class~~UsedByGraph module~ccs_class ccs_class module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class program~et_program eT_program module~ccs_class->program~et_program module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~cc2_class cc2_class module~ccs_class->module~cc2_class module~jacobian_transpose jacobian_transpose module~ccs_class->module~jacobian_transpose module~response response module~ccs_class->module~response module~fock fock module~ccs_class->module~fock module~ground_state ground_state module~ccs_class->module~ground_state module~input_reader~2 input_reader module~ccs_class->module~input_reader~2 module~jacobian jacobian module~ccs_class->module~jacobian module~cvs cvs module~ccs_class->module~cvs module~cholesky cholesky module~ccs_class->module~cholesky module~integrals integrals module~ccs_class->module~integrals module~excited_state excited_state module~ccs_class->module~excited_state module~ionized_state ionized_state module~ccs_class->module~ionized_state module~mlcc2_class->program~et_program module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~ccsd_class->program~et_program module~cc3_class cc3_class module~ccsd_class->module~cc3_class module~jacobian_transpose~2 jacobian_transpose module~ccsd_class->module~jacobian_transpose~2 module~cvs~2 cvs module~ccsd_class->module~cvs~2 module~omega~3 omega module~ccsd_class->module~omega~3 module~jacobian~3 jacobian module~ccsd_class->module~jacobian~3 module~ground_state~2 ground_state module~ccsd_class->module~ground_state~2 module~excited_state~2 excited_state module~ccsd_class->module~excited_state~2 module~ionized_state~2 ionized_state module~ccsd_class->module~ionized_state~2 module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces ground_state_driver_ccs ground_state_preparations_ccs ground_state_cleanup_ccs ground_state_solver_ccs calc_ampeqs_ccs calc_ampeqs_norm_ccs new_amplitudes_ccs calc_quasi_Newton_singles_ccs diis_ccs initialize_ground_state_ccs destruct_ground_state_ccs initialize_trial_vectors_ccs find_start_trial_indices_ccs transform_trial_vectors_ccs excited_state_driver_ccs excited_state_preparations_ccs excited_state_cleanup_ccs excited_state_solver_ccs solve_reduced_eigenvalue_equation_ccs construct_next_trial_vectors_ccs initialize_trial_vectors_valence_ccs initialize_trial_vectors_core_ccs trial_vectors_from_stored_solutions_ccs find_start_trial_indices_core_ccs find_core_mo_ccs calculate_orbital_differences_ccs initialize_excited_states_ccs precondition_residual_ccs precondition_residual_valence_ccs precondition_residual_core_ccs print_excited_state_info_ccs print_excitation_vector_ccs analyze_single_excitation_vector_ccs summary_excited_state_info_ccs response_driver_ccs response_solver_ccs response_preparations_ccs initialize_response_ccs solve_reduced_response_equation_ccs construct_reduced_matrix_ccs construct_reduced_gradient_ccs construct_gradient_vector_ccs construct_next_response_trial_vectors_ccs general_specs_reader_ccs calculation_reader_ccs read_ground_state_specs_ccs read_excited_state_specs_ccs read_property_specs_ccs get_cholesky_ij_ccs get_cholesky_ia_ccs get_cholesky_ai_ccs get_cholesky_ab_ccs store_vv_vv_electronic_repulsion_ccs store_t1_vv_vv_electronic_repulsion_ccs store_t1_vo_ov_electronic_repulsion_ccs store_t1_vv_ov_electronic_repulsion_ccs store_t1_vv_vo_electronic_repulsion_ccs read_vv_vv_electronic_repulsion_ccs read_t1_vv_vv_electronic_repulsion_ccs read_t1_vo_ov_electronic_repulsion_ccs read_t1_vv_vo_electronic_repulsion_ccs read_t1_vv_ov_electronic_repulsion_ccs get_oo_oo_ccs get_oo_ov_ccs get_ov_oo_ccs get_oo_vo_ccs get_vo_oo_ccs get_oo_vv_ccs get_vv_oo_ccs get_ov_ov_ccs get_vo_vo_ccs get_ov_vo_ccs get_vo_ov_ccs get_ov_vv_ccs get_vv_ov_ccs get_vo_vv_ccs get_vv_vo_ccs get_vv_vv_ccs get_oo_oo_electronic_repulsion_ccs get_oo_ov_electronic_repulsion_ccs get_ov_oo_electronic_repulsion_ccs get_oo_vo_electronic_repulsion_ccs get_oo_vv_electronic_repulsion_ccs get_vv_oo_electronic_repulsion_ccs get_ov_ov_electronic_repulsion_ccs get_vo_oo_electronic_repulsion_ccs get_vo_vo_electronic_repulsion_ccs get_ov_vo_electronic_repulsion_ccs get_vo_ov_electronic_repulsion_ccs get_ov_vv_electronic_repulsion_ccs get_vv_ov_electronic_repulsion_ccs get_vo_vv_electronic_repulsion_ccs get_vv_vo_electronic_repulsion_ccs get_vv_vv_electronic_repulsion_ccs t1_transform_vv_vv_ccs initialize_fock_matrix_ccs construct_fock_ccs one_electron_t1_ccs ionized_state_driver_ccs initialize_trial_vectors_valence_ionization_ccs initialize_trial_vectors_core_ionization_ccs precondition_residual_valence_ionization_ccs ionization_residual_projection_ccs ionization_rho_a_i_projection_ccs precondition_residual_core_ionization_ccs jacobian_ccs_transformation_ccs jacobian_ccs_a1_ccs jacobian_ccs_b1_ccs jacobian_transpose_ccs_transformation_ccs jacobian_transpose_ccs_a1_ccs jacobian_transpose_ccs_b1_ccs cvs_rho_a_i_projection_ccs cvs_residual_projection_ccs Derived Types ccs Subroutines init_ccs drv_ccs initialize_amplitudes_ccs initialize_omega_ccs calc_energy_ccs construct_omega_ccs omega_ccs_a1_ccs construct_eta_ccs save_amplitudes_ccs read_amplitudes_ccs read_single_amplitudes_ccs destruct_amplitudes_ccs destruct_omega_ccs jacobi_test_ccs read_atom_info read_center_info Interfaces interface public module subroutine ground_state_driver_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine ground_state_preparations_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine ground_state_cleanup_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine ground_state_solver_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine calc_ampeqs_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine calc_ampeqs_norm_ccs (wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp) :: ampeqs_norm interface public module subroutine new_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine calc_quasi_Newton_singles_ccs (wf, dt) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: dt interface public module subroutine diis_ccs (wf, dt, t_dt) Arguments Type Intent Optional Attributes Name class( ccs ), intent(in) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: dt real(kind=dp), dimension(wf%n_parameters, 1) :: t_dt interface public module subroutine initialize_ground_state_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine destruct_ground_state_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine initialize_trial_vectors_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine find_start_trial_indices_ccs (wf, index_list) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15), intent(inout), dimension(wf%excited_state_specifications%n_singlet_states,1) :: index_list interface public module subroutine transform_trial_vectors_ccs (wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial interface public module subroutine excited_state_driver_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine excited_state_preparations_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine excited_state_cleanup_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine excited_state_solver_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine solve_reduced_eigenvalue_equation_ccs (wf, eigenvalues_Re, eigenvalues_Im, solution_vectors_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: eigenvalues_Re real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: eigenvalues_Im real(kind=dp), dimension(reduced_dim, wf%excited_state_specifications%n_singlet_states) :: solution_vectors_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials interface public module subroutine construct_next_trial_vectors_ccs (wf, eigenvalues_Re, eigenvalues_Im, solution_vectors_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: eigenvalues_Re real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: eigenvalues_Im real(kind=dp), dimension(reduced_dim, wf%excited_state_specifications%n_singlet_states) :: solution_vectors_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials interface public module subroutine initialize_trial_vectors_valence_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine initialize_trial_vectors_core_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine trial_vectors_from_stored_solutions_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine find_start_trial_indices_core_ccs (wf, index_list) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15), intent(inout), dimension(wf%excited_state_specifications%n_singlet_states,1) :: index_list interface public module subroutine find_core_mo_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine calculate_orbital_differences_ccs (wf, orbital_diff) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: orbital_diff interface public module subroutine initialize_excited_states_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine precondition_residual_ccs (wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual interface public module subroutine precondition_residual_valence_ccs (wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual interface public module subroutine precondition_residual_core_ccs (wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual interface public module subroutine print_excited_state_info_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine print_excitation_vector_ccs (wf, vec, unit_id) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: vec integer(kind=i15) :: unit_id interface public module subroutine analyze_single_excitation_vector_ccs (wf, vec, n, sorted_short_vec, index_list) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_o*wf%n_v, 1) :: vec integer(kind=i15) :: n real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 2) :: index_list interface public module subroutine summary_excited_state_info_ccs (wf, energies) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies interface public module subroutine response_driver_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine response_solver_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine response_preparations_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine initialize_response_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine solve_reduced_response_equation_ccs (wf, solution_vector_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(reduced_dim, 1) :: solution_vector_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials interface public module subroutine construct_reduced_matrix_ccs (wf, A_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(reduced_dim, reduced_dim) :: A_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials interface public module subroutine construct_reduced_gradient_ccs (wf, F_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(reduced_dim, 1) :: F_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials interface public module subroutine construct_gradient_vector_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine construct_next_response_trial_vectors_ccs (wf, solution_vector_reduced, reduced_dim, n_new_trials) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(reduced_dim, 1) :: solution_vector_reduced integer(kind=i15) :: reduced_dim integer(kind=i15) :: n_new_trials interface public module subroutine general_specs_reader_ccs (wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15) :: unit_input interface public module subroutine calculation_reader_ccs (wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15) :: unit_input interface public module subroutine read_ground_state_specs_ccs (wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer :: unit_input interface public module subroutine read_excited_state_specs_ccs (wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15) :: unit_input interface public module subroutine read_property_specs_ccs (wf, unit_input) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf integer(kind=i15) :: unit_input interface public module subroutine get_cholesky_ij_ccs (wf, L_ij_J, i_first, i_last, j_first, j_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: L_ij_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: j_first integer(kind=i15), optional :: j_last interface public module subroutine get_cholesky_ia_ccs (wf, L_ia_J, i_first, i_last, a_first, a_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: L_ia_J integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last interface public module subroutine get_cholesky_ai_ccs (wf, L_ai_J, a_first, a_last, i_first, i_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: L_ai_J integer(kind=i15), optional :: a_first integer(kind=i15), optional :: a_last integer(kind=i15), optional :: i_first integer(kind=i15), optional :: i_last interface public module subroutine get_cholesky_ab_ccs (wf, L_ab_J, a_first, a_last, b_first, b_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(((b_last - b_first + 1)*(a_last - a_first + 1)), wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: a_first integer(kind=i15), intent(in) :: a_last integer(kind=i15), intent(in) :: b_first integer(kind=i15), intent(in) :: b_last interface public module subroutine store_vv_vv_electronic_repulsion_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine store_t1_vv_vv_electronic_repulsion_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine store_t1_vo_ov_electronic_repulsion_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine store_t1_vv_ov_electronic_repulsion_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine store_t1_vv_vo_electronic_repulsion_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine read_vv_vv_electronic_repulsion_ccs (wf, x_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine read_t1_vv_vv_electronic_repulsion_ccs (wf, x_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine read_t1_vo_ov_electronic_repulsion_ccs (wf, x_vo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vo_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine read_t1_vv_vo_electronic_repulsion_ccs (wf, x_vv_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine read_t1_vv_ov_electronic_repulsion_ccs (wf, x_vv_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_oo_oo_ccs (wf, integral_type, x_oo_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:, :) :: x_oo_oo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_oo_ov_ccs (wf, integral_type, x_oo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_oo_ov integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_ov_oo_ccs (wf, integral_type, x_ov_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_ov_oo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_oo_vo_ccs (wf, integral_type, x_oo_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_oo_vo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_vo_oo_ccs (wf, integral_type, x_vo_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vo_oo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_oo_vv_ccs (wf, integral_type, x_oo_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_oo_vv integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_vv_oo_ccs (wf, integral_type, x_vv_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vv_oo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_ov_ov_ccs (wf, integral_type, x_ov_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_ov_ov integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_vo_vo_ccs (wf, integral_type, x_vo_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vo_vo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_ov_vo_ccs (wf, integral_type, x_ov_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_ov_vo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_vo_ov_ccs (wf, integral_type, x_vo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vo_ov integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_ov_vv_ccs (wf, integral_type, x_ov_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_ov_vv integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_vv_ov_ccs (wf, integral_type, x_vv_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vv_ov integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_vo_vv_ccs (wf, integral_type, x_vo_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vo_vv integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_vv_vo_ccs (wf, integral_type, x_vv_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vv_vo integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_vv_vv_ccs (wf, integral_type, x_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf character(len=40) :: integral_type real(kind=dp), dimension(:,:) :: x_vv_vv integer(kind=i15), optional :: index1_first integer(kind=i15), optional :: index1_last integer(kind=i15), optional :: index2_first integer(kind=i15), optional :: index2_last integer(kind=i15), optional :: index3_first integer(kind=i15), optional :: index3_last integer(kind=i15), optional :: index4_first integer(kind=i15), optional :: index4_last interface public module subroutine get_oo_oo_electronic_repulsion_ccs (wf, x_oo_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_oo_oo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_oo_ov_electronic_repulsion_ccs (wf, x_oo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_oo_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_ov_oo_electronic_repulsion_ccs (wf, x_ov_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_ov_oo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_oo_vo_electronic_repulsion_ccs (wf, x_oo_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_oo_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_oo_vv_electronic_repulsion_ccs (wf, x_oo_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_oo_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_vv_oo_electronic_repulsion_ccs (wf, x_vv_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_vv_oo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_ov_ov_electronic_repulsion_ccs (wf, x_ov_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_ov_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_vo_oo_electronic_repulsion_ccs (wf, x_vo_oo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: x_vo_oo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_vo_vo_electronic_repulsion_ccs (wf, x_vo_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vo_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_ov_vo_electronic_repulsion_ccs (wf, x_ov_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_ov_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_vo_ov_electronic_repulsion_ccs (wf, x_vo_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vo_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_ov_vv_electronic_repulsion_ccs (wf, x_ov_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_ov_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_vv_ov_electronic_repulsion_ccs (wf, x_vv_ov, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_ov integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_vo_vv_electronic_repulsion_ccs (wf, x_vo_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vo_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_vv_vo_electronic_repulsion_ccs (wf, x_vv_vo, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vo integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine get_vv_vv_electronic_repulsion_ccs (wf, x_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:,:) :: x_vv_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine t1_transform_vv_vv_ccs (wf, g_vv_vv, index1_first, index1_last, index2_first, index2_last, index3_first, index3_last, index4_first, index4_last) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(:, :) :: g_vv_vv integer(kind=i15) :: index1_first integer(kind=i15) :: index1_last integer(kind=i15) :: index2_first integer(kind=i15) :: index2_last integer(kind=i15) :: index3_first integer(kind=i15) :: index3_last integer(kind=i15) :: index4_first integer(kind=i15) :: index4_last interface public module subroutine initialize_fock_matrix_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine construct_fock_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine one_electron_t1_ccs (wf, h1, h1_T1) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_mo, wf%n_mo) :: h1 real(kind=dp), dimension(wf%n_mo, wf%n_mo) :: h1_T1 interface public module subroutine ionized_state_driver_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine initialize_trial_vectors_valence_ionization_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine initialize_trial_vectors_core_ionization_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine precondition_residual_valence_ionization_ccs (wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual interface public module subroutine ionization_residual_projection_ccs (wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual interface public module subroutine ionization_rho_a_i_projection_ccs (wf, rho_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i interface public module subroutine precondition_residual_core_ionization_ccs (wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters ,1) :: residual interface public module subroutine jacobian_ccs_transformation_ccs (wf, c_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_ccs_a1_ccs (wf, rho, c1) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_o,wf%n_v) :: rho real(kind=dp), dimension(wf%n_o,wf%n_v) :: c1 interface public module subroutine jacobian_ccs_b1_ccs (wf, rho, c1) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_o,wf%n_v) :: rho real(kind=dp), dimension(wf%n_o,wf%n_v) :: c1 interface public module subroutine jacobian_transpose_ccs_transformation_ccs (wf, b_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i interface public module subroutine jacobian_transpose_ccs_a1_ccs (wf, sigma_a_i, b_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i interface public module subroutine jacobian_transpose_ccs_b1_ccs (wf, sigma_a_i, b_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: sigma_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: b_a_i interface public module subroutine cvs_rho_a_i_projection_ccs (wf, vec_a_i) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_o,wf%n_v) :: vec_a_i interface public module subroutine cvs_residual_projection_ccs (wf, residual) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual Derived Types type, public, extends( hf ) :: ccs Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf procedure, public :: init => init_ccs procedure, public :: drv => drv_ccs procedure, public :: initialize_amplitudes => initialize_amplitudes_ccs procedure, public :: initialize_omega => initialize_omega_ccs procedure, public :: ground_state_driver => ground_state_driver_ccs procedure, public :: ground_state_solver => ground_state_solver_ccs procedure, public :: ground_state_preparations => ground_state_preparations_ccs procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs procedure, public :: initialize_ground_state => initialize_ground_state_ccs procedure, public :: destruct_ground_state => destruct_ground_state_ccs procedure, public, non_overridable :: diis => diis_ccs procedure, public :: new_amplitudes => new_amplitudes_ccs procedure, public :: calc_ampeqs => calc_ampeqs_ccs procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccs procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs procedure, public :: calc_energy => calc_energy_ccs procedure, public :: excited_state_driver => excited_state_driver_ccs procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs procedure, public :: excited_state_preparations => excited_state_preparations_ccs procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs procedure, public :: initialize_excited_states => initialize_excited_states_ccs procedure, public :: transform_trial_vectors => transform_trial_vectors_ccs procedure, public :: calculate_orbital_differences => calculate_orbital_differences_ccs procedure, public :: precondition_residual => precondition_residual_ccs procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs procedure, public :: print_excited_state_info => print_excited_state_info_ccs procedure, public :: print_excitation_vector => print_excitation_vector_ccs procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs procedure, public :: summary_excited_state_info => summary_excited_state_info_ccs procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs procedure, public :: precondition_residual_core => precondition_residual_core_ccs procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs procedure, public :: response_driver => response_driver_ccs procedure, public :: response_solver => response_solver_ccs procedure, public :: response_preparations => response_preparations_ccs procedure, public :: initialize_response => initialize_response_ccs procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs procedure, public :: general_specs_reader => general_specs_reader_ccs procedure, public :: calculation_reader => calculation_reader_ccs procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs procedure, public :: read_property_specs => read_property_specs_ccs procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs procedure, public :: get_oo_oo => get_oo_oo_ccs procedure, public :: get_oo_ov => get_oo_ov_ccs procedure, public :: get_ov_oo => get_ov_oo_ccs procedure, public :: get_oo_vo => get_oo_vo_ccs procedure, public :: get_vo_oo => get_vo_oo_ccs procedure, public :: get_oo_vv => get_oo_vv_ccs procedure, public :: get_vv_oo => get_vv_oo_ccs procedure, public :: get_ov_ov => get_ov_ov_ccs procedure, public :: get_vo_vo => get_vo_vo_ccs procedure, public :: get_ov_vo => get_ov_vo_ccs procedure, public :: get_vo_ov => get_vo_ov_ccs procedure, public :: get_ov_vv => get_ov_vv_ccs procedure, public :: get_vv_ov => get_vv_ov_ccs procedure, public :: get_vo_vv => get_vo_vv_ccs procedure, public :: get_vv_vo => get_vv_vo_ccs procedure, public :: get_vv_vv => get_vv_vv_ccs procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure, public, non_overridable :: construct_fock => construct_fock_ccs procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs procedure, public :: jacobi_test => jacobi_test_ccs procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs procedure, public :: ionized_state_driver => ionized_state_driver_ccs procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs procedure, public :: ionization_residual_projection => ionization_residual_projection_ccs procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs procedure, public :: cvs_residual_projection => cvs_residual_projection_ccs procedure, public :: construct_omega => construct_omega_ccs procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs procedure, public :: construct_eta => construct_eta_ccs procedure, public :: save_amplitudes => save_amplitudes_ccs procedure, public :: read_amplitudes => read_amplitudes_ccs procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs procedure, public :: destruct_amplitudes => destruct_amplitudes_ccs procedure, public :: destruct_omega => destruct_omega_ccs Subroutines public subroutine init_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine initialize_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine initialize_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine calc_energy_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine construct_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine omega_ccs_a1_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine construct_eta_ccs (wf, eta) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: eta public subroutine save_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine read_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine read_single_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine destruct_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine destruct_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine jacobi_test_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine read_atom_info (n_nuclei, n_ao) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: n_nuclei integer(kind=i15) :: n_ao public subroutine read_center_info (n_nuclei, n_ao, n_ao_on_center, ao_center_info) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: n_nuclei integer(kind=i15) :: n_ao integer, dimension(n_nuclei, 1) :: n_ao_on_center integer, dimension(n_ao, 2) :: ao_center_info","tags":"","loc":"module/ccs_class.html","title":"ccs_class – The eT program"},{"text":"Uses: types utils workspace input_output hf_class module~~mp2_class~~UsesGraph module~mp2_class mp2_class module~hf_class hf_class module~hf_class->module~mp2_class module~utils utils module~utils->module~mp2_class module~utils->module~hf_class module~input_output input_output module~input_output->module~mp2_class module~input_output->module~hf_class module~input_output->module~utils module~workspace workspace module~input_output->module~workspace module~memory_manager_class memory_manager_class module~input_output->module~memory_manager_class module~batching_index_class batching_index_class module~input_output->module~batching_index_class module~types types module~types->module~mp2_class module~types->module~hf_class module~types->module~utils module~types->module~input_output module~types->module~workspace module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~types->module~memory_manager_class module~types->module~batching_index_class module~workspace->module~mp2_class module~workspace->module~hf_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmodulemp2_classUsesGraph = svgPanZoom('#modulemp2_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Second-order Möller-Plesset (MP2) class module                                 \n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 Used By module~~mp2_class~~UsedByGraph module~mp2_class mp2_class program~et_program eT_program module~mp2_class->program~et_program Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types mp2 Subroutines init_mp2 drv_mp2 calc_energy_mp2 Derived Types type, public, extends( hf ) :: mp2 Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf procedure, public :: init => init_mp2 procedure, public :: drv => drv_mp2 procedure, public :: calc_energy => calc_energy_mp2 Subroutines public subroutine init_mp2 (wf) Arguments Type Intent Optional Attributes Name class( mp2 ) :: wf public subroutine drv_mp2 (wf) Arguments Type Intent Optional Attributes Name class( mp2 ) :: wf public subroutine calc_energy_mp2 (wf) Arguments Type Intent Optional Attributes Name class( mp2 ) :: wf","tags":"","loc":"module/mp2_class.html","title":"mp2_class – The eT program"},{"text":"Uses: types utils workspace input_output ccs_class module~~cc2_class~~UsesGraph module~cc2_class cc2_class module~utils utils module~utils->module~cc2_class module~ccs_class ccs_class module~utils->module~ccs_class module~hf_class hf_class module~utils->module~hf_class module~ccs_class->module~cc2_class module~input_output input_output module~input_output->module~cc2_class module~input_output->module~utils module~input_output->module~ccs_class module~workspace workspace module~input_output->module~workspace module~input_output->module~hf_class module~memory_manager_class memory_manager_class module~input_output->module~memory_manager_class module~batching_index_class batching_index_class module~input_output->module~batching_index_class module~types types module~types->module~cc2_class module~types->module~utils module~types->module~ccs_class module~types->module~input_output module~types->module~workspace module~types->module~hf_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~types->module~memory_manager_class module~types->module~batching_index_class module~workspace->module~cc2_class module~workspace->module~ccs_class module~workspace->module~hf_class module~hf_class->module~ccs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmodulecc2_classUsesGraph = svgPanZoom('#modulecc2_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Descendants: excited_state jacobian omega Coupled cluster perturbative doubles (CC2) class module                                 \n     Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 Used By module~~cc2_class~~UsedByGraph module~cc2_class cc2_class program~et_program eT_program module~cc2_class->program~et_program module~excited_state~3 excited_state module~cc2_class->module~excited_state~3 module~jacobian~2 jacobian module~cc2_class->module~jacobian~2 module~omega~2 omega module~cc2_class->module~omega~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces construct_omega_cc2 omega_cc2_a1_cc2 omega_cc2_b1_cc2 get_s2am_cc2 jacobian_cc2_transformation_cc2 jacobian_cc2_a1_cc2 jacobian_cc2_b1_cc2 jacobian_cc2_a2_cc2 jacobian_cc2_b2_cc2 cvs_rho_aibj_projection_cc2 initialize_excited_states_cc2 calculate_orbital_differences_cc2 transform_trial_vectors_cc2 cvs_residual_projection_cc2 excited_state_preparations_cc2 analyze_double_excitation_vector_cc2 summary_excited_state_info_cc2 Derived Types cc2 Subroutines init_cc2 calc_energy_cc2 save_amplitudes_cc2 destruct_s2am_cc2 read_amplitudes_cc2 read_cc2_double_amplitudes_cc2 Interfaces interface public module subroutine construct_omega_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf interface public module subroutine omega_cc2_a1_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf interface public module subroutine omega_cc2_b1_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf interface public module subroutine get_s2am_cc2 (wf, s_ia_jb, b_first, b_length) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), b_length*(wf%n_o)) :: s_ia_jb integer(kind=i15) :: b_first integer(kind=i15) :: b_length interface public module subroutine jacobian_cc2_transformation_cc2 (wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_s2am, 1) :: c_aibj interface public module subroutine jacobian_cc2_a1_cc2 (wf, rho_a_i, c_a_i) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_cc2_b1_cc2 (wf, rho_a_i, c_ai_bj) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(:,:) :: c_ai_bj interface public module subroutine jacobian_cc2_a2_cc2 (wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_cc2_b2_cc2 (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj interface public module subroutine cvs_rho_aibj_projection_cc2 (wf, vec_aibj) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(:, :) :: vec_aibj interface public module subroutine initialize_excited_states_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf interface public module subroutine calculate_orbital_differences_cc2 (wf, orbital_diff) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: orbital_diff interface public module subroutine transform_trial_vectors_cc2 (wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial interface public module subroutine cvs_residual_projection_cc2 (wf, residual) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual interface public module subroutine excited_state_preparations_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf interface public module subroutine analyze_double_excitation_vector_cc2 (wf, vec, n, sorted_short_vec, index_list) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%n_s2am, 1) :: vec integer(kind=i15) :: n real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 4) :: index_list interface public module subroutine summary_excited_state_info_cc2 (wf, energies) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies Derived Types type, public, extends( ccs ) :: cc2 Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab real(kind=dp), public, dimension(:,:), allocatable :: s2am integer(kind=dp), public :: n_s2am Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf procedure, public :: drv => drv_ccs procedure, public :: initialize_amplitudes => initialize_amplitudes_ccs procedure, public :: initialize_omega => initialize_omega_ccs procedure, public :: ground_state_driver => ground_state_driver_ccs procedure, public :: ground_state_solver => ground_state_solver_ccs procedure, public :: ground_state_preparations => ground_state_preparations_ccs procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs procedure, public :: initialize_ground_state => initialize_ground_state_ccs procedure, public :: destruct_ground_state => destruct_ground_state_ccs procedure, public, non_overridable :: diis => diis_ccs procedure, public :: new_amplitudes => new_amplitudes_ccs procedure, public :: calc_ampeqs => calc_ampeqs_ccs procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccs procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs procedure, public :: excited_state_driver => excited_state_driver_ccs procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs procedure, public :: precondition_residual => precondition_residual_ccs procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs procedure, public :: print_excited_state_info => print_excited_state_info_ccs procedure, public :: print_excitation_vector => print_excitation_vector_ccs procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs procedure, public :: precondition_residual_core => precondition_residual_core_ccs procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs procedure, public :: response_driver => response_driver_ccs procedure, public :: response_solver => response_solver_ccs procedure, public :: response_preparations => response_preparations_ccs procedure, public :: initialize_response => initialize_response_ccs procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs procedure, public :: general_specs_reader => general_specs_reader_ccs procedure, public :: calculation_reader => calculation_reader_ccs procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs procedure, public :: read_property_specs => read_property_specs_ccs procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs procedure, public :: get_oo_oo => get_oo_oo_ccs procedure, public :: get_oo_ov => get_oo_ov_ccs procedure, public :: get_ov_oo => get_ov_oo_ccs procedure, public :: get_oo_vo => get_oo_vo_ccs procedure, public :: get_vo_oo => get_vo_oo_ccs procedure, public :: get_oo_vv => get_oo_vv_ccs procedure, public :: get_vv_oo => get_vv_oo_ccs procedure, public :: get_ov_ov => get_ov_ov_ccs procedure, public :: get_vo_vo => get_vo_vo_ccs procedure, public :: get_ov_vo => get_ov_vo_ccs procedure, public :: get_vo_ov => get_vo_ov_ccs procedure, public :: get_ov_vv => get_ov_vv_ccs procedure, public :: get_vv_ov => get_vv_ov_ccs procedure, public :: get_vo_vv => get_vo_vv_ccs procedure, public :: get_vv_vo => get_vv_vo_ccs procedure, public :: get_vv_vv => get_vv_vv_ccs procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure, public, non_overridable :: construct_fock => construct_fock_ccs procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs procedure, public :: jacobi_test => jacobi_test_ccs procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs procedure, public :: ionized_state_driver => ionized_state_driver_ccs procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs procedure, public :: ionization_residual_projection => ionization_residual_projection_ccs procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs procedure, public :: construct_eta => construct_eta_ccs procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs procedure, public :: destruct_amplitudes => destruct_amplitudes_ccs procedure, public :: destruct_omega => destruct_omega_ccs procedure, public :: init => init_cc2 procedure, public :: construct_omega => construct_omega_cc2 procedure, public :: omega_cc2_a1 => omega_cc2_a1_cc2 procedure, public :: omega_cc2_b1 => omega_cc2_b1_cc2 procedure, public :: get_s2am => get_s2am_cc2 procedure, public :: read_cc2_double_amplitudes => read_cc2_double_amplitudes_cc2 procedure, public :: read_amplitudes => read_amplitudes_cc2 procedure, public :: save_amplitudes => save_amplitudes_cc2 procedure, public :: destruct_s2am => destruct_s2am_cc2 procedure, public :: calc_energy => calc_energy_cc2 procedure, public :: jacobian_cc2_transformation => jacobian_cc2_transformation_cc2 procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_cc2 procedure, public :: jacobian_cc2_a1 => jacobian_cc2_a1_cc2 procedure, public :: jacobian_cc2_b1 => jacobian_cc2_b1_cc2 procedure, public :: jacobian_cc2_a2 => jacobian_cc2_a2_cc2 procedure, public :: jacobian_cc2_b2 => jacobian_cc2_b2_cc2 procedure, public :: initialize_excited_states => initialize_excited_states_cc2 procedure, public :: calculate_orbital_differences => calculate_orbital_differences_cc2 procedure, public :: transform_trial_vectors => transform_trial_vectors_cc2 procedure, public :: cvs_residual_projection => cvs_residual_projection_cc2 procedure, public :: excited_state_preparations => excited_state_preparations_cc2 procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_cc2 procedure, public :: summary_excited_state_info => summary_excited_state_info_cc2 Subroutines public subroutine init_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf public subroutine calc_energy_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf public subroutine save_amplitudes_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf public subroutine destruct_s2am_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf public subroutine read_amplitudes_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf public subroutine read_cc2_double_amplitudes_cc2 (wf) Arguments Type Intent Optional Attributes Name class( cc2 ) :: wf","tags":"","loc":"module/cc2_class.html","title":"cc2_class – The eT program"},{"text":"Uses: types utils workspace input_output ccsd_class module~~cc3_class~~UsesGraph module~cc3_class cc3_class module~ccsd_class ccsd_class module~ccsd_class->module~cc3_class module~utils utils module~utils->module~cc3_class module~utils->module~ccsd_class module~ccs_class ccs_class module~utils->module~ccs_class module~hf_class hf_class module~utils->module~hf_class module~input_output input_output module~input_output->module~cc3_class module~input_output->module~ccsd_class module~input_output->module~utils module~workspace workspace module~input_output->module~workspace module~input_output->module~ccs_class module~input_output->module~hf_class module~memory_manager_class memory_manager_class module~input_output->module~memory_manager_class module~batching_index_class batching_index_class module~input_output->module~batching_index_class module~types types module~types->module~cc3_class module~types->module~ccsd_class module~types->module~utils module~types->module~input_output module~types->module~workspace module~types->module~ccs_class module~types->module~hf_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~types->module~memory_manager_class module~types->module~batching_index_class module~workspace->module~cc3_class module~workspace->module~ccsd_class module~workspace->module~ccs_class module~workspace->module~hf_class module~ccs_class->module~ccsd_class module~hf_class->module~ccs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmodulecc3_classUsesGraph = svgPanZoom('#modulecc3_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Descendants: omega CC3 class module\n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Used By module~~cc3_class~~UsedByGraph module~cc3_class cc3_class module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class program~et_program eT_program module~cc3_class->program~et_program module~omega~4 omega module~cc3_class->module~omega~4 module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces construct_omega_cc3 omega_integrals_cc3 calc_triples_cc3 omega_cc3_a1_cc3 omega_cc3_a2_cc3 omega_cc3_b2_cc3 Derived Types cc3 Subroutines init_cc3 Interfaces interface public module subroutine construct_omega_cc3 (wf) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf interface public module subroutine omega_integrals_cc3 (wf) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf interface public module subroutine calc_triples_cc3 (wf, w_abc, i, j, k) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf real(kind=dp), dimension((wf%n_v)**3, 1) :: w_abc integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j integer(kind=i15), intent(in) :: k interface public module subroutine omega_cc3_a1_cc3 (wf, t_abc, i, j, k) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf real(kind=dp), dimension((wf%n_v)**3, 1) :: t_abc integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j integer(kind=i15), intent(in) :: k interface public module subroutine omega_cc3_a2_cc3 (wf, omega_ai_bj, t_abc, i, j, k) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: omega_ai_bj real(kind=dp), dimension((wf%n_v)**3, 1) :: t_abc integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j integer(kind=i15), intent(in) :: k interface public module subroutine omega_cc3_b2_cc3 (wf, omega_ai_bj, t_abc, i, j, k) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), (wf%n_v)*(wf%n_o)) :: omega_ai_bj real(kind=dp), dimension((wf%n_v)**3, 1) :: t_abc integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j integer(kind=i15), intent(in) :: k Derived Types type, public, extends( ccsd ) :: cc3 Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf procedure, public :: drv => drv_ccs procedure, public :: ground_state_driver => ground_state_driver_ccs procedure, public :: ground_state_solver => ground_state_solver_ccs procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs procedure, public :: destruct_ground_state => destruct_ground_state_ccs procedure, public, non_overridable :: diis => diis_ccs procedure, public :: calc_ampeqs => calc_ampeqs_ccs procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs procedure, public :: excited_state_driver => excited_state_driver_ccs procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs procedure, public :: initialize_excited_states => initialize_excited_states_ccs procedure, public :: precondition_residual => precondition_residual_ccs procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs procedure, public :: print_excited_state_info => print_excited_state_info_ccs procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs procedure, public :: precondition_residual_core => precondition_residual_core_ccs procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs procedure, public :: response_driver => response_driver_ccs procedure, public :: response_solver => response_solver_ccs procedure, public :: response_preparations => response_preparations_ccs procedure, public :: initialize_response => initialize_response_ccs procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs procedure, public :: general_specs_reader => general_specs_reader_ccs procedure, public :: calculation_reader => calculation_reader_ccs procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs procedure, public :: read_property_specs => read_property_specs_ccs procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs procedure, public :: get_oo_oo => get_oo_oo_ccs procedure, public :: get_oo_ov => get_oo_ov_ccs procedure, public :: get_ov_oo => get_ov_oo_ccs procedure, public :: get_oo_vo => get_oo_vo_ccs procedure, public :: get_vo_oo => get_vo_oo_ccs procedure, public :: get_oo_vv => get_oo_vv_ccs procedure, public :: get_vv_oo => get_vv_oo_ccs procedure, public :: get_ov_ov => get_ov_ov_ccs procedure, public :: get_vo_vo => get_vo_vo_ccs procedure, public :: get_ov_vo => get_ov_vo_ccs procedure, public :: get_vo_ov => get_vo_ov_ccs procedure, public :: get_ov_vv => get_ov_vv_ccs procedure, public :: get_vv_ov => get_vv_ov_ccs procedure, public :: get_vo_vv => get_vo_vv_ccs procedure, public :: get_vv_vo => get_vv_vo_ccs procedure, public :: get_vv_vv => get_vv_vv_ccs procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure, public, non_overridable :: construct_fock => construct_fock_ccs procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs procedure, public :: ionized_state_driver => ionized_state_driver_ccs procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs procedure, public :: initialize_amplitudes => initialize_amplitudes_ccsd procedure, public :: initialize_omega => initialize_omega_ccsd procedure, public :: initialize_ground_state => initialize_ground_state_ccsd procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd procedure, public :: new_amplitudes => new_amplitudes_ccsd procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd procedure, public :: ground_state_preparations => ground_state_preparations_ccsd procedure, public :: omega_ccsd_a1 => omega_ccsd_a1_ccsd procedure, public :: omega_ccsd_b1 => omega_ccsd_b1_ccsd procedure, public :: omega_ccsd_c1 => omega_ccsd_c1_ccsd procedure, public :: omega_ccsd_a2 => omega_ccsd_a2_ccsd procedure, public :: omega_ccsd_b2 => omega_ccsd_b2_ccsd procedure, public :: omega_ccsd_c2 => omega_ccsd_c2_ccsd procedure, public :: omega_ccsd_d2 => omega_ccsd_d2_ccsd procedure, public :: omega_ccsd_e2 => omega_ccsd_e2_ccsd procedure, public :: calculate_orbital_differences => calculate_orbital_differences_ccsd procedure, public :: transform_trial_vectors => transform_trial_vectors_ccsd procedure, public :: print_excitation_vector => print_excitation_vector_ccsd procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_ccsd procedure, public :: summary_excited_state_info => summary_excited_state_info_ccsd procedure, public :: excited_state_preparations => excited_state_preparations_ccsd procedure, public :: jacobian_ccsd_transformation => jacobian_ccsd_transformation_ccsd procedure, public :: jacobian_ccsd_a1 => jacobian_ccsd_a1_ccsd procedure, public :: jacobian_ccsd_b1 => jacobian_ccsd_b1_ccsd procedure, public :: jacobian_ccsd_c1 => jacobian_ccsd_c1_ccsd procedure, public :: jacobian_ccsd_d1 => jacobian_ccsd_d1_ccsd procedure, public :: jacobian_ccsd_a2 => jacobian_ccsd_a2_ccsd procedure, public :: jacobian_ccsd_b2 => jacobian_ccsd_b2_ccsd procedure, public :: jacobian_ccsd_c2 => jacobian_ccsd_c2_ccsd procedure, public :: jacobian_ccsd_d2 => jacobian_ccsd_d2_ccsd procedure, public :: jacobian_ccsd_e2 => jacobian_ccsd_e2_ccsd procedure, public :: jacobian_ccsd_f2 => jacobian_ccsd_f2_ccsd procedure, public :: jacobian_ccsd_g2 => jacobian_ccsd_g2_ccsd procedure, public :: jacobian_ccsd_h2 => jacobian_ccsd_h2_ccsd procedure, public :: jacobian_ccsd_i2 => jacobian_ccsd_i2_ccsd procedure, public :: jacobian_ccsd_j2 => jacobian_ccsd_j2_ccsd procedure, public :: jacobian_ccsd_k2 => jacobian_ccsd_k2_ccsd procedure, public :: jacobi_test => jacobi_test_ccsd procedure, public :: jacobian_transpose_ccsd_transformation => jacobian_transpose_ccsd_transformation_ccsd procedure, public :: jacobian_transpose_ccsd_a1 => jacobian_transpose_ccsd_a1_ccsd procedure, public :: jacobian_transpose_ccsd_b1 => jacobian_transpose_ccsd_b1_ccsd procedure, public :: jacobian_transpose_ccsd_c1 => jacobian_transpose_ccsd_c1_ccsd procedure, public :: jacobian_transpose_ccsd_d1 => jacobian_transpose_ccsd_d1_ccsd procedure, public :: jacobian_transpose_ccsd_e1 => jacobian_transpose_ccsd_e1_ccsd procedure, public :: jacobian_transpose_ccsd_f1 => jacobian_transpose_ccsd_f1_ccsd procedure, public :: jacobian_transpose_ccsd_g1 => jacobian_transpose_ccsd_g1_ccsd procedure, public :: jacobian_transpose_ccsd_a2 => jacobian_transpose_ccsd_a2_ccsd procedure, public :: jacobian_transpose_ccsd_b2 => jacobian_transpose_ccsd_b2_ccsd procedure, public :: jacobian_transpose_ccsd_c2 => jacobian_transpose_ccsd_c2_ccsd procedure, public :: jacobian_transpose_ccsd_d2 => jacobian_transpose_ccsd_d2_ccsd procedure, public :: jacobian_transpose_ccsd_e2 => jacobian_transpose_ccsd_e2_ccsd procedure, public :: jacobian_transpose_ccsd_f2 => jacobian_transpose_ccsd_f2_ccsd procedure, public :: jacobian_transpose_ccsd_g2 => jacobian_transpose_ccsd_g2_ccsd procedure, public :: jacobian_transpose_ccsd_h2 => jacobian_transpose_ccsd_h2_ccsd procedure, public :: jacobian_transpose_ccsd_i2 => jacobian_transpose_ccsd_i2_ccsd procedure, public :: ionization_residual_projection => ionization_residual_projection_ccsd procedure, public :: ionization_rho_aibj_projection => ionization_rho_aibj_projection_ccsd procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_ccsd procedure, public :: cvs_residual_projection => cvs_residual_projection_ccsd procedure, public :: construct_eta => construct_eta_ccsd procedure, public :: save_amplitudes => save_amplitudes_ccsd procedure, public :: read_amplitudes => read_amplitudes_ccsd procedure, public :: read_double_amplitudes => read_double_amplitudes_ccsd procedure, public :: destruct_amplitudes => destruct_amplitudes_ccsd procedure, public :: destruct_omega => destruct_omega_ccsd procedure, public :: construct_perturbative_doubles => construct_perturbative_doubles_ccsd procedure, public :: calc_energy => calc_energy_ccsd procedure, public :: init => init_cc3 procedure, public :: construct_omega => construct_omega_cc3 procedure, public :: omega_integrals => omega_integrals_cc3 procedure, public :: calc_triples => calc_triples_cc3 procedure, public :: omega_cc3_a1 => omega_cc3_a1_cc3 procedure, public :: omega_cc3_a2 => omega_cc3_a2_cc3 procedure, public :: omega_cc3_b2 => omega_cc3_b2_cc3 Subroutines public subroutine init_cc3 (wf) Arguments Type Intent Optional Attributes Name class( cc3 ) :: wf","tags":"","loc":"module/cc3_class.html","title":"cc3_class – The eT program"},{"text":"Uses: types utils workspace input_output input_reader mlcc_orbitals_class mlcc_calculation_settings_class ccs_class module~~mlcc2_class~~UsesGraph module~mlcc2_class mlcc2_class module~ccs_class ccs_class module~ccs_class->module~mlcc2_class module~types types module~types->module~mlcc2_class module~types->module~ccs_class module~input_reader input_reader module~types->module~input_reader module~workspace workspace module~types->module~workspace module~mlcc_orbitals_class mlcc_orbitals_class module~types->module~mlcc_orbitals_class module~utils utils module~types->module~utils module~input_output input_output module~types->module~input_output module~mlcc_calculation_settings_class mlcc_calculation_settings_class module~types->module~mlcc_calculation_settings_class module~hf_class hf_class module~types->module~hf_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~memory_manager_class memory_manager_class module~types->module~memory_manager_class module~batching_index_class batching_index_class module~types->module~batching_index_class module~input_reader->module~mlcc2_class module~input_reader->module~mlcc_orbitals_class module~workspace->module~mlcc2_class module~workspace->module~ccs_class module~workspace->module~input_reader module~workspace->module~hf_class module~mlcc_orbitals_class->module~mlcc2_class module~utils->module~mlcc2_class module~utils->module~ccs_class module~utils->module~hf_class module~input_output->module~mlcc2_class module~input_output->module~ccs_class module~input_output->module~input_reader module~input_output->module~workspace module~input_output->module~utils module~input_output->module~hf_class module~input_output->module~memory_manager_class module~input_output->module~batching_index_class module~mlcc_calculation_settings_class->module~mlcc2_class module~hf_class->module~ccs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmodulemlcc2_classUsesGraph = svgPanZoom('#modulemlcc2_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Descendants: excited_state input_reader jacobian omega orbital_partitioning Multi-level CC2 (MLCC2) class module                                \n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 Used By module~~mlcc2_class~~UsedByGraph module~mlcc2_class mlcc2_class module~mlccsd_class mlccsd_class module~mlcc2_class->module~mlccsd_class program~et_program eT_program module~mlcc2_class->program~et_program module~orbital_partitioning orbital_partitioning module~mlcc2_class->module~orbital_partitioning module~excited_state~4 excited_state module~mlcc2_class->module~excited_state~4 module~input_reader~3 input_reader module~mlcc2_class->module~input_reader~3 module~jacobian~4 jacobian module~mlcc2_class->module~jacobian~4 module~omega omega module~mlcc2_class->module~omega module~mlccsd_class->program~et_program module~input_reader~4 input_reader module~mlccsd_class->module~input_reader~4 module~ground_state~3 ground_state module~mlccsd_class->module~ground_state~3 module~cholesky~2 cholesky module~mlccsd_class->module~cholesky~2 module~jacobian~5 jacobian module~mlccsd_class->module~jacobian~5 module~orbital_partitioning~2 orbital_partitioning module~mlccsd_class->module~orbital_partitioning~2 module~excited_state~5 excited_state module~mlccsd_class->module~excited_state~5 module~omega~5 omega module~mlccsd_class->module~omega~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces mlcc_reader_mlcc2 read_orbital_info_mlcc2 orbital_partitioning_mlcc2 cholesky_localization_drv_mlcc2 cholesky_decomposition_mlcc2 cholesky_orbitals_mlcc2 cholesky_orbital_constructor_mlcc2 construct_active_ao_index_list cnto_orbital_drv_mlcc2 cc2_cnto_lower_level_method_mlcc2 cc2_cnto_orbitals_mlcc2 print_orbital_info_mlcc2 omega_mlcc2_a1_mlcc2 omega_mlcc2_b1_mlcc2 construct_omega_mlcc2 get_s2am_mlcc2 excited_state_preparations_mlcc2 initialize_excited_states_mlcc2 calculate_orbital_differences_mlcc2 transform_trial_vectors_mlcc2 cvs_residual_projection_mlcc2 print_excitation_vector_mlcc2 analyze_double_excitation_vector_mlcc2 summary_excited_state_info_mlcc2 jacobian_mlcc2_transformation_mlcc2 jacobian_mlcc2_a1_mlcc2 jacobian_mlcc2_b1_mlcc2 jacobian_mlcc2_a2_mlcc2 jacobian_mlcc2_b2_mlcc2 cvs_rho_aibj_projection_mlcc2 Derived Types mlcc2 Subroutines init_mlcc2 calc_energy_mlcc2 get_CC2_active_indices_mlcc2 get_CC2_n_active_mlcc2 save_amplitudes_mlcc2 read_amplitudes_mlcc2 read_cc2_double_amplitudes_mlcc2 destruct_x2am_mlcc2 Interfaces interface public subroutine mlcc_reader_mlcc2 (wf, unit_input) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: unit_input interface public module subroutine read_orbital_info_mlcc2 (wf, unit_input) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: unit_input interface public module subroutine orbital_partitioning_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine cholesky_localization_drv_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine cholesky_decomposition_mlcc2 (wf, density, cholesky_vectors, n_vectors, selection, n_active_aos, active_ao_index_list) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_ao,wf%n_ao) :: density real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: cholesky_vectors integer(kind=i15) :: n_vectors logical :: selection integer(kind=i15) :: n_active_aos integer(kind=i15), optional dimension( n_active_aos,1) :: active_ao_index_list interface public module subroutine cholesky_orbitals_mlcc2 (wf, cholesky_vectors, n_vectors, orbitals, orbital_energies, ao_fock) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: cholesky_vectors integer(kind=i15) :: n_vectors real(kind=dp), dimension(wf%n_ao, n_vectors) :: orbitals real(kind=dp), dimension(n_vectors, 1) :: orbital_energies real(kind=dp), dimension(wf%n_ao,wf%n_ao) :: ao_fock interface public module subroutine cholesky_orbital_constructor_mlcc2 (wf, orbitals, orbital_energies, offset, ao_fock, density, n_vectors, selection, n_active_aos, active_ao_index_list) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_ao, wf%n_mo) :: orbitals real(kind=dp), dimension(wf%n_mo, 1) :: orbital_energies integer(kind=i15) :: offset real(kind=dp), dimension(wf%n_ao, wf%n_ao) :: ao_fock real(kind=dp), dimension(wf%n_ao,wf%n_ao) :: density integer(kind=i15) :: n_vectors logical :: selection integer(kind=i15) :: n_active_aos integer(kind=i15), optional dimension( n_active_aos,1) :: active_ao_index_list interface public module subroutine construct_active_ao_index_list (active_ao_index_list, n_active_aos, active_atoms, n_active_atoms, ao_center_info, n_ao) Arguments Type Intent Optional Attributes Name integer(kind=i15), dimension(n_active_aos, 1) :: active_ao_index_list integer(kind=i15) :: n_active_aos integer(kind=i15), dimension(n_active_atoms, 1) :: active_atoms integer(kind=i15) :: n_active_atoms integer(kind=i15), dimension(n_ao, 2) :: ao_center_info integer(kind=i15) :: n_ao interface public module subroutine cnto_orbital_drv_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine cc2_cnto_lower_level_method_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine cc2_cnto_orbitals_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine print_orbital_info_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine omega_mlcc2_a1_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine omega_mlcc2_b1_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine construct_omega_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine get_s2am_mlcc2 (wf, s_ai_bj, b_first, b_length) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension((wf%n_CC2_v)*(wf%n_CC2_o), b_length*(wf%n_CC2_o)) :: s_ai_bj integer(kind=i15) :: b_first integer(kind=i15) :: b_length interface public module subroutine excited_state_preparations_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine initialize_excited_states_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf interface public module subroutine calculate_orbital_differences_mlcc2 (wf, orbital_diff) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: orbital_diff interface public module subroutine transform_trial_vectors_mlcc2 (wf, first_trial, last_trial) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15), intent(in) :: first_trial integer(kind=i15), intent(in) :: last_trial interface public module subroutine cvs_residual_projection_mlcc2 (wf, residual) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: residual interface public module subroutine print_excitation_vector_mlcc2 (wf, vec, unit_id) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_parameters, 1) :: vec integer(kind=i15) :: unit_id interface public module subroutine analyze_double_excitation_vector_mlcc2 (wf, vec, n, sorted_short_vec, index_list) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_x2am, 1) :: vec integer(kind=i15) :: n real(kind=dp), dimension(n, 1) :: sorted_short_vec integer(kind=i15), dimension(n, 4) :: index_list interface public module subroutine summary_excited_state_info_mlcc2 (wf, energies) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%excited_state_specifications%n_singlet_states,1) :: energies interface public module subroutine jacobian_mlcc2_transformation_mlcc2 (wf, c_a_i, c_aibj) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i real(kind=dp), dimension(wf%n_x2am, 1) :: c_aibj interface public module subroutine jacobian_mlcc2_a1_mlcc2 (wf, rho_a_i, c_a_i) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_mlcc2_b1_mlcc2 (wf, rho_a_i, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(wf%n_v, wf%n_o) :: rho_a_i real(kind=dp), dimension(:,:) :: c_ai_bj interface public module subroutine jacobian_mlcc2_a2_mlcc2 (wf, rho_ai_bj, c_a_i) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(wf%n_v, wf%n_o) :: c_a_i interface public module subroutine jacobian_mlcc2_b2_mlcc2 (wf, rho_ai_bj, c_ai_bj) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(:,:) :: rho_ai_bj real(kind=dp), dimension(:,:) :: c_ai_bj interface public module subroutine cvs_rho_aibj_projection_mlcc2 (wf, vec_aibj) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf real(kind=dp), dimension(:, :) :: vec_aibj Derived Types type, public, extends( ccs ) :: mlcc2 Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab type( mlcc_calculation_settings ), public :: mlcc_settings integer(kind=i15), public :: n_CCS_o = 0 integer(kind=i15), public :: n_CCS_v = 0 integer(kind=i15), public :: first_CCS_o = 0 integer(kind=i15), public :: first_CCS_v = 0 integer(kind=i15), public :: n_CC2_o = 0 integer(kind=i15), public :: n_CC2_v = 0 integer(kind=i15), public :: first_CC2_o = 0 integer(kind=i15), public :: first_CC2_v = 0 type( mlcc_orbitals ), public :: CC2_orbitals integer(kind=i15), public :: n_x2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: x2am Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf procedure, public :: drv => drv_ccs procedure, public :: initialize_amplitudes => initialize_amplitudes_ccs procedure, public :: initialize_omega => initialize_omega_ccs procedure, public :: ground_state_driver => ground_state_driver_ccs procedure, public :: ground_state_solver => ground_state_solver_ccs procedure, public :: ground_state_preparations => ground_state_preparations_ccs procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs procedure, public :: initialize_ground_state => initialize_ground_state_ccs procedure, public :: destruct_ground_state => destruct_ground_state_ccs procedure, public, non_overridable :: diis => diis_ccs procedure, public :: new_amplitudes => new_amplitudes_ccs procedure, public :: calc_ampeqs => calc_ampeqs_ccs procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccs procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs procedure, public :: excited_state_driver => excited_state_driver_ccs procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs procedure, public :: precondition_residual => precondition_residual_ccs procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs procedure, public :: print_excited_state_info => print_excited_state_info_ccs procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs procedure, public :: precondition_residual_core => precondition_residual_core_ccs procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs procedure, public :: response_driver => response_driver_ccs procedure, public :: response_solver => response_solver_ccs procedure, public :: response_preparations => response_preparations_ccs procedure, public :: initialize_response => initialize_response_ccs procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs procedure, public :: general_specs_reader => general_specs_reader_ccs procedure, public :: calculation_reader => calculation_reader_ccs procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs procedure, public :: read_property_specs => read_property_specs_ccs procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs procedure, public :: get_oo_oo => get_oo_oo_ccs procedure, public :: get_oo_ov => get_oo_ov_ccs procedure, public :: get_ov_oo => get_ov_oo_ccs procedure, public :: get_oo_vo => get_oo_vo_ccs procedure, public :: get_vo_oo => get_vo_oo_ccs procedure, public :: get_oo_vv => get_oo_vv_ccs procedure, public :: get_vv_oo => get_vv_oo_ccs procedure, public :: get_ov_ov => get_ov_ov_ccs procedure, public :: get_vo_vo => get_vo_vo_ccs procedure, public :: get_ov_vo => get_ov_vo_ccs procedure, public :: get_vo_ov => get_vo_ov_ccs procedure, public :: get_ov_vv => get_ov_vv_ccs procedure, public :: get_vv_ov => get_vv_ov_ccs procedure, public :: get_vo_vv => get_vo_vv_ccs procedure, public :: get_vv_vo => get_vv_vo_ccs procedure, public :: get_vv_vv => get_vv_vv_ccs procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure, public, non_overridable :: construct_fock => construct_fock_ccs procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs procedure, public :: jacobi_test => jacobi_test_ccs procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs procedure, public :: ionized_state_driver => ionized_state_driver_ccs procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs procedure, public :: ionization_residual_projection => ionization_residual_projection_ccs procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs procedure, public :: construct_eta => construct_eta_ccs procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs procedure, public :: destruct_amplitudes => destruct_amplitudes_ccs procedure, public :: destruct_omega => destruct_omega_ccs procedure, public :: mlcc_reader => mlcc_reader_mlcc2 procedure, public :: read_orbital_info => read_orbital_info_mlcc2 procedure, public :: init => init_mlcc2 procedure, public :: orbital_partitioning => orbital_partitioning_mlcc2 procedure, public :: cholesky_decomposition => cholesky_decomposition_mlcc2 procedure, public :: cholesky_localization_drv => cholesky_localization_drv_mlcc2 procedure, public :: cholesky_orbitals => cholesky_orbitals_mlcc2 procedure, public :: cholesky_orbital_constructor => cholesky_orbital_constructor_mlcc2 procedure, public :: cnto_orbital_drv => cnto_orbital_drv_mlcc2 procedure, public :: cc2_cnto_lower_level_method => cc2_cnto_lower_level_method_mlcc2 procedure, public :: cc2_cnto_orbitals => cc2_cnto_orbitals_mlcc2 procedure, public :: print_orbital_info => print_orbital_info_mlcc2 procedure, public :: get_CC2_active_indices => get_CC2_active_indices_mlcc2 procedure, public :: get_CC2_n_active => get_CC2_n_active_mlcc2 procedure, public :: save_amplitudes => save_amplitudes_mlcc2 procedure, public :: read_amplitudes => read_amplitudes_mlcc2 procedure, public :: read_cc2_double_amplitudes => read_cc2_double_amplitudes_mlcc2 procedure, public :: destruct_x2am => destruct_x2am_mlcc2 procedure, public :: omega_mlcc2_a1 => omega_mlcc2_a1_mlcc2 procedure, public :: omega_mlcc2_b1 => omega_mlcc2_b1_mlcc2 procedure, public :: construct_omega => construct_omega_mlcc2 procedure, public :: get_s2am => get_s2am_mlcc2 procedure, public :: calc_energy => calc_energy_mlcc2 procedure, public :: excited_state_preparations => excited_state_preparations_mlcc2 procedure, public :: initialize_excited_states => initialize_excited_states_mlcc2 procedure, public :: calculate_orbital_differences => calculate_orbital_differences_mlcc2 procedure, public :: transform_trial_vectors => transform_trial_vectors_mlcc2 procedure, public :: cvs_residual_projection => cvs_residual_projection_mlcc2 procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_mlcc2 procedure, public :: summary_excited_state_info => summary_excited_state_info_mlcc2 procedure, public :: print_excitation_vector => print_excitation_vector_mlcc2 procedure, public :: jacobian_mlcc2_transformation => jacobian_mlcc2_transformation_mlcc2 procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_mlcc2 procedure, public :: jacobian_mlcc2_a1 => jacobian_mlcc2_a1_mlcc2 procedure, public :: jacobian_mlcc2_b1 => jacobian_mlcc2_b1_mlcc2 procedure, public :: jacobian_mlcc2_a2 => jacobian_mlcc2_a2_mlcc2 procedure, public :: jacobian_mlcc2_b2 => jacobian_mlcc2_b2_mlcc2 Subroutines public subroutine init_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf public subroutine calc_energy_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf public subroutine get_CC2_active_indices_mlcc2 (wf, first_o, first_v) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: first_o integer(kind=i15) :: first_v public subroutine get_CC2_n_active_mlcc2 (wf, n_active_o, n_active_v) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf integer(kind=i15) :: n_active_o integer(kind=i15) :: n_active_v public subroutine save_amplitudes_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf public subroutine read_amplitudes_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf public subroutine read_cc2_double_amplitudes_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf public subroutine destruct_x2am_mlcc2 (wf) Arguments Type Intent Optional Attributes Name class( mlcc2 ) :: wf","tags":"","loc":"module/mlcc2_class.html","title":"mlcc2_class – The eT program"},{"text":"Uses: types utils workspace input_output cc3_class module~~ccsdpt_class~~UsesGraph module~ccsdpt_class ccsdpt_class module~utils utils module~utils->module~ccsdpt_class module~cc3_class cc3_class module~utils->module~cc3_class module~ccsd_class ccsd_class module~utils->module~ccsd_class module~ccs_class ccs_class module~utils->module~ccs_class module~hf_class hf_class module~utils->module~hf_class module~cc3_class->module~ccsdpt_class module~input_output input_output module~input_output->module~ccsdpt_class module~input_output->module~utils module~input_output->module~cc3_class module~workspace workspace module~input_output->module~workspace module~input_output->module~ccsd_class module~input_output->module~ccs_class module~input_output->module~hf_class module~memory_manager_class memory_manager_class module~input_output->module~memory_manager_class module~batching_index_class batching_index_class module~input_output->module~batching_index_class module~types types module~types->module~ccsdpt_class module~types->module~utils module~types->module~cc3_class module~types->module~input_output module~types->module~workspace module~types->module~ccsd_class module~types->module~ccs_class module~types->module~hf_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~types->module~memory_manager_class module~types->module~batching_index_class module~workspace->module~ccsdpt_class module~workspace->module~cc3_class module~workspace->module~ccsd_class module~workspace->module~ccs_class module~workspace->module~hf_class module~ccsd_class->module~cc3_class module~ccs_class->module~ccsd_class module~hf_class->module~ccs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmoduleccsdpt_classUsesGraph = svgPanZoom('#moduleccsdpt_classUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Descendants: ground_state omega CCSD(T) class module\n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Used By module~~ccsdpt_class~~UsedByGraph module~ccsdpt_class ccsdpt_class program~et_program eT_program module~ccsdpt_class->program~et_program module~omega~6 omega module~ccsdpt_class->module~omega~6 module~ground_state~4 ground_state module~ccsdpt_class->module~ground_state~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces construct_omega_ccsdpt destruct_ground_state_ccsdpt Derived Types ccsdpt Subroutines init_ccsdpt calc_energy_correction_ccsdpt Interfaces interface public module subroutine construct_omega_ccsdpt (wf) Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf interface public module subroutine destruct_ground_state_ccsdpt (wf) Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf Derived Types type, public, extends( cc3 ) :: ccsdpt Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_tasks ), public :: tasks type( calc_tasks ), public :: implemented type( ground_state_specs ), public :: ground_state_specifications type( excited_state_specs ), public :: excited_state_specifications type( core_excited_state_specs ), public :: core_excited_state_specifications type( response_calc_specs ), public :: response_specifications type( memory_manager ), public :: mem integer(kind=i15), public :: n_t1am = 0 integer(kind=i15), public :: n_parameters = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public, non_overridable :: construct_ao_fock => construct_ao_fock_hf procedure, public, non_overridable :: construct_ao_fock_new => construct_ao_fock_new_hf procedure, public, non_overridable :: construct_density_matrices => construct_density_matrices_hf procedure, public, non_overridable :: construct_density_matrix => construct_density_matrix_hf procedure, public, non_overridable :: construct_density_matrix_v => construct_density_matrix_v_hf procedure, public :: drv => drv_ccs procedure, public :: ground_state_driver => ground_state_driver_ccs procedure, public :: ground_state_solver => ground_state_solver_ccs procedure, public :: ground_state_cleanup => ground_state_cleanup_ccs procedure, public, non_overridable :: diis => diis_ccs procedure, public :: calc_ampeqs => calc_ampeqs_ccs procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs procedure, public :: excited_state_driver => excited_state_driver_ccs procedure, public, non_overridable :: excited_state_solver => excited_state_solver_ccs procedure, public :: excited_state_cleanup => excited_state_cleanup_ccs procedure, public :: initialize_excited_states => initialize_excited_states_ccs procedure, public :: precondition_residual => precondition_residual_ccs procedure, public :: precondition_residual_valence => precondition_residual_valence_ccs procedure, public :: print_excited_state_info => print_excited_state_info_ccs procedure, public :: analyze_single_excitation_vector => analyze_single_excitation_vector_ccs procedure, public, non_overridable :: initialize_trial_vectors => initialize_trial_vectors_ccs procedure, public, non_overridable :: initialize_trial_vectors_valence => initialize_trial_vectors_valence_ccs procedure, public, non_overridable :: find_start_trial_indices => find_start_trial_indices_ccs procedure, public, non_overridable :: trial_vectors_from_stored_solutions => trial_vectors_from_stored_solutions_ccs procedure, public :: precondition_residual_core => precondition_residual_core_ccs procedure, public, non_overridable :: find_start_trial_indices_core => find_start_trial_indices_core_ccs procedure, public, non_overridable :: find_core_mo => find_core_mo_ccs procedure, public, non_overridable :: initialize_trial_vectors_core => initialize_trial_vectors_core_ccs procedure, public, non_overridable :: solve_reduced_eigenvalue_equation => solve_reduced_eigenvalue_equation_ccs procedure, public, non_overridable :: construct_next_trial_vectors => construct_next_trial_vectors_ccs procedure, public :: response_driver => response_driver_ccs procedure, public :: response_solver => response_solver_ccs procedure, public :: response_preparations => response_preparations_ccs procedure, public :: initialize_response => initialize_response_ccs procedure, public :: solve_reduced_response_equation => solve_reduced_response_equation_ccs procedure, public :: construct_reduced_matrix => construct_reduced_matrix_ccs procedure, public :: construct_reduced_gradient => construct_reduced_gradient_ccs procedure, public :: construct_next_response_trial_vectors => construct_next_response_trial_vectors_ccs procedure, public :: construct_gradient_vector => construct_gradient_vector_ccs procedure, public :: general_specs_reader => general_specs_reader_ccs procedure, public :: calculation_reader => calculation_reader_ccs procedure, public :: read_ground_state_specs => read_ground_state_specs_ccs procedure, public :: read_excited_state_specs => read_excited_state_specs_ccs procedure, public :: read_property_specs => read_property_specs_ccs procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs procedure, public :: get_oo_oo => get_oo_oo_ccs procedure, public :: get_oo_ov => get_oo_ov_ccs procedure, public :: get_ov_oo => get_ov_oo_ccs procedure, public :: get_oo_vo => get_oo_vo_ccs procedure, public :: get_vo_oo => get_vo_oo_ccs procedure, public :: get_oo_vv => get_oo_vv_ccs procedure, public :: get_vv_oo => get_vv_oo_ccs procedure, public :: get_ov_ov => get_ov_ov_ccs procedure, public :: get_vo_vo => get_vo_vo_ccs procedure, public :: get_ov_vo => get_ov_vo_ccs procedure, public :: get_vo_ov => get_vo_ov_ccs procedure, public :: get_ov_vv => get_ov_vv_ccs procedure, public :: get_vv_ov => get_vv_ov_ccs procedure, public :: get_vo_vv => get_vo_vv_ccs procedure, public :: get_vv_vo => get_vv_vo_ccs procedure, public :: get_vv_vv => get_vv_vv_ccs procedure, public :: get_oo_oo_electronic_repulsion => get_oo_oo_electronic_repulsion_ccs procedure, public :: get_oo_ov_electronic_repulsion => get_oo_ov_electronic_repulsion_ccs procedure, public :: get_ov_oo_electronic_repulsion => get_ov_oo_electronic_repulsion_ccs procedure, public :: get_oo_vo_electronic_repulsion => get_oo_vo_electronic_repulsion_ccs procedure, public :: get_vo_oo_electronic_repulsion => get_vo_oo_electronic_repulsion_ccs procedure, public :: get_oo_vv_electronic_repulsion => get_oo_vv_electronic_repulsion_ccs procedure, public :: get_vv_oo_electronic_repulsion => get_vv_oo_electronic_repulsion_ccs procedure, public :: get_ov_ov_electronic_repulsion => get_ov_ov_electronic_repulsion_ccs procedure, public :: get_vo_vo_electronic_repulsion => get_vo_vo_electronic_repulsion_ccs procedure, public :: get_ov_vo_electronic_repulsion => get_ov_vo_electronic_repulsion_ccs procedure, public :: get_vo_ov_electronic_repulsion => get_vo_ov_electronic_repulsion_ccs procedure, public :: get_ov_vv_electronic_repulsion => get_ov_vv_electronic_repulsion_ccs procedure, public :: get_vv_ov_electronic_repulsion => get_vv_ov_electronic_repulsion_ccs procedure, public :: get_vo_vv_electronic_repulsion => get_vo_vv_electronic_repulsion_ccs procedure, public :: get_vv_vo_electronic_repulsion => get_vv_vo_electronic_repulsion_ccs procedure, public :: get_vv_vv_electronic_repulsion => get_vv_vv_electronic_repulsion_ccs procedure, public :: store_vv_vv_electronic_repulsion => store_vv_vv_electronic_repulsion_ccs procedure, public :: read_vv_vv_electronic_repulsion => read_vv_vv_electronic_repulsion_ccs procedure, public :: t1_transform_vv_vv => t1_transform_vv_vv_ccs procedure, public :: store_t1_vv_vv_electronic_repulsion => store_t1_vv_vv_electronic_repulsion_ccs procedure, public :: store_t1_vo_ov_electronic_repulsion => store_t1_vo_ov_electronic_repulsion_ccs procedure, public :: store_t1_vv_vo_electronic_repulsion => store_t1_vv_vo_electronic_repulsion_ccs procedure, public :: store_t1_vv_ov_electronic_repulsion => store_t1_vv_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_vo_electronic_repulsion => read_t1_vv_vo_electronic_repulsion_ccs procedure, public :: read_t1_vv_vv_electronic_repulsion => read_t1_vv_vv_electronic_repulsion_ccs procedure, public :: read_t1_vo_ov_electronic_repulsion => read_t1_vo_ov_electronic_repulsion_ccs procedure, public :: read_t1_vv_ov_electronic_repulsion => read_t1_vv_ov_electronic_repulsion_ccs procedure, public, non_overridable :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure, public, non_overridable :: construct_fock => construct_fock_ccs procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs procedure, public :: jacobian_ccs_transformation => jacobian_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_ccs_a1 => jacobian_ccs_a1_ccs procedure, public, non_overridable :: jacobian_ccs_b1 => jacobian_ccs_b1_ccs procedure, public :: jacobian_transpose_ccs_transformation => jacobian_transpose_ccs_transformation_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_a1 => jacobian_transpose_ccs_a1_ccs procedure, public, non_overridable :: jacobian_transpose_ccs_b1 => jacobian_transpose_ccs_b1_ccs procedure, public :: ionized_state_driver => ionized_state_driver_ccs procedure, public :: initialize_trial_vectors_core_ionization => initialize_trial_vectors_core_ionization_ccs procedure, public :: initialize_trial_vectors_valence_ionization => initialize_trial_vectors_valence_ionization_ccs procedure, public :: precondition_residual_valence_ionization => precondition_residual_valence_ionization_ccs procedure, public :: ionization_rho_a_i_projection => ionization_rho_a_i_projection_ccs procedure, public :: precondition_residual_core_ionization => precondition_residual_core_ionization_ccs procedure, public :: cvs_rho_a_i_projection => cvs_rho_a_i_projection_ccs procedure, public :: omega_ccs_a1 => omega_ccs_a1_ccs procedure, public :: read_single_amplitudes => read_single_amplitudes_ccs procedure, public :: initialize_amplitudes => initialize_amplitudes_ccsd procedure, public :: initialize_omega => initialize_omega_ccsd procedure, public :: initialize_ground_state => initialize_ground_state_ccsd procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd procedure, public :: new_amplitudes => new_amplitudes_ccsd procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd procedure, public :: ground_state_preparations => ground_state_preparations_ccsd procedure, public :: omega_ccsd_a1 => omega_ccsd_a1_ccsd procedure, public :: omega_ccsd_b1 => omega_ccsd_b1_ccsd procedure, public :: omega_ccsd_c1 => omega_ccsd_c1_ccsd procedure, public :: omega_ccsd_a2 => omega_ccsd_a2_ccsd procedure, public :: omega_ccsd_b2 => omega_ccsd_b2_ccsd procedure, public :: omega_ccsd_c2 => omega_ccsd_c2_ccsd procedure, public :: omega_ccsd_d2 => omega_ccsd_d2_ccsd procedure, public :: omega_ccsd_e2 => omega_ccsd_e2_ccsd procedure, public :: calculate_orbital_differences => calculate_orbital_differences_ccsd procedure, public :: transform_trial_vectors => transform_trial_vectors_ccsd procedure, public :: print_excitation_vector => print_excitation_vector_ccsd procedure, public :: analyze_double_excitation_vector => analyze_double_excitation_vector_ccsd procedure, public :: summary_excited_state_info => summary_excited_state_info_ccsd procedure, public :: excited_state_preparations => excited_state_preparations_ccsd procedure, public :: jacobian_ccsd_transformation => jacobian_ccsd_transformation_ccsd procedure, public :: jacobian_ccsd_a1 => jacobian_ccsd_a1_ccsd procedure, public :: jacobian_ccsd_b1 => jacobian_ccsd_b1_ccsd procedure, public :: jacobian_ccsd_c1 => jacobian_ccsd_c1_ccsd procedure, public :: jacobian_ccsd_d1 => jacobian_ccsd_d1_ccsd procedure, public :: jacobian_ccsd_a2 => jacobian_ccsd_a2_ccsd procedure, public :: jacobian_ccsd_b2 => jacobian_ccsd_b2_ccsd procedure, public :: jacobian_ccsd_c2 => jacobian_ccsd_c2_ccsd procedure, public :: jacobian_ccsd_d2 => jacobian_ccsd_d2_ccsd procedure, public :: jacobian_ccsd_e2 => jacobian_ccsd_e2_ccsd procedure, public :: jacobian_ccsd_f2 => jacobian_ccsd_f2_ccsd procedure, public :: jacobian_ccsd_g2 => jacobian_ccsd_g2_ccsd procedure, public :: jacobian_ccsd_h2 => jacobian_ccsd_h2_ccsd procedure, public :: jacobian_ccsd_i2 => jacobian_ccsd_i2_ccsd procedure, public :: jacobian_ccsd_j2 => jacobian_ccsd_j2_ccsd procedure, public :: jacobian_ccsd_k2 => jacobian_ccsd_k2_ccsd procedure, public :: jacobi_test => jacobi_test_ccsd procedure, public :: jacobian_transpose_ccsd_transformation => jacobian_transpose_ccsd_transformation_ccsd procedure, public :: jacobian_transpose_ccsd_a1 => jacobian_transpose_ccsd_a1_ccsd procedure, public :: jacobian_transpose_ccsd_b1 => jacobian_transpose_ccsd_b1_ccsd procedure, public :: jacobian_transpose_ccsd_c1 => jacobian_transpose_ccsd_c1_ccsd procedure, public :: jacobian_transpose_ccsd_d1 => jacobian_transpose_ccsd_d1_ccsd procedure, public :: jacobian_transpose_ccsd_e1 => jacobian_transpose_ccsd_e1_ccsd procedure, public :: jacobian_transpose_ccsd_f1 => jacobian_transpose_ccsd_f1_ccsd procedure, public :: jacobian_transpose_ccsd_g1 => jacobian_transpose_ccsd_g1_ccsd procedure, public :: jacobian_transpose_ccsd_a2 => jacobian_transpose_ccsd_a2_ccsd procedure, public :: jacobian_transpose_ccsd_b2 => jacobian_transpose_ccsd_b2_ccsd procedure, public :: jacobian_transpose_ccsd_c2 => jacobian_transpose_ccsd_c2_ccsd procedure, public :: jacobian_transpose_ccsd_d2 => jacobian_transpose_ccsd_d2_ccsd procedure, public :: jacobian_transpose_ccsd_e2 => jacobian_transpose_ccsd_e2_ccsd procedure, public :: jacobian_transpose_ccsd_f2 => jacobian_transpose_ccsd_f2_ccsd procedure, public :: jacobian_transpose_ccsd_g2 => jacobian_transpose_ccsd_g2_ccsd procedure, public :: jacobian_transpose_ccsd_h2 => jacobian_transpose_ccsd_h2_ccsd procedure, public :: jacobian_transpose_ccsd_i2 => jacobian_transpose_ccsd_i2_ccsd procedure, public :: ionization_residual_projection => ionization_residual_projection_ccsd procedure, public :: ionization_rho_aibj_projection => ionization_rho_aibj_projection_ccsd procedure, public :: cvs_rho_aibj_projection => cvs_rho_aibj_projection_ccsd procedure, public :: cvs_residual_projection => cvs_residual_projection_ccsd procedure, public :: construct_eta => construct_eta_ccsd procedure, public :: save_amplitudes => save_amplitudes_ccsd procedure, public :: read_amplitudes => read_amplitudes_ccsd procedure, public :: read_double_amplitudes => read_double_amplitudes_ccsd procedure, public :: destruct_amplitudes => destruct_amplitudes_ccsd procedure, public :: destruct_omega => destruct_omega_ccsd procedure, public :: construct_perturbative_doubles => construct_perturbative_doubles_ccsd procedure, public :: calc_energy => calc_energy_ccsd procedure, public :: omega_integrals => omega_integrals_cc3 procedure, public :: calc_triples => calc_triples_cc3 procedure, public :: omega_cc3_a1 => omega_cc3_a1_cc3 procedure, public :: omega_cc3_a2 => omega_cc3_a2_cc3 procedure, public :: omega_cc3_b2 => omega_cc3_b2_cc3 procedure, public :: init => init_ccsdpt procedure, public :: construct_omega => construct_omega_ccsdpt procedure, public :: calc_energy_correction => calc_energy_correction_ccsdpt procedure, public :: destruct_ground_state => destruct_ground_state_ccsdpt Subroutines public subroutine init_ccsdpt (wf) Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf public subroutine calc_energy_correction_ccsdpt (wf) Arguments Type Intent Optional Attributes Name class( ccsdpt ) :: wf","tags":"","loc":"module/ccsdpt_class.html","title":"ccsdpt_class – The eT program"},{"text":"Ancestors: mlcc2_class Jacobian transformation submodule (MLCC2) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\nContains the following family of procedures of the MLCC2 class:\n\njacobian_transformation: Directs the transformation by A.\n\nMLCC2 contributions to jacobi transformation\n\njacobian_mlcc2_a1\njacobian_mlcc2_b1\njacobian_mlcc2_a2\njacobian_mlcc2_b2\n\nUpper case indices are general indices, lower case indices are restricted\nto the CC2 orbital space.","tags":"","loc":"module/jacobian~4.html","title":"jacobian – The eT program"},{"text":"Ancestors: mlcc2_class Omega submodule (MLCC2) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Apr 2017\n\nContains the following family of procedures of the MLCC2 class:\n\n\nconstruct_omega: constructs the projection vector omega1\n                 for the current amplitudes t1am for the\n                 wavefunction object wf. \n                 The routine assumes that the projection\n                 vector is allocated.\n\nomega_a1:  adds A1 term to omega1\nomega_b1:  adds B1 term to omega1\n\n\nUpper case indices are general indices, lower case indices are restricted\nto the CC2 orbital space.","tags":"","loc":"module/omega.html","title":"omega – The eT program"},{"text":"Ancestors: mlcc2_class Excited state submodule (MLCC2) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\nContains the following family of procedures of the MLCC2 class:\n\ninititialize_excited_states: Initializes number of s2 amplitudes (n_x2am), and adds it n_parameters\ncalculate_orbital_differences: Calculates the orbital differences, including the double excitation differences \n                               in the active CC2 spaces\ntransform_trial_vectors: Transforms the new trial vectors. rho = Ac\n\nUpper case indices are general indices, lower case indices are restricted\nto the CC2 orbital space.","tags":"","loc":"module/excited_state~4.html","title":"excited_state – The eT program"},{"text":"Ancestors: mlcc2_class Uses: input_reader module~~input_reader~3~~UsesGraph module~input_reader~3 input_reader module~input_reader input_reader module~input_reader->module~input_reader~3 module~mlcc2_class mlcc2_class module~input_reader->module~mlcc2_class module~mlcc_orbitals_class mlcc_orbitals_class module~input_reader->module~mlcc_orbitals_class module~workspace workspace module~workspace->module~input_reader module~workspace->module~mlcc2_class module~ccs_class ccs_class module~workspace->module~ccs_class module~hf_class hf_class module~workspace->module~hf_class module~types types module~types->module~input_reader module~types->module~workspace module~input_output input_output module~types->module~input_output module~types->module~mlcc2_class module~types->module~ccs_class module~types->module~mlcc_orbitals_class module~utils utils module~types->module~utils module~mlcc_calculation_settings_class mlcc_calculation_settings_class module~types->module~mlcc_calculation_settings_class module~types->module~hf_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~memory_manager_class memory_manager_class module~types->module~memory_manager_class module~batching_index_class batching_index_class module~types->module~batching_index_class module~input_output->module~input_reader module~input_output->module~workspace module~input_output->module~mlcc2_class module~input_output->module~ccs_class module~input_output->module~utils module~input_output->module~hf_class module~input_output->module~memory_manager_class module~input_output->module~batching_index_class module~mlcc2_class->module~input_reader~3 module~ccs_class->module~mlcc2_class module~mlcc_orbitals_class->module~mlcc2_class module~utils->module~mlcc2_class module~utils->module~ccs_class module~utils->module~hf_class module~mlcc_calculation_settings_class->module~mlcc2_class module~hf_class->module~ccs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmoduleinput_reader3UsesGraph = svgPanZoom('#moduleinput_reader3UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Input reader submodule (MLCC2)\nWritten by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017\n\nContains the following family of procedures of the MLCC2 class:","tags":"","loc":"module/input_reader~3.html","title":"input_reader – The eT program"},{"text":"Ancestors: mlcc2_class Orbital partitioning submodule (MLCC2) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Apr 2017\n\nContains the following family of procedures of the MLCC2 class:\n\norbital_partitioning:         Directs the orbital partitioning\ncholesky_localization_drv:    Directs orbital localization by cholesky decomposition  \ncholesky_orbital_constructor: Directs construction of new orbitals                     \ncholesky_decomposition:       Cholesky decomposes the density\ncholesky_orbitals:            Constructs new orbitals (C matrix) from cholesky vectors\n\ncnto_orbital_drv:             \ncc2_cnto:\n\nContains the following module subroutines and functions: These should eventually be moved to some \n                                                   utils !\n\nget_number_of_active_spaces:     Returns number of active spaces from cholesky.inp\nget_number_of_active_atoms:      Returns number of active atoms from cholesky.inp\nget_active_atoms:                Returns the indices of the active atoms from cholesky.inp\nconstruct_active_ao_index_list:  Returns active_ao_index_list to be used as pivoting elements in cholesky decomposition\nread_atom_info:                  Reads info from dalton, n_nuclei and n_ao\nread_center_info:                Reads info from dalton, which aos belong to which nuclei","tags":"","loc":"module/orbital_partitioning.html","title":"orbital_partitioning – The eT program"},{"text":"Ancestors: mlccsd_class Jacobian transformation submodule (MLCCSD) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Aug 2017","tags":"","loc":"module/jacobian~5.html","title":"jacobian – The eT program"},{"text":"Ancestors: mlccsd_class","tags":"","loc":"module/omega~5.html","title":"omega – The eT program"},{"text":"Ancestors: mlccsd_class Ground state submodule (MLCCSD)\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n\n Consists of the following module subroutines of the MLCCSD module:\n\n new_amplitudes:             Calculates the quasi-Newton estimate and passes the \n                             information needed by the DIIS routine.\n calc_ampeqs_norm:           Calculates the norm of the amplitude equations.\n calc_quasi_Newton_doubles:  Calculates the doubles part of the quasi-Newton estimate.\n initialize_ground_state:    Initializes the amplitudes (MP2 estimate) and the amplitude \n                             equations.","tags":"","loc":"module/ground_state~3.html","title":"ground_state – The eT program"},{"text":"Ancestors: mlccsd_class Cholesky submodule (MLCCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017","tags":"","loc":"module/cholesky~2.html","title":"cholesky – The eT program"},{"text":"Ancestors: mlccsd_class Excited state submodule (MLCCSD) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Aug 2017","tags":"","loc":"module/excited_state~5.html","title":"excited_state – The eT program"},{"text":"Ancestors: mlccsd_class Uses: input_reader module~~input_reader~4~~UsesGraph module~input_reader~4 input_reader module~input_reader input_reader module~input_reader->module~input_reader~4 module~mlccsd_class mlccsd_class module~input_reader->module~mlccsd_class module~mlcc2_class mlcc2_class module~input_reader->module~mlcc2_class module~mlcc_orbitals_class mlcc_orbitals_class module~input_reader->module~mlcc_orbitals_class module~workspace workspace module~workspace->module~input_reader module~workspace->module~mlccsd_class module~workspace->module~mlcc2_class module~ccs_class ccs_class module~workspace->module~ccs_class module~hf_class hf_class module~workspace->module~hf_class module~types types module~types->module~input_reader module~types->module~workspace module~input_output input_output module~types->module~input_output module~types->module~mlccsd_class module~utils utils module~types->module~utils module~types->module~mlcc2_class module~types->module~ccs_class module~types->module~mlcc_orbitals_class module~mlcc_calculation_settings_class mlcc_calculation_settings_class module~types->module~mlcc_calculation_settings_class module~types->module~hf_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~memory_manager_class memory_manager_class module~types->module~memory_manager_class module~batching_index_class batching_index_class module~types->module~batching_index_class module~input_output->module~input_reader module~input_output->module~workspace module~input_output->module~mlccsd_class module~input_output->module~utils module~input_output->module~mlcc2_class module~input_output->module~ccs_class module~input_output->module~hf_class module~input_output->module~memory_manager_class module~input_output->module~batching_index_class module~mlccsd_class->module~input_reader~4 module~utils->module~mlccsd_class module~utils->module~mlcc2_class module~utils->module~ccs_class module~utils->module~hf_class module~mlcc2_class->module~mlccsd_class module~ccs_class->module~mlcc2_class module~mlcc_orbitals_class->module~mlcc2_class module~mlcc_calculation_settings_class->module~mlcc2_class module~hf_class->module~ccs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmoduleinput_reader4UsesGraph = svgPanZoom('#moduleinput_reader4UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Input reader submodule (mlccsd)\nWritten by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017\n\nContains the following family of procedures of the mlccsd class:","tags":"","loc":"module/input_reader~4.html","title":"input_reader – The eT program"},{"text":"Ancestors: mlccsd_class Orbital partitioning submodule (MLCCSD) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Apr 2017\n\nContains the following family of procedures of the MLCCSD class:","tags":"","loc":"module/orbital_partitioning~2.html","title":"orbital_partitioning – The eT program"},{"text":"Ancestors: cc3_class Omega submodule (CC3)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nContains the following subroutines:\n\nconstruct_omega: constructs the projection vector by adding the CC3 \n                 and CCSD contributions to omega1 and omega2. \nomega_integrals: constructs the integrals needed for the CC3 contributions,\n                 and saves them to disk.\nomega_cc3_a1:    adds the A1 term to omega1 (for a given i, j, and k).\nomega_cc3_a2:    adds the A2 term to omega2 (for a given i, j, and k).\nomega_cc3_b2:    adds the B2 term to omega2 (for a given i, j, and k).\n\nThe submodule was based on the MLCC3 routines implemented by Rolf H. Myhre\nand Henrik Koch in the Dalton quantum chemistry program.\n\nNote: the construction of omega has not yet been optimized, and is rather\nslow. Among other things, the factor of 1/6 (i >= j >= k) that can be saved\nin the construction of t_ijk&#94;abc has not been implemented. Todo.","tags":"","loc":"module/omega~4.html","title":"omega – The eT program"},{"text":"Ancestors: ccsd_class Ionized state submodule(CCSD)\nWritten by Eirik F. Kjønstad and Sarai Dery Folkestad, October 2017\n\nContains the following family of procedures of the CCS class:","tags":"","loc":"module/ionized_state~2.html","title":"ionized_state – The eT program"},{"text":"Ancestors: ccsd_class Jacobian submodule ( CCSD ) Written by Eirik F . Kj ø nstad and Sarai Dery Folkestad , May 2017 Contains the following family of procedures of the CCS class : jacobian_transformation : performs the transformation by the CCSD Jacobian matrix A , placing the result in the incoming vector . jacobian_ccsd_x1 : adds the X1 term to the transformed singles vector ; x = a , b , c , d jacobian_ccsd_x2 : adds the X2 term to the transformed doubles vector ; x = a , b , ..., k","tags":"","loc":"module/jacobian~3.html","title":"jacobian – The eT program"},{"text":"Ancestors: ccsd_class Jacobian transpose submodule ( CCSD ) Written by Eirik F . Kj ø nstad and Sarai D . Folkestad , June 2017 Contains the following family of procedures of the CCSD class : jacobian_transpose_ccsd_transformation : performs the transformation by the CCSD Jacobian transpose matrix A &#94; T , placing the result in the incoming vector . jacobian_transpose_ccsd_x1 : adds the X1 term to the transformed singles vector ; x = a , b , c , ..., g jacobian_transpose_ccsd_x2 : adds the X2 term to the transformed doubles vector ; x = a , b , ..., i","tags":"","loc":"module/jacobian_transpose~2.html","title":"jacobian_transpose – The eT program"},{"text":"Ancestors: ccsd_class Uses: batching_index_class module~~omega~3~~UsesGraph module~omega~3 omega module~batching_index_class batching_index_class module~batching_index_class->module~omega~3 module~memory_manager_class memory_manager_class module~batching_index_class->module~memory_manager_class module~types types module~types->module~batching_index_class module~input_output input_output module~types->module~input_output module~ccsd_class ccsd_class module~types->module~ccsd_class module~utils utils module~types->module~utils module~ccs_class ccs_class module~types->module~ccs_class module~workspace workspace module~types->module~workspace module~hf_class hf_class module~types->module~hf_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~types->module~memory_manager_class module~input_output->module~batching_index_class module~input_output->module~ccsd_class module~input_output->module~utils module~input_output->module~ccs_class module~input_output->module~workspace module~input_output->module~hf_class module~input_output->module~memory_manager_class module~ccsd_class->module~omega~3 module~utils->module~ccsd_class module~utils->module~ccs_class module~utils->module~hf_class module~ccs_class->module~ccsd_class module~workspace->module~ccsd_class module~workspace->module~ccs_class module~workspace->module~hf_class module~hf_class->module~ccs_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class var panmoduleomega3UsesGraph = svgPanZoom('#moduleomega3UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Omega submodule (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n\nContains the following family of procedures of the CCSD class:\n\ninitialize_omega: allocates the projection vector (omega1, omega2)\n                      and sets it to zero.\n\nconstruct_omega:  constructs the projection vector (omega1, omega2) \n                      for the current amplitudes (t1am, t2am) for the\n                      wavefunction object wf. The routine assumes that\n                      the projection vector is allocated.\n\nomega_ccsd_a1:         adds A1 term to omega1\nomega_ccsd_b1:         adds B1 term to omega1\nomega_ccsd_c1:         adds C1 term to omega1\n\nomega_ccsd_a2:         adds A2 term to omega2\nomega_ccsd_b2:         adds B2 term to omega2\nomega_ccsd_c2:         adds C2 term to omega2\nomega_ccsd_d2:         adds D2 term to omega2\nomega_ccsd_e2:         adds E2 term to omega2","tags":"","loc":"module/omega~3.html","title":"omega – The eT program"},{"text":"Ancestors: ccsd_class Ground state submodule (CCSD)\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n\n Consists of the following module subroutines of the CCSD module:\n\n new_amplitudes:             Calculates the quasi-Newton estimate and passes the \n                             information needed by the DIIS routine.\n calc_ampeqs_norm:           Calculates the norm of the amplitude equations.\n calc_quasi_Newton_doubles:  Calculates the doubles part of the quasi-Newton estimate.\n initialize_ground_state:    Initializes the amplitudes (MP2 estimate) and the amplitude \n                             equations.\n\n Can be inherited by models of the same level (e.g. CC3) without modification.\n\n When inherited by higher level models (e.g. CCSDT), the new_amplitudes and calc_ampeqs_norm\n routines should be overridden to account for the triples quasi-Newton estimate, amplitudes, \n and projection vector.","tags":"","loc":"module/ground_state~2.html","title":"ground_state – The eT program"},{"text":"Ancestors: ccsd_class Excited state  submodule (CCSD)\nWritten by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017\n\nContains the following family of procedures of the CCSD class:\n\ncalculate_orbital_differences: calculates the orbital energy differences.\ntransform_trial_vectors:       transform trial vectors by the Jacobian (or Jacobian&#94;T).","tags":"","loc":"module/excited_state~2.html","title":"excited_state – The eT program"},{"text":"Ancestors: ccsd_class CVS submodule(CCSD)\nWritten by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017\n\nContains the CVS routines for the CCSD class.\nNote that this submodule contains both excited state routines and jacobian transformation routines.","tags":"","loc":"module/cvs~2.html","title":"cvs – The eT program"},{"text":"Ancestors: cc2_class jacobian transformation submodule (cc2)) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, September 2017\n\ncontains the following family of procedures of the cc2 class:\n\njacobian_transformation: Directs the transformation by a.\n\ncc2 contributions to jacobi transformation\n\njacobian_cc2_a1\njacobian_cc2_b1\njacobian_cc2_a2\njacobian_cc2_b2\n\nUpper case indices are general indices, lower case indices are restricted\nto the cc2 orbital space.","tags":"","loc":"module/jacobian~2.html","title":"jacobian – The eT program"},{"text":"Ancestors: cc2_class Omega submodule (CC2) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Apr 2017\n\nContains the following family of procedures of the CC2 class:\n\ninitialize_omega: allocates the projection vector omega1\n                  and sets it to zero.\n\nconstruct_omega: constructs the projection vector omega1\n                 for the current amplitudes t1am for the\n                 wavefunction object wf. \n                 The routine assumes that the projection\n                 vector is allocated.\n\nomega_a1:  adds A1 term to omega1\nomega_b1:  adds B1 term to omega1\nomega_c1:  adds C1 term to omega1","tags":"","loc":"module/omega~2.html","title":"omega – The eT program"},{"text":"Ancestors: cc2_class Excited state submodule (CC2) \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\nContains the following family of procedures of the CC2 class:\n\ninititialize_excited_states: Initializes number of s2 amplitudes (n_s2am), and adds it n_parameters\ncalculate_orbital_differences: Calculates the orbital differences, including the double excitation differences \n                               in the active CC2 spaces\ntransform_trial_vectors: Transforms the new trial vectors. rho = Ac\n\nUpper case indices are general indices, lower case indices are restricted\nto the CC2 orbital space.","tags":"","loc":"module/excited_state~3.html","title":"excited_state – The eT program"},{"text":"Ancestors: ccsdpt_class Omega submodule (CCSD(T))\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n\nContains the following procedures of the CCSD(T) class:\n\nconstruct_omega:  constructs the projection vector (omega1, omega2).\n                  Calls the CCSD construction of omega (not CC3, its \n                  immediate parent).","tags":"","loc":"module/omega~6.html","title":"omega – The eT program"},{"text":"Ancestors: ccsdpt_class Ground state submodule (CCSD(T))\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n\n Consists of the following subroutines of the CCSD(T) module:\n\n destruct_ground_state: before destroying the converged CCSD amplitudes,\n                        the non-iterative CCSD(T) correction is to be added\n                        to the energy (call wf%calc_energy_correction).","tags":"","loc":"module/ground_state~4.html","title":"ground_state – The eT program"},{"text":"Ancestors: ccs_class Ionized state submodule ( CCS ) Written by Eirik F . Kjønstad and Sarai Dery Folkestad , October 2017 Contains the CCS class routines for ionization , both core and valence . Note that this submodule contains both excited state routines and jacobian transformation routines . -::- Subroutines in this submodule -::- ionized_state_driver - Driver for ionized state calculation initialize_trial_vectors_valence_ionization - Initializes trial vectors for valence ionization calculation initialize_trial_vectors_core_ionization - Initializes trial vectors for core ionization calculation precondition_residual_valence_ionization - Projects out contamination ( regular excitations ) and preconditions uncontaminated residual ionization_residual_projection - Projects out contamination ( regular excitations ) from residual ionization_rho_a_i_projection - Projection routine for rho_a_i ( valence contributions and regular excitations ) are projected out precondition_residual_core_ionization - Projects out contaminations ( valence contributiona and regular excitations ) and preconditions uncontaminated residual","tags":"","loc":"module/ionized_state.html","title":"ionized_state – The eT program"},{"text":"Ancestors: ccs_class Jacobian submodule (CCS)\nWritten by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017\n\nContains the following family of procedures of the CCS class:\n\njacobian_ccs_transformation: directs the transformation by A.\njacobian_ccs_a1:             adds the A1 term to the transformed vector. \njacobian_ccs_b1:             adds the B1 term to the transformed vector.","tags":"","loc":"module/jacobian.html","title":"jacobian – The eT program"},{"text":"Ancestors: ccs_class Jacobian transpose submodule (CCS)\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, June 2017\n\nContains the following family of procedures of the CCS class:\n\njacobian_transpose_ccs_transformation: performs the transposed Jacobian transformation (A&#94;T)\njacobian_transpose_ccs_a1:             adds the CCS A1 term for the A&#94;T transformation \njacobian_transpose_ccs_b1:             adds the CCS B1 term for the A&#94;T transformation","tags":"","loc":"module/jacobian_transpose.html","title":"jacobian_transpose – The eT program"},{"text":"Ancestors: ccs_class Ground state submodule (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nConsists of the following module subroutines of the CCS:\n\nground_state_solver:        Controls the iterative loop, calling in turn\n                            the calculation of the energy, the amplitude equations \n                            (and its norm), and the new_amplitudes routine.\n\nnew_amplitudes:             Calculates the quasi-Newton estimate and passes the \n                            information needed by the DIIS routine.\n\ndiis_ccs:                   This routine saves the quasi-Newton estimate Δ t and\n                            t + Δ t to file. It uses the previous estimates to\n                            select the amplitudes t for the next iteration.\n\n\ncalc_ampeqs:                Updates the amplitude equations for the current amplitudes.\ncalc_ampeqs_norm:           Calculates the norm of the amplitude equations.\ncalc_quasi_Newton_singles:  Calculates the singles part of the quasi-Newton estimate.\ninitialize_ground_state:    Initializes the amplitudes and the amplitude equations.\ndestruct_ground_state:      Deallocates the amplitudes and the amplitude equations.\n\nCan be inherited by models of the same level (e.g. CC2) without modification.\n\nWhen inherited by higher level models (e.g. CCSD), the new_amplitudes and calc_ampeqs_norm\nroutines should be overridden to account for the doubles quasi-Newton estimate, amplitudes, \nand projection vector. Non-standard CC methods may need to override the initialize_ground_state\nand destruct_ground_state.","tags":"","loc":"module/ground_state.html","title":"ground_state – The eT program"},{"text":"Ancestors: ccs_class Cholesky sub ( CCS ) Written by Sarai D . Folkestad and Eirik F . Kjønstad , Apr 2017 Contains the following family of procedures of the CCS class: get_cholesky_ij ( L_ij_J ): returns the T1-transformed Cholesky vector L_ij &#94; J get_cholesky_ia ( L_ia_J ): returns the T1-transformed Cholesky vector L_ia &#94; J get_cholesky_ai ( L_ai_J ): returns the T1-transformed Cholesky vector L_ai &#94; J get_cholesky_ab ( L_ab_J , ...): returns the T1-transformed Cholesky vector L_ab &#94; J , but has options (...) for batching over the two indices a and b","tags":"","loc":"module/cholesky.html","title":"cholesky – The eT program"},{"text":"Ancestors: ccs_class Excited state sub(CCS)\nWritten by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017\n\nContains the following family of procedures of the CCS class:\n\nexcited_state_driver:                directs the solution of excited state problems.\nexcited_state_solver:                solves the excited state problem.\nsolve_reduced_eigenvalue_equation:   solves the excited state problem in the projected/reduced space \n                                     of trial vectors (in a given iteration).\nconstruct_next_trial_vectors:        finds the new trial vectors resulting from the residuals found \n                                     by solving the reduced eigenvalue equation.\ncalculate_orbital_differences:       calculates the orbital differences (used for preconditioning and\n                                     start vector guess).\ntransform_trial_vectors:             transforms (by A) the new trial vectors and saves them to disk.\nfind_start_trial_indices:            find the indices corresponding to the lowest orbital differences.\ntrial_vectors_from_stored_solutions: finds suitable start trial vectors from stored solutions (for restart).","tags":"","loc":"module/excited_state.html","title":"excited_state – The eT program"},{"text":"Ancestors: ccs_class Fock submodule\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nContains the following family of procedures of the CCS class:\n\ninitialize_fock_matrix_ccs(wf):     Allocates and sets Fock matrix to 0.      \nconstruct_fock_ccs(wf):             Constructs T1_transformed mo Fock matrix.\none_electron_t1_ccs(wf, h1 ,h1_T1): T1-transformation of one-electron mo integrals.","tags":"","loc":"module/fock.html","title":"fock – The eT program"},{"text":"Ancestors: ccs_class Response submodule (CCS)\nWritten by Eirik F. Kjønstad and Sarai Dery Folkestad, June 2017\n\nContains the following family of procedures of the CCS class:\n\nresponse_driver:                       directs the solution of molecular properties.\nresponse_solver:                       solves for a particular molecular property.\ninitialize_response:                   finds a suitable start trial vector & requests the construction \n                                       of the so-called response gradient vector (F).\nsolve_reduced_response_equation:       solves the response equation in the reduced space\n                                       of trial vectors (in the given iteration).\nconstruct_gradient_vector:             constructs the gradient vector (F) & saves it to disk.\nconstruct_next_response_trial_vectors: finds the next trial vectors from the residual resulting\n                                       from the reduced space solution. \nconstruct_reduced_matrix:              constructs the reduced matrix (the reduced Jacobian, or Jacobian&#94;T).\nconstruct_reduced_gradient:            constructs the reduced gradient vector.\n\nNote: in order to implement new properties, changes needs to be made in the \"transform_trial_vectors\"\nand \"construct_gradient_vector\" routines. The behavior of these routines are governed by the value of\nthe \"response_task\" string, which must be set in the response driver.","tags":"","loc":"module/response.html","title":"response – The eT program"},{"text":"Ancestors: ccs_class CVS submodule ( CCS ) Written by Eirik F . Kjønstad and Sarai Dery Folkestad , May 2017 Contains the CVS routines for the CCS class and routines for core excitations . Note that this submodule contains both excited state routines and jacobian transformation routines . -::- Subroutines in this submodule -::- initialize_trial_vectors_core - Driver for initialization of trial vectors find_start_trial_indices_core - Finds indices of single core excitations of lowest energy to be used for start vectors precondition_residual_core - Projects out contamination ( valence contributions ) and preconditions uncontaminated residual cvs_residual_projection - Projection routine for residual core_jacobian_ccs_transformation - Jacobian transformation where contamination ( valence contributions ) is projected out cvs_rho_a_i_projection - Projection routine for rho_a_i Helper subroutines : find_core_mo - identifies the mo - index of the core orbital of interest .","tags":"","loc":"module/cvs.html","title":"cvs – The eT program"},{"text":"Ancestors: ccs_class Uses: input_reader module~~input_reader~2~~UsesGraph module~input_reader~2 input_reader module~input_reader input_reader module~input_reader->module~input_reader~2 module~workspace workspace module~workspace->module~input_reader module~ccs_class ccs_class module~workspace->module~ccs_class module~hf_class hf_class module~workspace->module~hf_class module~types types module~types->module~input_reader module~types->module~workspace module~input_output input_output module~types->module~input_output module~types->module~ccs_class module~types->module~hf_class module~utils utils module~types->module~utils module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~memory_manager_class memory_manager_class module~types->module~memory_manager_class module~batching_index_class batching_index_class module~types->module~batching_index_class module~input_output->module~input_reader module~input_output->module~workspace module~input_output->module~ccs_class module~input_output->module~hf_class module~input_output->module~utils module~input_output->module~memory_manager_class module~input_output->module~batching_index_class module~ccs_class->module~input_reader~2 module~hf_class->module~ccs_class module~utils->module~ccs_class module~utils->module~hf_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panmoduleinput_reader2UsesGraph = svgPanZoom('#moduleinput_reader2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Input reader submodule (CCS)\nWritten by Eirik F. Kjønstad and Sarai Dery Folkestad, May 2017\n\nContains the following family of procedures of the CCS class:","tags":"","loc":"module/input_reader~2.html","title":"input_reader – The eT program"},{"text":"Ancestors: ccs_class Integrals submodule (CCS)\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Sep 2017\n\nContains procedures for construction of general integrals, and \nspecifically:\n\n- electronic repulsion integrals\n- (...no other integrals yet...)\n\no - occupied index\nv - virtual index\n\nNote: for normal use, the get_pq_rs routines should be called. These\nwill call the appropriate routines for constructing (or reading) the integrals.\nFor example,\n\n   integral_type = 'electronic_repulsion'\n   call wf%get_vo_vo(integral_type, g_ai_bj)\n\nwill place the T1-transformed g_aibj integrals in the g_ai_bj array.\nThe indices may also be restricted (though this is optional):\n\n   integral_type = 'electronic_repulsion'\n   call wf%get_vo_vo(integral_type, g_ai_bj, a_first, a_last, i_first, i_last, ...)","tags":"","loc":"module/integrals.html","title":"integrals – The eT program"},{"text":"Uses: input_output input_reader hf_class mp2_class ccs_class cc2_class ccsd_class cc3_class ccsdpt_class mlcc2_class mlccsd_class program~~et_program~~UsesGraph program~et_program eT_program module~ccs_class ccs_class module~ccs_class->program~et_program module~cc2_class cc2_class module~ccs_class->module~cc2_class module~ccsd_class ccsd_class module~ccs_class->module~ccsd_class module~mlcc2_class mlcc2_class module~ccs_class->module~mlcc2_class module~mlccsd_class mlccsd_class module~mlccsd_class->program~et_program module~mp2_class mp2_class module~mp2_class->program~et_program module~cc3_class cc3_class module~cc3_class->program~et_program module~ccsdpt_class ccsdpt_class module~cc3_class->module~ccsdpt_class module~input_reader input_reader module~input_reader->program~et_program module~input_reader->module~mlccsd_class module~input_reader->module~mlcc2_class module~mlcc_orbitals_class mlcc_orbitals_class module~input_reader->module~mlcc_orbitals_class module~cc2_class->program~et_program module~ccsd_class->program~et_program module~ccsd_class->module~cc3_class module~mlcc2_class->program~et_program module~mlcc2_class->module~mlccsd_class module~ccsdpt_class->program~et_program module~input_output input_output module~input_output->program~et_program module~input_output->module~ccs_class module~input_output->module~mlccsd_class module~input_output->module~mp2_class module~input_output->module~cc3_class module~input_output->module~input_reader module~input_output->module~cc2_class module~input_output->module~ccsd_class module~input_output->module~mlcc2_class module~input_output->module~ccsdpt_class module~hf_class hf_class module~input_output->module~hf_class module~utils utils module~input_output->module~utils module~workspace workspace module~input_output->module~workspace module~memory_manager_class memory_manager_class module~input_output->module~memory_manager_class module~batching_index_class batching_index_class module~input_output->module~batching_index_class module~hf_class->program~et_program module~hf_class->module~ccs_class module~hf_class->module~mp2_class module~utils->module~ccs_class module~utils->module~mlccsd_class module~utils->module~mp2_class module~utils->module~cc3_class module~utils->module~cc2_class module~utils->module~ccsd_class module~utils->module~mlcc2_class module~utils->module~ccsdpt_class module~utils->module~hf_class module~types types module~types->module~ccs_class module~types->module~mlccsd_class module~types->module~mp2_class module~types->module~cc3_class module~types->module~input_reader module~types->module~cc2_class module~types->module~ccsd_class module~types->module~mlcc2_class module~types->module~ccsdpt_class module~types->module~input_output module~types->module~hf_class module~types->module~utils module~types->module~workspace module~types->module~mlcc_orbitals_class module~mlcc_calculation_settings_class mlcc_calculation_settings_class module~types->module~mlcc_calculation_settings_class module~ground_state_specs_class ground_state_specs_class module~types->module~ground_state_specs_class module~calc_settings_class calc_settings_class module~types->module~calc_settings_class module~response_calc_specs_class response_calc_specs_class module~types->module~response_calc_specs_class module~excited_state_specs_class excited_state_specs_class module~types->module~excited_state_specs_class module~calc_tasks_class~2 calc_tasks_class module~types->module~calc_tasks_class~2 module~core_excited_state_specs_class core_excited_state_specs_class module~types->module~core_excited_state_specs_class module~types->module~memory_manager_class module~types->module~batching_index_class module~workspace->module~ccs_class module~workspace->module~mlccsd_class module~workspace->module~mp2_class module~workspace->module~cc3_class module~workspace->module~input_reader module~workspace->module~cc2_class module~workspace->module~ccsd_class module~workspace->module~mlcc2_class module~workspace->module~ccsdpt_class module~workspace->module~hf_class module~mlcc_orbitals_class->module~mlcc2_class module~mlcc_calculation_settings_class->module~mlcc2_class module~ground_state_specs_class->module~hf_class module~calc_settings_class->module~hf_class module~response_calc_specs_class->module~hf_class module~excited_state_specs_class->module~hf_class module~calc_tasks_class~2->module~hf_class module~core_excited_state_specs_class->module~hf_class module~memory_manager_class->module~hf_class module~batching_index_class->module~memory_manager_class var panprogramet_programUsesGraph = svgPanZoom('#programet_programUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. eT - a coupled cluster program                                \n     Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 Calls program~~et_program~~CallsGraph program~et_program eT_program work_init work_init program~et_program->work_init proc~generate_unit_identifier generate_unit_identifier program~et_program->proc~generate_unit_identifier proc~method_reader method_reader program~et_program->proc~method_reader proc~remove_preceding_blanks remove_preceding_blanks proc~method_reader->proc~remove_preceding_blanks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables mp2_wf ccs_wf cc2_wf ccsd_wf cc3_wf ccsdpt_wf mlcc2_wf mlccsd_wf wf method unit_input orbital_level Variables Type Attributes Name Initial type( mp2 ), allocatable, target :: mp2_wf type( ccs ), allocatable, target :: ccs_wf type( cc2 ), allocatable, target :: cc2_wf type( ccsd ), allocatable, target :: ccsd_wf type( cc3 ), allocatable, target :: cc3_wf type( ccsdpt ), allocatable, target :: ccsdpt_wf type( mlcc2 ), allocatable, target :: mlcc2_wf type( mlccsd ), allocatable, target :: mlccsd_wf class( hf ), pointer :: wf => null() character(len=40) :: method integer(kind=i15) :: unit_input = -1 character(len=13) :: orbital_level","tags":"","loc":"program/et_program.html","title":"eT_program – The eT program"}]}