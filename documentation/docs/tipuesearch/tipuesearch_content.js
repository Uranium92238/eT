var tipuesearch = {"pages":[{"text":"Fortran Program Developer Info Eirik F. Kjønstad and Sarai D. Folkestad","tags":"","loc":"index.html","title":" Fortran Program "},{"text":"Modules calc_procedures_class Source Code calc_procedures_class.F90 Source Code module calc_procedures_class ! !! !!                       Calculation procedures class module !!            Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    The procedures class is used for two purposes. Wavefunctions possess !!    \"implemented\" and \"tasks\" objects, which are both instances of the class !!    calculation procedures. If one of the tasks requested is not implemented !!    for the wavefunction in question, the program stops, letting the user know !!    that the requested functionality is not a part of eT (yet). !! !!    Tasks are determined during the read of the input (see the main program). !!    Implemented are set by the wavefunction's initialization routine. !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  ::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the calc_procedures class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::: ! type :: calc_procedures ! logical :: do_ground_state = . false . logical :: do_excited_state = . false . logical :: do_properties = . false . ! integer ( i15 ) :: n_singlet_states = 0 integer ( i15 ) :: n_triplet_states = 0 ! end type calc_procedures ! contains ! end module calc_procedures_class","tags":"","loc":"sourcefile/calc_procedures_class.f90.html","title":"calc_procedures_class.F90 – Fortran Program"},{"text":"Modules calc_settings_class Source Code calc_settings_class.F90 Source Code module calc_settings_class ! !! !!                         Calculation settings class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! use types ! !  ::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Definition of the calc_settings class -::- !  ::::::::::::::::::::::::::::::::::::::::::::::: ! type :: calc_settings ! real ( dp ) :: energy_threshold = 1.0D-06 real ( dp ) :: ampeqs_threshold = 1.0D-06 ! integer ( i15 ) :: ampeqs_max_iterations = 25 ! end type calc_settings ! contains ! end module calc_settings_class","tags":"","loc":"sourcefile/calc_settings_class.f90.html","title":"calc_settings_class.F90 – Fortran Program"},{"text":"Modules ccs_class Source Code ccs_class.F90 Source Code module ccs_class ! !! !!              Coupled cluster singles (CCS) class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output ! !  The ancestor class module (HF) ! use hf_class ! implicit none ! !  ::::::::::::::::::::::::::::::::::::: !  -::- Definition of the CCS class -::- !  ::::::::::::::::::::::::::::::::::::: ! type , extends ( hf ) :: ccs ! !     Amplitude attributes ! integer ( i15 ) :: n_t1am = 0 ! Number of singles amplitudes real ( dp ), dimension (:,:), allocatable :: t1am ! Singles amplitude vector ! !     Projection vector < mu | exp(-T) H exp(T) | R > (the omega vector) ! real ( dp ), dimension (:,:), allocatable :: omega1 ! Singles vector ! !     The T1-transformed Fock matrix (in vir-occ block form) ! real ( dp ), dimension (:,:), allocatable :: fock_ij ! occ-occ block real ( dp ), dimension (:,:), allocatable :: fock_ia ! occ-vir block real ( dp ), dimension (:,:), allocatable :: fock_ai ! vir-occ block real ( dp ), dimension (:,:), allocatable :: fock_ab ! vir-vir block ! contains ! !     Initialization and driver routines ! procedure :: init => init_ccs procedure :: drv => drv_ccs ! !     Initialization routine for the (singles) amplitudes ! procedure :: initialize_amplitudes => initialize_amplitudes_ccs ! !     Routine to initialize omega (allocate and set to zero) ! procedure :: initialize_omega => initialize_omega_ccs ! !     Initialization routine for the Fock matrix, and a Fock matrix constructor !     (for the given T1 amplitudes) ! procedure :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure , non_overridable :: construct_fock => construct_fock_ccs ! procedure , non_overridable :: one_electron_t1 => one_electron_t1_ccs ! T1-transf. of h_pq ! !     Routine to calculate the energy (trivial: it is the SCF energy) ! procedure :: calc_energy => calc_energy_ccs ! !     get Cholesky routines to calculate the occ/vir-occ/vir  blocks of the !     T1-transformed Cholesky vectors ! procedure , non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs ! occ-occ procedure , non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs ! occ-vir procedure , non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs ! vir-occ procedure , non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs ! vir-vir ! !     Routine to construct projection vector (omega) ! procedure :: construct_omega => construct_omega_ccs ! !     Ground state solver routines (and helpers) ! !     Note: while this solver is strictly uneccessary for CCS, where the solution !           is trivial, it is inherited mostly unaltered by descendants (CCSD, CC2, !           etc.), where it serves an actual role. ! procedure :: ground_state_solver => ground_state_solver_ccs ! procedure :: new_amplitudes => new_amplitudes_ccs procedure :: calc_ampeqs => calc_ampeqs_ccs procedure :: calc_ampeqs_norm => calc_ampeqs_norm_ccs procedure :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs ! procedure , non_overridable :: diis => diis_ccs ! ! end type ccs ! !  :::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Interface to the submodule routines of CCS -::- !  :::::::::::::::::::::::::::::::::::::::::::::::::::: ! interface ! ! module subroutine get_cholesky_ij_ccs ( wf , L_ij_J ) !! !!       Get Cholesky IJ !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Reads and T1-transforms the IA Cholesky vectors: !! !!          L_ij_J_T1 = L_ij_J + sum_a t_aj * L_ia_J !! !!       Memory required in routine: !! !!          2*n_J*n_o*n_v     -> for reading L_ia_J contribution and reordering !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (( wf % n_o ) ** 2 , wf % n_J ) :: L_ij_J ! end subroutine get_cholesky_ij_ccs ! ! module subroutine get_cholesky_ia_ccs ( wf , L_ia_J ) !! !!       Get Cholesky IA !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Reads and T1-transforms IA Cholesky vectors !! !!          L_ia_J_T1 = L_ia_J (only reading necessary) !! !!       Memory required in routine: !! !!          No additional memory !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), wf % n_J ) :: L_ia_J ! end subroutine get_cholesky_ia_ccs ! ! module subroutine get_cholesky_ai_ccs ( wf , L_ai_J ) !! !!       Get Cholesky AI !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Read and T1-transform Cholesky AI vectors: !! !!           L_ai_J_T1 = L_ia_J - sum_j  t_aj*L_ji_J !!                           + sum_b  t_bi*L_ab_J !!                           - sum_bj t_aj*t_bi*L_jb_J !! !!       Allocations in routine: !! !!          (1) n_J*n_o*n_v + 2*n_J*n_v*batch_length   ->  for L_ab_J contribution !!          (2) n_J*n_o*n_v + 2*n_J*n_o&#94;2              ->  for L_ij_J contribution !!          (3) 2*n_J*n_o*n_v                          ->  for L_jb_J contribution !! !!          (1) determines memory requirement. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), wf % n_J ) :: L_ai_J ! end subroutine get_cholesky_ai_ccs ! ! module subroutine get_cholesky_ab_ccs ( wf , L_ab_J , first , last , ab_dim , reorder ) !! !!       Get Cholesky AB !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Reads and T1-transforms the IA Cholesky vectors: !! !!          L_ab_J_T1 = L_ab_J - sum_i t_ai*L_ib_J !! !!       If reorder = .true.,  L_ba_J is returned with batching over a !!       If reorder = .false., L_ab_J is returned with batching over b !! !!       Required memory: !! !!          n_J*batch_length*n_v   ->   For reordering of L_ab_J / L_ba_J !!          2*n_v*n_o*n_J          ->   For L_ib_J contribution !! implicit none ! class ( ccs ) :: wf ! logical , intent ( in ) :: reorder ! integer ( i15 ), intent ( in ) :: ab_dim integer ( i15 ), intent ( in ) :: first integer ( i15 ), intent ( in ) :: last ! real ( dp ), dimension ( ab_dim , wf % n_J ) :: L_ab_J ! end subroutine get_cholesky_ab_ccs ! ! module subroutine initialize_fock_matrix_ccs ( wf ) !! !!       Initialize Fock matrix !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Allocates and sets Fock matrix blocks (ij, ia, ai, ab) to zero !!       before calling the Fock matrix constructor. !! implicit none ! class ( ccs ) :: wf ! end subroutine initialize_fock_matrix_ccs ! ! module subroutine construct_fock_ccs ( wf ) !! !!       Construct Fock !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Constructs the T1-transformed Fock matrix blocks (occ/vir-occ/vir), !!       and saves the result in the class variables fock_pq. !! implicit none ! class ( ccs ) :: wf ! end subroutine construct_fock_ccs ! ! module subroutine one_electron_t1_ccs ( wf , h1 , h1_T1 ) !! !!       One-electron T1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       T1-transforms the one-electron MO integrals h_pq !! !!           h_p_q_T1 = sum_st x_p_s * y_q_t * h_s_t, !! !!       where !! !!           x = I - t1, !!           y = I - t1&#94;T. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_mo , wf % n_mo ) :: h1 real ( dp ), dimension ( wf % n_mo , wf % n_mo ) :: h1_T1 ! end subroutine one_electron_t1_ccs ! ! module subroutine ground_state_solver_ccs ( wf ) !! !!       Ground State Solver !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Directs the solution of the ground state amplitude equations !!       using a DIIS algorithm. The problem the routine solves is !! !!          X_mu(t) = 0, where t = { t_mu }_mu !! !!       For standard coupled cluster theories, the vector X is the !!       projection vector (omega). !! implicit none ! class ( ccs ) :: wf ! end subroutine ground_state_solver_ccs ! ! module subroutine calc_ampeqs_ccs ( wf ) !! !!       Calculate Amplitude Equations (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Constructs the amplitude equations vector (the projection vector !!       in CCS) for the amplitudes of the current iteration of the ground state !!       solver. It also calculates the norm of the amplitude equations, which !!       is zero when the equations are exactly solved. !! implicit none ! class ( ccs ) :: wf ! end subroutine calc_ampeqs_ccs ! ! module subroutine calc_ampeqs_norm_ccs ( wf , ampeqs_norm ) !! !!       Calculate Amplitude Equations Norm (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf real ( dp ) :: ampeqs_norm ! end subroutine calc_ampeqs_norm_ccs ! ! module subroutine new_amplitudes_ccs ( wf ) !! !!       New Amplitudes (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Directs the calculation of the quasi-Newton estimate Δ t_i, !!       and t_i + Δ t_i, and calls the DIIS routine to save & get !!       the amplitudes for the next iteration. !! implicit none ! class ( ccs ) :: wf ! end subroutine new_amplitudes_ccs ! ! module subroutine calc_quasi_Newton_singles_ccs ( wf , dt , n_variables ) !! !!       Calculate quasi-Newton estimate (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Calculates the quasi-Newton estimate Δ t_i (singles part) !!       and places the contribution in the dt vector (of length n_variables, !!       with singles first, then doubles, etc. if inherited) !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ), intent ( in ) :: n_variables real ( dp ), dimension ( n_variables , 1 ) :: dt ! end subroutine calc_quasi_Newton_singles_ccs ! ! module subroutine diis_ccs ( wf , dt , t_dt , n_variables ) !! !!       DIIS routine (CCS) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad !! !!       The next amplitudes are !! !!          t_n+1 = sum_k w_k (t_k + dt_k), !! !!       where the weights w_k in front of the quasi-Newton estimate dt_k !!       are determined so as to minimize !! !!          f(w_k) = sum_k w_k dt_k, !! !!       with the constraint that g(w_k) = sum_k w_k - 1 = 0. !! implicit none ! class ( ccs ), intent ( in ) :: wf ! integer ( i15 ), intent ( in ) :: n_variables ! real ( dp ), dimension ( n_variables , 1 ) :: dt real ( dp ), dimension ( n_variables , 1 ) :: t_dt ! end subroutine diis_ccs ! ! end interface ! ! contains ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::- Initialization and driver routines -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! subroutine init_ccs ( wf ) !! !!    Initialize CCS object !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Performs the following tasks !! !!    1. Sets HF orbital and energy information by reading from file !!    2. Transforms AO Cholesky vectors to MO basis and saves to file !!    3. Allocates the singles amplitudes and sets them to zero, and sets associated properties !!    4. Allocates the omega vector and sets it to zero !!    5. Initializes the Fock matrix and sets it to zero !! implicit none ! class ( ccs ) :: wf ! !     Set model name ! wf % name = 'CCS' ! !     Read Hartree-Fock info from SIRIUS ! call wf % read_hf_info ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize amplitudes and associated attributes ! call wf % initialize_amplitudes ! !     Initialize the projection vector ! call wf % initialize_omega ! !     Allocate Fock matrix and set to zero ! call wf % initialize_fock_matrix ! end subroutine init_ccs ! ! subroutine drv_ccs ( wf ) !! !!    CCS Driver !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    If called, the routine lets the user know there is no driver !!    for CCS, then exits the program. !! implicit none ! class ( ccs ) :: wf ! write ( unit_output , * ) 'ERROR: There is no driver for the CCS class' stop ! end subroutine drv_ccs ! !  ::::::::::::::::::::::::::::::::::::::::: !  -::- Class subroutines and functions -::- !  ::::::::::::::::::::::::::::::::::::::::: ! subroutine initialize_amplitudes_ccs ( wf ) !! !!    Initialize Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Allocates the singles amplitudes, sets them to zero, and calculates !!    the number of singles amplitudes. !! implicit none ! class ( ccs ) :: wf ! !     Calculate the number of singles amplitudes ! wf % n_t1am = ( wf % n_o ) * ( wf % n_v ) ! !     Allocate the singles amplitudes and set to zero !     (which is also the value that solves the projected Scrödinger eq.) ! call allocator ( wf % t1am , wf % n_v , wf % n_o ) wf % t1am = zero ! end subroutine initialize_amplitudes_ccs ! ! subroutine initialize_omega_ccs ( wf ) !! !!    Initialize Omega (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Allocates and sets the projection vector to zero (which is !!    also its correct value, by Brillouin) !! implicit none ! class ( ccs ) :: wf ! call allocator ( wf % omega1 , wf % n_v , wf % n_o ) wf % omega1 = zero ! end subroutine initialize_omega_ccs ! ! subroutine calc_energy_ccs ( wf ) !! !!    Calculate Energy (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! wf % energy = wf % scf_energy ! end subroutine calc_energy_ccs ! ! subroutine construct_omega_ccs ( wf ) !! !!    Construct Omega (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! wf % omega1 = zero ! Brillouin ! end subroutine construct_omega_ccs ! ! end module ccs_class","tags":"","loc":"sourcefile/ccs_class.f90.html","title":"ccs_class.F90 – Fortran Program"},{"text":"Modules ccsd_class Source Code ccsd_class.F90 Source Code module ccsd_class ! !! !!           Coupled cluster singles and doubles (CCSD) class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output ! !  Ancestor class module (CCS) ! use ccs_class ! implicit none ! !  :::::::::::::::::::::::::::::::::::::: !  -::- Definition of the CCSD class -::- !  :::::::::::::::::::::::::::::::::::::: ! type , extends ( ccs ) :: ccsd ! !     Amplitude variables ! integer ( i15 ) :: n_t2am = 0 ! Number of doubles amplitudes real ( dp ), dimension (:,:), allocatable :: t2am ! Doubles amplitude vector ! !     Schrödinger equation projection vector (the omega vector) ! !        < mu | exp(-T) H exp(T) | R > ! real ( dp ), dimension (:,:), allocatable :: omega2 ! Doubles vector ! contains ! !     Initialization and driver routines ! procedure :: init => init_ccsd procedure :: drv => drv_ccsd ! !     Initialization routine for the (singles, doubles) amplitudes ! procedure :: initialize_amplitudes => initialize_amplitudes_ccsd ! !     Routine to calculate the energy from the current amplitudes ! procedure :: calc_energy => calc_energy_ccsd ! !     Routine to initialize omega (allocate and set to zero) ! procedure :: initialize_omega => initialize_omega_ccsd ! !     Routines to construct the projection vector (omega) ! procedure :: construct_omega => construct_omega_ccsd ! !     Helper routines for construct_omega ! procedure :: omega_a1 => omega_a1_ccsd procedure :: omega_b1 => omega_b1_ccsd procedure :: omega_c1 => omega_c1_ccsd procedure :: omega_d1 => omega_d1_ccsd ! procedure :: omega_a2 => omega_a2_ccsd procedure :: omega_b2 => omega_b2_ccsd procedure :: omega_c2 => omega_c2_ccsd procedure :: omega_d2 => omega_d2_ccsd procedure :: omega_e2 => omega_e2_ccsd ! !     Ground state solver routine (helpers only, see CCS for the rest) ! procedure :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd procedure :: new_amplitudes => new_amplitudes_ccsd procedure :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd ! end type ccsd ! !  ::::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Interface to the submodule routines of CCSD -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::::::: ! interface ! ! module subroutine initialize_omega_ccsd ( wf ) !! !!       Initialize Omega (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Allocates the projection vector (omega1, omega2) and sets it !!       to zero. !! implicit none ! class ( ccsd ) :: wf ! end subroutine initialize_omega_ccsd ! ! module subroutine construct_omega_ccsd ( wf ) !! !!       Construct Omega (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Directs the construction of the projection vector < mu | exp(-T) H exp(T) | R > !!       for the current amplitudes of the object wfn !! implicit none ! class ( ccsd ) :: wf ! end subroutine construct_omega_ccsd ! ! module subroutine omega_a1_ccsd ( wf ) !! !!       Omega A1 term !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Calculates the A1 term, !! !!       A1: sum_ckd g_adkc * u_ki&#94;cd, !! !!       and adds it to the singles projection vector (omeg1) of !!       the wavefunction object wf. !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_a1_ccsd ! ! module subroutine omega_b1_ccsd ( wf ) !! !!       Omega B1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Calculates the B1 term, !! !!       B1: - sum_ckl u_kl&#94;ac * g_kilc, !! !!       and adds it to the singles projection vector (omeg1) of !!       the wavefunction object wf !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_b1_ccsd ! ! module subroutine omega_c1_ccsd ( wf ) !! !!     Omega C1 !!     Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! !!     Calculates the C1 term of omega, !! !!     C1: sum_ck F_kc*u_ai_ck, !! !!     and adds it to the projection vector (omega1) of !!     the wavefunction object wf !! !!     u_ai_ck = 2*t_ck_ai - t_ci_ak !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_c1_ccsd ! ! module subroutine omega_d1_ccsd ( wf ) !! !!       Omega D1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, March 2017 !! !!       Omega_ai&#94;D1 = F_ai_T1 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_d1_ccsd ! ! module subroutine omega_a2_ccsd ( wf ) !! !!     Omega A2 term: Omega A2 = g_ai_bj + sum_(cd)g_ac_bd * t_ci_dj = A2.1 + A.2.2 !! !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, 10 Mar 2017 !! !!     Structure: Batching over both a and b for A2.2. !!                t&#94;+_ci_dj = t_ci_dj + t_di_cj !!                t&#94;-_ci_dj = t_ci_dj - t_di_cj !!                g&#94;+_ac_bd = g_ac_bd + g_bc_ad !!                g&#94;-_ac_bd = g_ac_bd - g_bc_ad !! !!                omega_A2.2_ai_bj = 1/4*(g&#94;+_ac_bd*t&#94;+_ci_dj + g&#94;-_ac_bd*t&#94;-_ci_dj) = omega_A2.2_bj_ai !!                omega_A2.2_aj_bi = 1/4*(g&#94;+_ac_bd*t&#94;+_ci_dj - g&#94;-_ac_bd*t&#94;-_ci_dj) = omega_A2.2_bi_aj !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_a2_ccsd ! ! module subroutine omega_b2_ccsd ( wf ) !! !!       Omega B2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, 11 Mar 2017 !! !!       Omega B2 = sum_(kl) t_ak_bl*(g_kilj + sum_(cd) t_ci_dj * g_kc_ld) !! !!       Structure: g_kilj is constructed first and reordered as g_kl_ij. !!       Then the contraction over cd is performed, and the results added to g_kl_ij. !!       t_ak_bl is then reordered as t_ab_kl and the contraction over kl is performed. !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_b2_ccsd ! ! module subroutine omega_c2_ccsd ( wf ) !! !!       Omega C2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017 !! !!       Omega C2 = -1/2* sum_(ck)t_bk_cj*(g_ki_ac -1/2 sum_(dl)t_al_di * g_kd_lc) !!                                  - sum_(ck) t_bk_ci (g_kj_ac-sum_(dl)t_al_dj*g_kd_lc) !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_c2_ccsd ! ! module subroutine omega_d2_ccsd ( wf ) !! !!       Omega D2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Calculates the D2 term, !! !!          sum_ck u_jk&#94;bc g_aikc !!           - 1/2 * sum_ck u_jk&#94;bc g_acki !!           + 1/4 * sum_ck u_jk&#94;bc sum_dl L_ldkc u_il&#94;ad, !! !!       where !! !!          u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc, !!          L_ldkc  = 2 * g_ldkc  - g_lckd. !! !!       The first, second, and third terms are referred to as D2.1, D2.2, and D2.3, !!       and comes out ordered as (ai,bj). All terms are added to the omega vector of the !!       wavefunction object wf. !! !!       The routine adds the terms in the following order: D2.3, D2.1, D2.2 !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_d2_ccsd ! ! module subroutine omega_e2_ccsd ( wf ) !! !!       Omega E2 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Calculates the E2 term, !! !!           sum_c t_ij&#94;ac (F_bc - sum_dkl g_ldkc u_kl&#94;bd) !!           - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc), !! !!       where !! !!          u_kl&#94;bc = 2 * t_kl&#94;bc - t_lk&#94;bc. !! !!       The first term is referred to as the E2.1 term, and comes out ordered as (b,jai). !!       The second term is referred to as the E2.2 term, and comes out ordered as (aib,j). !! !!       Both are permuted added to the projection vector element omega2(ai,bj) of !!       the wavefunction object wf. !! implicit none ! class ( ccsd ) :: wf ! end subroutine omega_e2_ccsd ! ! module subroutine calc_ampeqs_norm_ccsd ( wf , ampeqs_norm ) !! !!       Calculate Amplitude Equations Norm (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccsd ) :: wf ! real ( dp ) :: ampeqs_norm ! end subroutine calc_ampeqs_norm_ccsd ! ! module subroutine new_amplitudes_ccsd ( wf ) !! !!       New Amplitudes (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Directs the calculation of the quasi-Newton estimate Δ t_i, !!       and t_i + Δ t_i, and calls the DIIS routine to save & get !!       the amplitudes for the next iteration. !! implicit none ! class ( ccsd ) :: wf ! end subroutine new_amplitudes_ccsd ! ! module subroutine calc_quasi_Newton_doubles_ccsd ( wf , dt , n_variables ) !! !!       Calculate quasi-Newton estimate (CCSD) !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!       Calculates the quasi-Newton estimate Δ t_i (doubbles part) !!       and places the contribution in the dt vector (of length n_variables, !!       with singles first, then doubles, etc. if inherited) !! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ), intent ( in ) :: n_variables real ( dp ), dimension ( n_variables , 1 ) :: dt ! end subroutine calc_quasi_Newton_doubles_ccsd ! ! end interface ! ! contains ! ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::- Initialization and driver routines -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! ! subroutine init_ccsd ( wf ) !! !!    Initialize CCSD object !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Performs the following tasks: !! !!       1. Sets HF orbital and energy information by reading from file (read_hf_info) !!       2. Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky) !!       3. Allocates the Fock matrix and sets it to zero !!       4. Initializes the amplitudes (sets their initial values and associated variables) !! !!    Note: this routine does not calculate the energy, which is postponed until the wavefunction !!    is passed to the ground-state solver. !! implicit none ! class ( ccsd ) :: wf ! !     Set model name ! wf % name = 'CCSD' ! !     Read Hartree-Fock info from SIRIUS ! call wf % read_hf_info ! !     Read Cholesky AO integrals and transform to MO basis ! call wf % read_transform_cholesky ! !     Initialize (singles and doubles) amplitudes ! call wf % initialize_amplitudes ! !     Initialize the Fock matrix (allocate and construct given the initial amplitudes) ! call wf % initialize_fock_matrix ! !     Initialize the projection vector (omega) ! call wf % initialize_omega ! end subroutine init_ccsd ! ! subroutine drv_ccsd ( wf ) !! !!    Driver (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Controls the CCSD calculation using requested calculations from !!    user (eventually: still under construction). !! implicit none ! class ( ccsd ) :: wf ! call wf % ground_state_solver ! end subroutine drv_ccsd ! !  ::::::::::::::::::::::::::::::::::::::::: !  -::- Class subroutines and functions -::- !  ::::::::::::::::::::::::::::::::::::::::: ! subroutine initialize_amplitudes_ccsd ( wf ) !! !!     Initialize Amplitudes (CCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Allocates the amplitudes, sets them to zero, calculates !!     the number of amplitudes, and sets the doubles amplitudes !!     to the perturbative MP2 estimate. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: g_ia_jb ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , b = 0 integer ( i15 ) :: ai = 0 , bj = 0 , ia = 0 , jb = 0 , aibj = 0 ! !     Calculate the number of singles and doubles amplitudes ! wf % n_t1am = ( wf % n_o ) * ( wf % n_v ) wf % n_t2am = ( wf % n_t1am ) * ( wf % n_t1am + 1 ) / 2 ! !     Allocate the singles amplitudes and set to zero ! call allocator ( wf % t1am , wf % n_v , wf % n_o ) wf % t1am = zero ! !     Allocate the doubles amplitudes and set to zero ! call allocator ( wf % t2am , wf % n_t2am , 1 ) wf % t2am = zero ! ! !     :: Initialize the doubles amplitudes to the MP2 estimate :: ! ! !     Allocate L_ia_J and g_ia_jb ! call allocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call allocator ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! L_ia_J = zero g_ia_jb = zero ! !     Get the Cholesky IA vector ! call wf % get_cholesky_ia ( L_ia_J ) ! !     Calculate g_ia_jb = g_iajb ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ia_jb , & ( wf % n_o ) * ( wf % n_v )) ! !     Set the doubles amplitudes ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! jb = index_two ( j , b , wf % n_o ) bj = index_two ( b , j , wf % n_v ) ! !                 Set the doubles amplitudes ! if ( ai . le . bj ) then ! To avoid setting the same element twice ! aibj = index_packed ( ai , bj ) ! wf % t2am ( aibj , 1 ) = - g_ia_jb ( ia , jb ) / ( wf % fock_diagonal ( wf % n_o + a , 1 ) + & wf % fock_diagonal ( wf % n_o + b , 1 ) - & wf % fock_diagonal ( i , 1 ) - & wf % fock_diagonal ( j , 1 )) ! endif ! enddo enddo enddo enddo ! !     Deallocations ! call deallocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), ( wf % n_J )) call deallocator ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine initialize_amplitudes_ccsd ! ! subroutine calc_energy_ccsd ( wf ) !! !!     Calculate Energy (CCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Calculates the CCSD energy for the wavefunction's current amplitudes. !! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: L_ia_J ! L_ia&#94;J real ( dp ), dimension (:,:), allocatable :: g_ia_jb ! g_iajb ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 , ai = 0 integer ( i15 ) :: bj = 0 , aibj = 0 , ia = 0 , jb = 0 , ib = 0 , ja = 0 ! !     Allocate the Cholesky vector L_ia_J = L_ia&#94;J and set to zero ! call allocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_ia_J = zero ! !     Get the Cholesky vector L_ia_J ! call wf % get_cholesky_ia ( L_ia_J ) ! !     Allocate g_ia_jb = g_iajb and set it to zero ! call allocator ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ia_jb = zero ! !     Calculate the integrals g_ia_jb from the Cholesky vector L_ia_J ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ia_jb , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate the Cholesky vector L_ia_J ! call deallocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Set the initial value of the energy ! wf % energy = wf % scf_energy ! !     Add the correlation energy E = E + sum_aibj (t_ij&#94;ab + t_i&#94;a t_j&#94;b) L_iajb ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ! do j = 1 , wf % n_o ! ja = index_two ( j , a , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) jb = index_two ( j , b , wf % n_o ) ib = index_two ( i , b , wf % n_o ) ! aibj = index_packed ( ai , bj ) ! !                 Add the correlation energy ! wf % energy = wf % energy + & ( wf % t2am ( aibj , 1 ) + ( wf % t1am ( a , i )) * ( wf % t1am ( b , j ))) * & ( two * g_ia_jb ( ia , jb ) - g_ia_jb ( ib , ja )) ! enddo enddo enddo enddo ! !     Deallocate g_ia_jb ! call deallocator ( g_ia_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine calc_energy_ccsd ! ! end module ccsd_class","tags":"","loc":"sourcefile/ccsd_class.f90.html","title":"ccsd_class.F90 – Fortran Program"},{"text":"Programs eT_program Source Code eT_program.F90 Source Code program eT_program ! !! !!                        eT - a coupled cluster program !!         Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 !! ! !  ::::::::::::::::::::::::::::::::::::: !  -::- Modules used by the program -::- !  ::::::::::::::::::::::::::::::::::::: ! use input_output ! IO module use input_reader ! Input reader routines ! !  Wavefunction classes ! use hf_class use ccs_class use ccsd_class ! implicit none ! !  Method class allocatable objects ! type ( ccsd ), allocatable , target :: ccsd_wf ! !  Wavefunction pointer ! class ( hf ), pointer :: wf => null () ! !  Method string ! character ( len = 40 ) :: method ! !  Unit identifier for input file eT.inp ! integer ( i15 ) :: unit_input = - 1 ! !  :::::::::::::::::::::::::::::::::::::::::::::: !  -::-     Set up memory controller         -::- !  :::::::::::::::::::::::::::::::::::::::::::::: ! call work_init ! !  :::::::::::::::::::::::::::::::::::::::::::::: !  -::-  Create & open the main output file  -::- !  :::::::::::::::::::::::::::::::::::::::::::::: ! call generate_unit_identifier ( unit_output ) open ( unit = unit_output , file = 'eT.out' , status = 'unknown' , form = 'formatted' ) rewind ( unit_output ) ! !  :::::::::::::::::::::::::::::::::::::::::::::: !  -::-         Print program banner         -::- !  :::::::::::::::::::::::::::::::::::::::::::::: ! write ( unit_output , '(//t18,a)' ) 'eT - a coupled cluster program' write ( unit_output , '(t15,a//)' ) 'S. D. Folkestad, E. F. Kjønstad, 2017' ! !  :::::::::::::::::::::::::::::::::::::::::::::: !  -::-    Print banner for input section    -::- !  :::::::::::::::::::::::::::::::::::::::::::::: ! write ( unit_output , '(t3,a/)' ) ':: Input reader' ! !  Open input file ! call generate_unit_identifier ( unit_input ) open ( unit = unit_input , file = 'eT.inp' , status = 'old' , form = 'formatted' ) rewind ( unit_input ) ! !  :::::::::::::::::::::::::::::::::::::::::::::: !  -::- Reading method section of input file -::- !  :::::::::::::::::::::::::::::::::::::::::::::: ! !  Read the method from file, allocate the appropriate !  wavefunction object, and point to the main wavefunction !  wf to this object. ! call method_reader ( unit_input , method ) ! write ( unit_output , '(t3,a,a,a)' ) 'Our wavefunction is of type ' , trim ( method ), '.' flush ( unit_output ) ! if ( trim ( method ) == 'CCSD' ) then ! allocate ( ccsd_wf ) wf => ccsd_wf ! else ! write ( unit_output , * ) 'Method ' , trim ( method ), ' not recognized.' flush ( unit_output ) stop ! endif ! !  ::::::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Reading calculation section of input file -::- !  ::::::::::::::::::::::::::::::::::::::::::::::::::: ! !  Set calculation specifications ! call calculation_reader ( unit_input , wf % tasks ) ! if ( wf % tasks % do_ground_state ) write ( unit_output , '(t3,a)' ) 'Ground state calculation requested.' if ( wf % tasks % do_excited_state ) write ( unit_output , '(t3,a)' ) 'Excited state calculation requested.' ! Dummy as of now if ( wf % tasks % do_properties ) write ( unit_output , '(t3,a)' ) 'Properties calculation requested.' ! Dummy as of now ! !  :::::::::::::::::::::::::::::::::::::::::::::::: !  -::- Reading settings section of input file -::- !  :::::::::::::::::::::::::::::::::::::::::::::::: ! !  Set the calculation settings of the wavefunction ! call settings_reader ( unit_input , wf % settings ) ! write ( unit_output , '(/t3,a/)' ) 'Settings for this calculation:' ! write ( unit_output , '(t6,a25,e14.2)' ) 'Energy threshold:' , wf % settings % energy_threshold write ( unit_output , '(t6,a25,e14.2)' ) 'Amplitude eqs. threshold:' , wf % settings % ampeqs_threshold write ( unit_output , '(t6,a25,i14/)' ) 'Memory:' , mem ! !  Close input file ! close ( unit_input ) ! !  ::::::::::::::::::::::::: !  -::- Run Calculation -::- !  ::::::::::::::::::::::::: ! call wf % init call wf % drv ! !  ::::::::::::::::::::::::::: !  -::- Close output file -::- !  ::::::::::::::::::::::::::: ! close ( unit_output ) ! end program eT_program","tags":"","loc":"sourcefile/et_program.f90.html","title":"eT_program.F90 – Fortran Program"},{"text":"Modules hf_class Source Code hf_class.F90 Source Code module hf_class ! !! !!                      Hartree-Fock (HF) class module !!        Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! ! !  ::::::::::::::::::::::::::::::::::: !  -::- Modules used by the class -::- !  ::::::::::::::::::::::::::::::::::: ! !  General tools ! use types use utils use workspace use input_output use calc_procedures_class use calc_settings_class ! implicit none ! !  :::::::::::::::::::::::::::::::::::: !  -::- Definition of the HF class -::- !  :::::::::::::::::::::::::::::::::::: ! type :: hf ! !     Model name ! character ( len = 40 ) :: name = 'HF' ! !     Orbital information variables ! integer ( i15 ) :: n_o ! Number of occupied orbitals integer ( i15 ) :: n_v ! Number of virtual orbitals integer ( i15 ) :: n_ao ! Number of atomic orbitals (AOs) integer ( i15 ) :: n_mo ! Number of molecular orbitals (MOs) integer ( i15 ) :: n_J ! Number of Cholesky vectors ! real ( dp ), dimension (:,:), allocatable :: mo_coef ! MO coefficient matrix ! !     Fock matrix variables ! real ( dp ), dimension (:,:), allocatable :: fock_diagonal ! diagonal vector ! !     Energy variables ! real ( dp ) :: energy ! Same as scf_energy for HF class, different for descendants ! real ( dp ) :: nuclear_potential ! Nuclear potential energy term real ( dp ) :: scf_energy ! The Hartree-Fock (HF/SCF) energy ! !     Calculation settings, tasks, and implemented methods ! type ( calc_settings ) :: settings ! type ( calc_procedures ) :: tasks type ( calc_procedures ) :: implemented ! contains ! !     Initialization and driver routines ! procedure :: init => init_hf procedure :: drv => drv_hf ! !     Routines to read MO Cholesky vectors from file ! procedure , non_overridable :: read_cholesky_ij => read_cholesky_ij_hf ! occ-occ procedure , non_overridable :: read_cholesky_ia => read_cholesky_ia_hf ! occ-vir procedure , non_overridable :: read_cholesky_ai => read_cholesky_ai_hf ! vir-occ procedure , non_overridable :: read_cholesky_ab => read_cholesky_ab_hf ! vir-vir ! !     Routines needed to initialize HF ! !     read_info               : sets variables from file (n_o, n_v, scf_energy,...) !     read_transform_cholesky : reads AO Cholesky vectors, transforms to MO, and saves to file ! procedure , non_overridable :: read_hf_info => read_hf_info_hf procedure , non_overridable :: read_transform_cholesky => read_transform_cholesky_hf ! end type hf ! ! contains ! !  :::::::::::::::::::::::::::::::::::::::::::: !  -::- Initialization and driver routines -::- !  :::::::::::::::::::::::::::::::::::::::::::: ! subroutine init_hf ( wf ) !! !!    Initialization of Hartree-Fock object !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Performs the following tasks: !! !!    1. Sets HF orbital and energy information by reading from file !!    2. Transforms AO Cholesky vectors to MO basis and saves to file !! implicit none ! class ( hf ) :: wf ! !     Initialize HF variables ! call wf % read_hf_info ! !     Initialize Cholesky vectors ! call wf % read_transform_cholesky ! end subroutine init_hf ! ! subroutine drv_hf ( wf ) !! !!    Driver (HF) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Lets the user know there is no driver for Hartree-Fock and exits !!    the program if called. The module reads Hartree-Fock information !!    from files and contains no independent solver. !! implicit none ! class ( hf ) :: wf ! write ( unit_output , * ) 'ERROR: There is no driver for the Hartree-Fock class' call exit ! end subroutine drv_hf ! !  ::::::::::::::::::::::::::::::::::::::::: !  -::- Class subroutines and functions -::- !  ::::::::::::::::::::::::::::::::::::::::: ! subroutine read_hf_info_hf ( wf ) !! !!    Read HF Info !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the file mlcc_hf_info and sets the following HF variables: !!    n_o, n_v, n_mo, orbital_coef, and the fock_diagonal. !! !!    The file mlcc_hf_info is written in the mlcc_write_sirifc !!    subroutine, which is called from the wr_sirifc subroutine in !!    the siropt module of the DALTON suite. !! implicit none ! class ( hf ) :: wf ! integer ( i15 ) :: unit_hf = - 1 ! Unit identifier for mlcc_hf_info file ! integer ( i15 ) :: n_lambda = 0 ! n_ao * n_mo, read but discarded integer ( i15 ) :: i = 0 , j = 0 ! !     Open the file mlcc_hf_info ! call generate_unit_identifier ( unit_hf ) open ( unit = unit_hf , file = 'mlcc_hf_info' , status = 'old' , form = 'formatted' ) rewind ( unit_hf ) ! !     Read mlcc_hf_info into HF variables ! read ( unit_hf , * ) wf % n_mo , wf % n_o , n_lambda , & wf % nuclear_potential , wf % scf_energy ! !     Set the energy equal to the read SCF energy ! wf % energy = wf % scf_energy ! !     Calculate the number of virtuals ! wf % n_v = wf % n_mo - wf % n_o ! !     Allocate the Fock diagonal and the MO coefficients ! call allocator ( wf % fock_diagonal , wf % n_mo , 1 ) wf % fock_diagonal = zero ! call allocator ( wf % mo_coef , n_lambda , 1 ) wf % mo_coef = zero ! !     Read in the Fock diagonal and MO coefficients ! read ( unit_hf , * ) ( wf % fock_diagonal ( i , 1 ), i = 1 , wf % n_mo ) read ( unit_hf , * ) ( wf % mo_coef ( i , 1 ), i = 1 , n_lambda ) ! !     Close the mlcc_hf_info file ! close ( unit_hf ) ! end subroutine read_hf_info_hf ! ! subroutine read_transform_cholesky_hf ( wf ) !! !!    Read and Transform Cholesky !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, 20 Apr 2017 !! !!    Reads the AO Cholesky vectors from file, transforms the vectors !!    to the MO basis, and saves the MO vectors to file !! implicit none ! class ( hf ) :: wf ! integer ( i15 ) :: unit_chol_ao = - 1 ! Unit identifier for mlcc_cholesky file integer ( i15 ) :: unit_chol_mo_ij = - 1 ! cholesky_ij file integer ( i15 ) :: unit_chol_mo_ia = - 1 ! cholesky_ia file integer ( i15 ) :: unit_chol_mo_ab = - 1 ! cholesky_ab file ! integer ( i15 ) :: n_ao_sq_packed = 0 ! Packed dimensionality of (n_ao x n_ao) matrix ! real ( dp ), dimension (:,:), allocatable :: chol_ao ! Packed AO Cholesky vector real ( dp ), dimension (:,:), allocatable :: chol_ao_sq ! Unpacked AO Cholesky vector real ( dp ), dimension (:,:), allocatable :: chol_mo_sq ! Unpacked MO Cholesky vector ! real ( dp ), dimension (:,:), allocatable :: X ! An intermediate matrix ! integer ( i15 ) :: i , j , a , b , k ! !     Open Dalton file mlcc_cholesky (see mlcc_write_cholesky.F) ! call generate_unit_identifier ( unit_chol_ao ) open ( unit = unit_chol_ao , file = 'mlcc_cholesky' , status = 'old' , form = 'formatted' ) rewind ( unit_chol_ao ) ! !     Read the number of Cholesky vectors (n_J) and !     the number of atomic orbitals (n_ao) ! read ( unit_chol_ao , * ) wf % n_ao , wf % n_J ! !     Open files for MO Cholesky vectors ! call generate_unit_identifier ( unit_chol_mo_ij ) call generate_unit_identifier ( unit_chol_mo_ia ) call generate_unit_identifier ( unit_chol_mo_ab ) ! open ( unit_chol_mo_ij , file = 'cholesky_ij' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ij ) ! open ( unit_chol_mo_ia , file = 'cholesky_ia' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ia ) ! open ( unit_chol_mo_ab , file = 'cholesky_ab' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ab ) ! !     Allocate packed and unpacked Cholesky AO, and !     unpacked Cholesky MO vectors ! n_ao_sq_packed = packed_size ( wf % n_ao ) ! call allocator ( chol_ao , n_ao_sq_packed , 1 ) call allocator ( chol_ao_sq , wf % n_ao , wf % n_ao ) call allocator ( chol_mo_sq , wf % n_mo , wf % n_mo ) ! chol_ao = zero chol_ao_sq = zero chol_mo_sq = zero ! !     Allocate an intermediate, X ! call allocator ( X , wf % n_ao , wf % n_mo ) ! X = zero ! !     Loop over the number of Cholesky vectors, !     reading them one by one ! do j = 1 , wf % n_J ! !        Read Cholesky AO vector ! read ( unit_chol_ao , * ) ( chol_ao ( i , 1 ), i = 1 , n_ao_sq_packed ) ! !        Unpack/square up AO vector ! call squareup ( chol_ao , chol_ao_sq , wf % n_ao ) ! !        Transform the AO vectors to form the Cholesky MO vectors ! call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_mo , & wf % n_ao , & one , & chol_ao_sq , & wf % n_ao , & wf % mo_coef , & wf % n_ao , & zero , & X , & wf % n_ao ) ! call dgemm ( 'T' , 'N' , & wf % n_mo , & wf % n_mo , & wf % n_ao , & one , & wf % mo_coef , & wf % n_ao , & X , & wf % n_ao , & zero , & chol_mo_sq , & wf % n_mo ) ! !        Write the MO vectors to files in blocks ! write ( unit_chol_mo_ij ) (( chol_mo_sq ( i , k ), i = 1 , wf % n_o ), k = 1 , wf % n_o ) write ( unit_chol_mo_ia ) (( chol_mo_sq ( i , a ), i = 1 , wf % n_o ), a = wf % n_o + 1 , wf % n_mo ) write ( unit_chol_mo_ab ) (( chol_mo_sq ( a , b ), a = wf % n_o + 1 , wf % n_mo ), b = wf % n_o + 1 , wf % n_mo ) ! enddo ! !     Close files ! close ( unit_chol_ao ) close ( unit_chol_mo_ij ) close ( unit_chol_mo_ia ) close ( unit_chol_mo_ab ) ! end subroutine read_transform_cholesky_hf ! ! subroutine read_cholesky_ij_hf ( wf , L_ij_J ) !! !!    Read Cholesky IJ !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky IJ (occ-occ) vectors from file and !!    places them in the incoming L_ij_J matrix !! implicit none ! class ( hf ) :: wf ! real ( dp ), dimension (( wf % n_o ) ** 2 , wf % n_J ) :: L_ij_J ! L_ij&#94;J ! integer ( i15 ) :: unit_chol_mo_ij = - 1 ! Unit identifier for cholesky_ij file integer ( i15 ) :: i = 0 , j = 0 ! !     Prepare for reading: generate unit idientifier, open file, and rewind ! call generate_unit_identifier ( unit_chol_mo_ij ) open ( unit = unit_chol_mo_ij , file = 'cholesky_ij' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ij ) ! !     Read the Cholesky vectors into the L_ij_J matrix ! do j = 1 , wf % n_J read ( unit_chol_mo_ij ) ( L_ij_J ( i , j ), i = 1 , ( wf % n_o ) ** 2 ) enddo ! !     Close file ! close ( unit_chol_mo_ij ) ! end subroutine read_cholesky_ij_hf ! ! subroutine read_cholesky_ia_hf ( wf , L_ia_J ) !! !!    Read Cholesky IA !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky IA (occ-vir) vectors from file and !!    places them in the incoming L_ia_J matrix !! implicit none ! class ( hf ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), wf % n_J ) :: L_ia_J ! L_ia&#94;J ! integer ( i15 ) :: unit_chol_mo_ia = - 1 ! Unit identifier for cholesky_ia file integer ( i15 ) :: i = 0 , j = 0 ! !     Prepare for reading: generate unit idientifier, open, and rewind file ! call generate_unit_identifier ( unit_chol_mo_ia ) open ( unit = unit_chol_mo_ia , file = 'cholesky_ia' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ia ) ! !     Read Cholesky vectors into the L_ia_J matrix ! do j = 1 , wf % n_J ! read ( unit_chol_mo_ia ) ( L_ia_J ( i , j ), i = 1 , ( wf % n_o ) * ( wf % n_v )) ! enddo ! !     Close file ! close ( unit_chol_mo_ia ) ! end subroutine read_cholesky_ia_hf ! ! subroutine read_cholesky_ai_hf ( wf , L_ai_J ) !! !!    Read Cholesky AI !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky AI (vir-occ) vectors from file and !!    places them in the incoming L_ai_J matrix !! implicit none ! class ( hf ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), wf % n_J ) :: L_ai_J ! L_ai&#94;J ! real ( dp ), dimension (:,:), allocatable :: L_ia_J ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , ia = 0 , ai = 0 ! !     Allocation ! call allocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_ia_J = zero ! !     Get Cholesky IA vector ! call wf % read_cholesky_ia ( L_ia_J ) ! !     Reorder and save in AI vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! !           Needed indices ! ai = index_two ( a , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ! do j = 1 , wf % n_J ! L_ai_J ( ai , j ) = L_ia_J ( ia , j ) ! enddo ! enddo enddo ! !     Deallocate temporary vector ! call deallocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! end subroutine read_cholesky_ai_hf ! ! subroutine read_cholesky_ab_hf ( wf , L_ab_J , first , last , ab_dim , reorder ) !! !!    Read Cholesky AB !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads the MO Cholesky AB (vir-vir) vectors from file and !!    places them in the incoming L_ab_J matrix, with batching !!    if necessary !! !!    If reorder = .true.,  L_ba_J is returned with batching over a !!    If reorder = .false., L_ab_J is returned with batching over b !! implicit none ! class ( hf ) :: wf ! integer ( i15 ), intent ( in ) :: first ! First index (can differ from 1 when batching) integer ( i15 ), intent ( in ) :: last ! Last index  (can differ from n_v when batching) integer ( i15 ), intent ( in ) :: ab_dim ! Dimension of ab index (not n_v&#94;2 when batching) ! logical , intent ( in ) :: reorder ! See description above ! real ( dp ), dimension ( ab_dim , wf % n_J ) :: L_ab_J ! L_ab&#94;J ! integer ( i15 ) :: unit_chol_mo_ab = - 1 ! Unit identifier for cholesky_ab file ! integer ( i15 ) :: a = 0 , b = 0 , j = 0 , i = 0 integer ( i15 ) :: batch_length = 0 ! integer ( i15 ) :: throw_away_index = 0 real ( dp ) :: throw_away = 0 ! !     Prepare for reading: generate unit identifier, open, and rewind file ! call generate_unit_identifier ( unit_chol_mo_ab ) open ( unit = unit_chol_mo_ab , file = 'cholesky_ab' , status = 'unknown' , form = 'unformatted' ) rewind ( unit_chol_mo_ab ) ! !     Calculating batch length ! batch_length = last - first + 1 ! if (. not . reorder ) then ! if ( first . ne . 1 ) then ! !           Calculate index of last element to throw away ! throw_away_index = index_two ( wf % n_v , first - 1 , wf % n_v ) ! !           Throw away all elements from 1 to throw_away_index, then read from batch start ! do j = 1 , wf % n_J ! read ( unit_chol_mo_ab ) ( throw_away , i = 1 , throw_away_index ),& ( L_ab_J ( a , j ), a = 1 , ab_dim ) ! enddo ! else ! !           Read from the start of each entry ! do j = 1 , wf % n_J ! read ( unit_chol_mo_ab ) ( L_ab_J ( a , j ), a = 1 , ab_dim ) ! enddo ! endif ! else ! Reorder L_ab_J is L_ba_J ! throw_away_index = index_two ( wf % n_v , first - 1 , wf % n_v ) ! !        Reading vectors ! do j = 1 , wf % n_J ! if ( first . eq . 1 ) then ! read ( unit_chol_mo_ab ) (( L_ab_J ( index_two ( b , a , wf % n_v ), j ), b = 1 , wf % n_v ), a = 1 , batch_length ) ! else ! read ( unit_chol_mo_ab ) ( throw_away , i = 1 , throw_away_index ),& (( L_ab_J ( index_two ( b , a , wf % n_v ), j ), b = 1 , wf % n_v ), a = 1 , batch_length ) ! endif ! enddo ! endif ! Reorder ! !     Close file ! close ( unit_chol_mo_ab ) ! end subroutine read_cholesky_ab_hf ! ! end module hf_class","tags":"","loc":"sourcefile/hf_class.f90.html","title":"hf_class.F90 – Fortran Program"},{"text":"Submodules cholesky Source Code cholesky_submodule.F90 Source Code submodule ( ccs_class ) cholesky ! !! !!    Cholesky submodule (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Contains the following family of procedures of the CCS class: !! !!    get_cholesky_ij(L_ij_J):         returns the T1-transformed Cholesky vector L_ij&#94;J !!    get_cholesky_ia(L_ia_J):         returns the T1-transformed Cholesky vector L_ia&#94;J !!    get_cholesky_ai(L_ai_J):         returns the T1-transformed Cholesky vector L_ai&#94;J !!    get_cholesky_ab(L_ab_J, ...):    returns the T1-transformed Cholesky vector L_ab&#94;J, !!                                     but has options (...) for batching over the two !!                                     indices a and b !! ! implicit none ! ! contains ! ! module subroutine get_cholesky_ij_ccs ( wf , L_ij_J ) !! !!    Get Cholesky IJ !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads and T1-transforms the IA Cholesky vectors: !! !!       L_ij_J_T1 = L_ij_J + sum_a t_aj * L_ia_J !! !!    Memory required in routine: !! !!       2*n_J*n_o*n_v     -> for reading L_ia_J contribution and reordering !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (( wf % n_o ) ** 2 , wf % n_J ) :: L_ij_J ! real ( dp ), dimension (:,:), allocatable :: L_ia_J ! L_ia&#94;J real ( dp ), dimension (:,:), allocatable :: L_iJ_a ! L_ia&#94;J reordered real ( dp ), dimension (:,:), allocatable :: L_iJ_k ! L_ik&#94;J reordered ! integer ( i15 ) :: i = 0 , J = 0 , a = 0 , ij = 0 , ia = 0 , ik = 0 , k = 0 ! !     Allocate ! call allocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call allocator ( L_iJ_a , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) ! !     Read the untransformed Cholesky vectors ! call wf % read_cholesky_ij ( L_ij_J ) call wf % read_cholesky_ia ( L_ia_J ) ! !     Reorder L_ia_J to L_iJ_a ! do i = 1 , wf % n_o do J = 1 , wf % n_J do a = 1 , wf % n_v ! iJ = index_two ( i , J , wf % n_o ) ia = index_two ( i , a , wf % n_o ) ! L_iJ_a ( iJ , a ) = L_ia_J ( ia , J ) ! enddo enddo enddo ! !     Deallocate L_ia_J ! call deallocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Allocate L_iJ_k ! call allocator ( L_iJ_k , ( wf % n_o ) * ( wf % n_J ), wf % n_o ) ! !     T1-transformation ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_J ), & wf % n_o , & wf % n_v , & one , & L_iJ_a , & ( wf % n_o ) * ( wf % n_J ), & wf % t1am , & wf % n_v , & zero , & L_iJ_k , & ( wf % n_o ) * ( wf % n_J )) ! !     Place terms from L_iJ_k into L_ij_J ! do i = 1 , wf % n_o do k = 1 , wf % n_o do J = 1 , wf % n_J ! !              Needed indices ! iJ = index_two ( i , J , wf % n_o ) ik = index_two ( i , k , wf % n_o ) ! L_ij_J ( ik , J ) = L_ij_J ( ik , J ) + L_iJ_k ( iJ , k ) ! enddo enddo enddo ! !     Deallocate L_iJ_k and L_iJ_a ! call deallocator ( L_iJ_k , ( wf % n_o ) * ( wf % n_J ), wf % n_o ) call deallocator ( L_iJ_a , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) ! end subroutine get_cholesky_ij_ccs ! ! module subroutine get_cholesky_ia_ccs ( wf , L_ia_J ) !! !!    Get Cholesky IA !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads and T1-transforms IA Cholesky vectors !! !!       L_ia_J_T1 = L_ia_J (only reading necessary) !! !!    Memory required in routine: !! !!       No additional memory !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (( wf % n_o ) * ( wf % n_v ), wf % n_J ) :: L_ia_J ! call wf % read_cholesky_ia ( L_ia_J ) ! end subroutine get_cholesky_ia_ccs ! ! module subroutine get_cholesky_ai_ccs ( wf , L_ai_J ) !! !!     Get Cholesky AI !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Read and T1-transform Cholesky AI vectors: !! !!        L_ai_J_T1 = L_ia_J - sum_j  t_aj*L_ji_J !!                           + sum_b  t_bi*L_ab_J !!                           - sum_bj t_aj*t_bi*L_jb_J !! !!     Allocations in routine: !! !!       (1) n_J*n_o*n_v + 2*n_J*n_v*batch_length   ->  for L_ab_J contribution !!       (2) n_J*n_o*n_v + 2*n_J*n_o&#94;2              ->  for L_ij_J contribution !!       (3) 2*n_J*n_o*n_v                          ->  for L_jb_J contribution !! !!       (1) determines memory requirement. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (( wf % n_v ) * ( wf % n_o ), wf % n_J ) :: L_ai_J ! logical :: reorder ! Reorder or not, when reading Cholesky AB ! !     Batch variables ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , n_batch = 0 , L_off = 0 integer ( i15 ) :: a_batch = 0 , batch_start = 0 , batch_end = 0 , batch_length = 0 ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , J = 0 , i = 0 , ai = 0 , Ja = 0 integer ( i15 ) :: ba = 0 , k = 0 , ik = 0 , iJ = 0 , kb = 0 , kJ = 0 ! !     Cholesky vectors (in many different orderings) ! real ( dp ), dimension (:,:), allocatable :: L_ba_J real ( dp ), dimension (:,:), allocatable :: L_Ja_b real ( dp ), dimension (:,:), allocatable :: L_Ja_i real ( dp ), dimension (:,:), allocatable :: L_ik_J real ( dp ), dimension (:,:), allocatable :: L_k_iJ real ( dp ), dimension (:,:), allocatable :: L_a_iJ real ( dp ), dimension (:,:), allocatable :: L_kJ_b real ( dp ), dimension (:,:), allocatable :: L_kJ_i real ( dp ), dimension (:,:), allocatable :: L_kb_J ! !     Read L_ai&#94;J from file ! call wf % read_cholesky_ai ( L_ai_J ) ! ! !     :: L_ab_J contributions :: ! ! !     Allocate L_Ja_i ! call allocator ( L_Ja_i , ( wf % n_J ) * ( wf % n_v ), wf % n_o ) L_Ja_i = zero ! !     Set batching variables ! required = 2 * ( wf % n_v ) ** 2 * ( wf % n_J ) * 4 available = get_available () max_batch_length = 0 ! n_batch = 0 a_batch = 0 ! batch_length = 0 batch_start = 0 batch_end = 0 ! !     Calculate the number of batches ! call num_batch ( required , available , max_batch_length , n_batch , wf % n_v ) ! do a_batch = 1 , n_batch ! !        Get start, end, and length of batch ! call batch_limits ( batch_start , batch_end , a_batch , max_batch_length , wf % n_v ) batch_length = batch_end - batch_start + 1 ! !        Allocate L_ab_J and L_Ja_b ! call allocator ( L_ba_J , ( wf % n_v ) * batch_length , wf % n_J ) ! L_ab&#94;J = L_ba_J(ba,J) call allocator ( L_Ja_b , batch_length * ( wf % n_J ), wf % n_v ) ! L_ba_J = zero L_Ja_b = zero ! !        Read Cholesky AB vectors, batching over a ! reorder = . true . call wf % read_cholesky_ab ( L_ba_J , batch_start , batch_end , ( wf % n_v ) * batch_length , reorder ) ! !        Reorder the Cholesky array L_ba_J ! do a = 1 , batch_length do b = 1 , wf % n_v do J = 1 , wf % n_J ! !                 Needed indices ! ba = index_two ( b , a , wf % n_v ) Ja = index_two ( J , a , wf % n_J ) ! L_Ja_b ( Ja , b ) = L_ba_J ( ba , J ) ! L_ab&#94;J ! enddo enddo enddo ! !        Calculate sum_b L_Ja_b*t_b_i = L_Ja_i ! L_off = index_two ( 1 , batch_start , wf % n_J ) ! call dgemm ( 'N' , 'N' , & batch_length * ( wf % n_J ), & wf % n_o , & wf % n_v , & one , & L_Ja_b , & batch_length * ( wf % n_J ), & wf % t1am , & wf % n_v , & one , & L_Ja_i ( L_off , 1 ), & ( wf % n_v ) * ( wf % n_J )) ! !        Deallocate L_ab_J and L_Ja_b ! call deallocator ( L_ba_J , ( wf % n_v ) * batch_length , wf % n_J ) call deallocator ( L_Ja_b , batch_length * ( wf % n_J ), wf % n_v ) ! enddo ! batching over a ! !     Add terms to T1-transformed Cholesky AI vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v do J = 1 , wf % n_J ! !              Needed indices ! Ja = index_two ( J , a , wf % n_J ) ai = index_two ( a , i , wf % n_v ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_Ja_i ( Ja , i ) ! enddo enddo enddo ! !     Deallocate L_Ja_i ! call deallocator ( L_Ja_i , ( wf % n_J ) * ( wf % n_v ), wf % n_o ) ! ! !     :: L_ij_J contributions :: ! ! !     Allocate L_a_iJ, L_ik_J, L_k_iJ ! call allocator ( L_a_iJ , wf % n_v , ( wf % n_J ) * ( wf % n_o )) call allocator ( L_k_iJ , wf % n_o , ( wf % n_o ) * ( wf % n_J )) ! call allocator ( L_ik_J , ( wf % n_o ) ** 2 , wf % n_J ) ! !     Read Cholesky IJ vectors ! call wf % read_cholesky_ij ( L_ik_J ) ! L_ik_J(ik,J) = L_ik&#94;J ! !     Reorder IJ Cholesky vectors ! do i = 1 , wf % n_o do k = 1 , wf % n_o do J = 1 , wf % n_J ! !              Needed indices ! ik = index_two ( i , k , wf % n_o ) iJ = index_two ( i , J , wf % n_o ) ! L_k_iJ ( k , iJ ) = L_ik_J ( ik , J ) ! L_k_iJ(k,iJ) = L_ik&#94;J ! enddo enddo enddo ! !     Calculate -sum_k t_a_k*L_k_iJ = L_a_iJ  ! Here we assume L_ik&#94;J = L_ki&#94;J ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_o ) * ( wf % n_J ), & wf % n_o , & - one , & wf % t1am , & wf % n_v , & L_k_iJ , & wf % n_o , & zero , & L_a_iJ , & wf % n_v ) ! !     Add terms to T1-transformation of L_ai_J ! do i = 1 , wf % n_o do a = 1 , wf % n_v do J = 1 , wf % n_J ! !              Needed indices ! ai = index_two ( a , i , wf % n_v ) iJ = index_two ( i , J , wf % n_o ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_a_iJ ( a , iJ ) ! enddo enddo enddo ! !     Deallocate L_a_iJ, L_ik_J, L_k_iJ ! call deallocator ( L_a_iJ , wf % n_v , ( wf % n_J ) * ( wf % n_o )) call deallocator ( L_k_iJ , wf % n_o , ( wf % n_o ) * ( wf % n_J )) ! call deallocator ( L_ik_J , ( wf % n_o ) ** 2 , wf % n_J ) ! ! !     :: L_jb_J contributions :: ! ! call allocator ( L_kJ_b , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) call allocator ( L_kb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Read the Cholesky vector L_kb_J ! call wf % read_cholesky_ia ( L_kb_J ) ! !     Reorder L_kb_J to L_kJ_b ! do k = 1 , wf % n_o do b = 1 , wf % n_v do J = 1 , wf % n_J ! kb = index_two ( k , b , wf % n_o ) kJ = index_two ( k , J , wf % n_o ) ! L_kJ_b ( kJ , b ) = L_kb_J ( kb , J ) ! enddo enddo enddo ! !     Deallocate L_kb_J ! call deallocator ( L_kb_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Allocate L_kJ_i ! call allocator ( L_kJ_i , ( wf % n_o ) * ( wf % n_J ), wf % n_o ) ! !     Calculate sum_b L_kJ_b*t_b_i = L_kJ_i ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_J ), & wf % n_o , & wf % n_v , & one , & L_kJ_b , & ( wf % n_o ) * ( wf % n_J ), & wf % t1am , & wf % n_v , & zero , & L_kJ_i , & ( wf % n_o ) * ( wf % n_J )) ! !     Deallocate L_kJ_b ! call deallocator ( L_kJ_b , ( wf % n_o ) * ( wf % n_J ), wf % n_v ) ! !     Allocate L_k_iJ ! call allocator ( L_k_iJ , ( wf % n_o ), ( wf % n_o ) * ( wf % n_J )) ! !     Reorder L_kJ_i to L_k_iJ ! do i = 1 , wf % n_o do k = 1 , wf % n_o do J = 1 , wf % n_J ! kJ = index_two ( k , J , wf % n_o ) iJ = index_two ( i , J , wf % n_o ) ! L_k_iJ ( k , iJ ) = L_kJ_i ( kJ , i ) ! enddo enddo enddo ! !     Deallocate L_kJ_i ! call deallocator ( L_kJ_i , ( wf % n_o ) * ( wf % n_J ), wf % n_o ) ! !     Allocate L_a_iJ ! call allocator ( L_a_iJ , wf % n_v , ( wf % n_o ) * ( wf % n_J )) ! !     Calculate sum_k t_a_k*L_k_iJ = L_a_iJ ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_o ) * ( wf % n_J ), & wf % n_o , & - one , & wf % t1am , & wf % n_v , & L_k_iJ , & wf % n_o , & zero , & L_a_iJ , & wf % n_v ) ! !     Add contribution to L ai_J ! do a = 1 , wf % n_v do i = 1 , wf % n_o do J = 1 , wf % n_J ! iJ = index_two ( i , J , wf % n_o ) ai = index_two ( a , i , wf % n_v ) ! L_ai_J ( ai , J ) = L_ai_J ( ai , J ) + L_a_iJ ( a , iJ ) ! enddo enddo enddo ! !     Deallocations ! call deallocator ( L_a_iJ , wf % n_v , ( wf % n_o ) * ( wf % n_J )) call deallocator ( L_k_iJ , wf % n_o , ( wf % n_o ) * ( wf % n_J )) ! end subroutine get_cholesky_ai_ccs ! ! module subroutine get_cholesky_ab_ccs ( wf , L_ab_J , first , last , ab_dim , reorder ) !! !!    Get Cholesky AB !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Reads and T1-transforms the IA Cholesky vectors: !! !!       L_ab_J_T1 = L_ab_J - sum_i t_ai*L_ib_J !! !!    If reorder = .true.,  L_ba_J is returned with batching over a !!    If reorder = .false., L_ab_J is returned with batching over b !! !!    Required memory: !! !!       n_J*batch_length*n_v   ->   For reordering of L_ab_J / L_ba_J !!       2*n_v*n_o*n_J          ->   For L_ib_J contribution !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ), intent ( in ) :: ab_dim integer ( i15 ), intent ( in ) :: first integer ( i15 ), intent ( in ) :: last ! logical , intent ( in ) :: reorder ! real ( dp ), dimension ( ab_dim , wf % n_J ) :: L_ab_J ! integer ( i15 ) :: memory_lef = 0 ! integer :: unit_chol_ab = - 1 ! Unit identifier for cholesky_ab file ! integer :: a = 0 , b = 0 , J = 0 , i = 0 , ia = 0 , aJ = 0 , ib = 0 , Jb = 0 , ab = 0 , ba = 0 ! real ( dp ), dimension (:,:), allocatable :: L_ib_J real ( dp ), dimension (:,:), allocatable :: L_Jb_i real ( dp ), dimension (:,:), allocatable :: L_Jb_a real ( dp ), dimension (:,:), allocatable :: L_a_Jb real ( dp ), dimension (:,:), allocatable :: L_i_Jb integer ( i15 ) :: batch_length = 0 ! batch_length = last - first + 1 ! !     Testing which index is batched ! if ( reorder ) then !! Batching over a !! ! !        Allocate L_ib_J ! call allocator ( L_ib_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Read L_ia_J ! call wf % read_cholesky_ia ( L_ib_J ) ! Note: using L_ia_J instead of L_ai_J, here, to avoid two reorderings. ! This is possible because of the symmetry L_ai_J(ai,J) == L_ia_J(ia,J). ! !        Read L_ab_J for batch of a ! call wf % read_cholesky_ab ( L_ab_J , first , last , ab_dim , reorder ) ! L_ab_J(ba) = L_ab&#94;J ! !        Allocate L_i,Jb ! call allocator ( L_i_Jb , wf % n_o , ( wf % n_J ) * ( wf % n_v )) ! !        Reorder L_ib_J to L_i_Jb ! do i = 1 , wf % n_o do b = 1 , wf % n_v do J = 1 , wf % n_J ! ib = index_two ( i , b , wf % n_o ) Jb = index_two ( J , b , wf % n_J ) ! L_i_Jb ( i , Jb ) = L_ib_J ( ib , J ) ! enddo enddo enddo ! !        Dellocate L_ib_J ! call deallocator ( L_ib_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Allocate L_a_Jb for batch of a ! call allocator ( L_a_Jb , batch_length , ( wf % n_v ) * ( wf % n_J )) ! !        Calculate  -t1_a_i * L_i_Jb = L_a_Jb ! call dgemm ( 'N' , 'N' , & batch_length , & ( wf % n_v ) * ( wf % n_J ), & wf % n_o , & - one , & wf % t1am ( first , 1 ), & wf % n_v , & L_i_Jb , & wf % n_o , & zero , & L_a_Jb , & batch_length ) ! !        Add terms of L_a_Jb to L_ab_J ! do a = 1 , batch_length do b = 1 , wf % n_v do J = 1 , wf % n_J ! Jb = index_two ( J , b , wf % n_J ) ba = index_two ( b , a , wf % n_v ) ! L_ab_J ( ba , J ) = L_ab_J ( ba , J ) + L_a_Jb ( a , Jb ) ! enddo enddo enddo ! !        Dellocate L_i_Jb and L_a_Jb for batch of a ! call deallocator ( L_a_Jb , batch_length , ( wf % n_J ) * ( wf % n_v )) call deallocator ( L_i_Jb , ( wf % n_J ) * ( wf % n_v ), ( wf % n_o )) ! else !! Batching over b !! ! !        Allocate L_ib_J ! call allocator ( L_ib_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Read L_ia_J ! !        Note: using L_ia_J instead of L_ai_J, here, to avoid two reorderings. !              This is possible because of the symmetry L_ai_J(ai,J) == L_ia_J(ia,J). ! call wf % read_cholesky_ia ( L_ib_J ) ! !        Read L_ab_J for batch of b ! call wf % read_cholesky_ab ( L_ab_J , first , last , ab_dim , reorder ) ! !        Allocate L_Jb,i for batch of b ! call allocator ( L_Jb_i , ( wf % n_J ) * batch_length , wf % n_o ) ! !        Reorder L_ib_J to L_Jb_i ! do i = 1 , wf % n_o do b = 1 , batch_length do J = 1 , wf % n_J ! ib = index_two ( i , b + first - 1 , wf % n_o ) ! Note: in L_ib_J we have all b, not the case for L_Jb_i Jb = index_two ( J , b , wf % n_J ) ! L_Jb_i ( Jb , i ) = L_ib_J ( ib , J ) ! enddo enddo enddo ! !        Dellocate L_ib_J ! call deallocator ( L_ib_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Allocate L_Jb_a for batch of b ! call allocator ( L_Jb_a , ( wf % n_J ) * batch_length , wf % n_v ) ! !        T1-transformation ! call dgemm ( 'N' , 'T' , & ( wf % n_J ) * batch_length , & wf % n_v , & wf % n_o , & - one , & L_Jb_i , & ( wf % n_J ) * batch_length , & wf % t1am , & wf % n_v , & zero , & L_Jb_a , & batch_length * ( wf % n_J )) ! !        Add terms of L_Jb_a to L_ab_J ! do a = 1 , wf % n_v do b = 1 , batch_length do J = 1 , wf % n_J ! Jb = index_two ( J , b , wf % n_J ) ab = index_two ( a , b , wf % n_v ) ! L_ab_J ( ab , J ) = L_ab_J ( ab , J ) + L_Jb_a ( Jb , a ) ! enddo enddo enddo ! !        Dellocate L_Jb,i and L_Jb_a for batch of b ! call deallocator ( L_Jb_a , ( wf % n_J ) * batch_length , wf % n_v ) call deallocator ( L_Jb_i , ( wf % n_J ) * batch_length , wf % n_o ) ! endif ! end subroutine get_cholesky_ab_ccs ! ! end submodule cholesky","tags":"","loc":"sourcefile/cholesky_submodule.f90.html","title":"cholesky_submodule.F90 – Fortran Program"},{"text":"Submodules fock Source Code fock_submodule.F90 Source Code submodule ( ccs_class ) fock ! !! !!    Fock submodule !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Contains the following family of procedures of the CCS class: !! !!    initialize_fock_matrix_ccs(wf):     Allocates and sets Fock matrix to 0. !!    construct_fock_ccs(wf):             Constructs T1_transformed mo Fock matrix. !!    one_electron_t1_ccs(wf, h1 ,h1_T1): T1-transformation of one-electron mo integrals. !! ! implicit none ! ! contains ! ! subroutine initialize_fock_matrix_ccs ( wf ) !! !!     Initialize Fock Matrix !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!     Allocates and sets Fock matrix blocks (ij, ia, ai, ab) to zero !!     before calling the Fock matrix constructor. !! implicit none ! class ( ccs ) :: wf ! call allocator ( wf % fock_ij , wf % n_o , wf % n_o ) call allocator ( wf % fock_ia , wf % n_o , wf % n_v ) call allocator ( wf % fock_ai , wf % n_v , wf % n_o ) call allocator ( wf % fock_ab , wf % n_v , wf % n_v ) ! wf % fock_ij = zero wf % fock_ia = zero wf % fock_ai = zero wf % fock_ab = zero ! call wf % construct_fock ! end subroutine initialize_fock_matrix_ccs ! ! subroutine construct_fock_ccs ( wf ) !! !!    Construct Fock !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    Constructs the T1-transformed Fock matrix blocks (occ/vir-occ/vir), !!    and saves the result in the class variables fock_pq. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:), allocatable :: fock_ao real ( dp ), dimension (:,:), allocatable :: fock_matrix ! real ( dp ), dimension (:,:), allocatable :: h1ao ! AO basis matrix h_αβ real ( dp ), dimension (:,:), allocatable :: h1mo ! MO basis matrix h_pq real ( dp ), dimension (:,:), allocatable :: X ! An intermediate ! integer ( i15 ) :: unit_identifier_ao_integrals = - 1 ! Unit identifier for file mlcc_aoint ! !     Indices ! integer ( i15 ) :: i = 0 , j = 0 , k = 0 , a = 0 , b = 0 integer ( i15 ) :: kj = 0 , ii = 0 , ij = 0 , kk = 0 , ik = 0 , jj = 0 , ji = 0 , ai = 0 , ib = 0 , bi = 0 , ia = 0 integer ( i15 ) :: aj = 0 , ja = 0 , ab = 0 ! !     Useful orbital information ! integer ( i15 ) :: n_ao_sq_packed = 0 ! Dimension of packed (n_ao x n_ao) matrix ! !     Two electron integrals ! real ( dp ), dimension (:,:), allocatable :: g_ij_kl real ( dp ), dimension (:,:), allocatable :: g_ab_ij real ( dp ), dimension (:,:), allocatable :: g_ai_jb real ( dp ), dimension (:,:), allocatable :: g_ia_jk real ( dp ), dimension (:,:), allocatable :: g_ai_jk ! !     Cholesky vectors ! real ( dp ), dimension (:,:), allocatable :: L_ij_J real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: L_ab_J ! !     Batch settings ! integer ( i15 ) :: available = 0 , required = 0 , max_batch_length = 0 integer ( i15 ) :: batch_end = 0 , batch_length = 0 , g_off = 0 , n_batches = 0 integer ( i15 ) :: b_batch = 0 , batch_start = 0 ! !     Allocate one-electron MO integrals ! call allocator ( h1mo , wf % n_mo , wf % n_mo ) h1mo = zero ! call allocator ( fock_matrix , wf % n_mo , wf % n_mo ) fock_matrix = zero ! ! !     :: One-electron contribution :: ! ! !     Allocate for one-electron ao integrals ! n_ao_sq_packed = packed_size ( wf % n_ao ) ! call allocator ( h1ao , n_ao_sq_packed , 1 ) h1ao = zero ! !     Open mlcc_aoint file ! call generate_unit_identifier ( unit_identifier_ao_integrals ) open ( unit = unit_identifier_ao_integrals , file = 'mlcc_aoint' , status = 'old' , form = 'formatted' ) rewind ( unit_identifier_ao_integrals ) ! !     Read in one-electron AO integrals ! read ( unit_identifier_ao_integrals , * ) ( h1ao ( i , 1 ), i = 1 , n_ao_sq_packed ) ! !     Close mlcc_aoint ! close ( unit_identifier_ao_integrals ) ! !     Allocate the AO Fock matrix and add the one-electron contributions ! call allocator ( fock_ao , wf % n_ao , wf % n_ao ) fock_ao = zero ! call squareup ( h1ao , fock_ao , wf % n_ao ) ! !     Deallocation of one-electron AO integrals ! call deallocator ( h1ao , n_ao_sq_packed , 1 ) ! !     Transform to one-electron part to MO basis and save it !     in the fock_matrix ! call allocator ( X , wf % n_ao , wf % n_mo ) ! call dgemm ( 'N' , 'N' , & wf % n_ao , & wf % n_mo , & wf % n_ao , & one , & fock_ao , & wf % n_ao , & wf % mo_coef , & wf % n_ao , & zero , & X , & wf % n_ao ) ! call dgemm ( 'T' , 'N' , & wf % n_mo , & wf % n_mo , & wf % n_ao , & one , & wf % mo_coef , & wf % n_ao , & X , & wf % n_ao , & zero , & h1mo , & wf % n_mo ) ! !     T1-transformation of one-electron integrals in MO basis ! call wf % one_electron_t1 ( h1mo , fock_matrix ) call deallocator ( h1mo , wf % n_mo , wf % n_mo ) ! !     Deallocate intermediate X and fock_ao ! call deallocator ( X , wf % n_ao , wf % n_mo ) call deallocator ( fock_ao , wf % n_ao , wf % n_ao ) ! ! !     :: Two-electron occupied-occupied block: F_ij = h_ij + sum_k (2*g_ijkk - g_ikkj) :: ! ! !     Allocation for L_ij_J ! call allocator ( L_ij_J , ( wf % n_o ) ** 2 , wf % n_J ) call allocator ( g_ij_kl , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! L_ij_J = zero g_ij_kl = zero ! !     Read Cholesky IJ vector ! call wf % get_cholesky_ij ( L_ij_J ) ! !     Calculate g_ij_kl ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & wf % n_J , & one , & L_ij_J , & ( wf % n_o ) ** 2 , & L_ij_J , & ( wf % n_o ) ** 2 , & zero , & g_ij_kl , & ( wf % n_o ) ** 2 ) ! !     Add two-electron contributions to occupied-occupied block ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do k = 1 , wf % n_o ! kk = index_two ( k , k , wf % n_o ) ik = index_two ( i , k , wf % n_o ) kj = index_two ( k , j , wf % n_o ) ! fock_matrix ( i , j ) = fock_matrix ( i , j ) + & two * g_ij_kl ( ij , kk ) - & g_ij_kl ( ik , kj ) ! enddo ! enddo ! enddo ! !     Deallocate g_ij_kl ! call deallocator ( g_ij_kl , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! ! !     :: Two-electron occupied-virtual blocks :: ! ! !     Allocation for g_ia_jk ! call allocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call allocator ( g_ia_jk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) L_ia_J = zero g_ia_jk = zero ! !     Read Cholesky vector L_ia_J ! call wf % get_cholesky_ia ( L_ia_J ) ! !     Calculate g_ia_jk ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) ** 2 , & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ij_J , & ( wf % n_o ) ** 2 , & zero , & g_ia_jk , & ( wf % n_o ) * ( wf % n_v )) ! !     Dealllocate L_ia_J ! call deallocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Allocation for g_ai_jk ! call allocator ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call allocator ( g_ai_jk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) L_ai_J = zero g_ai_jk = zero ! !     Get Cholesky AI vector ! call wf % get_cholesky_ai ( L_ai_J ) ! !     Calculate g_ai_jk ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) ** 2 , & wf % n_J , & one , & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & L_ij_J , & ( wf % n_o ) ** 2 , & zero , & g_ai_jk , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate L_ai_J ! call deallocator ( L_ai_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) ! !     Add terms to Fock matrix ! do i = 1 , wf % n_o do a = 1 , wf % n_v do j = 1 , wf % n_o ! !              Needed indices ! ia = index_two ( i , a , wf % n_o ) ja = index_two ( j , a , wf % n_o ) ! ai = index_two ( a , i , wf % n_v ) aj = index_two ( a , j , wf % n_v ) ! jj = index_two ( j , j , wf % n_o ) ji = index_two ( j , i , wf % n_o ) ij = index_two ( i , j , wf % n_o ) ! !              Set the blocks of the Fock matrix ! fock_matrix ( i , a + wf % n_o ) = fock_matrix ( i , a + wf % n_o ) + & two * g_ia_jk ( ia , jj ) - g_ia_jk ( ja , ij ) ! g_ia_jk(ja,ij) = g_jaij = g_ijja ! fock_matrix ( a + wf % n_o , i ) = fock_matrix ( a + wf % n_o , i ) + & two * g_ai_jk ( ai , jj ) - g_ai_jk ( aj , ji ) ! enddo enddo enddo ! call deallocator ( g_ia_jk , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) ** 2 ) call deallocator ( g_ai_jk , ( wf % n_v ) * ( wf % n_o ), ( wf % n_o ) ** 2 ) ! ! !     :: Two-electron virtual-virtual block F_ab = h_ab + sum_k (2*g_abkk - g_akkb) :: ! ! call allocator ( g_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) g_ab_ij = zero ! !     Batch over index b ! available = get_available () ! required = 2 * ( wf % n_v ) * ( wf % n_v ) * ( wf % n_J ) * 4 + & 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ) * 4 ! call num_batch ( required , available , max_batch_length , n_batches , wf % n_v ) ! batch_start = 1 batch_end = 0 batch_length = 0 ! !     Loop over the batches ! do b_batch = 1 , n_batches ! !        Get batch limits and length of batch ! call batch_limits ( batch_start , batch_end , b_batch , max_batch_length , wf % n_v ) batch_length = batch_end - batch_start + 1 ! !        Allocate L_ab_J ! call allocator ( L_ab_J , ( wf % n_v ) * batch_length , wf % n_J ) L_ab_J = zero ! !        Read Cholesky vectors ! call wf % get_cholesky_ab ( L_ab_J , batch_start , batch_end , ( wf % n_v ) * batch_length , . false .) ! !        Calculate g_ab_ij = sum_J L_ab_J*L_ij_J ! g_off = index_two ( 1 , batch_start , wf % n_v ) ! call dgemm ( 'N' , 'T' , & ( wf % n_v ) * batch_length , & ( wf % n_o ) ** 2 , & wf % n_J , & one , & L_ab_J , & ( wf % n_v ) * batch_length , & L_ij_J , & ( wf % n_o ) ** 2 , & one , & g_ab_ij ( g_off , 1 ), & ( wf % n_v ) ** 2 ) ! !        Deallocate L_ab_J ! call deallocator ( L_ab_J , batch_length * ( wf % n_v ), wf % n_J ) ! enddo ! batching done ! !     Deallocate L_ij_J ! call deallocator ( L_ij_J , ( wf % n_o ) ** 2 , wf % n_J ) ! !     Allocate for g_ai_jb ! call allocator ( g_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ai_jb = 0 ! call allocator ( L_ai_J , ( wf % n_v ) * ( wf % n_o ), wf % n_J ) call allocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_ai_J = 0 L_ia_J = 0 ! !     Read Cholesky vectors L_ia_J and L_ai_J ! call wf % get_cholesky_ia ( L_ia_J ) call wf % get_cholesky_ai ( L_ai_J ) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ai_jb , & ( wf % n_o ) * ( wf % n_v )) ! !     Calculate two-electron terms for virtual-virtual blocks ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ai_jb , & ( wf % n_o ) * ( wf % n_v )) ! !    Deallocate L_ia_J ! call deallocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call deallocator ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! do a = 1 , wf % n_v do b = 1 , wf % n_v ! ab = index_two ( a , b , wf % n_v ) ! do i = 1 , wf % n_o ! ii = index_two ( i , i , wf % n_o ) ai = index_two ( a , i , wf % n_v ) bi = index_two ( b , i , wf % n_v ) ia = index_two ( i , a , wf % n_o ) ib = index_two ( i , b , wf % n_o ) ! fock_matrix ( wf % n_o + a , wf % n_o + b ) = fock_matrix ( wf % n_o + a , wf % n_o + b ) & + two * g_ab_ij ( ab , ii ) & - g_ai_jb ( ai , ib ) ! enddo ! enddo enddo ! call deallocator ( g_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) call deallocator ( g_ai_jb , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Save the blocks of the Fock matrix in memory (ij,ia,ai,ab) ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! wf % fock_ij ( i , j ) = fock_matrix ( i , j ) ! enddo enddo ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! wf % fock_ia ( i , a ) = fock_matrix ( i , wf % n_o + a ) wf % fock_ai ( a , i ) = fock_matrix ( wf % n_o + a , i ) ! enddo enddo ! do a = 1 , wf % n_v do b = 1 , wf % n_v ! wf % fock_ab ( a , b ) = fock_matrix ( wf % n_o + a , wf % n_o + b ) ! enddo enddo ! call deallocator ( fock_matrix , wf % n_mo , wf % n_mo ) ! end subroutine construct_fock_ccs ! ! subroutine one_electron_t1_ccs ( wf , h1 , h1_T1 ) !! !!    One-electron T1 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!    T1-transforms the one-electron MO integrals h_pq !! !!       h_p_q_T1 = sum_st x_p_s * y_q_t * h_s_t, !! !!    where !! !!       x = I - t1, !!       y = I - t1&#94;T. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension ( wf % n_mo , wf % n_mo ) :: h1 real ( dp ), dimension ( wf % n_mo , wf % n_mo ) :: h1_T1 ! real ( dp ), dimension (:,:), allocatable :: x real ( dp ), dimension (:,:), allocatable :: y real ( dp ), dimension (:,:), allocatable :: t1 ! real ( dp ), dimension (:,:), allocatable :: Z ! Intermediate for matrix multiplication ! integer ( i15 ) :: p = 0 , q = 0 , a = 0 , i = 0 ! !     Allocate the arrays t1, x, and y ! call allocator ( t1 , wf % n_mo , wf % n_mo ) t1 = zero ! call allocator ( y , wf % n_mo , wf % n_mo ) call allocator ( x , wf % n_mo , wf % n_mo ) ! y = zero x = zero ! !     Set t1_p_q = t1am_p_q for p virtual and q occupied, 0 otherwise ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! t1 ( wf % n_o + a , i ) = wf % t1am ( a , i ) ! enddo enddo ! !     Form the x and y arrays ! do p = 1 , wf % n_mo do q = 1 , wf % n_mo ! if ( p . eq . q ) then ! x ( p , q ) = 1 y ( p , q ) = 1 ! else ! x ( p , q ) = x ( p , q ) - t1 ( p , q ) y ( p , q ) = y ( p , q ) + t1 ( q , p ) ! endif ! enddo enddo ! !     Deallocate t1 (only x and y are needed below) ! call deallocator ( t1 , wf % n_mo , wf % n_mo ) ! !     Allocate Z intermediate ! call allocator ( Z , wf % n_mo , wf % n_mo ) ! !     Calculate h1_T1 = x*h1*y&#94;T = x*Z ! call dgemm ( 'N' , 'T' , & wf % n_mo , & wf % n_mo , & wf % n_mo , & one , & h1 , & wf % n_mo , & y , & wf % n_mo , & zero , & Z , & wf % n_mo ) ! call dgemm ( 'N' , 'N' , & wf % n_mo , & wf % n_mo , & wf % n_mo , & one , & x , & wf % n_mo , & Z , & wf % n_mo , & zero , & h1_T1 , & wf % n_mo ) ! !     Deallocate x and y, and the intermediate Z ! call deallocator ( Z , wf % n_mo , wf % n_mo ) call deallocator ( y , wf % n_mo , wf % n_mo ) call deallocator ( x , wf % n_mo , wf % n_mo ) ! end subroutine one_electron_t1_ccs ! ! end submodule","tags":"","loc":"sourcefile/fock_submodule.f90.html","title":"fock_submodule.F90 – Fortran Program"},{"text":"Submodules ground_state Source Code ground_state_submodule.F90 Source Code submodule ( ccs_class ) ground_state ! !! !!                                Ground state submodule (CCS) !!                Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Consists of the following subroutines of the CCS module: !! !!    ground_state_solver:        Controls the iterative loop, calling in turn !!                                the calculation of the energy, the amplitude equations !!                                (and its norm), and the new_amplitudes routine. !! !!    new_amplitudes:             Calculates the quasi-Newton estimate and passes the !!                                information needed by the DIIS routine. !! !!    diis_ccs:                   This routine saves the quasi-Newton estimate Δ t and !!                                t + Δ t to file. It uses the previous estimates to !!                                select the amplitudes t for the next iteration. !! !! !!    calc_ampeqs:                Updates the amplitude equations for the current amplitudes. !!    calc_ampeqs_norm:           Calculates the norm of the amplitude equations. !!    calc_quasi_Newton_singles:  Calculates the singles part of the quasi-Newton estimate. !! !!    Can be inherited by models of the same level (e.g. CC2) without modification. !! !!    When inherited by higher level models (e.g. CCSD), the new_amplitudes and calc_ampeqs_norm !!    routines should be overridden to account for the doubles quasi-Newton estimate, amplitudes, !!    and projection vector. !! ! implicit none ! !  Some variables available to all routines of the module ! integer ( i15 ) :: iteration = - 1 ! integer ( i15 ) :: unit_dt = - 1 ! Unit identifier for Δ t_i file integer ( i15 ) :: unit_t_dt = - 1 ! Unit identifier for t_i + Δ t_i file integer ( i15 ) :: unit_diis_matrix = - 1 ! Unit identifier for DIIS matrix file ! integer ( i15 ), parameter :: diis_dim = 9 ! The maximum dimension of the DIIS matrix, plus 1 ! ! contains ! ! module subroutine ground_state_solver_ccs ( wf ) !! !!    Ground State Solver !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Directs the solution of the ground state amplitude equations !!    using a DIIS algorithm. The problem the routine solves is !! !!       X_mu(t) = 0, where t = { t_mu }_mu !! !!    For standard coupled cluster theories, the vector X is the !!    projection vector (omega). !! implicit none ! class ( ccs ) :: wf ! real ( dp ) :: prev_energy real ( dp ) :: ampeqs_norm ! real ( dp ) :: start_gs_solver , end_gs_solver ! logical :: converged_energy = . false . logical :: converged_ampeqs = . false . ! logical :: converged = . false . ! True iff both the energy and the equations have converged ! !     Let the user know the ground state solver is running ! write ( unit_output , '(/t3,a)' ) ':: Ground state solver (DIIS)' write ( unit_output , '(t3,a/)' ) ':: S. D. Folkestad, E. F. Kjønstad, May 2017' write ( unit_output , '(t3,a,a,a/)' ) & 'Requested the ground state for: ' , trim ( wf % name ), '.' ! write ( unit_output , '(t3,a)' ) 'Iter.   Energy           Norm of amplitude eq.' write ( unit_output , '(t3,a)' ) '----------------------------------------------' ! !     Make sure the initial energy is up to date ! call wf % calc_energy ! !     Open DIIS files ! call generate_unit_identifier ( unit_dt ) open ( unit = unit_dt , file = 'diis_dt' , status = 'unknown' , form = 'unformatted' ) ! call generate_unit_identifier ( unit_t_dt ) open ( unit = unit_t_dt , file = 'diis_t_dt' , status = 'unknown' , form = 'unformatted' ) ! call generate_unit_identifier ( unit_diis_matrix ) open ( unit = unit_diis_matrix , file = 'diis_matrix' , status = 'unknown' , form = 'unformatted' ) ! !     Enter iterative loop ! iteration = 1 ! call cpu_time ( start_gs_solver ) ! do while ((. not . converged ) . and . ( iteration . le . wf % settings % ampeqs_max_iterations )) ! !        Save the previous energy ! prev_energy = wf % energy ! !        Update the energy ! call wf % calc_energy ! !        Update the Fock matrix ! call wf % construct_fock ! !        Construct the current amplitude equations vector, !        and calculate the norm of the amplitude equations ! call wf % calc_ampeqs call wf % calc_ampeqs_norm ( ampeqs_norm ) ! !        Check for convergence of the energy and the amplitude equations ! converged_energy = abs ( wf % energy - prev_energy ) . lt . wf % settings % energy_threshold converged_ampeqs = ampeqs_norm . lt . wf % settings % ampeqs_threshold ! !        Print information to output ! write ( unit_output , '(T3,I2,5X,F14.8,4X,E10.4)' ) iteration , wf % energy , ampeqs_norm flush ( unit_output ) ! Flush so that the user can follow each iteration in real-time ! !        Perform DIIS update if convergence hasn't been reached ! if ( converged_energy . and . converged_ampeqs ) then ! converged = . true . ! write ( unit_output , '(/t3,a,i2,a/)' ) 'Converged in ' , iteration , ' iterations!' write ( unit_output , '(t3,a27,f14.8)' ) 'Total energy (hartrees):' , wf % energy ! else ! !           Update the amplitudes for the next iteration ! call wf % new_amplitudes iteration = iteration + 1 ! endif ! enddo ! !     Close the DIIS files ! close ( unit_dt ) close ( unit_t_dt ) close ( unit_diis_matrix ) ! call cpu_time ( end_gs_solver ) ! write ( unit_output , '(t3,a27,f14.8/)' ) 'Total time (seconds):' , end_gs_solver - start_gs_solver ! end subroutine ground_state_solver_ccs ! ! module subroutine calc_ampeqs_ccs ( wf ) !! !!    Calculate Amplitude Equations (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Constructs the amplitude equations vector (the projection vector !!    in CCS) for the amplitudes of the current iteration of the ground !!    state solver. It also calculates the norm of the amplitude equations, !!    which is zero when the equations are exactly solved. !! implicit none ! class ( ccs ) :: wf ! !     Update the projection vector ! call wf % construct_omega ! end subroutine calc_ampeqs_ccs ! ! module subroutine calc_ampeqs_norm_ccs ( wf , ampeqs_norm ) !! !!     Calculate Amplitude Equations Norm (CCS) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! class ( ccs ) :: wf ! real ( dp ) :: ampeqs_norm ! real ( dp ) :: ddot ! For dot product ! ampeqs_norm = zero ampeqs_norm = ddot ( wf % n_t1am , wf % omega1 , 1 , wf % omega1 , 1 ) ampeqs_norm = sqrt ( ampeqs_norm ) ! end subroutine calc_ampeqs_norm_ccs ! ! module subroutine new_amplitudes_ccs ( wf ) !! !!    New Amplitudes (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Directs the calculation of the quasi-Newton estimate Δ t_i, !!    and t_i + Δ t_i, and calls the DIIS routine to save & get !!    the amplitudes for the next iteration. !! implicit none ! class ( ccs ) :: wf ! real ( dp ), dimension (:,:), allocatable :: dt ! Δ t_i real ( dp ), dimension (:,:), allocatable :: t_dt ! t_i + Δ t_i ! integer ( i15 ) :: n_variables = 0 ! n_variables = wf % n_t1am ! !     Allocate Δ t_i and t_i + Δ t_i vectors ! call allocator ( dt , n_variables , 1 ) call allocator ( t_dt , n_variables , 1 ) ! dt = zero t_dt = zero ! !     Calculate Δ t_i ! call wf % calc_quasi_Newton_singles ( dt , n_variables ) ! !     Set t_i + Δ t_i ! call dcopy ( wf % n_t1am , dt , 1 , t_dt , 1 ) ! t_dt = Δ t_i call daxpy ( wf % n_t1am , one , wf % t1am , 1 , t_dt , 1 ) ! t_dt = t_i + Δ t_i ! !     Save estimates to file and get the next amplitudes !     (they are placed in dt on exit from diis) ! call wf % diis ( dt , t_dt , n_variables ) ! !     Set the new amplitudes ! call dcopy ( wf % n_t1am , dt , 1 , wf % t1am , 1 ) ! !     Deallocate vectors ! call deallocator ( dt , n_variables , 1 ) call deallocator ( t_dt , n_variables , 1 ) ! end subroutine new_amplitudes_ccs ! ! module subroutine calc_quasi_Newton_singles_ccs ( wf , dt , n_variables ) !! !!    Calculate quasi-Newton estimate (CCS) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Calculates the quasi-Newton estimate Δ t_i (singles part) !!    and places the contribution in the dt vector (of length n_variables, !!    with singles first, then doubles, etc. if inherited) !! implicit none ! class ( ccs ) :: wf ! integer ( i15 ), intent ( in ) :: n_variables real ( dp ), dimension ( n_variables , 1 ) :: dt ! integer ( i15 ) :: a = 0 , i = 0 , ai = 0 ! !     Calculate the singles Δ t_i contribbution ! do a = 1 , wf % n_v do i = 1 , wf % n_o ! ai = index_two ( a , i , wf % n_v ) ! dt ( ai , 1 ) = - wf % omega1 ( a , i ) / ( wf % fock_diagonal ( wf % n_o + a , 1 ) - & wf % fock_diagonal ( i , 1 )) ! enddo enddo ! end subroutine calc_quasi_Newton_singles_ccs ! ! module subroutine diis_ccs ( wf , dt , t_dt , n_variables ) !! !!    DIIS routine !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    The next amplitudes are !! !!       t_n+1 = sum_k w_k (t_k + dt_k), !! !!    where the weights w_k in front of the quasi-Newton estimate dt_k !!    are determined so as to minimize !! !!       f(w_k) = sum_k w_k dt_k, !! !!    with the constraint that g(w_k) = sum_k w_k - 1 = 0. !! implicit none ! class ( ccs ), intent ( in ) :: wf ! integer ( i15 ), intent ( in ) :: n_variables ! real ( dp ), dimension ( n_variables , 1 ) :: dt real ( dp ), dimension ( n_variables , 1 ) :: t_dt ! real ( dp ), dimension (:,:), allocatable :: dt_i ! To hold previous Δ t_i temporarily ! real ( dp ) :: ddot ! integer ( i15 ) :: i = 0 , j = 0 ! integer :: info = - 1 ! Error integer for dgesv routine (LU factorization) integer ( i15 ) :: current_index = 0 ! Progressing as follows: 1,2,...,7,8,1,2,... ! real ( dp ), dimension (:,:), allocatable :: diis_vector real ( dp ), dimension (:,:), allocatable :: diis_matrix ! integer ( i15 ), dimension ( diis_dim ) :: ipiv = 0 ! Pivot integers (see dgesv routine) ! !     Set the current index ! current_index = iteration - ( diis_dim - 1 ) * (( iteration - 1 ) / ( diis_dim - 1 )) ! 1,2,...,7,8,1,2,... ! !     :: Save (Δ t_i) and (t_i + Δ t_i) to files :: ! if ( current_index . eq . 1 ) then rewind ( unit_dt ) rewind ( unit_t_dt ) endif ! write ( unit_dt ) ( dt ( i , 1 ), i = 1 , n_variables ) write ( unit_t_dt ) ( t_dt ( i , 1 ), i = 1 , n_variables ) ! !     :: Solve the least squares problem, G * w = H :: ! !        G : DIIS matrix, G_ij = Δ t_i Δ t_j, !        H : DIIS vector,  H_i = 0, ! !     where i, j = 1, 2, ..., current_index. To enforce normality !     of the solution, G is extended with a row & column of -1's !     and H with a -1 at the end. ! !     First set the DIIS vector to one ! call allocator ( diis_vector , current_index + 1 , 1 ) diis_vector = zero ! !     Allocate the DIIS matrix and read in previous matrix elements ! call allocator ( diis_matrix , current_index + 1 , current_index + 1 ) diis_matrix = zero ! if ( current_index . gt . 1 ) then ! rewind ( unit_diis_matrix ) ! do j = 1 , current_index - 1 do i = 1 , current_index - 1 ! read ( unit_diis_matrix ) diis_matrix ( i , j ) ! enddo enddo ! endif ! !     Get the parts of the DIIS matrix G not constructed in !     the previous iterations ! call allocator ( dt_i , n_variables , 1 ) ! Allocate temporary holder of quasi-Newton estimates dt_i = zero ! rewind ( unit_dt ) ! do i = 1 , current_index ! read ( unit_dt ) ( dt_i ( j , 1 ), j = 1 , n_variables ) ! diis_matrix ( current_index , i ) = ddot ( n_variables , dt , 1 , dt_i , 1 ) diis_matrix ( i , current_index ) = diis_matrix ( current_index , i ) ! diis_matrix ( current_index + 1 , i ) = - one diis_matrix ( i , current_index + 1 ) = - one ! enddo ! diis_vector ( current_index + 1 , 1 ) = - one ! !     Write the current DIIS matrix to file ! rewind ( unit_diis_matrix ) ! do j = 1 , current_index do i = 1 , current_index ! write ( unit_diis_matrix ) diis_matrix ( i , j ) ! enddo enddo ! !     Solve the DIIS equation ! !     Note: on exit, the solution is in the diis_vector, !     provided info = 0 (see LAPACK documentation for more) ! call dgesv ( current_index + 1 , & 1 , & diis_matrix , & current_index + 1 , & ipiv , & diis_vector , & current_index + 1 , & info ) ! !     :: Update the amplitudes (placed in dt on exit) :: ! dt = zero ! rewind ( unit_t_dt ) ! do i = 1 , current_index ! !        Read the t_i + Δ t_i vector ! t_dt = zero read ( unit_t_dt ) ( t_dt ( j , 1 ), j = 1 , n_variables ) ! !        Add w_i (t_i + Δ t_i) to the amplitudes ! call daxpy ( n_variables , diis_vector ( i , 1 ), t_dt , 1 , dt , 1 ) ! enddo ! !     Deallocations ! call deallocator ( dt_i , n_variables , 1 ) call deallocator ( diis_vector , current_index + 1 , 1 ) call deallocator ( diis_matrix , current_index + 1 , current_index + 1 ) ! end subroutine diis_ccs ! ! end submodule ground_state","tags":"","loc":"sourcefile/ground_state_submodule.f90.html","title":"ground_state_submodule.F90 – Fortran Program"},{"text":"Submodules ground_state Source Code ground_state_submodule.F90 Source Code submodule ( ccsd_class ) ground_state ! !! !!     Ground state submodule (CCSD) !!     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !! !!     Consists of the following subroutines of the CCSD module: !! !!     new_amplitudes:             Calculates the quasi-Newton estimate and passes the !!                                 information needed by the DIIS routine. !!     calc_ampeqs_norm:           Calculates the norm of the amplitude equations. !!     calc_quasi_Newton_doubles:  Calculates the doubles part of the quasi-Newton estimate. !! !!     Can be inherited by models of the same level (e.g. CC3) without modification. !! !!     When inherited by higher level models (e.g. CCSDT), the new_amplitudes and calc_ampeqs_norm !!     routines should be overridden to account for the triples quasi-Newton estimate, amplitudes, !!     and projection vector. !! ! implicit none ! ! contains ! ! module subroutine calc_ampeqs_norm_ccsd ( wf , ampeqs_norm ) ! !     Calculate Amplitude Equations Norm (CCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! implicit none ! class ( ccsd ) :: wf ! real ( dp ) :: ampeqs_norm ! real ( dp ) :: ddot ! For dot product ! ampeqs_norm = zero ampeqs_norm = ddot ( wf % n_t1am , wf % omega1 , 1 , wf % omega1 , 1 ) ampeqs_norm = ddot ( wf % n_t2am , wf % omega2 , 1 , wf % omega2 , 1 ) + ampeqs_norm ampeqs_norm = sqrt ( ampeqs_norm ) ! end subroutine calc_ampeqs_norm_ccsd ! ! module subroutine new_amplitudes_ccsd ( wf ) ! !     New Amplitudes (CCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !     Directs the calculation of the quasi-Newton estimate Δ t_i, !     and t_i + Δ t_i, and calls the DIIS routine to save & get !     the amplitudes for the next iteration. ! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ) :: i = 0 ! for debug purposes ! real ( dp ), dimension (:,:), allocatable :: dt ! Δ t_i real ( dp ), dimension (:,:), allocatable :: t_dt ! t_i + Δ t_i ! integer ( i15 ) :: n_variables = 0 ! n_variables = wf % n_t1am + wf % n_t2am ! !     Allocate Δ t_i and t_i + Δ t_i vectors ! call allocator ( dt , n_variables , 1 ) call allocator ( t_dt , n_variables , 1 ) ! dt = zero t_dt = zero ! !     Calculate Δ t_i ! call wf % calc_quasi_Newton_singles ( dt , n_variables ) call wf % calc_quasi_Newton_doubles ( dt , n_variables ) ! !     Set t_i + Δ t_i ! call dcopy ( n_variables , dt , 1 , t_dt , 1 ) ! t_dt = Δ t_i ! call daxpy ( wf % n_t1am , one , wf % t1am , 1 , t_dt , 1 ) ! t_dt = t_i + Δ t_i singles call daxpy ( wf % n_t2am , one , wf % t2am , 1 , t_dt ( wf % n_t1am + 1 , 1 ), 1 ) ! t_dt = t_i + Δ t_i doubles ! !     Save estimates to file and get the next amplitudes !     (they are placed in dt on exit from diis) ! call wf % diis ( dt , t_dt , n_variables ) ! !     Set the new amplitudes ! call dcopy ( wf % n_t1am , dt , 1 , wf % t1am , 1 ) call dcopy ( wf % n_t2am , dt ( wf % n_t1am + 1 , 1 ), 1 , wf % t2am , 1 ) ! !     Deallocate vectors ! call deallocator ( dt , n_variables , 1 ) call deallocator ( t_dt , n_variables , 1 ) ! end subroutine new_amplitudes_ccsd ! ! module subroutine calc_quasi_Newton_doubles_ccsd ( wf , dt , n_variables ) ! !     Calculate quasi-Newtoni doubles estimate (CCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !     Calculates the quasi-Newton estimate Δ t_i (doubbles part) !     and places the contribution in the dt vector (of length n_variables, !     with singles first, then doubles, etc. if inherited) ! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ), intent ( in ) :: n_variables real ( dp ), dimension ( n_variables , 1 ) :: dt ! integer ( i15 ) :: a = 0 , i = 0 , b = 0 , j = 0 integer ( i15 ) :: ai = 0 , bj = 0 , aibj = 0 , offset = 0 ! !     Calculate the doubles Δ t_i contribbution ! do a = 1 , wf % n_v do i = 1 , wf % n_o do b = 1 , wf % n_v do j = 1 , wf % n_o ! !                 Calculate the necessary indices ! ai = index_two ( a , i , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! offset = wf % n_t1am + aibj ! dt has singles first, then doubles ! dt ( offset , 1 ) = - wf % omega2 ( aibj , 1 ) / ( wf % fock_diagonal ( wf % n_o + a , 1 ) + & wf % fock_diagonal ( wf % n_o + b , 1 ) - & wf % fock_diagonal ( i , 1 ) - & wf % fock_diagonal ( j , 1 )) ! enddo enddo enddo enddo ! end subroutine calc_quasi_Newton_doubles_ccsd ! ! end submodule ground_state","tags":"","loc":"sourcefile/ground_state_submodule.f90~2.html","title":"ground_state_submodule.F90 – Fortran Program"},{"text":"Submodules omega Source Code omega_submodule.F90 Source Code submodule ( ccsd_class ) omega ! !! !!    Omega submodule (CCSD) !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !! !!    Contains the following family of procedures of the CCSD class: !! !!    initialize_omega: allocates the projection vector (omega1, omega2) !!                          and sets it to zero. !! !!    construct_omega:  constructs the projection vector (omega1, omega2) !!                          for the current amplitudes (t1am, t2am) for the !!                          wavefunction object wf. The routine assumes that !!                          the projection vector is allocated. !! !!    omega_a1:         adds A1 term to omega1 !!    omega_b1:         adds B1 term to omega1 !!    omega_c1:         adds C1 term to omega1 !!    omega_d1:         adds D1 term to omega1 !! !!    omega_a2:         adds A2 term to omega2 !!    omega_b2:         adds B2 term to omega2 !!    omega_c2:         adds C2 term to omega2 !!    omega_d2:         adds D2 term to omega2 !!    omega_e2:         adds E2 term to omega2 !! ! implicit none ! logical :: debug = . false . ! real ( dp ) :: begin_timer real ( dp ) :: end_timer ! ! contains ! ! module subroutine initialize_omega_ccsd ( wf ) ! !      Initialize Omega (CCSD) !      Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 ! !      Allocates the projection vector (omega1, omega2) and sets it !      to zero. ! implicit none ! class ( ccsd ) :: wf ! call allocator ( wf % omega1 , wf % n_v , wf % n_o ) wf % omega1 = zero ! call allocator ( wf % omega2 , wf % n_t2am , 1 ) wf % omega2 = zero ! end subroutine initialize_omega_ccsd ! ! module subroutine construct_omega_ccsd ( wf ) ! !     Construct Omega (CCSD) !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 ! !     Directs the construction of the projection vector < mu | exp(-T) H exp(T) | R > !     for the current amplitudes of the object wfn ! implicit none ! class ( ccsd ) :: wf ! !     Set the omega vector to zero ! wf % omega1 = zero wf % omega2 = zero ! !     Construct singles contributions ! call wf % omega_a1 call wf % omega_b1 call wf % omega_c1 call wf % omega_d1 ! !     Construct doubles contributions ! call wf % omega_a2 call wf % omega_b2 call wf % omega_c2 call wf % omega_d2 call wf % omega_e2 ! end subroutine construct_omega_ccsd ! ! module subroutine omega_a1_ccsd ( wf ) ! !       Omega A1 term !       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 ! !       Calculates the A1 term, ! !       A1: sum_ckd g_adkc * u_ki&#94;cd, ! !       and adds it to the singles projection vector (omega1) of !       the wavefunction object wf. ! implicit none ! class ( ccsd ) :: wf ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , batch_dimension = 0 integer ( i15 ) :: n_batch = 0 , a_begin = 0 , a_end = 0 , a_batch = 0 , batch_length = 0 ! !     Indices ! integer ( i15 ) :: i = 0 , j = 0 , a = 0 , c = 0 , k = 0 , d = 0 integer ( i15 ) :: ad = 0 , ad_dim = 0 , ci = 0 , cidk = 0 , ck = 0 integer ( i15 ) :: ckd = 0 , ckdi = 0 , di = 0 , dk = 0 , kc = 0 , da = 0 ! real ( dp ), dimension (:,:), allocatable :: L_kc_J real ( dp ), dimension (:,:), allocatable :: L_da_J ! L_ad&#94;J; a is being batched over real ( dp ), dimension (:,:), allocatable :: g_da_kc ! g_adkc; a is being batched over real ( dp ), dimension (:,:), allocatable :: g_a_ckd ! reordered g_adkc; a is being batched over real ( dp ), dimension (:,:), allocatable :: u_ckd_i ! u_ki&#94;cd ! logical :: reorder ! To get L_ab_J reordered, for batching over a (first index) ! !     Allocate u_ckd_i = u_ki&#94;cd ! call allocator ( u_ckd_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) u_ckd_i = zero ! !     Calculate u_ckd_i ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) ! do d = 1 , wf % n_v ! ckd = index_three ( c , k , d , wf % n_v , wf % n_o ) dk = index_two ( d , k , wf % n_v ) ! do i = 1 , wf % n_o ! di = index_two ( d , i , wf % n_v ) ci = index_two ( c , i , wf % n_v ) ! ckdi = index_packed ( ck , di ) cidk = index_packed ( ci , dk ) ! !                 Calculate u_ckd_i ! u_ckd_i ( ckd , i ) = two * ( wf % t2am ( ckdi , 1 )) - wf % t2am ( cidk , 1 ) ! enddo enddo enddo enddo ! !     Calculate the batching parameters over a = 1,2,...,n_vir, !     for which we need to have enough room to store L_ad_J and g_ad_kc, and, !     later on in the same loop, g_ad_kc and g_a_ckd simultaneously ! available = get_available () required = ( wf % n_J ) * ( wf % n_v ** 2 ) + ( wf % n_J ) * ( wf % n_o ) * ( wf % n_v ) ! Needed to hold L_ab_J and L_kc_J required = required & + max (( wf % n_J ) * ( wf % n_v ** 2 ) + 2 * ( wf % n_J ) * ( wf % n_o ) * ( wf % n_v ), & ! Determine if it is more demanding to get L_ab_J 2 * ( wf % n_o ) * ( wf % n_v ** 3 )) ! or to hold g_ad_kc and g_a_ckd ! required = 4 * required ! In words ! batch_dimension = wf % n_v ! Batch over the virtual index a max_batch_length = 0 ! Initilization of unset variables n_batch = 0 ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Loop over the number of a batches ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_begin , a_end , a_batch , max_batch_length , batch_dimension ) batch_length = a_end - a_begin + 1 ! !        Allocate Cholesky vector L_kc_J ! call allocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) L_kc_J = zero ! !        Get Cholesky vector L_kc_J ! call wf % get_cholesky_ia ( L_kc_J ) ! !        Allocate the Cholesky vector L_da_J = L_ad&#94;J ! ad_dim = batch_length * ( wf % n_v ) ! Dimension of ad for the batch over index a ! call allocator ( L_da_J , ad_dim , wf % n_J ) L_da_J = zero ! !        Get reordered Cholesky vector (Note: L_da_J(da,J) = L_ad&#94;J) ! reorder = . true . call wf % get_cholesky_ab ( L_da_J , a_begin , a_end , & ad_dim , reorder ) ! !        Allocate g_da_kc = g_adkc ! call allocator ( g_da_kc , ad_dim , ( wf % n_o ) * ( wf % n_v )) ! !        Calculate g_da_kc = sum_J L_da_J L_kc_J&#94;T = sum_J L_ad&#94;J L_kc&#94;J = g_adkc ! call dgemm ( 'N' , 'T' , & ad_dim , & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_da_J , & ad_dim , & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_da_kc , & ad_dim ) ! !        Deallocate the reordered Cholesky vector L_da_J and L_kc_J ! call deallocator ( L_da_J , ad_dim , wf % n_J ) call deallocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !        Form the reordered integrals g_a_ckd = g_adkc ! call allocator ( g_a_ckd , batch_length , ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! do c = 1 , wf % n_v do k = 1 , wf % n_o ! kc = index_two ( k , c , wf % n_o ) ! do d = 1 , wf % n_v do a = 1 , batch_length ! da = index_two ( d , a , wf % n_v ) ckd = index_three ( c , k , d , wf % n_v , wf % n_o ) ! g_a_ckd ( a , ckd ) = g_da_kc ( da , kc ) ! g_adkc ! enddo enddo enddo enddo ! !        Deallocate reordered integrals g_da_kc ! call deallocator ( g_da_kc , ad_dim , ( wf % n_o ) * ( wf % n_v )) ! !        Calculate the A1 term (sum_ckd g_a,ckd * u_ckd,i) & add to the omega vector ! call dgemm ( 'N' , 'N' , & batch_length , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & g_a_ckd , & batch_length , & u_ckd_i , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & wf % omega1 ( a_begin , 1 ), & wf % n_v ) ! call deallocator ( g_a_ckd , batch_length , ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! enddo ! End of batches of the index a ! !     Deallocate vectors ! call deallocator ( u_ckd_i , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! end subroutine omega_a1_ccsd ! ! module subroutine omega_b1_ccsd ( wf ) !! !!       Omega B1 !!       Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 !! !!       Calculates the B1 term, !! !!        B1:  - sum_ckl u_kl&#94;ac * g_kilc, !! !!       and adds it to the singles projection vector (omeg1) of !!       the wavefunction object wf !! implicit none ! class ( ccsd ) :: wf ! integer ( i15 ) :: a = 0 , c = 0 , k = 0 , l = 0 , ckl = 0 , ki = 0 integer ( i15 ) :: ak = 0 , akcl = 0 , al = 0 , alck = 0 , ck = 0 , ai = 0 integer ( i15 ) :: cl = 0 , lc = 0 , i = 0 , j = 0 ! real ( dp ), dimension (:,:), allocatable :: L_ki_J ! L_ki&#94;J real ( dp ), dimension (:,:), allocatable :: L_lc_J ! L_lc&#94;J real ( dp ), dimension (:,:), allocatable :: g_ki_lc ! g_kilc real ( dp ), dimension (:,:), allocatable :: g_ckl_i ! g_kilc real ( dp ), dimension (:,:), allocatable :: u_a_ckl ! u_kl&#94;ac = 2 t_kl&#94;ac - t_lk&#94;ac ! !     Form the Cholesky vectors L_ki_J and L_lc_J ! call allocator ( L_ki_J , ( wf % n_o ) ** 2 , wf % n_J ) call allocator ( L_lc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! call wf % get_cholesky_ij ( L_ki_J ) call wf % get_cholesky_ia ( L_lc_J ) ! !     Allocate integrals g_ki_lc = g_kilc ! call allocator ( g_ki_lc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Calculate g_ki_lc = sum_J L_ki_J L_lc_J&#94;T ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ki_J , & ( wf % n_o ) ** 2 , & L_lc_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ki_lc , & ( wf % n_o ) ** 2 ) ! !     Deallocate the Cholesky vectors L_ki_J and L_lc_J ! call deallocator ( L_ki_J , ( wf % n_o ) ** 2 , wf % n_J ) call deallocator ( L_lc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Form the reordered integrals g_ckl_i = g_kilc ! call allocator ( g_ckl_i , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_o ) ! do i = 1 , wf % n_o do l = 1 , wf % n_o do k = 1 , wf % n_o ! ki = index_two ( k , i , wf % n_o ) ! do c = 1 , wf % n_v ! ckl = index_three ( c , k , l , wf % n_v , wf % n_o ) lc = index_two ( l , c , wf % n_o ) ! g_ckl_i ( ckl , i ) = g_ki_lc ( ki , lc ) ! enddo enddo enddo enddo ! !     Deallocate unordered integrals g_ki_lc ! call deallocator ( g_ki_lc , ( wf % n_o ) ** 2 , ( wf % n_o ) * ( wf % n_v )) ! !     Form the redordered u_a_ckl = u_kl&#94;ac ! call allocator ( u_a_ckl , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! do l = 1 , wf % n_o do k = 1 , wf % n_o do c = 1 , wf % n_v ! cl = index_two ( c , l , wf % n_v ) ck = index_two ( c , k , wf % n_v ) ckl = index_three ( c , k , l , wf % n_v , wf % n_o ) ! do a = 1 , wf % n_v ! ak = index_two ( a , k , wf % n_v ) ! akcl = index_packed ( ak , cl ) ! al = index_two ( a , l , wf % n_v ) ! alck = index_packed ( al , ck ) ! !                 Set the value of u_a_ckl = u_kl&#94;ac = 2*t_kl&#94;ac - t_lk&#94;ac = 2*t_ak,cl - t_al,ck ! u_a_ckl ( a , ckl ) = two * ( wf % t2am ( akcl , 1 )) - wf % t2am ( alck , 1 ) ! enddo enddo enddo enddo ! !     Calculate the B1 term, - sum_ckl u_a_ckl g_ckl_i ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_o , & ( wf % n_v ) * (( wf % n_o ) ** 2 ), & - one , & u_a_ckl , & wf % n_v , & g_ckl_i , & ( wf % n_v ) * (( wf % n_o ) ** 2 ), & one , & wf % omega1 , & wf % n_v ) ! !     Deallocate remaining vectors ! call deallocator ( u_a_ckl , wf % n_v , ( wf % n_v ) * (( wf % n_o ) ** 2 )) call deallocator ( g_ckl_i , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_o ) ! end subroutine omega_b1_ccsd ! ! module subroutine omega_c1_ccsd ( wf ) ! !     Omega C1 !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 ! !     Calculates the C1 term of omega, ! !     C1: sum_ck F_kc*u_ai_ck, ! !     and adds it to the projection vector (omega1) of !     the wavefunction object wf ! !     u_ai_ck = 2*t_ck_ai - t_ci_ak ! implicit none ! class ( ccsd ) :: wf ! real ( dp ), dimension (:,:), allocatable :: F_ck real ( dp ), dimension (:,:), allocatable :: u_ai_ck real ( dp ), dimension (:,:), allocatable :: omega1_ai ! integer ( i15 ) :: i = 0 , k = 0 , c = 0 , a = 0 integer ( i15 ) :: ck = 0 , ai = 0 , ak = 0 , ci = 0 integer ( i15 ) :: aick = 0 , akci = 0 ! !     Allocation of F_ck and u_ai_ck ! call allocator ( F_ck , ( wf % n_o ) * ( wf % n_v ), 1 ) call allocator ( u_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Set up u_ai_ck and virtual-occupied Fock matrix ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! !           Set up compound index ! ck = index_two ( c , k , wf % n_v ) ! !           Reorder MO Fock matrix ! F_ck ( ck , 1 ) = wf % fock_ia ( k , c ) ! do i = 1 , wf % n_o ! ci = index_two ( c , i , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ak = index_two ( a , k , wf % n_v ) ! aick = index_packed ( ck , ai ) akci = index_packed ( ci , ak ) ! u_ai_ck ( ai , ck ) = two * ( wf % t2am ( aick , 1 )) - wf % t2am ( akci , 1 ) ! enddo enddo enddo enddo ! !     Allocate holder of omega contribution ! call allocator ( omega1_ai , ( wf % n_o ) * ( wf % n_v ), 1 ) ! !     ... and calculate it ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & 1 , & ( wf % n_o ) * ( wf % n_v ), & one , & u_ai_ck , & ( wf % n_o ) * ( wf % n_v ), & F_ck , & ( wf % n_o ) * ( wf % n_v ), & zero , & omega1_ai , & ( wf % n_o ) * ( wf % n_v )) ! !     Copy the contribution into the wavefunction's omega ! call daxpy (( wf % n_o ) * ( wf % n_v ), one , omega1_ai , 1 , wf % omega1 , 1 ) ! !     Deallocations ! call deallocator ( F_ck , ( wf % n_o ) * ( wf % n_v ), 1 ) call deallocator ( omega1_ai , ( wf % n_o ) * ( wf % n_v ), 1 ) call deallocator ( u_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine omega_c1_ccsd ! ! module subroutine omega_d1_ccsd ( wf ) ! !     Omega D1 term: Omega_ai&#94;D1=F_ai_T1 ! !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mars 2017 ! implicit none ! class ( ccsd ) :: wf ! !     Add F_a_i to omega ! call daxpy (( wf % n_o ) * ( wf % n_v ), one , wf % fock_ai , 1 , wf % omega1 , 1 ) ! end subroutine omega_d1_ccsd ! ! module subroutine omega_a2_ccsd ( wf ) ! !     Omega A2 term: Omega A2 = g_ai_bj + sum_(cd)g_ac_bd * t_ci_dj = A2.1 + A.2.2 ! !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, 10 Mar 2017 ! !     Structure: Batching over both a and b for A2.2. !                t&#94;+_ci_dj = t_ci_dj + t_di_cj !                t&#94;-_ci_dj = t_ci_dj - t_di_cj !                g&#94;+_ac_bd = g_ac_bd + g_bc_ad !                g&#94;-_ac_bd = g_ac_bd - g_bc_ad ! !                omega_A2.2_ai_bj = 1/4*(g&#94;+_ac_bd*t&#94;+_ci_dj + g&#94;-_ac_bd*t&#94;-_ci_dj) = omega_A2.2_bj_ai !                omega_A2.2_aj_bi = 1/4*(g&#94;+_ac_bd*t&#94;+_ci_dj - g&#94;-_ac_bd*t&#94;-_ci_dj) = omega_A2.2_bi_aj ! implicit none ! class ( ccsd ) :: wf ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: g_ai_bj real ( dp ), dimension (:,:), allocatable :: g_ca_db real ( dp ), dimension (:,:), allocatable :: g_p_ab_cd real ( dp ), dimension (:,:), allocatable :: g_m_ab_cd real ( dp ), dimension (:,:), allocatable :: L_ai_J real ( dp ), dimension (:,:), allocatable :: L_ca_J real ( dp ), dimension (:,:), allocatable :: L_db_J ! !     Reordered T2 amplitudes ! real ( dp ), dimension (:,:), allocatable :: t_p_cd_ij real ( dp ), dimension (:,:), allocatable :: t_m_cd_ij ! !     Reordered omega 2 ! real ( dp ), dimension (:,:), allocatable :: omega2_p_ab_ij real ( dp ), dimension (:,:), allocatable :: omega2_m_ab_ij ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 ! integer ( i15 ) :: ab = 0 , ca = 0 , cb = 0 , cd = 0 , da = 0 , db = 0 integer ( i15 ) :: ai = 0 , aj = 0 , bj = 0 , bi = 0 , ci = 0 , cj = 0 , dj = 0 , di = 0 integer ( i15 ) :: ij = 0 ! integer ( i15 ) :: aibj = 0 , biaj = 0 , cidj = 0 , cjdi = 0 ! !     Batching and memory handling variables ! integer ( i15 ) :: a_n_batch = 0 , a_first = 0 , a_last = 0 , a_length = 0 , a_max_length = 0 , a_batch = 0 integer ( i15 ) :: b_n_batch = 0 , b_first = 0 , b_last = 0 , b_length = 0 , b_max_length = 0 , b_batch = 0 integer ( i15 ) :: required = 0 , available = 0 ! !     Logical for reordering in L_ab_J when batching over the last index ! logical :: reorder ! ! !     ::  Calculate the A2.1 term of omega :: ! ! !     Create g_ai_bj ! call allocator ( g_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call allocator ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! call wf % get_cholesky_ai ( L_ai_J ) ! !     g_ai_bj = sum_J L_ai_J*L_bj_J ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! ! call deallocator ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Add A2.1 to Omega 2 ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! if ( ai . ge . bj ) then ! aibj = index_packed ( ai , bj ) ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + g_ai_bj ( ai , bj ) ! endif enddo enddo enddo enddo ! call deallocator ( g_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     ::  Calculate the A2.2 term  of omega :: ! ! required = max ( 2 * ( wf % n_v ) ** 2 * ( wf % n_J ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ), & ! Needed to get L_ca_J or L_db_J ( wf % n_v ) ** 4 + 2 * ( wf % n_v ) ** 2 * ( wf % n_J ), & ! Needed to get g_ac_bd ( wf % n_v ) ** 4 + 2 * ( packed_size ( wf % n_v )) * ( packed_size ( wf % n_v )) & ! Needed to get g+- and t+- + 2 * ( packed_size ( wf % n_v )) * ( packed_size ( wf % n_o )), & ! 2 * ( packed_size ( wf % n_v )) * ( packed_size ( wf % n_v )) & ! Needed for g+- and t+- and Omega+- + 2 * ( packed_size ( wf % n_v )) * ( packed_size ( wf % n_o )) & ! + 2 * ( wf % n_v ) ** 2 * ( packed_size ( wf % n_v ))) ! ! required = required * 4 ! Words available = get_available () ! a_max_length = 0 call num_two_batch ( required , available , a_max_length , a_n_batch , wf % n_v ) ! !     Initialize some variables for batching ! a_first = 0 a_last = 0 a_length = 0 ! !     Start looping over a-batches ! do a_batch = 1 , a_n_batch ! call batch_limits ( a_first , a_last , a_batch , a_max_length , wf % n_v ) a_length = a_last - a_first + 1 ! !        Start looping over batches of b ! b_first = 0 b_last = 0 b_length = 0 ! b_max_length = a_max_length ! do b_batch = 1 , a_batch ! call batch_limits ( b_first , b_last , b_batch , b_max_length , wf % n_v ) b_length = b_last - b_first + 1 ! !           Get cholesky vectors L_ac&#94;J ordered as L_ca_J ! call allocator ( L_ca_J , ( wf % n_v ) * a_length , wf % n_J ) L_ca_J = zero ! reorder = . true . call wf % get_cholesky_ab ( L_ca_J , a_first , a_last , ( wf % n_v ) * a_length , reorder ) ! !           Get cholesky vectors L_bd&#94;J ordered as L_db_J ! call allocator ( L_db_J , ( wf % n_v ) * b_length , wf % n_J ) L_db_J = zero ! reorder = . true . call wf % get_cholesky_ab ( L_db_J , b_first , b_last , ( wf % n_v ) * b_length , reorder ) ! !           Allocate g_ca_db ! call allocator ( g_ca_db , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) g_ca_db = zero ! !           g_ca_db = sum_J L_ca_J*L_db_J ! call dgemm ( 'N' , 'T' , & ( wf % n_v ) * a_length , & ( wf % n_v ) * b_length , & wf % n_J , & one , & L_ca_J , & ( wf % n_v ) * a_length , & L_db_J , & ( wf % n_v ) * b_length , & zero , & g_ca_db , & ( wf % n_v ) * a_length ) ! !           Deallocate L_db_J ! call deallocator ( L_db_J , ( wf % n_v ) * b_length , wf % n_J ) ! !           Deallocate L_ca_J ! call deallocator ( L_ca_J , ( wf % n_v ) * a_length , wf % n_J ) ! if ( b_batch . eq . a_batch ) then ! ! !           Allocate for +-g, +-t ! call allocator ( g_p_ab_cd , packed_size ( a_length ), packed_size ( wf % n_v )) call allocator ( g_m_ab_cd , packed_size ( a_length ), packed_size ( wf % n_v )) call allocator ( t_p_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) call allocator ( t_m_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) ! g_p_ab_cd = zero g_m_ab_cd = zero t_p_cd_ij = zero t_m_cd_ij = zero ! !              Reorder g_ca_db to g_ab_cd and t_ci_dj to t_cd_ij ! do c = 1 , wf % n_v do d = 1 , c ! cd = index_packed ( c , d ) ! do a = 1 , a_length ! ca = index_two ( c , a , wf % n_v ) da = index_two ( d , a , wf % n_v ) ! do b = 1 , b_length if (( a + a_first - 1 ) . ge . ( b + b_first - 1 )) then ! db = index_two ( d , b , wf % n_v ) cb = index_two ( c , b , wf % n_v ) ! ab = index_packed ( a , b ) ! g_p_ab_cd ( ab , cd ) = g_ca_db ( ca , db ) + g_ca_db ( da , cb ) g_m_ab_cd ( ab , cd ) = g_ca_db ( ca , db ) - g_ca_db ( da , cb ) ! if ( c . ne . d ) then g_p_ab_cd ( ab , cd ) = two * g_p_ab_cd ( ab , cd ) g_m_ab_cd ( ab , cd ) = two * g_m_ab_cd ( ab , cd ) endif ! endif enddo enddo ! do i = 1 , wf % n_o do j = 1 , i ! ij = index_packed ( i , j ) ! ci = index_two ( c , i , wf % n_v ) dj = index_two ( d , j , wf % n_v ) cj = index_two ( c , j , wf % n_v ) di = index_two ( d , i , wf % n_v ) ! cidj = index_packed ( ci , dj ) cjdi = index_packed ( cj , di ) ! t_p_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) + wf % t2am ( cjdi , 1 ) t_m_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) - wf % t2am ( cjdi , 1 ) ! enddo enddo enddo enddo ! !              Dellocate g_ac_bd ! call deallocator ( g_ca_db , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) ! !              Allocate omega +- ! call allocator ( omega2_p_ab_ij , packed_size ( a_length ), packed_size ( wf % n_o )) call allocator ( omega2_m_ab_ij , packed_size ( a_length ), packed_size ( wf % n_o )) ! !               omega2_ab_ij = sum_(cd) g_ab_cd*t_cd_ij ! call dgemm ( 'N' , 'N' , & packed_size ( a_length ), & packed_size ( wf % n_o ), & packed_size ( wf % n_v ), & one / four , & g_p_ab_cd , & packed_size ( a_length ), & t_p_cd_ij , & packed_size ( wf % n_v ), & zero , & omega2_p_ab_ij , & packed_size ( a_length )) ! call dgemm ( 'N' , 'N' , & packed_size ( a_length ), & packed_size ( wf % n_o ), & packed_size ( wf % n_v ), & one / four , & g_m_ab_cd , & packed_size ( a_length ), & t_m_cd_ij , & packed_size ( wf % n_v ), & zero , & omega2_m_ab_ij , & packed_size ( a_length ) ) ! !              Deallocate +-g, +-t ! call deallocator ( g_p_ab_cd , packed_size ( a_length ), packed_size ( wf % n_v )) call deallocator ( g_m_ab_cd , packed_size ( a_length ), packed_size ( wf % n_v )) call deallocator ( t_p_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) call deallocator ( t_m_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) ! do i = 1 , wf % n_o do j = 1 , i ! ij = index_packed ( i , j ) ! do a = 1 , a_length ! Ai = index_two ( a + a_first - 1 , i , wf % n_v ) ! A is full-space a index Aj = index_two ( a + a_first - 1 , j , wf % n_v ) ! A is full-space a index ! do b = 1 , b_length ! if (( a + a_first - 1 ) . ge . ( b + b_first - 1 )) then Bj = index_two ( b + b_first - 1 , j , wf % n_v ) ! B is full-space b index Bi = index_two ( b + b_first - 1 , i , wf % n_v ) ! B is full-space b index ! ! ab = index_packed ( a , b ) ! AiBj = index_packed ( Ai , Bj ) BiAj = index_packed ( Bi , Aj ) ! !                             Reorder into omega2_aibj ! wf % omega2 ( AiBj , 1 ) = wf % omega2 ( AiBj , 1 ) + omega2_p_ab_ij ( ab , ij ) + omega2_m_ab_ij ( ab , ij ) ! if ( AiBj . ne . BiAj ) then wf % omega2 ( BiAj , 1 ) = wf % omega2 ( BiAj , 1 ) + omega2_p_ab_ij ( ab , ij ) - omega2_m_ab_ij ( ab , ij ) endif endif ! enddo enddo enddo enddo ! !              Deallocate omega +- ! call deallocator ( omega2_p_ab_ij , packed_size ( a_length ), packed_size ( wf % n_o )) call deallocator ( omega2_m_ab_ij , packed_size ( a_length ), packed_size ( wf % n_o )) else ! !              Allocate for +-g, +-t ! call allocator ( g_p_ab_cd , a_length * b_length , packed_size ( wf % n_v )) call allocator ( g_m_ab_cd , a_length * b_length , packed_size ( wf % n_v )) call allocator ( t_p_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) call allocator ( t_m_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) ! g_p_ab_cd = zero g_m_ab_cd = zero t_p_cd_ij = zero t_m_cd_ij = zero ! !              Reorder g_ca_db to g_ab_cd and t_ci_dj to t_cd_ij ! do c = 1 , wf % n_v do d = 1 , c ! cd = index_packed ( c , d ) ! do a = 1 , a_length ! ca = index_two ( c , a , wf % n_v ) da = index_two ( d , a , wf % n_v ) ! do b = 1 , b_length ! db = index_two ( d , b , wf % n_v ) cb = index_two ( c , b , wf % n_v ) ! ab = index_two ( a , b , a_length ) ! g_p_ab_cd ( ab , cd ) = g_ca_db ( ca , db ) + g_ca_db ( da , cb ) g_m_ab_cd ( ab , cd ) = g_ca_db ( ca , db ) - g_ca_db ( da , cb ) ! if ( c . ne . d ) then g_p_ab_cd ( ab , cd ) = two * g_p_ab_cd ( ab , cd ) g_m_ab_cd ( ab , cd ) = two * g_m_ab_cd ( ab , cd ) endif ! enddo enddo ! do i = 1 , wf % n_o do j = 1 , i ! ij = index_packed ( i , j ) ! ci = index_two ( c , i , wf % n_v ) dj = index_two ( d , j , wf % n_v ) cj = index_two ( c , j , wf % n_v ) di = index_two ( d , i , wf % n_v ) ! cidj = index_packed ( ci , dj ) cjdi = index_packed ( cj , di ) ! t_p_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) + wf % t2am ( cjdi , 1 ) t_m_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) - wf % t2am ( cjdi , 1 ) ! enddo enddo enddo enddo ! !              Dellocate g_ac_bd ! call deallocator ( g_ca_db , ( wf % n_v ) * a_length , ( wf % n_v ) * b_length ) ! !              Allocate omega +- ! call allocator ( omega2_p_ab_ij , b_length * a_length , packed_size ( wf % n_o )) call allocator ( omega2_m_ab_ij , b_length * a_length , packed_size ( wf % n_o )) ! !               omega2_ab_ij = sum_(cd) g_ab_cd*t_cd_ij ! call dgemm ( 'N' , 'N' , & b_length * a_length , & packed_size ( wf % n_o ), & packed_size ( wf % n_v ), & one / four , & g_p_ab_cd , & b_length * a_length , & t_p_cd_ij , & packed_size ( wf % n_v ), & zero , & omega2_p_ab_ij , & b_length * a_length ) ! call dgemm ( 'N' , 'N' , & b_length * a_length , & packed_size ( wf % n_o ), & packed_size ( wf % n_v ), & one / four , & g_m_ab_cd , & b_length * a_length , & t_m_cd_ij , & packed_size ( wf % n_v ), & zero , & omega2_m_ab_ij , & b_length * a_length ) ! !           Deallocate +-g, +-t ! call deallocator ( g_p_ab_cd , b_length * a_length , packed_size ( wf % n_v )) call deallocator ( g_m_ab_cd , b_length * a_length , packed_size ( wf % n_v )) call deallocator ( t_p_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) call deallocator ( t_m_cd_ij , packed_size ( wf % n_v ), packed_size ( wf % n_o )) ! do i = 1 , wf % n_o do j = 1 , i ! ij = index_packed ( i , j ) ! do a = 1 , a_length ! Ai = index_two ( a + a_first - 1 , i , wf % n_v ) ! A is full-space a index Aj = index_two ( a + a_first - 1 , j , wf % n_v ) ! A is full-space a index ! do b = 1 , b_length ! Bj = index_two ( b + b_first - 1 , j , wf % n_v ) ! B is full-space b index Bi = index_two ( b + b_first - 1 , i , wf % n_v ) ! B is full-space b index ! ! ab = index_two ( a , b , a_length ) ! AiBj = index_packed ( Ai , Bj ) BiAj = index_packed ( Bi , Aj ) ! !                             Reorder into omega2_aibj ! wf % omega2 ( AiBj , 1 ) = wf % omega2 ( AiBj , 1 ) + omega2_p_ab_ij ( ab , ij ) + omega2_m_ab_ij ( ab , ij ) ! if ( AiBj . ne . BiAj ) then wf % omega2 ( BiAj , 1 ) = wf % omega2 ( BiAj , 1 ) + omega2_p_ab_ij ( ab , ij ) - omega2_m_ab_ij ( ab , ij ) endif ! enddo enddo enddo enddo ! !              Deallocate omega +- ! call deallocator ( omega2_p_ab_ij , b_length * a_length , packed_size ( wf % n_o )) call deallocator ( omega2_m_ab_ij , b_length * a_length , packed_size ( wf % n_o )) endif ! enddo ! enddo ! end subroutine omega_a2_ccsd ! ! module subroutine omega_b2_ccsd ( wf ) !! !!    Omega B2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, 11 Mar 2017 !! !!    Omega B2 = sum_(kl) t_ak_bl*(g_kilj + sum_(cd) t_ci_dj * g_kc_ld) !! !!    Structure: g_kilj is constructed first and reordered as g_kl_ij. !!    Then the contraction over cd is performed, and the results added to g_kl_ij. !!    t_ak_bl is then reordered as t_ab_kl and the contraction over kl is performed. !! implicit none ! class ( ccsd ) :: wf ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: L_kc_J real ( dp ), dimension (:,:), allocatable :: L_ij_J real ( dp ), dimension (:,:), allocatable :: g_kc_ld real ( dp ), dimension (:,:), allocatable :: g_kl_cd real ( dp ), dimension (:,:), allocatable :: g_kl_ij real ( dp ), dimension (:,:), allocatable :: g_ki_lj ! !     Reordered T2 apmlitudes ! real ( dp ), dimension (:,:), allocatable :: t_cd_ij real ( dp ), dimension (:,:), allocatable :: t_ab_kl ! !     Intermediate for matrix multiplication ! real ( dp ), dimension (:,:), allocatable :: X_kl_ij ! !     Reordered omega ! real ( dp ), dimension (:,:), allocatable :: omega_ab_ij ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ab = 0 , cd = 0 integer ( i15 ) :: ai = 0 , ak = 0 , bj = 0 , bl = 0 , ci = 0 , dj = 0 integer ( i15 ) :: kc = 0 , ld = 0 integer ( i15 ) :: ij = 0 , ki = 0 , kl = 0 , lj = 0 ! integer ( i15 ) :: aibj = 0 , akbl = 0 , cidj = 0 ! !     Read Cholesky vector of type L_ij_J ! call allocator ( L_ij_J , ( wf % n_o ) * ( wf % n_o ), wf % n_J ) ! call wf % get_cholesky_ij ( L_ij_J ) ! !     Create g_ki_lj = sum_J L_li_J*L_lj_J ! call allocator ( g_ki_lj , ( wf % n_o ) * ( wf % n_o ), ( wf % n_o ) * ( wf % n_o )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_o ), & ( wf % n_o ) * ( wf % n_o ), & wf % n_J , & one , & L_ij_J , & ( wf % n_o ) * ( wf % n_o ), & L_ij_J , & ( wf % n_o ) * ( wf % n_o ), & zero , & g_ki_lj , & ( wf % n_o ) * ( wf % n_o )) ! ! call deallocator ( L_ij_J , ( wf % n_o ) * ( wf % n_o ), wf % n_J ) ! call allocator ( g_kl_ij , ( wf % n_o ) * ( wf % n_o ),( wf % n_o ) * ( wf % n_o )) ! do k = 1 , wf % n_o do l = 1 , wf % n_o do i = 1 , wf % n_o do j = 1 , wf % n_o ! !                 Calculate compound indices ! ki = index_two ( k , i , wf % n_o ) lj = index_two ( l , j , wf % n_o ) kl = index_two ( k , l , wf % n_o ) ij = index_two ( i , j , wf % n_o ) ! !                 Reordering g_ki_lj to g_kl_ij ! g_kl_ij ( kl , ij ) = g_ki_lj ( ki , lj ) ! enddo enddo enddo enddo ! call deallocator ( g_ki_lj , ( wf % n_o ) * ( wf % n_o ), ( wf % n_o ) * ( wf % n_o )) ! !     Read Cholesky vectors of ia-type into L_kc_J ! call allocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! call wf % get_cholesky_ia ( L_kc_J ) ! !     Create g_ck_ld = sum_(J) L_kc_J*L_ld_J ! call allocator ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_kc_ld , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate cholesky vectors L_ck_J ! call deallocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Reorder g_kc_ld as g_kl_cd, also reordering t_ci_dj as t_cd_ij ! call allocator ( t_cd_ij , ( wf % n_v ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_o )) call allocator ( g_kl_cd , ( wf % n_o ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_v )) ! do d = 1 , wf % n_v do c = 1 , wf % n_v ! cd = index_two ( c , d , wf % n_v ) ! do l = 1 , wf % n_o ! ld = index_two ( l , d , wf % n_o ) dj = index_two ( d , l , wf % n_v ) ! do k = 1 , wf % n_o ! kl = index_two ( k , l , wf % n_o ) kc = index_two ( k , c , wf % n_o ) ci = index_two ( c , k , wf % n_v ) ij = kl ! cidj = index_packed ( ci , dj ) ! g_kl_cd ( kl , cd ) = g_kc_ld ( kc , ld ) t_cd_ij ( cd , ij ) = wf % t2am ( cidj , 1 ) ! enddo enddo enddo enddo ! !     Deallocate g_kc_ld ! call deallocator ( g_kc_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_v ) ** 2 , & one , & g_kl_cd , & ( wf % n_o ) ** 2 , & t_cd_ij , & ( wf % n_v ) ** 2 , & one , & g_kl_ij , & ( wf % n_o ) ** 2 ) ! !     Deallocate t_cd_ij and g_kl_cd ! call deallocator ( t_cd_ij , ( wf % n_v ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_o )) call deallocator ( g_kl_cd , ( wf % n_o ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_v )) ! !     Reorder t_ak_bl to t_ab_kl ! call allocator ( t_ab_kl , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! do l = 1 , wf % n_o do k = 1 , wf % n_o ! kl = index_two ( k , l , wf % n_o ) ! do b = 1 , wf % n_v ! bl = index_two ( b , l , wf % n_v ) ! do a = 1 , wf % n_v ! ak = index_two ( a , k , wf % n_v ) ab = index_two ( a , b , wf % n_v ) ! akbl = index_packed ( ak , bl ) ! t_ab_kl ( ab , kl ) = wf % t2am ( akbl , 1 ) ! enddo enddo enddo enddo ! !     omega_ab_ij = sum_(kl) t_ab_kl*X_kl_ij ! call allocator ( omega_ab_ij , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & ( wf % n_v ) ** 2 , & ( wf % n_o ) ** 2 , & ( wf % n_o ) ** 2 , & one , & t_ab_kl , & ( wf % n_v ) ** 2 , & g_kl_ij , & ( wf % n_o ) ** 2 , & zero , & omega_ab_ij , & ( wf % n_v ) ** 2 ) ! call deallocator ( t_ab_kl , ( wf % n_v ) ** 2 , ( wf % n_o ) ** 2 ) call deallocator ( g_kl_ij , ( wf % n_o ) ** 2 , ( wf % n_o ) ** 2 ) ! !     Reorder into omega2 ! do i = 1 , wf % n_o do j = 1 , wf % n_o ! ij = index_two ( i , j , wf % n_o ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! if ( ai . ge . bj ) then ! ab = index_two ( a , b , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega_ab_ij ( ab , ij ) ! endif ! enddo enddo enddo enddo ! call deallocator ( omega_ab_ij ,( wf % n_v ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_o )) ! end subroutine omega_b2_ccsd ! ! module subroutine omega_c2_ccsd ( wf ) !! !!    Omega C2 !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017 !! !!    Omega C2 = -1/2* sum_(ck)t_bk_cj*(g_ki_ac -1/2 sum_(dl)t_al_di * g_kd_lc) !!                                  - sum_(ck) t_bk_ci (g_kj_ac-sum_(dl)t_al_dj*g_kd_lc) !! implicit none ! class ( ccsd ) :: wf ! !     Integrals ! real ( dp ), dimension (:,:), allocatable :: L_ia_J real ( dp ), dimension (:,:), allocatable :: L_ki_J real ( dp ), dimension (:,:), allocatable :: L_ca_J real ( dp ), dimension (:,:), allocatable :: g_kd_lc real ( dp ), dimension (:,:), allocatable :: g_dl_ck real ( dp ), dimension (:,:), allocatable :: g_ki_ca real ( dp ), dimension (:,:), allocatable :: g_ai_ck ! !     Reordered T2 amplitudes ! real ( dp ), dimension (:,:), allocatable :: t_ai_dl real ( dp ), dimension (:,:), allocatable :: t_ck_bj ! !     Intermediates for matrix multiplication ! real ( dp ), dimension (:,:), allocatable :: X_ai_ck real ( dp ), dimension (:,:), allocatable :: Y_ai_bj ! !     Indices ! integer ( i15 ) :: a = 0 , b = 0 , c = 0 , d = 0 integer ( i15 ) :: i = 0 , j = 0 , k = 0 , l = 0 ! integer ( i15 ) :: ca = 0 integer ( i15 ) :: ai = 0 , aj = 0 , al = 0 , bi = 0 , bj = 0 , bk = 0 , cj = 0 , ck = 0 , cl = 0 , di = 0 , dk = 0 , dl = 0 integer ( i15 ) :: kd = 0 , lc = 0 integer ( i15 ) :: ki = 0 ! integer ( i15 ) :: aldi = 0 , aibj = 0 , cldk = 0 , bkcj = 0 ! !     Batching and memory handling ! integer ( i15 ) :: required = 0 , available = 0 ! integer ( i15 ) :: n_batch = 0 , max_batch_length = 0 integer ( i15 ) :: a_batch = 0 , a_start = 0 , a_end = 0 , a_length = 0 ! !     Logical for reordering L_ab_J when batching over last index ! logical :: reorder ! !     Allocate L_ia_J ! call allocator ( L_ia_J ,( wf % n_o ) * ( wf % n_v ),( wf % n_J )) ! !     Get L_ia_J ! call wf % get_cholesky_ia ( L_ia_J ) ! !     Create g_kd_lc = sum_J L_kd_J * L_lc_J ! call allocator ( g_kd_lc ,( wf % n_o ) * ( wf % n_v ),( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & L_ia_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_kd_lc , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate L_ia_J ! call deallocator ( L_ia_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Reorder g_kd_lc as g_dl_ck and t_al_di as t_ai_dl ! call allocator ( g_dl_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call allocator ( t_ai_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do k = 1 , wf % n_o do d = 1 , wf % n_v ! kd = index_two ( k , d , wf % n_o ) dk = index_two ( d , k , wf % n_v ) ! do l = 1 , wf % n_o ! dl = index_two ( d , l , wf % n_v ) ! do c = 1 , wf % n_v ! lc = index_two ( l , c , wf % n_o ) ck = index_two ( c , k , wf % n_v ) cl = index_two ( c , l , wf % n_v ) ! cldk = index_packed ( cl , dk ) ! g_dl_ck ( dl , ck ) = g_kd_lc ( kd , lc ) t_ai_dl ( ck , dl ) = wf % t2am ( cldk , 1 ) ! enddo enddo enddo enddo call deallocator ( g_kd_lc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     -1/2*sum_(dl) t_ai_dl*g_dl_ck = X_ai_ck ! call allocator ( X_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - half , & t_ai_dl , & ( wf % n_o ) * ( wf % n_v ), & g_dl_ck , & ( wf % n_o ) * ( wf % n_v ), & zero , & X_ai_ck , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate L_ia_J and g_dl_ck, ! call deallocator ( g_dl_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call deallocator ( t_ai_dl , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Constructing g_ki_ac ordered as g_ki_ca ! !     Allocate g_ki_ca ! call allocator ( g_ki_ca , ( wf % n_o ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_v )) g_ki_ca = zero ! !     Allocate L_ki_J ! call allocator ( L_ki_J , ( wf % n_o ) * ( wf % n_o ), wf % n_J ) ! !     Get cholesky vectors of ij-type ! call wf % get_cholesky_ij ( L_ki_J ) ! !     Prepare batching over a ! !     Setup of variables needed for batching ! available = get_available () required = 2 * ( wf % n_v ** 2 ) * ( wf % n_J ) + 2 * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_J ) required = 4 * required call num_batch ( required , available , max_batch_length , n_batch , wf % n_v ) ! a_start = 1 a_end = 0 a_length = 0 ! !     Start looping over batches ! do a_batch = 1 , n_batch ! !        Get batch limits  and  length of batch ! call batch_limits ( a_start , a_end , a_batch , max_batch_length , wf % n_v ) a_length = a_end - a_start + 1 ! !        Allocation for L_ac_J as L_ca_J (L_ca_J = L_acJ) ! call allocator ( L_ca_J ,( wf % n_v ) * a_length , wf % n_J ) ! !        Read Cholesky vectors ! reorder = . true . call wf % get_cholesky_ab ( L_ca_J , a_start , a_end , ( wf % n_v ) * a_length , reorder ) ! !        g_ki_ca = sum_J L_ki_J*L_ca_J ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_o ), & ( wf % n_v ) * a_length , & wf % n_J , & one , & L_ki_J , & ( wf % n_o ) * ( wf % n_o ), & L_ca_J , & ( wf % n_v ) * a_length , & one , & g_ki_ca ( 1 , index_two ( 1 , a_start , wf % n_v )), & ( wf % n_o ) * ( wf % n_o )) ! !        Deallocate L_ca_J ! call deallocator ( L_ca_J , ( wf % n_v ) * a_length , wf % n_J ) ! enddo ! End of batching ! !     Deallocate L_ki_J ! call deallocator ( L_ki_J , ( wf % n_o ) * ( wf % n_o ), wf % n_J ) ! !     Reorder g_ki_ca to g_ai_ck ! call allocator ( g_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do i = 1 , wf % n_o do k = 1 , wf % n_o ! ki = index_two ( k , i , wf % n_o ) ! do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do c = 1 , wf % n_v ! ca = index_two ( c , a , wf % n_v ) ck = index_two ( c , k , wf % n_v ) ! g_ai_ck ( ai , ck ) = g_ki_ca ( ki , ca ) ! enddo enddo enddo enddo ! call deallocator ( g_ki_ca , ( wf % n_o ) * ( wf % n_o ), ( wf % n_v ) * ( wf % n_v )) ! !     X_ai_ck = X_ai_ck + g_ai_ck ! call daxpy (( wf % n_o ) * ( wf % n_v ) * ( wf % n_o ) * ( wf % n_v ), one , g_ai_ck , 1 , X_ai_ck , 1 ) ! !     Deallocate g_ai_kc ! call deallocator ( g_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Reorder t_bkcj_1 as t_ck_bj ! call allocator ( t_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! do j = 1 , wf % n_o do k = 1 , wf % n_o do b = 1 , wf % n_v ! bk = index_two ( b , k , wf % n_v ) bj = index_two ( b , j , wf % n_v ) ! do c = 1 , wf % n_v ! cj = index_two ( c , j , wf % n_v ) ck = index_two ( c , k , wf % n_v ) ! bkcj = index_packed ( bk , cj ) ! t_ck_bj ( ck , bj ) = wf % t2am ( bkcj , 1 ) ! enddo enddo enddo enddo ! !     Allocate intermediate Y_ai_bj ! call allocator ( Y_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Y_ai_bj = - sum_(ck) X_ai_ck*t_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one , & X_ai_ck , & ( wf % n_o ) * ( wf % n_v ), & t_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & Y_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate the X intermediate ! call deallocator ( X_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate t_ck_bj ! call deallocator ( t_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Omega_aibj,1 = P_ai_bj ( 1/2*Y_ai_bj + Y_aj_bi ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! if ( ai . ge . bj ) then aj = index_two ( a , j , wf % n_v ) bi = index_two ( b , i , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + half * Y_ai_bj ( ai , bj ) + Y_ai_bj ( aj , bi ) & + half * Y_ai_bj ( bj , ai ) + Y_ai_bj ( bi , aj ) ! endif ! enddo enddo enddo enddo ! !     Deallocate intermediate Y_ai_bj ! call deallocator ( Y_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine omega_c2_ccsd ! ! module subroutine omega_d2_ccsd ( wf ) ! !     Omega D2 !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 ! !     Calculates the D2 term, ! !      D2: sum_ck u_jk&#94;bc g_aikc !        - 1/2 * sum_ck u_jk&#94;bc g_acki !        + 1/4 * sum_ck u_jk&#94;bc sum_dl L_ldkc u_il&#94;ad, ! !     where ! !        u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc, !        L_ldkc  = 2 * g_ldkc  - g_lckd. ! !     The first, second, and third terms are referred to as D2.1, D2.2, and D2.3, !     and comes out ordered as (ai,bj). All terms are added to the omega vector of the !     wavefunction object wf. ! !     The routine adds the terms in the following order: D2.3, D2.1, D2.2 ! implicit none ! class ( ccsd ) :: wf ! !     Batching variables ! integer ( i15 ) :: required = 0 , available = 0 , max_batch_length = 0 , batch_dimension = 0 , n_batch = 0 integer ( i15 ) :: a_begin = 0 , a_end = 0 , a_batch = 0 , batch_length = 0 , a_full = 0 , ac_dim = 0 ! !     Indices ! integer ( i15 ) :: ai = 0 , aidl = 0 , al = 0 , aldi = 0 , a = 0 , i = 0 , b = 0 , ca = 0 integer ( i15 ) :: j = 0 , c = 0 , d = 0 , di = 0 , dl = 0 , k = 0 , kc = 0 , kd = 0 , l = 0 , ki = 0 integer ( i15 ) :: lc = 0 , ld = 0 , aibj = 0 , bj = 0 , bjck = 0 , bk = 0 , bkcj = 0 , cj = 0 , ck = 0 ! real ( dp ), dimension (:,:), allocatable :: omega2_ai_bj ! For storing D2.3, D2.2 & D2.1 ! !     Vectors for D2.3 term ! real ( dp ), dimension (:,:), allocatable :: L_kc_J ! L_kc&#94;J real ( dp ), dimension (:,:), allocatable :: g_ld_kc ! g_ldkc real ( dp ), dimension (:,:), allocatable :: L_ld_kc ! L_ldkc = 2 * g_ldkc - g_lckd real ( dp ), dimension (:,:), allocatable :: u_ai_ld ! u_il&#94;ad = 2 * t_il&#94;ad - t_li&#94;ad real ( dp ), dimension (:,:), allocatable :: Z_ai_kc ! An intermediate, see below ! !     Vectors for D2.2 term ! real ( dp ), dimension (:,:), allocatable :: g_ai_kc ! g_aikc real ( dp ), dimension (:,:), allocatable :: u_kc_bj ! u_jk&#94;bc real ( dp ), dimension (:,:), allocatable :: L_ai_J ! L_ai&#94;J ! !     Vectors for D2.1 term ! real ( dp ), dimension (:,:), allocatable :: g_ai_ck ! g_acki real ( dp ), dimension (:,:), allocatable :: g_ca_ki ! g_acki; a is batched over real ( dp ), dimension (:,:), allocatable :: L_ca_J ! L_ac&#94;J; a is batched over real ( dp ), dimension (:,:), allocatable :: L_ki_J ! L_ki&#94;J real ( dp ), dimension (:,:), allocatable :: u_ck_bj ! u_jk&#94;bc ! !     Logical for reordering L_ab_J when batching over the last index ! logical :: reorder ! !     :: Calculate the D2.3 term of omega :: ! ! !     Allocate the Cholesky vector L_kc_J = L_kc&#94;J and set to zero ! call allocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Read the Cholesky vector L_kc_J from file ! call wf % get_cholesky_ia ( L_kc_J ) ! !     Allocate g_ld_kc = g_ldkc and set to zero ! call allocator ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Calculate g_ld_kc = g_ldkc = sum_J L_ld&#94;J L_kc&#94;J ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ld_kc , & ( wf % n_o ) * ( wf % n_v )) ! !     Allocate L_ld_kc = L_ldkc and set to zero ! call allocator ( L_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Determine L_ld_kc = L_ldkc from g_ld_kc = g_ldkc ! do l = 1 , wf % n_o do d = 1 , wf % n_v do k = 1 , wf % n_o do c = 1 , wf % n_v ! !                 Calculate the necessary indices ! ld = index_two ( l , d , wf % n_o ) kc = index_two ( k , c , wf % n_o ) ! lc = index_two ( l , c , wf % n_o ) kd = index_two ( k , d , wf % n_o ) ! !                 Set the value of L_ld_kc = 2 * g_ldkc - g_lckd ! L_ld_kc ( ld , kc ) = two * g_ld_kc ( ld , kc ) - g_ld_kc ( lc , kd ) ! enddo enddo enddo enddo ! !     Deallocate g_ld_kc and L_kc_J ! call deallocator ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call deallocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Allocate u_ai_ld = u_il&#94;ad ! call allocator ( u_ai_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Determine u_ai_ld = u_il&#94;ad = 2 * t_il&#94;ad - t_li&#94;ad ! do i = 1 , wf % n_o do l = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) al = index_two ( a , l , wf % n_v ) ! do d = 1 , wf % n_v ! ld = index_two ( l , d , wf % n_o ) dl = index_two ( d , l , wf % n_v ) di = index_two ( d , i , wf % n_v ) ! aidl = index_packed ( ai , dl ) aldi = index_packed ( al , di ) ! u_ai_ld ( ai , ld ) = two * ( wf % t2am ( aidl , 1 )) - wf % t2am ( aldi , 1 ) ! enddo enddo enddo enddo ! !     Allocate the intermediate Z_ai_kc = sum_dl u_ai_ld L_ld_kc and set it to zero ! call allocator ( Z_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form the intermediate Z_ai_kc = sum_dl u_ai_ld L_ld_kc ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & u_ai_ld , & ( wf % n_o ) * ( wf % n_v ), & L_ld_kc , & ( wf % n_o ) * ( wf % n_v ), & zero , & Z_ai_kc , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate L_ld_kc ! call deallocator ( L_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Allocate the D2.3 term omega2_ai_bj and set it to zero ! call allocator ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form the D2.3 term, 1/4 sum_kc Z_ai_kc u_kc_bj = 1/4 sum_kc Z_ai_kc(ai,kc) u_ai_ld(bj,kc) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one / four , & Z_ai_kc , & ( wf % n_o ) * ( wf % n_v ), & u_ai_ld , & ( wf % n_o ) * ( wf % n_v ), & zero , & omega2_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! !     Some mathematical justification for the above matrix multiplication. We have ! !           1/4 * sum_ck (sum_dl u_il&#94;ad L_ldkc) u_jk&#94;bc = 1/4 * sum_ck Z_ai,kc u_kc,bj, ! !     where Z_ai,kc = sum_dl u_ai,ld L_ld,kc. Note that u_ai_ld(ai,ld) = u_il&#94;ad, !     which means that u_ai_ld(bj,kc)&#94;T = u_ai_ld(kc,bj) = u_kj&#94;cb = u_jk&#94;bc. ! ! !     Deallocate the Z_ai_kc intermediate ! call deallocator ( Z_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Add the D2.3 term to the omega vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do b = 1 , wf % n_v do j = 1 , wf % n_o ! bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_ai_bj ( ai , bj ) & + omega2_ai_bj ( bj , ai ) ! endif ! enddo enddo enddo enddo ! !     Deallocate the omega2_ai_bj and u_ai_ld(ai,ld) = u_il&#94;ad vector ! call deallocator ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call deallocator ( u_ai_ld , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     :: Calculate the D2.1 term of omega :: ! ! !     Allocate the L_ai_J and L_kc_J terms and set them to zero ! call allocator ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call allocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Read the Cholesky vectors from file ! call wf % get_cholesky_ai ( L_ai_J ) call wf % get_cholesky_ia ( L_kc_J ) ! !     Allocate g_ai_kc = g_aikc and set it zero ! call allocator ( g_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Form the g_ai_kc integrals from L_ai_J and L_kc_J ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_ai_J , & ( wf % n_o ) * ( wf % n_v ), & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ai_kc , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate the Cholesky vectors L_ai_J and L_kc_J ! call deallocator ( L_ai_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) call deallocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Allocate u_kc_bj and set it to zero ! call allocator ( u_kc_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Determine u_kc_bj = u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc ! do k = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) kc = index_two ( k , c , wf % n_o ) ! do j = 1 , wf % n_o ! cj = index_two ( c , j , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) bk = index_two ( b , k , wf % n_v ) ! bjck = index_packed ( bj , ck ) bkcj = index_packed ( bk , cj ) ! u_kc_bj ( kc , bj ) = two * ( wf % t2am ( bjck , 1 )) - wf % t2am ( bkcj , 1 ) ! enddo enddo enddo enddo ! !     Allocate omega2_ai_bj and set it to zero ! call allocator ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Calculate the D2.1 term sum_ck u_jk&#94;bc g_aikc = sum_ck g_ai_kc u_kc_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & one , & g_ai_kc , & ( wf % n_o ) * ( wf % n_v ), & u_kc_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & omega2_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! !     Add the D2.1 term to the omega vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_ai_bj ( ai , bj ) & + omega2_ai_bj ( bj , ai ) ! endif ! enddo enddo enddo enddo ! !     Deallocate g_ai_kc, u_kc_bj, and the omega2_ai_bj vectors ! call deallocator ( g_ai_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call deallocator ( u_kc_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call deallocator ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     :: Calculate D2.2 term of Omega :: ! !     - 1/2 * sum_ck u_jk&#94;bc g_acki = -1/2 * sum_ck g_ai_ck u_ck_bj ! !     Allocate L_ki_J and set it to zero ! call allocator ( L_ki_J , ( wf % n_o ) ** 2 , wf % n_J ) ! !     Read the Cholesky vector L_ki_J from file ! call wf % get_cholesky_ij ( L_ki_J ) ! !     Allocate the full g_ai_ck = g_acki and set it to zero ! call allocator ( g_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) g_ai_ck = zero ! !     Prepare for batching over the index a to calculate g_ai_ck = g_acki ! !     To calculate this term, we need to first create L_ac&#94;J, then hold L_ac&#94;J and g_acki !     in memory simultaneously ! required = ( wf % n_J ) * ( wf % n_v ) ** 2 ! Holding L_ac&#94;J ! required = required & + max ( (( wf % n_v ) ** 2 ) * (( wf % n_o ) ** 2 ), & ! Testing if it is more demanding ( wf % n_J ) * ( wf % n_v ) ** 2 + 2 * ( wf % n_J ) * ( wf % n_v ) * ( wf % n_o )) ! to hold g_acki or to create L_ac&#94;J ! required = four * required ! In words ! available = get_available () batch_dimension = wf % n_v ! !     Determine the batching variables ! call num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) ! !     Determine g_ai_ck = g_acki successively in batches over a ! do a_batch = 1 , n_batch ! !        For each batch, get the limits for the a index ! call batch_limits ( a_begin , a_end , a_batch , max_batch_length , batch_dimension ) batch_length = a_end - a_begin + 1 ! !        Allocate the Cholesky vector L_ca_J = L_ac&#94;J and set it to zero ! ac_dim = batch_length * ( wf % n_v ) ! Dimension of ac for the batch over index a ! call allocator ( L_ca_J , ac_dim , wf % n_J ) ! !        Read the Cholesky vector from file ! reorder = . true . call wf % get_cholesky_ab ( L_ca_J , a_begin , a_end , ac_dim , reorder ) ! !        Allocate the integral g_ca_ki = g_acki and set to zero ! call allocator ( g_ca_ki , ac_dim , ( wf % n_o ) ** 2 ) ! !        Calculate g_ca_ki = g_acki from L_ca_J = L_ac&#94;J and L_ki_J = L_ki&#94;J ! call dgemm ( 'N' , 'T' , & ac_dim , & ( wf % n_o ) ** 2 , & wf % n_J , & one , & L_ca_J , & ac_dim , & L_ki_J , & ( wf % n_o ) ** 2 , & zero , & g_ca_ki , & ac_dim ) ! !        Reorder the integrals g_ca_ki (reduced a) = g_acki = g_ai_ck (full a) ! do a = 1 , batch_length ! a_full = a - 1 + a_begin ! The full matrix index a ! do i = 1 , wf % n_o ! ai = index_two ( a_full , i , wf % n_v ) ! do k = 1 , wf % n_o ! ki = index_two ( k , i , wf % n_o ) ! do c = 1 , wf % n_v ! ca = index_two ( c , a , wf % n_v ) ck = index_two ( c , k , wf % n_v ) ! g_ai_ck ( ai , ck ) = g_ca_ki ( ca , ki ) ! enddo enddo enddo enddo ! !        Deallocate the g_ca_ki and L_ca_J vectors ! call deallocator ( g_ca_ki , ac_dim , ( wf % n_o ) ** 2 ) call deallocator ( L_ca_J , ac_dim , wf % n_J ) ! enddo ! End of loop over batches of a ! !     Allocate the u_ck_bj = u_jk&#94;bc vector and set it to zero ! call allocator ( u_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) u_ck_bj = zero ! !     Determine u_ck_bj = u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc ! do k = 1 , wf % n_o do j = 1 , wf % n_o do c = 1 , wf % n_v ! ck = index_two ( c , k , wf % n_v ) cj = index_two ( c , j , wf % n_v ) ! do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) bk = index_two ( b , k , wf % n_v ) ! bjck = index_packed ( bj , ck ) ! bkcj = index_packed ( bk , cj ) ! u_ck_bj ( ck , bj ) = two * ( wf % t2am ( bjck , 1 )) - wf % t2am ( bkcj , 1 ) ! enddo enddo enddo enddo ! !     Allocate the D2.2 term and set it to zero ! call allocator ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Calculate the D2.2 term, - 1/2 * sum_ck u_jk&#94;bc g_acki = -1/2 * sum_ck g_ai_ck u_ck_bj ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & - one / two , & g_ai_ck , & ( wf % n_o ) * ( wf % n_v ), & u_ck_bj , & ( wf % n_o ) * ( wf % n_v ), & zero , & omega2_ai_bj , & ( wf % n_o ) * ( wf % n_v )) ! !     Add the D2.2 term to the omega vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_ai_bj ( ai , bj ) & + omega2_ai_bj ( bj , ai ) ! endif ! enddo enddo enddo enddo ! !     Deallocations ! call deallocator ( g_ai_ck , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call deallocator ( u_ck_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) call deallocator ( L_ki_J , ( wf % n_o ) ** 2 , wf % n_J ) ! call deallocator ( omega2_ai_bj , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! end subroutine omega_d2_ccsd ! ! module subroutine omega_e2_ccsd ( wf ) ! !     Omega E2 !     Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 ! !     Calculates the E2 term, ! !      E2: sum_c t_ij&#94;ac (F_bc - sum_dkl g_ldkc u_kl&#94;bd) !        - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc), ! !     where ! !        u_kl&#94;bc = 2 * t_kl&#94;bc - t_lk&#94;bc. ! !     The first term is referred to as the E2.1 term, and comes out ordered as (b,jai). !     The second term is referred to as the E2.2 term, and comes out ordered as (aib,j). ! !     Both are permuted added to the projection vector element omega2(ai,bj) of !     the wavefunction object wf. ! implicit none ! class ( ccsd ) :: wf ! !     Indices ! integer ( i15 ) :: aib = 0 , aibk = 0 , bk = 0 , bja = 0 , ibj = 0 , aibj = 0 , dlck = 0 integer ( i15 ) :: b = 0 , c = 0 , k = 0 , d = 0 , ck = 0 , ckdl = 0 , cl = 0 , cldk = 0 integer ( i15 ) :: dk = 0 , dl = 0 , kc = 0 , kdl = 0 , l = 0 , ld = 0 , a = 0 , ai = 0 integer ( i15 ) :: bj = 0 , aicj = 0 , cj = 0 , i = 0 , j = 0 , jai = 0 , dlc = 0 , dkcl = 0 ! !     Vectors for E2.1 term ! real ( dp ), dimension (:,:), allocatable :: omega2_b_jai ! For storing the E2.1 term temporarily real ( dp ), dimension (:,:), allocatable :: L_kc_J ! L_kc&#94;J real ( dp ), dimension (:,:), allocatable :: g_ld_kc ! g_ldkc real ( dp ), dimension (:,:), allocatable :: g_kdl_c ! g_ldkc real ( dp ), dimension (:,:), allocatable :: u_b_kdl ! u_kl&#94;bd real ( dp ), dimension (:,:), allocatable :: X_b_c ! An intermediate, see below for definition real ( dp ), dimension (:,:), allocatable :: t_c_jai ! t_ij&#94;ac ! !     Vectors for E2.2 term ! real ( dp ), dimension (:,:), allocatable :: g_k_dlc ! g_ldkc real ( dp ), dimension (:,:), allocatable :: u_dlc_j ! u_lj&#94;dc real ( dp ), dimension (:,:), allocatable :: omega2_aib_j ! For storing the E2.2 term temporarily real ( dp ), dimension (:,:), allocatable :: Y_k_j ! An intermediate, see below for definition real ( dp ), dimension (:,:), allocatable :: t_aib_k ! t_ik&#94;ab ! !     :: Calculate the E2.1 term of omega :: ! !     Form the Cholesky vector L_kc_J = L_kc&#94;J ! call allocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! call wf % get_cholesky_ia ( L_kc_J ) ! !     Form g_ld_kc = g_ldkc ! call allocator ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ld_kc , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate the Cholesky vector, L_kc_J ! call deallocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Allocate u_b_kdl = u_kl&#94;bd ! call allocator ( u_b_kdl , wf % n_v , ( wf % n_v ) * (( wf % n_o ) ** 2 )) ! !     Allocate g_kdl_c = g_ldkc ! call allocator ( g_kdl_c , ( wf % n_v ) * (( wf % n_o ) ** 2 ), wf % n_v ) ! !     Determine u_b_kdl = u_kl&#94;bd and g_kdl_c = g_ldkc ! do l = 1 , wf % n_o do d = 1 , wf % n_v ! ld = index_two ( l , d , wf % n_o ) dl = index_two ( d , l , wf % n_v ) ! do k = 1 , wf % n_o ! dk = index_two ( d , k , wf % n_v ) kdl = index_three ( k , d , l , wf % n_o , wf % n_v ) ! do c = 1 , wf % n_v ! Use as though \"b\" for u_b_kdl term ! kc = index_two ( k , c , wf % n_o ) cl = index_two ( c , l , wf % n_v ) ck = index_two ( c , k , wf % n_v ) ! ckdl = index_packed ( ck , dl ) cldk = index_packed ( cl , dk ) ! !                 Set the values of u_b_kdl and g_kdl_c ! u_b_kdl ( c , kdl ) = two * ( wf % t2am ( ckdl , 1 )) - wf % t2am ( cldk , 1 ) ! g_kdl_c ( kdl , c ) = g_ld_kc ( ld , kc ) ! g_ldkc ! enddo enddo enddo enddo ! !     Deallocate the unordered integrals g_ld_kc = g_ldkc ! !        Note: It might be better to reorder g_kdl_c to g_k_dlc in the !        calculation of the E2.2 term. For now (8 Mar 2017), it remains !        simple & stupid. ! call deallocator ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Allocate the intermediate X_b_c = F_bc - sum_dkl g_ldkc u_kl&#94;bd and set to zero ! call allocator ( X_b_c , wf % n_v , wf % n_v ) ! !     Copy the virtual-virtual Fock matrix into the intermediate ! call dcopy (( wf % n_v ) ** 2 , wf % fock_ab , 1 , X_b_c , 1 ) ! X_b_c = F_bc ! !     Add the second contribution, !     - sum_dkl g_ldkc u_kl&#94;bd = - sum_dkl u_b_kdl * g_kdl_c, to X_b_c ! call dgemm ( 'N' , 'N' , & wf % n_v , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & - one , & u_b_kdl , & wf % n_v , & g_kdl_c , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & one , & X_b_c , & wf % n_v ) ! !     Deallocate u_b_kdl and g_kdl_c ! call deallocator ( u_b_kdl , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) call deallocator ( g_kdl_c , ( wf % n_v ) * ( wf % n_o ) ** 2 , wf % n_v ) ! !     Form the reordered t_c_jai = t_ij&#94;ac ! call allocator ( t_c_jai , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o ! jai = index_three ( j , a , i , wf % n_o , wf % n_v ) ! do c = 1 , wf % n_v ! cj = index_two ( c , j , wf % n_v ) ! aicj = index_packed ( ai , cj ) ! t_c_jai ( c , jai ) = wf % t2am ( aicj , 1 ) ! enddo enddo enddo enddo ! !     Form the E2.1 term ! call allocator ( omega2_b_jai , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! call dgemm ( 'N' , 'N' , & wf % n_v , & ( wf % n_v ) * ( wf % n_o ) ** 2 , & wf % n_v , & one , & X_b_c , & wf % n_v , & t_c_jai , & wf % n_v , & zero , & omega2_b_jai , & wf % n_v ) ! !     Add the E2.1 term to the omega vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o ! jai = index_three ( j , a , i , wf % n_o , wf % n_v ) ! do b = 1 , wf % n_v ! ibj = index_three ( i , b , j , wf % n_o , wf % n_v ) ! bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! !                 Restrict the indices to avoid adding both (ai,bj) and (bj,ai), !                 as they are identical in packed indices ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_b_jai ( b , jai ) & + omega2_b_jai ( a , ibj ) ! endif ! enddo enddo enddo enddo ! !     Deallocate the E2.1 term, the X intermediate, and the reordered amplitudes ! call deallocator ( omega2_b_jai , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) call deallocator ( X_b_c , wf % n_v , wf % n_v ) call deallocator ( t_c_jai , wf % n_v , ( wf % n_v ) * ( wf % n_o ) ** 2 ) ! !     :: Calculate E.2.2 term of omega :: ! ! !     Form the Cholesky vector L_kc_J = L_kc&#94;J ! call allocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! call wf % get_cholesky_ia ( L_kc_J ) ! !     Form g_ld_kc = g_ldkc = sum_J L_ld&#94;J L_kc&#94;J ! call allocator ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! call dgemm ( 'N' , 'T' , & ( wf % n_o ) * ( wf % n_v ), & ( wf % n_o ) * ( wf % n_v ), & wf % n_J , & one , & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & L_kc_J , & ( wf % n_o ) * ( wf % n_v ), & zero , & g_ld_kc , & ( wf % n_o ) * ( wf % n_v )) ! !     Deallocate the Cholesky vector, L_kc_J ! call deallocator ( L_kc_J , ( wf % n_o ) * ( wf % n_v ), wf % n_J ) ! !     Allocate g_k_dlc = g_ldkc ! call allocator ( g_k_dlc , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! !     Allocate u_dlc_j = u_lj&#94;dc ! call allocator ( u_dlc_j , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! !     Determine g_k_dlc = g_ldkc and u_dlc_j = u_lj&#94;dc ! do k = 1 , wf % n_o ! Use as though \"j\" for u_dlc_j term do c = 1 , wf % n_v ! kc = index_two ( k , c , wf % n_o ) ck = index_two ( c , k , wf % n_v ) ! do l = 1 , wf % n_o ! cl = index_two ( c , l , wf % n_v ) ! do d = 1 , wf % n_v ! dlc = index_three ( d , l , c , wf % n_v , wf % n_o ) ! ld = index_two ( l , d , wf % n_o ) dl = index_two ( d , l , wf % n_v ) dk = index_two ( d , k , wf % n_v ) ! dlck = index_packed ( dl , ck ) dkcl = index_packed ( dk , cl ) ! !                 Set the value of g_k_dlc and u_dlc_j ! g_k_dlc ( k , dlc ) = g_ld_kc ( ld , kc ) ! g_ldkc u_dlc_j ( dlc , k ) = two * ( wf % t2am ( dlck , 1 )) - wf % t2am ( dkcl , 1 ) ! u_lk&#94;dc = 2 * t_lk&#94;dc - t_kl&#94;dc ! enddo enddo enddo enddo ! !     Deallocate the integrals g_ld_kc = g_ldkc ! call deallocator ( g_ld_kc , ( wf % n_o ) * ( wf % n_v ), ( wf % n_o ) * ( wf % n_v )) ! !     Allocate the intermediate Y_k_j = F_kj  + sum_cdl u_lj&#94;dc g_ldkc !                                     = F_k_j + sum_cdl g_k_dlc * u_dlc_j ! call allocator ( Y_k_j , wf % n_o , wf % n_o ) ! !     Copy the occupied-occupied Fock matrix, such that Y_k_j = F_kj ! call dcopy (( wf % n_o ) ** 2 , wf % fock_ij , 1 , Y_k_j , 1 ) ! !     Add sum_cdl g_k_dlc u_dlc_j to Y_k_j, such that !     Y_k_j = F_k_j + sum_cdl g_k_dlc u_dlc_j ! call dgemm ( 'N' , 'N' , & wf % n_o , & wf % n_o , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & g_k_dlc , & wf % n_o , & u_dlc_j , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & one , & Y_k_j , & wf % n_o ) ! !     Deallocate u_dlc_j and g_k_dlc ! call deallocator ( u_dlc_j , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) call deallocator ( g_k_dlc , wf % n_o , ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! !     Allocate t_aib_k = t_ik&#94;ab and set it to zero ! call allocator ( t_aib_k , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! !     Determine t_aib_k = t_ik&#94;ab ! do k = 1 , wf % n_o do b = 1 , wf % n_v ! bk = index_two ( b , k , wf % n_v ) ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) aib = index_three ( a , i , b , wf % n_v , wf % n_o ) ! aibk = index_packed ( ai , bk ) ! t_aib_k ( aib , k ) = wf % t2am ( aibk , 1 ) ! enddo enddo enddo enddo ! !     Allocate the E2.2 term and set to zero ! call allocator ( omega2_aib_j , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! !     Calculate the E2.2 term, !     - sum_k t_aib_k Y_k_j = - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc) ! call dgemm ( 'N' , 'N' , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & wf % n_o , & wf % n_o , & - one , & t_aib_k , & ( wf % n_o ) * ( wf % n_v ) ** 2 , & Y_k_j , & wf % n_o , & zero , & omega2_aib_j , & ( wf % n_o ) * ( wf % n_v ) ** 2 ) ! !     Deallocate t_aib_k and Y_k_j ! call deallocator ( t_aib_k , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) call deallocator ( Y_k_j , wf % n_o , wf % n_o ) ! !     Add the E2.2 term to the omega vector ! do i = 1 , wf % n_o do a = 1 , wf % n_v ! ai = index_two ( a , i , wf % n_v ) ! do j = 1 , wf % n_o do b = 1 , wf % n_v ! bj = index_two ( b , j , wf % n_v ) ! aibj = index_packed ( ai , bj ) ! aib = index_three ( a , i , b , wf % n_v , wf % n_o ) bja = index_three ( b , j , a , wf % n_v , wf % n_o ) ! !                 Restrict the indices to avoid adding both (ai,bj) and (bj,ai), !                 as they are identical in packed indices ! if ( ai . ge . bj ) then ! wf % omega2 ( aibj , 1 ) = wf % omega2 ( aibj , 1 ) + omega2_aib_j ( aib , j ) & + omega2_aib_j ( bja , i ) ! endif ! enddo enddo enddo enddo ! !     Deallocate the E2.2 term ! call deallocator ( omega2_aib_j , ( wf % n_o ) * ( wf % n_v ) ** 2 , wf % n_o ) ! end subroutine omega_e2_ccsd ! ! end submodule omega","tags":"","loc":"sourcefile/omega_submodule.f90.html","title":"omega_submodule.F90 – Fortran Program"},{"text":"Modules input_output Source Code input_output.F90 Source Code module input_output ! !! !!    Input_output module !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, April 2017 !! !!    Handles input and output and contains: !! !!    generate_unit_identifier: Returns a free unit_identifier which can be assigned to a file that is opened. !!    vec_print:                Prints vector in compound index order. !! ! use types ! implicit none ! integer ( i15 ) :: unit_output = 0 integer , private :: n_files = 0 ! contains ! ! subroutine generate_unit_identifier ( unit_identifier ) !! !!    Generate unit identifier !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, April 2017 !! !!    Returns a valid unit identifier for opening file. !! implicit none ! integer ( i15 ) :: unit_identifier ! n_files = n_files + 1 unit_identifier = n_files ! end subroutine generate_unit_identifier ! ! subroutine vec_print ( vec , dim_1 , dim_2 ) !! !!    Vector print !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, March 2017 !! !!    A vector is printed with a compound index (p q) of dimension (dim_1 x dim_2) !! implicit none ! integer ( i15 ) :: p = 0 , q = 0 , pq = 0 ! integer ( i15 ), intent ( in ) :: dim_1 , dim_2 real ( dp ), dimension ( dim_1 , dim_2 ), intent ( in ) :: vec ! do q = 1 , dim_2 do p = 1 , dim_1 ! write ( unit_output , * ) p , q , vec ( p , q ) ! enddo enddo ! end subroutine vec_print ! ! end module input_output","tags":"","loc":"sourcefile/input_output.f90.html","title":"input_output.F90 – Fortran Program"},{"text":"Modules input_reader Source Code input_reader.F90 Source Code module input_reader ! !! !!    Input reader module !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! ! use types use workspace use input_output use calc_procedures_class use calc_settings_class ! implicit none ! contains ! ! subroutine method_reader ( unit_input , method ) !! !!    Method Reader !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! implicit none ! integer ( i15 ), intent ( in ) :: unit_input ! character ( len = 40 ) :: method ! character ( len = 40 ) :: line ! do ! General do loop - ends when it reaches 'exit' ! read ( unit_input , '(a40)' ) line ! do while ( line ( 1 : 1 ) == '!' . or . trim ( line ) == '' ) ! Comment or blank line: read the next line read ( unit_input , '(a40)' ) line enddo ! if ( trim ( line ) == 'Method:' ) then ! read ( unit_input , '(a40)' ) line ! do while ( line ( 1 : 1 ) == '!' . or . trim ( line ) == '' ) ! Comment or blank line: read the next line read ( unit_input , '(a40)' ) line enddo ! if ( line ( 1 : 1 ) == '.' ) then ! method = trim ( line ( 2 : 40 )) exit ! Escape from general do loop ! else ! write ( unit_output , * ) 'Input error: expected method, not the line ' , trim ( line ), '.' stop ! Terminate program ! endif ! else ! write ( unit_output , * ) 'Input error: expected method section, not the line ' , trim ( line ), '.' stop ! Terminate program ! endif ! enddo ! End general do loop ! end subroutine method_reader ! ! subroutine calculation_reader ( unit_input , tasks ) !! !!    Calculation Reader !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Reads the calculation from the input file and initializes the !!    tasks requested of the wavefunction. !! implicit none ! type ( calc_procedures ) :: tasks ! integer ( i15 ), intent ( in ) :: unit_input ! character ( len = 40 ) :: calculation ! character ( len = 40 ) :: line ! read ( unit_input , '(a40)' ) line ! do while ( line ( 1 : 1 ) == '!' . or . trim ( line ) == '' ) ! Comment or blank line: read the next line ! read ( unit_input , '(a40)' ) line ! enddo ! if ( trim ( line ) == 'Calculation:' ) then ! do ! Read calculations ! read ( unit_input , '(a40)' ) line ! do while ( line ( 1 : 1 ) == '!' . or . trim ( line ) == '' ) ! Comment or blank line: read the next line read ( unit_input , '(a40)' ) line enddo ! if ( line ( 1 : 1 ) == '.' ) then ! calculation = trim ( line ( 2 : 40 )) ! !              Test for which type, set the logical in tasks, and cycle! ! if ( calculation == 'ground_state' ) then ! tasks % do_ground_state = . true . cycle ! elseif ( calculation == 'excited_state' ) then ! tasks % do_excited_state = . true . cycle ! elseif ( calculation == 'properties' ) then ! tasks % do_properties = . true . cycle ! else ! write ( unit_output , * ) 'Input error: calculation ' , trim ( line ( 2 : 40 )), ' not recognized.' stop ! endif ! elseif ( trim ( line ) == 'Settings:' ) then ! backspace ( unit_input ) exit ! escape the do loop ! else ! write ( unit_output , * ) 'Input error: line ' , trim ( line ), ' not recognized.' stop ! endif ! enddo ! else ! write ( unit_output , * ) 'Expected calculation settings, not ' , trim ( line ), '.' ! endif ! end subroutine calculation_reader ! ! subroutine settings_reader ( unit_input , settings ) !! !!    Settings Reader !!    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 !! !!    Reads the calculation settings from the input file and initializes !!    the settings requested of the wavefunction. !! implicit none ! type ( calc_settings ) :: settings ! integer ( i15 ), intent ( in ) :: unit_input ! character ( len = 40 ) :: setting ! character ( len = 40 ) :: line ! read ( unit_input , '(a40)' ) line ! do while ( line ( 1 : 1 ) == '!' . or . trim ( line ) == '' ) ! Comment or blank line: read the next line ! read ( unit_input , '(a40)' ) line ! enddo ! if ( trim ( line ) == 'Settings:' ) then ! do ! Read settings ! read ( unit_input , '(a40)' ) line ! do while ( line ( 1 : 1 ) == '!' . or . trim ( line ) == '' ) ! Comment or blank line: read the next line read ( unit_input , '(a40)' ) line enddo ! if ( line ( 1 : 1 ) == '.' ) then ! setting = trim ( line ( 2 : 40 )) ! !              Test for which type, set the logical in tasks, and cycle! ! if ( setting == 'energy_threshold' ) then ! read ( unit_input , * ) settings % energy_threshold cycle ! elseif ( setting == 'ampeqs_threshold' ) then ! read ( unit_input , * ) settings % ampeqs_threshold cycle ! elseif ( setting == 'memory' ) then ! read ( unit_input , * ) mem cycle ! elseif ( trim ( line ) == '#end of eT input' ) then ! exit ! escape do loop ! else ! write ( unit_output , * ) 'Input error: setting ' , trim ( line ( 2 : 40 )), ' not recognized.' stop ! endif ! elseif ( trim ( line ) == '#end of eT input' ) then ! exit ! else ! write ( unit_output , * ) 'Input error: unregonized line ' , trim ( line ), '.' stop ! endif ! enddo ! else ! write ( unit_output , * ) 'Input error: expected settings section, not the line ' , trim ( line ), '.' stop ! Terminate program ! endif ! end subroutine settings_reader ! ! end module input_reader","tags":"","loc":"sourcefile/input_reader.f90.html","title":"input_reader.F90 – Fortran Program"},{"text":"Modules types Source Code types.F90 Source Code module types ! !! !!  Types module !!  Written by Sarai D. Folkestad and Eirik F. Kjønstad, April 2017 !! !!  Defines the real and integer types used throughout the module !! ! implicit none ! !  Kind numbers for real and integers ! !  Usage:\treal(dp) \t :: foo !\t\t\t\tinteger(i15) :: foo_int ! integer , parameter :: sp = selected_real_kind ( 6 , 37 ) integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: qp = selected_real_kind ( 33 , 4931 ) integer , parameter :: i15 = selected_int_kind ( 15 ) ! !  Integers as reals ! real ( dp ), parameter :: zero = 0.0D0 , one = 1.0D0 , two = 2.0D0 , half = 0.5D0 real ( dp ), parameter :: three = 3.0D0 , four = 4.0D0 , five = 5.0D0 , six = 6.0D0 ! end module types","tags":"","loc":"sourcefile/types.f90.html","title":"types.F90 – Fortran Program"},{"text":"Modules utils Source Code utils.F90 Source Code module utils ! !! !!    Utilities module !!    Written by Sarai D. Folkstad and Eirik F. Kjønstad, 28 Feb 2017 !! !!    Contains: !! !!    Index functions: !!       index_packed: Calculates the packed index of symetric matrix !!       index_two:    Calculates the compound index of two indices !!       index_three   Calculates the compound index given by three indices !! !!    Matrix utilities: !!       packin:      packs in symetric matrix !!       packed_size: Returns size of packed matrix !!       squeareup:   squares up symmetric matrix !! !!    Batching subroutines: !!        num_batch:     Calculates the number of batches needed. !!        num_two_batch: Calculates the number of batches needed !!                       for to batching variables with equal number of batches. !!        batch_limits:  Returns batch start index and batch end index. !! ! use input_output use types ! contains ! !  ::::::::::::::::::::::::: !  -::- Index functions -::- !  ::::::::::::::::::::::::: ! integer ( i15 ) function index_packed ( i , j ) !! !!    Packed index !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Calculates the packed index of symetric matrix. !! implicit none ! integer ( i15 ), intent ( in ) :: i , j ! index_packed = ( max ( i , j ) * ( max ( i , j ) - 3 ) / 2 ) + i + j ! end function index_packed ! ! integer ( i15 ) function index_three ( p , q , r , dim_p , dim_q ) !! !!    Three index compound !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Returns the compound index (pqr) !! implicit none ! integer ( i15 ), intent ( in ) :: p , q , r , dim_p , dim_q ! index_three = dim_p * ( dim_q * ( r - 1 ) + q - 1 ) + p ! end function index_three ! ! integer ( i15 ) function index_two ( p , q , dim_p ) !! !!    Two index compound !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Returns the compound index (pq) !! implicit none ! integer ( i15 ), intent ( in ) :: p , q , dim_p ! index_two = dim_p * ( q - 1 ) + p ! end function index_two ! ! :::::::::::::::::::::::: ! -:- Matrix utilities -:- ! :::::::::::::::::::::::: ! integer ( i15 ) function packed_size ( N ) !! !!    Packed size !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Returns size of packed symmetric matrices !!    of dimension N x N (triangular elements) !! implicit none ! integer ( i15 ), intent ( in ) :: N ! packed_size = N * ( N + 1 ) / 2 ! end function packed_size ! ! subroutine squareup ( packed , unpacked , N ) !! !!    Square up packed symmetric matrix !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Squares up to full dimension (N x N) of packed matrices. !! implicit none ! integer ( i15 ), intent ( in ) :: N ! real ( dp ), dimension (:,:), intent ( in ) :: packed real ( dp ), dimension (:,:) :: unpacked ! integer ( i15 ) :: i = 0 , j = 0 ! do i = 1 , N do j = 1 , N unpacked ( i , j ) = packed ( index_packed ( i , j ), 1 ) enddo enddo ! end subroutine ! ! subroutine packin ( packed , unpacked , N ) !! !!    Pack in symmetric matrix !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Pack down full square matrix of dimension N x N. !! implicit none ! integer ( i15 ), intent ( in ) :: N ! real ( dp ), dimension (:,:) :: packed real ( dp ), dimension (:,:), intent ( in ) :: unpacked ! integer ( i15 ) :: i = 0 , j = 0 ! do i = 1 , N do j = 1 , N packed ( index_packed ( i , j ), 1 ) = unpacked ( i , j ) enddo enddo ! end subroutine ! ! ::::::::::::::::::::::::::::::: !  -:- Batching functionality -:- ! ::::::::::::::::::::::::::::::: ! subroutine num_batch ( required , available , max_batch_length , n_batch , batch_dimension ) !! !!    Number of batches !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Calculates number of batches !! !!    Batching structure will be: !!    With rest:     (n_batch-1)*(max_batch_length) + rest = required !!    Without rest:  (n_batch)*(max_batch_length) = required !! implicit none ! ! integer ( i15 ), intent ( in ) :: available , batch_dimension integer ( i15 ) :: max_batch_length , n_batch integer ( i15 ) :: required integer ( i15 ) :: buffer ! !     Adding buffer for required ! buffer = required / 10 ! required = required + buffer ! if ( required . lt . available ) then n_batch = 1 max_batch_length = batch_dimension return endif ! !  Max batch size ! max_batch_length = available / ( required / batch_dimension ) ! !  Number of full batches ! n_batch = batch_dimension / max_batch_length ! !  Test for rest ! if ( n_batch * max_batch_length . lt . batch_dimension ) then n_batch = n_batch + 1 endif ! end subroutine num_batch ! subroutine num_two_batch ( required , available , max_batch_length , n_batch , batch_dimension ) !! !!    Number of batches !!    Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!    Calculates number of batches when two batching variables are needed !! !!    Batching structure will be: !!    With rest:     (n_batch-1)*(max_batch_length) + rest = required !!    Without rest:  (n_batch)*(max_batch_length) = required !! implicit none ! ! integer ( i15 ), intent ( in ) :: available , batch_dimension integer ( i15 ) :: max_batch_length , n_batch , i , buffer , required ! buffer = required / 10 ! required = required + buffer ! n_batch = 1 ! if ( required . lt . available ) then n_batch = 1 max_batch_length = batch_dimension return endif ! do i = 1 , batch_dimension if ( available . gt . buffer / i ** 2 ) then ! E: insert logical for success! ! n_batch = i max_batch_length = batch_dimension / n_batch ! !        Test for rest ! if ( n_batch * max_batch_length . lt . batch_dimension ) then n_batch = n_batch + 1 endif ! return endif enddo ! end subroutine num_two_batch ! ! subroutine batch_limits ( first , last , batch_number , max_batch_length , batch_dimension ) !! !!     Batch limits !!     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 !! !!     Find batch limits (first and last) !! !!     batch_number: the current batch (1,2,...,n_batch) !!     max_batch_length: the length of each batch (except the last, which may be a rest, see n_one_batch routine) !!     batch_dimension: the dimensionality of the batching variable (e.g., n_vir for a virtual index) !! implicit none ! integer ( i15 ) :: first , last integer ( i15 ), intent ( in ) :: batch_number , max_batch_length , batch_dimension ! first = 1 + ( batch_number - 1 ) * max_batch_length last = min ( max_batch_length + ( batch_number - 1 ) * max_batch_length , batch_dimension ) ! end subroutine batch_limits ! ! end module utils","tags":"","loc":"sourcefile/utils.f90.html","title":"utils.F90 – Fortran Program"},{"text":"Modules workspace Source Code workspace.F90 Source Code module workspace ! !! !!    Workspace module !!    Written by Henrik Koch, Rolf H. Myhre, Eirik Kjønstad and Sarai Folkestad, Jan 2017 !! !!    Manages program memory usage and contains: !! !!    work_init: Initializes the memory management variables. !! !!    allocator:   Allocation of double precission array of two dimmensions (M,N). !!                 Updates memory management variables. !!    deallocator: Deallocation of double precission array of two dimmensions (M,N). !!                 Updates memory management variables. !! !!    allocator_int:   Allocation of integer array of two dimmensions (M,N). !!                     Updates memory management variables. !!    deallocator_int: Deallocation of integer array of two dimmensions (M,N) !!                     Updates memory management variables. !! !!    get_available: Returns available memory. !! ! use types use input_output ! implicit none ! integer , private :: work_length = 0 integer , private :: work_remains = 0 integer , private :: work_used = 0 ! integer ( i15 ) :: mem = 1000000000 ! 7 GB S: Settes i input og bør testes avhengig av minimumskravene for metoden. ! ! contains ! ! subroutine work_init ! !     Work Initilization ! !     Initializes memory management variables ! implicit none ! work_length = mem work_remains = mem work_used = 0 ! end subroutine work_init ! ! subroutine allocator ( elm , M , N ) ! !     Allocator !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 ! !     Allocates array and updates memory variables ! implicit none ! integer , intent ( in ) :: M , N real ( dp ), dimension (:,:), allocatable :: elm integer :: size integer :: stat = 0 , error = 0 ! size = M * N ! allocate ( elm ( M , N ), stat = error ) ! if ( stat . ne . 0 ) then write ( unit_output , '(t3,a,i15)' ) 'Allocation error! Could not allocate array of size (M*N):' , size stop endif ! work_remains = work_remains - 4 * size work_used = work_used + 4 * size ! if ( work_remains . lt . 0 ) then write ( unit_output , '(t3,a)' ) \"Error: user-specified memory insufficient.\" stop endif ! end subroutine allocator ! ! subroutine deallocator ( elm , M , N ) ! !     Deallocator !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 ! !     Deallocation and update of memory information ! implicit none ! real ( dp ), dimension (:,:), allocatable :: elm integer :: stat = 0 , error = 0 integer , intent ( in ) :: M , N integer :: size ! size = M * N ! deallocate ( elm , stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Deallocation error! Could not deallocate array of size (M*N):' , size stop ! endif ! work_remains = work_remains + 4 * size work_used = work_used - 4 * size ! end subroutine deallocator ! ! subroutine allocator_int ( elm , M , N ) ! !     Allocator Integer Arrays !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 ! !     Allocates array and updates memory information ! implicit none ! integer , intent ( in ) :: M , N integer , dimension (:,:), allocatable :: elm integer :: size integer :: stat = 0 , error = 0 ! size = M * N ! allocate ( elm ( M , N ), stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Allocation error! Could not allocate array of size (M*N):' , size stop ! endif ! work_remains = work_remains - 2 * size work_used = work_used + 2 * size ! if ( work_remains . lt . 0 ) then ! write ( unit_output , '(t3,a)' ) \"Error: user-specified memory insufficient.\" stop ! endif ! end subroutine allocator_int ! ! subroutine deallocator_int ( elm , M , N ) ! ! !     Deallocator Integer Arrays !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017 ! !     Deallocates array and updates memory information ! ! implicit none ! integer , dimension (:,:), allocatable :: elm integer :: stat = 0 , error = 0 integer , intent ( in ) :: M , N integer :: size ! size = M * N ! deallocate ( elm , stat = error ) ! if ( stat . ne . 0 ) then ! write ( unit_output , '(t3,a,i15)' ) 'Deallocation error! Could not deallocate array of size (M*N):' , size stop ! endif ! work_remains = work_remains + 2 * size work_used = work_used - 2 * size ! end subroutine deallocator_int ! ! integer function get_available () ! !     Get Available !     Written by Eirik F. Kjønstad and Sarai D. Folkestad, Mar 2017 ! !     Returns the available memory ! get_available = work_remains ! end function get_available ! ! end module workspace","tags":"","loc":"sourcefile/workspace.f90.html","title":"workspace.F90 – Fortran Program"},{"text":"type, public :: calc_procedures Variables do_ground_state do_excited_state do_properties n_singlet_states n_triplet_states Components Type Visibility Attributes Name Initial logical, public :: do_ground_state = .false. logical, public :: do_excited_state = .false. logical, public :: do_properties = .false. integer(kind=i15), public :: n_singlet_states = 0 integer(kind=i15), public :: n_triplet_states = 0","tags":"","loc":"type/calc_procedures.html","title":"calc_procedures – Fortran Program "},{"text":"type, public :: calc_settings Variables energy_threshold ampeqs_threshold ampeqs_max_iterations Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy_threshold = 1.0D-06 real(kind=dp), public :: ampeqs_threshold = 1.0D-06 integer(kind=i15), public :: ampeqs_max_iterations = 25","tags":"","loc":"type/calc_settings.html","title":"calc_settings – Fortran Program "},{"text":"type, public, extends( hf ) :: ccs Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented n_t1am t1am omega1 fock_ij fock_ia fock_ai fock_ab Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky init drv initialize_amplitudes initialize_omega initialize_fock_matrix construct_fock one_electron_t1 calc_energy get_cholesky_ij get_cholesky_ia get_cholesky_ai get_cholesky_ab construct_omega ground_state_solver new_amplitudes calc_ampeqs calc_ampeqs_norm calc_quasi_Newton_singles diis Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_procedures ), public :: tasks type( calc_procedures ), public :: implemented integer(kind=i15), public :: n_t1am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)**2, wf%n_J) :: L_ij_J procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), wf%n_J) :: L_ia_J procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), wf%n_J) :: L_ai_J procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, first, last, ab_dim, reorder) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(ab_dim, wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: first integer(kind=i15), intent(in) :: last integer(kind=i15), intent(in) :: ab_dim logical, intent(in) :: reorder procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public :: init => init_ccs public subroutine init_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: drv => drv_ccs public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_amplitudes => initialize_amplitudes_ccs public subroutine initialize_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_omega => initialize_omega_ccs public subroutine initialize_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: initialize_fock_matrix => initialize_fock_matrix_ccs public interface initialize_fock_matrix_ccs () Arguments None procedure, public, non_overridable :: construct_fock => construct_fock_ccs public interface construct_fock_ccs () Arguments None procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs public interface one_electron_t1_ccs () Arguments None procedure, public :: calc_energy => calc_energy_ccs public subroutine calc_energy_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs public interface get_cholesky_ij_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs public interface get_cholesky_ia_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs public interface get_cholesky_ai_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs public interface get_cholesky_ab_ccs () Arguments None procedure, public :: construct_omega => construct_omega_ccs public subroutine construct_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf procedure, public :: ground_state_solver => ground_state_solver_ccs public interface ground_state_solver_ccs () Arguments None procedure, public :: new_amplitudes => new_amplitudes_ccs public interface new_amplitudes_ccs () Arguments None procedure, public :: calc_ampeqs => calc_ampeqs_ccs public interface calc_ampeqs_ccs () Arguments None procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccs public interface calc_ampeqs_norm_ccs () Arguments None procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs public interface calc_quasi_Newton_singles_ccs () Arguments None procedure, public, non_overridable :: diis => diis_ccs public interface diis_ccs () Arguments None","tags":"","loc":"type/ccs.html","title":"ccs – Fortran Program "},{"text":"type, public, extends( ccs ) :: ccsd Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented n_t1am t1am omega1 fock_ij fock_ia fock_ai fock_ab n_t2am t2am omega2 Type-Bound Procedures read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky initialize_fock_matrix construct_fock one_electron_t1 get_cholesky_ij get_cholesky_ia get_cholesky_ai get_cholesky_ab ground_state_solver calc_ampeqs calc_quasi_Newton_singles diis init drv initialize_amplitudes calc_energy initialize_omega construct_omega omega_a1 omega_b1 omega_c1 omega_d1 omega_a2 omega_b2 omega_c2 omega_d2 omega_e2 calc_ampeqs_norm new_amplitudes calc_quasi_Newton_doubles Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_procedures ), public :: tasks type( calc_procedures ), public :: implemented integer(kind=i15), public :: n_t1am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)**2, wf%n_J) :: L_ij_J procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), wf%n_J) :: L_ia_J procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), wf%n_J) :: L_ai_J procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, first, last, ab_dim, reorder) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(ab_dim, wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: first integer(kind=i15), intent(in) :: last integer(kind=i15), intent(in) :: ab_dim logical, intent(in) :: reorder procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public :: initialize_fock_matrix => initialize_fock_matrix_ccs public interface initialize_fock_matrix_ccs () Arguments None procedure, public, non_overridable :: construct_fock => construct_fock_ccs public interface construct_fock_ccs () Arguments None procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs public interface one_electron_t1_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs public interface get_cholesky_ij_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs public interface get_cholesky_ia_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs public interface get_cholesky_ai_ccs () Arguments None procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs public interface get_cholesky_ab_ccs () Arguments None procedure, public :: ground_state_solver => ground_state_solver_ccs public interface ground_state_solver_ccs () Arguments None procedure, public :: calc_ampeqs => calc_ampeqs_ccs public interface calc_ampeqs_ccs () Arguments None procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs public interface calc_quasi_Newton_singles_ccs () Arguments None procedure, public, non_overridable :: diis => diis_ccs public interface diis_ccs () Arguments None procedure, public :: init => init_ccsd public subroutine init_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: drv => drv_ccsd public subroutine drv_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: initialize_amplitudes => initialize_amplitudes_ccsd public subroutine initialize_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: calc_energy => calc_energy_ccsd public subroutine calc_energy_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf procedure, public :: initialize_omega => initialize_omega_ccsd public interface initialize_omega_ccsd () Arguments None procedure, public :: construct_omega => construct_omega_ccsd public interface construct_omega_ccsd () Arguments None procedure, public :: omega_a1 => omega_a1_ccsd public interface omega_a1_ccsd () Arguments None procedure, public :: omega_b1 => omega_b1_ccsd public interface omega_b1_ccsd () Arguments None procedure, public :: omega_c1 => omega_c1_ccsd public interface omega_c1_ccsd () Arguments None procedure, public :: omega_d1 => omega_d1_ccsd public interface omega_d1_ccsd () Arguments None procedure, public :: omega_a2 => omega_a2_ccsd public interface omega_a2_ccsd () Arguments None procedure, public :: omega_b2 => omega_b2_ccsd public interface omega_b2_ccsd () Arguments None procedure, public :: omega_c2 => omega_c2_ccsd public interface omega_c2_ccsd () Arguments None procedure, public :: omega_d2 => omega_d2_ccsd public interface omega_d2_ccsd () Arguments None procedure, public :: omega_e2 => omega_e2_ccsd public interface omega_e2_ccsd () Arguments None procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd public interface calc_ampeqs_norm_ccsd () Arguments None procedure, public :: new_amplitudes => new_amplitudes_ccsd public interface new_amplitudes_ccsd () Arguments None procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd public interface calc_quasi_Newton_doubles_ccsd () Arguments None","tags":"","loc":"type/ccsd.html","title":"ccsd – Fortran Program "},{"text":"type, public :: hf Variables name n_o n_v n_ao n_mo n_J mo_coef fock_diagonal energy nuclear_potential scf_energy settings tasks implemented Type-Bound Procedures init drv read_cholesky_ij read_cholesky_ia read_cholesky_ai read_cholesky_ab read_hf_info read_transform_cholesky Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_procedures ), public :: tasks type( calc_procedures ), public :: implemented Type-Bound Procedures procedure, public :: init => init_hf public subroutine init_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public :: drv => drv_hf public subroutine drv_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf public subroutine read_cholesky_ij_hf (wf, L_ij_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)**2, wf%n_J) :: L_ij_J procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf public subroutine read_cholesky_ia_hf (wf, L_ia_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), wf%n_J) :: L_ia_J procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf public subroutine read_cholesky_ai_hf (wf, L_ai_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), wf%n_J) :: L_ai_J procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf public subroutine read_cholesky_ab_hf (wf, L_ab_J, first, last, ab_dim, reorder) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(ab_dim, wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: first integer(kind=i15), intent(in) :: last integer(kind=i15), intent(in) :: ab_dim logical, intent(in) :: reorder procedure, public, non_overridable :: read_hf_info => read_hf_info_hf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf","tags":"","loc":"type/hf.html","title":"hf – Fortran Program "},{"text":"public subroutine init_ccs(wf) Initialize CCS object\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nPerforms the following tasks\n\n1. Sets HF orbital and energy information by reading from file\n2. Transforms AO Cholesky vectors to MO basis and saves to file \n3. Allocates the singles amplitudes and sets them to zero, and sets associated properties \n4. Allocates the omega vector and sets it to zero\n5. Initializes the Fock matrix and sets it to zero Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/init_ccs.html","title":"init_ccs – Fortran Program"},{"text":"public subroutine drv_ccs(wf) CCS Driver\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nIf called, the routine lets the user know there is no driver \nfor CCS, then exits the program. Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/drv_ccs.html","title":"drv_ccs – Fortran Program"},{"text":"public subroutine initialize_amplitudes_ccs(wf) Initialize Amplitudes (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nAllocates the singles amplitudes, sets them to zero, and calculates\nthe number of singles amplitudes. Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/initialize_amplitudes_ccs.html","title":"initialize_amplitudes_ccs – Fortran Program"},{"text":"public subroutine initialize_omega_ccs(wf) Initialize Omega (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nAllocates and sets the projection vector to zero (which is\nalso its correct value, by Brillouin) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/initialize_omega_ccs.html","title":"initialize_omega_ccs – Fortran Program"},{"text":"public subroutine calc_energy_ccs(wf) Calculate Energy (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/calc_energy_ccs.html","title":"calc_energy_ccs – Fortran Program"},{"text":"public subroutine construct_omega_ccs(wf) Construct Omega (CCS)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"proc/construct_omega_ccs.html","title":"construct_omega_ccs – Fortran Program"},{"text":"interface public module subroutine get_cholesky_ij_ccs(wf, L_ij_J) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension((wf%n_o)**2, wf%n_J) :: L_ij_J Description Get Cholesky IJ\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Reads and T1-transforms the IA Cholesky vectors:\n\n      L_ij_J_T1 = L_ij_J + sum_a t_aj * L_ia_J\n\n   Memory required in routine:\n\n      2*n_J*n_o*n_v     -> for reading L_ia_J contribution and reordering","tags":"","loc":"interface/get_cholesky_ij_ccs.html","title":"get_cholesky_ij_ccs – Fortran Program"},{"text":"interface public module subroutine get_cholesky_ia_ccs(wf, L_ia_J) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), wf%n_J) :: L_ia_J Description Get Cholesky IA\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Reads and T1-transforms IA Cholesky vectors\n\n      L_ia_J_T1 = L_ia_J (only reading necessary)\n\n   Memory required in routine:\n\n      No additional memory","tags":"","loc":"interface/get_cholesky_ia_ccs.html","title":"get_cholesky_ia_ccs – Fortran Program"},{"text":"interface public module subroutine get_cholesky_ai_ccs(wf, L_ai_J) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), wf%n_J) :: L_ai_J Description Get Cholesky AI\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Read and T1-transform Cholesky AI vectors:\n\n       L_ai_J_T1 = L_ia_J - sum_j  t_aj*L_ji_J \n                       + sum_b  t_bi*L_ab_J\n                       - sum_bj t_aj*t_bi*L_jb_J\n\n   Allocations in routine:\n\n      (1) n_J*n_o*n_v + 2*n_J*n_v*batch_length   ->  for L_ab_J contribution\n      (2) n_J*n_o*n_v + 2*n_J*n_o&#94;2              ->  for L_ij_J contribution\n      (3) 2*n_J*n_o*n_v                          ->  for L_jb_J contribution\n\n      (1) determines memory requirement.","tags":"","loc":"interface/get_cholesky_ai_ccs.html","title":"get_cholesky_ai_ccs – Fortran Program"},{"text":"interface public module subroutine get_cholesky_ab_ccs(wf, L_ab_J, first, last, ab_dim, reorder) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(ab_dim, wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: first integer(kind=i15), intent(in) :: last integer(kind=i15), intent(in) :: ab_dim logical, intent(in) :: reorder Description Get Cholesky AB\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Reads and T1-transforms the IA Cholesky vectors:\n\n      L_ab_J_T1 = L_ab_J - sum_i t_ai*L_ib_J\n\n   If reorder = .true.,  L_ba_J is returned with batching over a\n   If reorder = .false., L_ab_J is returned with batching over b\n\n   Required memory:\n\n      n_J*batch_length*n_v   ->   For reordering of L_ab_J / L_ba_J\n      2*n_v*n_o*n_J          ->   For L_ib_J contribution","tags":"","loc":"interface/get_cholesky_ab_ccs.html","title":"get_cholesky_ab_ccs – Fortran Program"},{"text":"interface public subroutine initialize_fock_matrix_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Initialize Fock matrix\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Allocates and sets Fock matrix blocks (ij, ia, ai, ab) to zero\n   before calling the Fock matrix constructor.","tags":"","loc":"interface/initialize_fock_matrix_ccs.html","title":"initialize_fock_matrix_ccs – Fortran Program"},{"text":"interface public subroutine construct_fock_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Construct Fock \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Constructs the T1-transformed Fock matrix blocks (occ/vir-occ/vir),\n   and saves the result in the class variables fock_pq.","tags":"","loc":"interface/construct_fock_ccs.html","title":"construct_fock_ccs – Fortran Program"},{"text":"interface public subroutine one_electron_t1_ccs(wf, h1, h1_T1) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_mo, wf%n_mo) :: h1 real(kind=dp), dimension(wf%n_mo, wf%n_mo) :: h1_T1 Description One-electron T1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   T1-transforms the one-electron MO integrals h_pq\n\n       h_p_q_T1 = sum_st x_p_s * y_q_t * h_s_t,\n\n   where\n\n       x = I - t1,\n       y = I - t1&#94;T.","tags":"","loc":"interface/one_electron_t1_ccs.html","title":"one_electron_t1_ccs – Fortran Program"},{"text":"interface public module subroutine ground_state_solver_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Ground State Solver \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Directs the solution of the ground state amplitude equations\n   using a DIIS algorithm. The problem the routine solves is\n\n      X_mu(t) = 0, where t = { t_mu }_mu\n\n   For standard coupled cluster theories, the vector X is the\n   projection vector (omega).","tags":"","loc":"interface/ground_state_solver_ccs.html","title":"ground_state_solver_ccs – Fortran Program"},{"text":"interface public module subroutine calc_ampeqs_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description Calculate Amplitude Equations (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Constructs the amplitude equations vector (the projection vector \n   in CCS) for the amplitudes of the current iteration of the ground state\n   solver. It also calculates the norm of the amplitude equations, which \n   is zero when the equations are exactly solved.","tags":"","loc":"interface/calc_ampeqs_ccs.html","title":"calc_ampeqs_ccs – Fortran Program"},{"text":"interface public module subroutine calc_ampeqs_norm_ccs(wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp) :: ampeqs_norm Description Calculate Amplitude Equations Norm (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/calc_ampeqs_norm_ccs.html","title":"calc_ampeqs_norm_ccs – Fortran Program"},{"text":"interface public module subroutine new_amplitudes_ccs(wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf Description New Amplitudes (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Directs the calculation of the quasi-Newton estimate Δ t_i, \n   and t_i + Δ t_i, and calls the DIIS routine to save & get \n   the amplitudes for the next iteration.","tags":"","loc":"interface/new_amplitudes_ccs.html","title":"new_amplitudes_ccs – Fortran Program"},{"text":"interface public module subroutine calc_quasi_Newton_singles_ccs(wf, dt, n_variables) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(n_variables, 1) :: dt integer(kind=i15), intent(in) :: n_variables Description Calculate quasi-Newton estimate (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Calculates the quasi-Newton estimate Δ t_i (singles part)\n   and places the contribution in the dt vector (of length n_variables,\n   with singles first, then doubles, etc. if inherited)","tags":"","loc":"interface/calc_quasi_newton_singles_ccs.html","title":"calc_quasi_Newton_singles_ccs – Fortran Program"},{"text":"interface public module subroutine diis_ccs(wf, dt, t_dt, n_variables) Arguments Type Intent Optional Attributes Name class( ccs ), intent(in) :: wf real(kind=dp), dimension(n_variables, 1) :: dt real(kind=dp), dimension(n_variables, 1) :: t_dt integer(kind=i15), intent(in) :: n_variables Description DIIS routine (CCS)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad\n\n   The next amplitudes are\n\n      t_n+1 = sum_k w_k (t_k + dt_k),\n\n   where the weights w_k in front of the quasi-Newton estimate dt_k\n   are determined so as to minimize\n\n      f(w_k) = sum_k w_k dt_k,\n\n   with the constraint that g(w_k) = sum_k w_k - 1 = 0.","tags":"","loc":"interface/diis_ccs.html","title":"diis_ccs – Fortran Program"},{"text":"public subroutine init_ccsd(wf) Initialize CCSD object\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nPerforms the following tasks:\n\n   1. Sets HF orbital and energy information by reading from file (read_hf_info)\n   2. Transforms AO Cholesky vectors to MO basis and saves to file (read_transform_cholesky)\n   3. Allocates the Fock matrix and sets it to zero\n   4. Initializes the amplitudes (sets their initial values and associated variables)\n\nNote: this routine does not calculate the energy, which is postponed until the wavefunction\nis passed to the ground-state solver. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"proc/init_ccsd.html","title":"init_ccsd – Fortran Program"},{"text":"public subroutine drv_ccsd(wf) Driver (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nControls the CCSD calculation using requested calculations from\nuser (eventually: still under construction). Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"proc/drv_ccsd.html","title":"drv_ccsd – Fortran Program"},{"text":"public subroutine initialize_amplitudes_ccsd(wf) Initialize Amplitudes (CCSD)\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n Allocates the amplitudes, sets them to zero, calculates\n the number of amplitudes, and sets the doubles amplitudes\n to the perturbative MP2 estimate. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"proc/initialize_amplitudes_ccsd.html","title":"initialize_amplitudes_ccsd – Fortran Program"},{"text":"public subroutine calc_energy_ccsd(wf) Calculate Energy (CCSD)\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n Calculates the CCSD energy for the wavefunction's current amplitudes. Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"proc/calc_energy_ccsd.html","title":"calc_energy_ccsd – Fortran Program"},{"text":"interface public module subroutine initialize_omega_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Initialize Omega (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Allocates the projection vector (omega1, omega2) and sets it\n   to zero.","tags":"","loc":"interface/initialize_omega_ccsd.html","title":"initialize_omega_ccsd – Fortran Program"},{"text":"interface public module subroutine construct_omega_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Construct Omega (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Directs the construction of the projection vector < mu | exp(-T) H exp(T) | R >\n   for the current amplitudes of the object wfn","tags":"","loc":"interface/construct_omega_ccsd.html","title":"construct_omega_ccsd – Fortran Program"},{"text":"interface public module subroutine omega_a1_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega A1 term\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Calculates the A1 term,\n\n   A1: sum_ckd g_adkc * u_ki&#94;cd,\n\n   and adds it to the singles projection vector (omeg1) of\n   the wavefunction object wf.","tags":"","loc":"interface/omega_a1_ccsd.html","title":"omega_a1_ccsd – Fortran Program"},{"text":"interface public module subroutine omega_b1_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega B1\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Calculates the B1 term,\n\n   B1: - sum_ckl u_kl&#94;ac * g_kilc,\n\n   and adds it to the singles projection vector (omeg1) of\n   the wavefunction object wf","tags":"","loc":"interface/omega_b1_ccsd.html","title":"omega_b1_ccsd – Fortran Program"},{"text":"interface public module subroutine omega_c1_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega C1\n Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017\n\n Calculates the C1 term of omega,\n\n C1: sum_ck F_kc*u_ai_ck,\n\n and adds it to the projection vector (omega1) of    \n the wavefunction object wf\n\n u_ai_ck = 2*t_ck_ai - t_ci_ak","tags":"","loc":"interface/omega_c1_ccsd.html","title":"omega_c1_ccsd – Fortran Program"},{"text":"interface public module subroutine omega_d1_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega D1 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, March 2017\n\n   Omega_ai&#94;D1 = F_ai_T1","tags":"","loc":"interface/omega_d1_ccsd.html","title":"omega_d1_ccsd – Fortran Program"},{"text":"interface public module subroutine omega_a2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega A2 term: Omega A2 = g_ai_bj + sum_(cd)g_ac_bd * t_ci_dj = A2.1 + A.2.2\n\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, 10 Mar 2017\n\n Structure: Batching over both a and b for A2.2.\n            t&#94;+_ci_dj = t_ci_dj + t_di_cj\n            t&#94;-_ci_dj = t_ci_dj - t_di_cj\n            g&#94;+_ac_bd = g_ac_bd + g_bc_ad \n            g&#94;-_ac_bd = g_ac_bd - g_bc_ad\n\n            omega_A2.2_ai_bj = 1/4*(g&#94;+_ac_bd*t&#94;+_ci_dj + g&#94;-_ac_bd*t&#94;-_ci_dj) = omega_A2.2_bj_ai\n            omega_A2.2_aj_bi = 1/4*(g&#94;+_ac_bd*t&#94;+_ci_dj - g&#94;-_ac_bd*t&#94;-_ci_dj) = omega_A2.2_bi_aj","tags":"","loc":"interface/omega_a2_ccsd.html","title":"omega_a2_ccsd – Fortran Program"},{"text":"interface public module subroutine omega_b2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega B2\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, 11 Mar 2017\n\n   Omega B2 = sum_(kl) t_ak_bl*(g_kilj + sum_(cd) t_ci_dj * g_kc_ld)\n\n   Structure: g_kilj is constructed first and reordered as g_kl_ij. \n   Then the contraction over cd is performed, and the results added to g_kl_ij.\n   t_ak_bl is then reordered as t_ab_kl and the contraction over kl is performed.","tags":"","loc":"interface/omega_b2_ccsd.html","title":"omega_b2_ccsd – Fortran Program"},{"text":"interface public module subroutine omega_c2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega C2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Mar 2017\n\n   Omega C2 = -1/2* sum_(ck)t_bk_cj*(g_ki_ac -1/2 sum_(dl)t_al_di * g_kd_lc)\n                              - sum_(ck) t_bk_ci (g_kj_ac-sum_(dl)t_al_dj*g_kd_lc)","tags":"","loc":"interface/omega_c2_ccsd.html","title":"omega_c2_ccsd – Fortran Program"},{"text":"interface public module subroutine omega_d2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega D2 \n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Calculates the D2 term,\n\n      sum_ck u_jk&#94;bc g_aikc \n       - 1/2 * sum_ck u_jk&#94;bc g_acki \n       + 1/4 * sum_ck u_jk&#94;bc sum_dl L_ldkc u_il&#94;ad,\n\n   where\n\n      u_jk&#94;bc = 2 * t_jk&#94;bc - t_kj&#94;bc,\n      L_ldkc  = 2 * g_ldkc  - g_lckd.\n\n   The first, second, and third terms are referred to as D2.1, D2.2, and D2.3, \n   and comes out ordered as (ai,bj). All terms are added to the omega vector of the \n   wavefunction object wf.\n\n   The routine adds the terms in the following order: D2.3, D2.1, D2.2","tags":"","loc":"interface/omega_d2_ccsd.html","title":"omega_d2_ccsd – Fortran Program"},{"text":"interface public module subroutine omega_e2_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description Omega E2\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n   Calculates the E2 term,\n\n       sum_c t_ij&#94;ac (F_bc - sum_dkl g_ldkc u_kl&#94;bd) \n       - sum_k t_ik&#94;ab (F_kj + sum_cdl g_ldkc u_lj&#94;dc),\n\n   where\n\n      u_kl&#94;bc = 2 * t_kl&#94;bc - t_lk&#94;bc.\n\n   The first term is referred to as the E2.1 term, and comes out ordered as (b,jai).\n   The second term is referred to as the E2.2 term, and comes out ordered as (aib,j).\n\n   Both are permuted added to the projection vector element omega2(ai,bj) of\n   the wavefunction object wf.","tags":"","loc":"interface/omega_e2_ccsd.html","title":"omega_e2_ccsd – Fortran Program"},{"text":"interface public module subroutine calc_ampeqs_norm_ccsd(wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp) :: ampeqs_norm Description Calculate Amplitude Equations Norm (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017","tags":"","loc":"interface/calc_ampeqs_norm_ccsd.html","title":"calc_ampeqs_norm_ccsd – Fortran Program"},{"text":"interface public module subroutine new_amplitudes_ccsd(wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf Description New Amplitudes (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Directs the calculation of the quasi-Newton estimate Δ t_i, \n   and t_i + Δ t_i, and calls the DIIS routine to save & get \n   the amplitudes for the next iteration.","tags":"","loc":"interface/new_amplitudes_ccsd.html","title":"new_amplitudes_ccsd – Fortran Program"},{"text":"interface public module subroutine calc_quasi_Newton_doubles_ccsd(wf, dt, n_variables) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(n_variables, 1) :: dt integer(kind=i15), intent(in) :: n_variables Description Calculate quasi-Newton estimate (CCSD)\n   Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n   Calculates the quasi-Newton estimate Δ t_i (doubbles part)\n   and places the contribution in the dt vector (of length n_variables,\n   with singles first, then doubles, etc. if inherited)","tags":"","loc":"interface/calc_quasi_newton_doubles_ccsd.html","title":"calc_quasi_Newton_doubles_ccsd – Fortran Program"},{"text":"public subroutine init_hf(wf) Initialization of Hartree-Fock object\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nPerforms the following tasks:\n\n1. Sets HF orbital and energy information by reading from file\n2. Transforms AO Cholesky vectors to MO basis and saves to file Arguments Type Intent Optional Attributes Name class( hf ) :: wf","tags":"","loc":"proc/init_hf.html","title":"init_hf – Fortran Program"},{"text":"public subroutine drv_hf(wf) Driver (HF)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nLets the user know there is no driver for Hartree-Fock and exits\nthe program if called. The module reads Hartree-Fock information \nfrom files and contains no independent solver. Arguments Type Intent Optional Attributes Name class( hf ) :: wf","tags":"","loc":"proc/drv_hf.html","title":"drv_hf – Fortran Program"},{"text":"public subroutine read_hf_info_hf(wf) Read HF Info\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the file mlcc_hf_info and sets the following HF variables: \nn_o, n_v, n_mo, orbital_coef, and the fock_diagonal.\n\nThe file mlcc_hf_info is written in the mlcc_write_sirifc \nsubroutine, which is called from the wr_sirifc subroutine in\nthe siropt module of the DALTON suite. Arguments Type Intent Optional Attributes Name class( hf ) :: wf","tags":"","loc":"proc/read_hf_info_hf.html","title":"read_hf_info_hf – Fortran Program"},{"text":"public subroutine read_transform_cholesky_hf(wf) Read and Transform Cholesky\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, 20 Apr 2017\n\nReads the AO Cholesky vectors from file, transforms the vectors \nto the MO basis, and saves the MO vectors to file Arguments Type Intent Optional Attributes Name class( hf ) :: wf","tags":"","loc":"proc/read_transform_cholesky_hf.html","title":"read_transform_cholesky_hf – Fortran Program"},{"text":"public subroutine read_cholesky_ij_hf(wf, L_ij_J) Read Cholesky IJ \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky IJ (occ-occ) vectors from file and \nplaces them in the incoming L_ij_J matrix Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)**2, wf%n_J) :: L_ij_J","tags":"","loc":"proc/read_cholesky_ij_hf.html","title":"read_cholesky_ij_hf – Fortran Program"},{"text":"public subroutine read_cholesky_ia_hf(wf, L_ia_J) Read Cholesky IA \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky IA (occ-vir) vectors from file and\nplaces them in the incoming L_ia_J matrix Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), wf%n_J) :: L_ia_J","tags":"","loc":"proc/read_cholesky_ia_hf.html","title":"read_cholesky_ia_hf – Fortran Program"},{"text":"public subroutine read_cholesky_ai_hf(wf, L_ai_J) Read Cholesky AI \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky AI (vir-occ) vectors from file and\nplaces them in the incoming L_ai_J matrix Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), wf%n_J) :: L_ai_J","tags":"","loc":"proc/read_cholesky_ai_hf.html","title":"read_cholesky_ai_hf – Fortran Program"},{"text":"public subroutine read_cholesky_ab_hf(wf, L_ab_J, first, last, ab_dim, reorder) Read Cholesky AB \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nReads the MO Cholesky AB (vir-vir) vectors from file and\nplaces them in the incoming L_ab_J matrix, with batching \nif necessary\n\nIf reorder = .true.,  L_ba_J is returned with batching over a\nIf reorder = .false., L_ab_J is returned with batching over b Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(ab_dim, wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: first integer(kind=i15), intent(in) :: last integer(kind=i15), intent(in) :: ab_dim logical, intent(in) :: reorder","tags":"","loc":"proc/read_cholesky_ab_hf.html","title":"read_cholesky_ab_hf – Fortran Program"},{"text":"public subroutine generate_unit_identifier(unit_identifier) Generate unit identifier\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, April 2017\n\nReturns a valid unit identifier for opening file. Arguments Type Intent Optional Attributes Name integer(kind=i15) :: unit_identifier","tags":"","loc":"proc/generate_unit_identifier.html","title":"generate_unit_identifier – Fortran Program"},{"text":"public subroutine vec_print(vec, dim_1, dim_2) Vector print\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, March 2017\n\nA vector is printed with a compound index (p q) of dimension (dim_1 x dim_2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(dim_1, dim_2) :: vec integer(kind=i15), intent(in) :: dim_1 integer(kind=i15), intent(in) :: dim_2","tags":"","loc":"proc/vec_print.html","title":"vec_print – Fortran Program"},{"text":"public subroutine method_reader(unit_input, method) Method Reader\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: unit_input character(len=40) :: method","tags":"","loc":"proc/method_reader.html","title":"method_reader – Fortran Program"},{"text":"public subroutine calculation_reader(unit_input, tasks) Calculation Reader\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nReads the calculation from the input file and initializes the \ntasks requested of the wavefunction. Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: unit_input type( calc_procedures ) :: tasks","tags":"","loc":"proc/calculation_reader.html","title":"calculation_reader – Fortran Program"},{"text":"public subroutine settings_reader(unit_input, settings) Settings Reader\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nReads the calculation settings from the input file and initializes \nthe settings requested of the wavefunction. Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: unit_input type( calc_settings ) :: settings","tags":"","loc":"proc/settings_reader.html","title":"settings_reader – Fortran Program"},{"text":"public function index_packed(i, j) Packed index    \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nCalculates the packed index of symetric matrix. Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j Return Value integer(kind=i15)","tags":"","loc":"proc/index_packed.html","title":"index_packed – Fortran Program"},{"text":"public function index_three(p, q, r, dim_p, dim_q) Three index compound\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nReturns the compound index (pqr) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: p integer(kind=i15), intent(in) :: q integer(kind=i15), intent(in) :: r integer(kind=i15), intent(in) :: dim_p integer(kind=i15), intent(in) :: dim_q Return Value integer(kind=i15)","tags":"","loc":"proc/index_three.html","title":"index_three – Fortran Program"},{"text":"public function index_two(p, q, dim_p) Two index compound\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nReturns the compound index (pq) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: p integer(kind=i15), intent(in) :: q integer(kind=i15), intent(in) :: dim_p Return Value integer(kind=i15)","tags":"","loc":"proc/index_two.html","title":"index_two – Fortran Program"},{"text":"public function packed_size(N) Packed size    \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nReturns size of packed symmetric matrices\nof dimension N x N (triangular elements) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: N Return Value integer(kind=i15)","tags":"","loc":"proc/packed_size.html","title":"packed_size – Fortran Program"},{"text":"public subroutine squareup(packed, unpacked, N) Square up packed symmetric matrix\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nSquares up to full dimension (N x N) of packed matrices. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:,:) :: packed real(kind=dp), dimension(:,:) :: unpacked integer(kind=i15), intent(in) :: N","tags":"","loc":"proc/squareup.html","title":"squareup – Fortran Program"},{"text":"public subroutine packin(packed, unpacked, N) Pack in symmetric matrix\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nPack down full square matrix of dimension N x N. Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:) :: packed real(kind=dp), intent(in), dimension(:,:) :: unpacked integer(kind=i15), intent(in) :: N","tags":"","loc":"proc/packin.html","title":"packin – Fortran Program"},{"text":"public subroutine num_batch(required, available, max_batch_length, n_batch, batch_dimension) Number of batches \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nCalculates number of batches\n\nBatching structure will be:\nWith rest:     (n_batch-1)*(max_batch_length) + rest = required\nWithout rest:  (n_batch)*(max_batch_length) = required Arguments Type Intent Optional Attributes Name integer(kind=i15) :: required integer(kind=i15), intent(in) :: available integer(kind=i15) :: max_batch_length integer(kind=i15) :: n_batch integer(kind=i15), intent(in) :: batch_dimension","tags":"","loc":"proc/num_batch.html","title":"num_batch – Fortran Program"},{"text":"public subroutine num_two_batch(required, available, max_batch_length, n_batch, batch_dimension) Number of batches \nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\nCalculates number of batches when two batching variables are needed\n\nBatching structure will be:\nWith rest:     (n_batch-1)*(max_batch_length) + rest = required\nWithout rest:  (n_batch)*(max_batch_length) = required Arguments Type Intent Optional Attributes Name integer(kind=i15) :: required integer(kind=i15), intent(in) :: available integer(kind=i15) :: max_batch_length integer(kind=i15) :: n_batch integer(kind=i15), intent(in) :: batch_dimension","tags":"","loc":"proc/num_two_batch.html","title":"num_two_batch – Fortran Program"},{"text":"public subroutine batch_limits(first, last, batch_number, max_batch_length, batch_dimension) Batch limits \n Written by Eirik F. Kjønstad and Sarai D. Folkestad, Jan 2017\n\n Find batch limits (first and last)\n\n batch_number: the current batch (1,2,...,n_batch)\n max_batch_length: the length of each batch (except the last, which may be a rest, see n_one_batch routine)\n batch_dimension: the dimensionality of the batching variable (e.g., n_vir for a virtual index) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: first integer(kind=i15) :: last integer(kind=i15), intent(in) :: batch_number integer(kind=i15), intent(in) :: max_batch_length integer(kind=i15), intent(in) :: batch_dimension","tags":"","loc":"proc/batch_limits.html","title":"batch_limits – Fortran Program"},{"text":"public function get_available() Arguments None Return Value integer","tags":"","loc":"proc/get_available.html","title":"get_available – Fortran Program"},{"text":"public subroutine work_init() Arguments None","tags":"","loc":"proc/work_init.html","title":"work_init – Fortran Program"},{"text":"public subroutine allocator(elm, M, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N","tags":"","loc":"proc/allocator.html","title":"allocator – Fortran Program"},{"text":"public subroutine deallocator(elm, M, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N","tags":"","loc":"proc/deallocator.html","title":"deallocator – Fortran Program"},{"text":"public subroutine allocator_int(elm, M, N) Arguments Type Intent Optional Attributes Name integer, dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N","tags":"","loc":"proc/allocator_int.html","title":"allocator_int – Fortran Program"},{"text":"public subroutine deallocator_int(elm, M, N) Arguments Type Intent Optional Attributes Name integer, dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N","tags":"","loc":"proc/deallocator_int.html","title":"deallocator_int – Fortran Program"},{"text":"Uses: types Calculation procedures class module                                 \n        Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nThe procedures class is used for two purposes. Wavefunctions possess \n\"implemented\" and \"tasks\" objects, which are both instances of the class \ncalculation procedures. If one of the tasks requested is not implemented\nfor the wavefunction in question, the program stops, letting the user know\nthat the requested functionality is not a part of eT (yet).\n\nTasks are determined during the read of the input (see the main program).\nImplemented are set by the wavefunction's initialization routine. Derived Types calc_procedures Derived Types type, public :: calc_procedures Components Type Visibility Attributes Name Initial logical, public :: do_ground_state = .false. logical, public :: do_excited_state = .false. logical, public :: do_properties = .false. integer(kind=i15), public :: n_singlet_states = 0 integer(kind=i15), public :: n_triplet_states = 0","tags":"","loc":"module/calc_procedures_class.html","title":"calc_procedures_class – Fortran Program"},{"text":"Uses: types Calculation settings class module                                 \n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Derived Types calc_settings Derived Types type, public :: calc_settings Components Type Visibility Attributes Name Initial real(kind=dp), public :: energy_threshold = 1.0D-06 real(kind=dp), public :: ampeqs_threshold = 1.0D-06 integer(kind=i15), public :: ampeqs_max_iterations = 25","tags":"","loc":"module/calc_settings_class.html","title":"calc_settings_class – Fortran Program"},{"text":"Uses: types utils workspace input_output hf_class Descendants: cholesky fock ground_state Coupled cluster singles (CCS) class module                                 \n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 Interfaces get_cholesky_ij_ccs get_cholesky_ia_ccs get_cholesky_ai_ccs get_cholesky_ab_ccs initialize_fock_matrix_ccs construct_fock_ccs one_electron_t1_ccs ground_state_solver_ccs calc_ampeqs_ccs calc_ampeqs_norm_ccs new_amplitudes_ccs calc_quasi_Newton_singles_ccs diis_ccs Derived Types ccs Subroutines init_ccs drv_ccs initialize_amplitudes_ccs initialize_omega_ccs calc_energy_ccs construct_omega_ccs Interfaces interface public module subroutine get_cholesky_ij_ccs (wf, L_ij_J) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension((wf%n_o)**2, wf%n_J) :: L_ij_J interface public module subroutine get_cholesky_ia_ccs (wf, L_ia_J) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), wf%n_J) :: L_ia_J interface public module subroutine get_cholesky_ai_ccs (wf, L_ai_J) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), wf%n_J) :: L_ai_J interface public module subroutine get_cholesky_ab_ccs (wf, L_ab_J, first, last, ab_dim, reorder) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(ab_dim, wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: first integer(kind=i15), intent(in) :: last integer(kind=i15), intent(in) :: ab_dim logical, intent(in) :: reorder interface public subroutine initialize_fock_matrix_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public subroutine construct_fock_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public subroutine one_electron_t1_ccs (wf, h1, h1_T1) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(wf%n_mo, wf%n_mo) :: h1 real(kind=dp), dimension(wf%n_mo, wf%n_mo) :: h1_T1 interface public module subroutine ground_state_solver_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine calc_ampeqs_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine calc_ampeqs_norm_ccs (wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp) :: ampeqs_norm interface public module subroutine new_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf interface public module subroutine calc_quasi_Newton_singles_ccs (wf, dt, n_variables) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf real(kind=dp), dimension(n_variables, 1) :: dt integer(kind=i15), intent(in) :: n_variables interface public module subroutine diis_ccs (wf, dt, t_dt, n_variables) Arguments Type Intent Optional Attributes Name class( ccs ), intent(in) :: wf real(kind=dp), dimension(n_variables, 1) :: dt real(kind=dp), dimension(n_variables, 1) :: t_dt integer(kind=i15), intent(in) :: n_variables Derived Types type, public, extends( hf ) :: ccs Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_procedures ), public :: tasks type( calc_procedures ), public :: implemented integer(kind=i15), public :: n_t1am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public :: init => init_ccs procedure, public :: drv => drv_ccs procedure, public :: initialize_amplitudes => initialize_amplitudes_ccs procedure, public :: initialize_omega => initialize_omega_ccs procedure, public :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure, public, non_overridable :: construct_fock => construct_fock_ccs procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs procedure, public :: calc_energy => calc_energy_ccs procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs procedure, public :: construct_omega => construct_omega_ccs procedure, public :: ground_state_solver => ground_state_solver_ccs procedure, public :: new_amplitudes => new_amplitudes_ccs procedure, public :: calc_ampeqs => calc_ampeqs_ccs procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccs procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs procedure, public, non_overridable :: diis => diis_ccs Subroutines public subroutine init_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine drv_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine initialize_amplitudes_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine initialize_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine calc_energy_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf public subroutine construct_omega_ccs (wf) Arguments Type Intent Optional Attributes Name class( ccs ) :: wf","tags":"","loc":"module/ccs_class.html","title":"ccs_class – Fortran Program"},{"text":"Uses: types utils workspace input_output ccs_class Descendants: ground_state omega Coupled cluster singles and doubles (CCSD) class module                                 \n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 Interfaces initialize_omega_ccsd construct_omega_ccsd omega_a1_ccsd omega_b1_ccsd omega_c1_ccsd omega_d1_ccsd omega_a2_ccsd omega_b2_ccsd omega_c2_ccsd omega_d2_ccsd omega_e2_ccsd calc_ampeqs_norm_ccsd new_amplitudes_ccsd calc_quasi_Newton_doubles_ccsd Derived Types ccsd Subroutines init_ccsd drv_ccsd initialize_amplitudes_ccsd calc_energy_ccsd Interfaces interface public module subroutine initialize_omega_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine construct_omega_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_a1_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_b1_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_c1_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_d1_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_a2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_b2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_c2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_d2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine omega_e2_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine calc_ampeqs_norm_ccsd (wf, ampeqs_norm) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp) :: ampeqs_norm interface public module subroutine new_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf interface public module subroutine calc_quasi_Newton_doubles_ccsd (wf, dt, n_variables) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf real(kind=dp), dimension(n_variables, 1) :: dt integer(kind=i15), intent(in) :: n_variables Derived Types type, public, extends( ccs ) :: ccsd Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_procedures ), public :: tasks type( calc_procedures ), public :: implemented integer(kind=i15), public :: n_t1am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t1am real(kind=dp), public, dimension(:,:), allocatable :: omega1 real(kind=dp), public, dimension(:,:), allocatable :: fock_ij real(kind=dp), public, dimension(:,:), allocatable :: fock_ia real(kind=dp), public, dimension(:,:), allocatable :: fock_ai real(kind=dp), public, dimension(:,:), allocatable :: fock_ab integer(kind=i15), public :: n_t2am = 0 real(kind=dp), public, dimension(:,:), allocatable :: t2am real(kind=dp), public, dimension(:,:), allocatable :: omega2 Type-Bound Procedures procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf procedure, public :: initialize_fock_matrix => initialize_fock_matrix_ccs procedure, public, non_overridable :: construct_fock => construct_fock_ccs procedure, public, non_overridable :: one_electron_t1 => one_electron_t1_ccs procedure, public, non_overridable :: get_cholesky_ij => get_cholesky_ij_ccs procedure, public, non_overridable :: get_cholesky_ia => get_cholesky_ia_ccs procedure, public, non_overridable :: get_cholesky_ai => get_cholesky_ai_ccs procedure, public, non_overridable :: get_cholesky_ab => get_cholesky_ab_ccs procedure, public :: ground_state_solver => ground_state_solver_ccs procedure, public :: calc_ampeqs => calc_ampeqs_ccs procedure, public :: calc_quasi_Newton_singles => calc_quasi_Newton_singles_ccs procedure, public, non_overridable :: diis => diis_ccs procedure, public :: init => init_ccsd procedure, public :: drv => drv_ccsd procedure, public :: initialize_amplitudes => initialize_amplitudes_ccsd procedure, public :: calc_energy => calc_energy_ccsd procedure, public :: initialize_omega => initialize_omega_ccsd procedure, public :: construct_omega => construct_omega_ccsd procedure, public :: omega_a1 => omega_a1_ccsd procedure, public :: omega_b1 => omega_b1_ccsd procedure, public :: omega_c1 => omega_c1_ccsd procedure, public :: omega_d1 => omega_d1_ccsd procedure, public :: omega_a2 => omega_a2_ccsd procedure, public :: omega_b2 => omega_b2_ccsd procedure, public :: omega_c2 => omega_c2_ccsd procedure, public :: omega_d2 => omega_d2_ccsd procedure, public :: omega_e2 => omega_e2_ccsd procedure, public :: calc_ampeqs_norm => calc_ampeqs_norm_ccsd procedure, public :: new_amplitudes => new_amplitudes_ccsd procedure, public :: calc_quasi_Newton_doubles => calc_quasi_Newton_doubles_ccsd Subroutines public subroutine init_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine drv_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine initialize_amplitudes_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf public subroutine calc_energy_ccsd (wf) Arguments Type Intent Optional Attributes Name class( ccsd ) :: wf","tags":"","loc":"module/ccsd_class.html","title":"ccsd_class – Fortran Program"},{"text":"Uses: types utils workspace input_output calc_procedures_class calc_settings_class Hartree-Fock (HF) class module                                 \n    Written by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017 Derived Types hf Subroutines init_hf drv_hf read_hf_info_hf read_transform_cholesky_hf read_cholesky_ij_hf read_cholesky_ia_hf read_cholesky_ai_hf read_cholesky_ab_hf Derived Types type, public :: hf Components Type Visibility Attributes Name Initial character(len=40), public :: name = 'HF' integer(kind=i15), public :: n_o integer(kind=i15), public :: n_v integer(kind=i15), public :: n_ao integer(kind=i15), public :: n_mo integer(kind=i15), public :: n_J real(kind=dp), public, dimension(:,:), allocatable :: mo_coef real(kind=dp), public, dimension(:,:), allocatable :: fock_diagonal real(kind=dp), public :: energy real(kind=dp), public :: nuclear_potential real(kind=dp), public :: scf_energy type( calc_settings ), public :: settings type( calc_procedures ), public :: tasks type( calc_procedures ), public :: implemented Type-Bound Procedures procedure, public :: init => init_hf procedure, public :: drv => drv_hf procedure, public, non_overridable :: read_cholesky_ij => read_cholesky_ij_hf procedure, public, non_overridable :: read_cholesky_ia => read_cholesky_ia_hf procedure, public, non_overridable :: read_cholesky_ai => read_cholesky_ai_hf procedure, public, non_overridable :: read_cholesky_ab => read_cholesky_ab_hf procedure, public, non_overridable :: read_hf_info => read_hf_info_hf procedure, public, non_overridable :: read_transform_cholesky => read_transform_cholesky_hf Subroutines public subroutine init_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf public subroutine drv_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf public subroutine read_hf_info_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf public subroutine read_transform_cholesky_hf (wf) Arguments Type Intent Optional Attributes Name class( hf ) :: wf public subroutine read_cholesky_ij_hf (wf, L_ij_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)**2, wf%n_J) :: L_ij_J public subroutine read_cholesky_ia_hf (wf, L_ia_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_o)*(wf%n_v), wf%n_J) :: L_ia_J public subroutine read_cholesky_ai_hf (wf, L_ai_J) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension((wf%n_v)*(wf%n_o), wf%n_J) :: L_ai_J public subroutine read_cholesky_ab_hf (wf, L_ab_J, first, last, ab_dim, reorder) Arguments Type Intent Optional Attributes Name class( hf ) :: wf real(kind=dp), dimension(ab_dim, wf%n_J) :: L_ab_J integer(kind=i15), intent(in) :: first integer(kind=i15), intent(in) :: last integer(kind=i15), intent(in) :: ab_dim logical, intent(in) :: reorder","tags":"","loc":"module/hf_class.html","title":"hf_class – Fortran Program"},{"text":"Uses: types Input_output module\nWritten by Eirik F. Kjønstad and Sarai D. Folkestad, April 2017\n\nHandles input and output and contains:\n\ngenerate_unit_identifier: Returns a free unit_identifier which can be assigned to a file that is opened. \nvec_print:                Prints vector in compound index order. Variables unit_output Subroutines generate_unit_identifier vec_print Variables Type Visibility Attributes Name Initial integer(kind=i15), public :: unit_output = 0 Subroutines public subroutine generate_unit_identifier (unit_identifier) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: unit_identifier public subroutine vec_print (vec, dim_1, dim_2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(dim_1, dim_2) :: vec integer(kind=i15), intent(in) :: dim_1 integer(kind=i15), intent(in) :: dim_2","tags":"","loc":"module/input_output.html","title":"input_output – Fortran Program"},{"text":"Uses: types workspace input_output calc_procedures_class calc_settings_class Input reader module                                 \nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017 Subroutines method_reader calculation_reader settings_reader Subroutines public subroutine method_reader (unit_input, method) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: unit_input character(len=40) :: method public subroutine calculation_reader (unit_input, tasks) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: unit_input type( calc_procedures ) :: tasks public subroutine settings_reader (unit_input, settings) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: unit_input type( calc_settings ) :: settings","tags":"","loc":"module/input_reader.html","title":"input_reader – Fortran Program"},{"text":"Types module\n  Written by Sarai D. Folkestad and Eirik F. Kjønstad, April 2017 Defines the real and integer types used throughout the module Variables sp dp qp i15 zero one two half three four five six Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = selected_real_kind(6, 37) integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: qp = selected_real_kind(33, 4931) integer, public, parameter :: i15 = selected_int_kind(15) real(kind=dp), public, parameter :: zero = 0.0D0 real(kind=dp), public, parameter :: one = 1.0D0 real(kind=dp), public, parameter :: two = 2.0D0 real(kind=dp), public, parameter :: half = 0.5D0 real(kind=dp), public, parameter :: three = 3.0D0 real(kind=dp), public, parameter :: four = 4.0D0 real(kind=dp), public, parameter :: five = 5.0D0 real(kind=dp), public, parameter :: six = 6.0D0","tags":"","loc":"module/types.html","title":"types – Fortran Program"},{"text":"Uses: input_output types Utilities module \nWritten by Sarai D. Folkstad and Eirik F. Kjønstad, 28 Feb 2017\n\nContains:\n\nIndex functions:\n   index_packed: Calculates the packed index of symetric matrix\n   index_two:    Calculates the compound index of two indices\n   index_three   Calculates the compound index given by three indices\n\nMatrix utilities:\n   packin:      packs in symetric matrix\n   packed_size: Returns size of packed matrix\n   squeareup:   squares up symmetric matrix\n\nBatching subroutines:\n    num_batch:     Calculates the number of batches needed.\n    num_two_batch: Calculates the number of batches needed \n                   for to batching variables with equal number of batches. \n    batch_limits:  Returns batch start index and batch end index. Functions index_packed index_three index_two packed_size Subroutines squareup packin num_batch num_two_batch batch_limits Functions public function index_packed (i, j) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: i integer(kind=i15), intent(in) :: j Return Value integer(kind=i15) public function index_three (p, q, r, dim_p, dim_q) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: p integer(kind=i15), intent(in) :: q integer(kind=i15), intent(in) :: r integer(kind=i15), intent(in) :: dim_p integer(kind=i15), intent(in) :: dim_q Return Value integer(kind=i15) public function index_two (p, q, dim_p) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: p integer(kind=i15), intent(in) :: q integer(kind=i15), intent(in) :: dim_p Return Value integer(kind=i15) public function packed_size (N) Arguments Type Intent Optional Attributes Name integer(kind=i15), intent(in) :: N Return Value integer(kind=i15) Subroutines public subroutine squareup (packed, unpacked, N) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:,:) :: packed real(kind=dp), dimension(:,:) :: unpacked integer(kind=i15), intent(in) :: N public subroutine packin (packed, unpacked, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:) :: packed real(kind=dp), intent(in), dimension(:,:) :: unpacked integer(kind=i15), intent(in) :: N public subroutine num_batch (required, available, max_batch_length, n_batch, batch_dimension) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: required integer(kind=i15), intent(in) :: available integer(kind=i15) :: max_batch_length integer(kind=i15) :: n_batch integer(kind=i15), intent(in) :: batch_dimension public subroutine num_two_batch (required, available, max_batch_length, n_batch, batch_dimension) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: required integer(kind=i15), intent(in) :: available integer(kind=i15) :: max_batch_length integer(kind=i15) :: n_batch integer(kind=i15), intent(in) :: batch_dimension public subroutine batch_limits (first, last, batch_number, max_batch_length, batch_dimension) Arguments Type Intent Optional Attributes Name integer(kind=i15) :: first integer(kind=i15) :: last integer(kind=i15), intent(in) :: batch_number integer(kind=i15), intent(in) :: max_batch_length integer(kind=i15), intent(in) :: batch_dimension","tags":"","loc":"module/utils.html","title":"utils – Fortran Program"},{"text":"Uses: types input_output Workspace module\nWritten by Henrik Koch, Rolf H. Myhre, Eirik Kjønstad and Sarai Folkestad, Jan 2017\n\nManages program memory usage and contains:\n\nwork_init: Initializes the memory management variables.\n\nallocator:   Allocation of double precission array of two dimmensions (M,N). \n             Updates memory management variables.\ndeallocator: Deallocation of double precission array of two dimmensions (M,N).\n             Updates memory management variables.\n\nallocator_int:   Allocation of integer array of two dimmensions (M,N). \n                 Updates memory management variables.\ndeallocator_int: Deallocation of integer array of two dimmensions (M,N)\n                 Updates memory management variables.\n\nget_available: Returns available memory. Variables mem Functions get_available Subroutines work_init allocator deallocator allocator_int deallocator_int Variables Type Visibility Attributes Name Initial integer(kind=i15), public :: mem = 1000000000 Functions public function get_available () Arguments None Return Value integer Subroutines public subroutine work_init () Arguments None public subroutine allocator (elm, M, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N public subroutine deallocator (elm, M, N) Arguments Type Intent Optional Attributes Name real(kind=dp), dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N public subroutine allocator_int (elm, M, N) Arguments Type Intent Optional Attributes Name integer, dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N public subroutine deallocator_int (elm, M, N) Arguments Type Intent Optional Attributes Name integer, dimension(:,:), allocatable :: elm integer, intent(in) :: M integer, intent(in) :: N","tags":"","loc":"module/workspace.html","title":"workspace – Fortran Program"},{"text":"Ancestors: ccs_class Cholesky submodule ( CCS ) Written by Sarai D . Folkestad and Eirik F . Kjønstad , Apr 2017 Contains the following family of procedures of the CCS class: get_cholesky_ij ( L_ij_J ): returns the T1-transformed Cholesky vector L_ij &#94; J get_cholesky_ia ( L_ia_J ): returns the T1-transformed Cholesky vector L_ia &#94; J get_cholesky_ai ( L_ai_J ): returns the T1-transformed Cholesky vector L_ai &#94; J get_cholesky_ab ( L_ab_J , ...): returns the T1-transformed Cholesky vector L_ab &#94; J , but has options (...) for batching over the two indices a and b","tags":"","loc":"module/cholesky.html","title":"cholesky – Fortran Program"},{"text":"Ancestors: ccs_class Fock submodule\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\nContains the following family of procedures of the CCS class:\n\ninitialize_fock_matrix_ccs(wf):     Allocates and sets Fock matrix to 0.      \nconstruct_fock_ccs(wf):             Constructs T1_transformed mo Fock matrix.\none_electron_t1_ccs(wf, h1 ,h1_T1): T1-transformation of one-electron mo integrals.","tags":"","loc":"module/fock.html","title":"fock – Fortran Program"},{"text":"Ancestors: ccs_class Ground state submodule (CCS)\n            Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\nConsists of the following subroutines of the CCS module:\n\nground_state_solver:        Controls the iterative loop, calling in turn\n                            the calculation of the energy, the amplitude equations \n                            (and its norm), and the new_amplitudes routine.\n\nnew_amplitudes:             Calculates the quasi-Newton estimate and passes the \n                            information needed by the DIIS routine.\n\ndiis_ccs:                   This routine saves the quasi-Newton estimate Δ t and\n                            t + Δ t to file. It uses the previous estimates to\n                            select the amplitudes t for the next iteration.\n\n\ncalc_ampeqs:                Updates the amplitude equations for the current amplitudes.\ncalc_ampeqs_norm:           Calculates the norm of the amplitude equations.\ncalc_quasi_Newton_singles:  Calculates the singles part of the quasi-Newton estimate.\n\nCan be inherited by models of the same level (e.g. CC2) without modification.\n\nWhen inherited by higher level models (e.g. CCSD), the new_amplitudes and calc_ampeqs_norm\nroutines should be overridden to account for the doubles quasi-Newton estimate, amplitudes, \nand projection vector.","tags":"","loc":"module/ground_state.html","title":"ground_state – Fortran Program"},{"text":"Ancestors: ccsd_class Ground state submodule (CCSD)\n Written by Sarai D. Folkestad and Eirik F. Kjønstad, May 2017\n\n\n Consists of the following subroutines of the CCSD module:\n\n new_amplitudes:             Calculates the quasi-Newton estimate and passes the \n                             information needed by the DIIS routine.\n calc_ampeqs_norm:           Calculates the norm of the amplitude equations.\n calc_quasi_Newton_doubles:  Calculates the doubles part of the quasi-Newton estimate.\n\n Can be inherited by models of the same level (e.g. CC3) without modification.\n\n When inherited by higher level models (e.g. CCSDT), the new_amplitudes and calc_ampeqs_norm\n routines should be overridden to account for the triples quasi-Newton estimate, amplitudes, \n and projection vector.","tags":"","loc":"module/ground_state~2.html","title":"ground_state – Fortran Program"},{"text":"Ancestors: ccsd_class Omega submodule (CCSD)\nWritten by Sarai D. Folkestad and Eirik F. Kjønstad, Apr 2017\n\n\nContains the following family of procedures of the CCSD class:\n\ninitialize_omega: allocates the projection vector (omega1, omega2)\n                      and sets it to zero.\n\nconstruct_omega:  constructs the projection vector (omega1, omega2) \n                      for the current amplitudes (t1am, t2am) for the\n                      wavefunction object wf. The routine assumes that\n                      the projection vector is allocated.\n\nomega_a1:         adds A1 term to omega1\nomega_b1:         adds B1 term to omega1\nomega_c1:         adds C1 term to omega1\nomega_d1:         adds D1 term to omega1\n\nomega_a2:         adds A2 term to omega2\nomega_b2:         adds B2 term to omega2\nomega_c2:         adds C2 term to omega2\nomega_d2:         adds D2 term to omega2\nomega_e2:         adds E2 term to omega2","tags":"","loc":"module/omega.html","title":"omega – Fortran Program"},{"text":"Uses: input_output input_reader hf_class ccs_class ccsd_class eT - a coupled cluster program                                \n     Written by Eirik F. Kjønstad and Sarai D. Folkestad, May 2017 Variables ccsd_wf wf method unit_input Variables Type Attributes Name Initial type( ccsd ), allocatable, target :: ccsd_wf class( hf ), pointer :: wf => null() character(len=40) :: method integer(kind=i15) :: unit_input = -1","tags":"","loc":"program/et_program.html","title":"eT_program – Fortran Program"}]}