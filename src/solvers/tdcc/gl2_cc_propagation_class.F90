!
!
!  eT - a coupled cluster program
!  Copyright (C) 2016-2022 the authors of eT
!
!  eT is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
!
!  eT is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with this program. If not, see <https://www.gnu.org/licenses/>.
!
!
module gl2_cc_propagation_class
!
!!
!! gl2 CC propagation solver class
!! Written by Andreas Skeidsvoll, Jan 2019
!!
!! Makes an Gauss-Legendre 2 solver by letting the propagation solver do Gauss-Legendre 2 steps.
!!
!! Initial guesses are used to accelerate the solution of equations taking part in implicit
!! integration methods. The guesses at given time step are generated by using the solution from the
!! previous time step. The method used is described in Section VIII.6.1 (A) in Hairer et. al.,
!! Geometric Numerical Integration.
!!
!
   use parameters
   use butcher_tables
   use continuous_output_coefficients
   use memory_manager_class, only: mem
   use global_out, only: output
   use ccs_class, only: ccs
   use electric_field_class, only: electric_field
   use cc_propagation_class, only: cc_propagation
!
   implicit none
!
   type, extends(cc_propagation) :: gl2_cc_propagation
!
!     Initial guess used to accelerate the convergence of equations in implicit methods, see
!     Section VIII.6.1 (A) in Hairer et. al., Geometric Numerical Integration.
!
      complex(dp), dimension(:), allocatable :: z1_guess
!
   contains
!
      procedure :: step => gl2_step
!
      procedure :: initializations => initializations_gl2_cc_propagation
!
      final :: destructor_gl2_cc_propagation
!
   end type gl2_cc_propagation
!
!
   interface gl2_cc_propagation
!
      procedure :: new_gl2_cc_propagation
!
   end interface gl2_cc_propagation
!
!
contains
!
!
   function new_gl2_cc_propagation(wf) result(solver)
!!
!!    New gl2 CC propagation
!!    Written by Andreas Skeidsvoll, Sep 2019
!!
      implicit none
!
      class(ccs) :: wf
      type(gl2_cc_propagation) :: solver
!
      solver%tag = 'gl2'
      solver%name_ = 'Gauss-Legendre 2 coupled cluster propagation solver'
!
      call solver%new_cc_propagation(wf)
!
   end function new_gl2_cc_propagation
!
!
   subroutine initializations_gl2_cc_propagation(solver)
!!
!!    Initializations 
!!    Written by Andreas Skedsvoll, Sep 2019
!!
!!    Allocates z1 guess and sets it to zero.
!!
!!    Moved from constructor, Eirik F. Kj√∏nstad, Jan 2020.
!!
      implicit none 
!
      class(gl2_cc_propagation), intent(inout) :: solver 
!
      call mem%alloc(solver%z1_guess, solver%vector_length)
      solver%z1_guess = zero_complex      
!
   end subroutine initializations_gl2_cc_propagation
!
!
   subroutine destructor_gl2_cc_propagation(solver)
!!
!!    Destructor
!!    Written by Andreas Skeidsvoll, Oct 2018
!!
!!    Deallocates arrays.
!!
      implicit none
!
      type(gl2_cc_propagation), intent(inout) :: solver
!
      if (allocated(solver%z1_guess)) call mem%dealloc(solver%z1_guess, solver%vector_length)
!
   end subroutine destructor_gl2_cc_propagation
!
!
   subroutine gl2_step(solver, wf, field, ti, dt, ui, uf, n)
!!
!!    gl2 step
!!    Written by Andreas Skeidsvoll, Mar 2019
!!
!!    Takes one forward gl2 step
!!
      implicit none
!
      class(gl2_cc_propagation), intent(inout) :: solver
      class(ccs), intent(inout) :: wf
      class(electric_field), intent(inout) :: field
!
      real(dp), intent(in) :: dt
      real(dp), intent(in) :: ti
!
      integer, intent(in) :: n
!
      complex(dp), dimension(n), intent(in) :: ui
      complex(dp), dimension(n), intent(out) :: uf
!
      complex(dp), dimension(:), allocatable :: ddt_u1, z1, z1_next
!
      integer :: i = 0
!
      logical :: converged
!
      call mem%alloc(ddt_u1, n)
      call mem%alloc(z1, n)
      call mem%alloc(z1_next, n)
!
!     Get guess of z vectors
!
      call zcopy(n, solver%z1_guess, 1, z1, 1)
!
      converged = .false.
!
!     Iterate until convergence
!
      i = 0
!
      do
!
!        Construct derivative of the first stage
!
         call solver%update_field_and_wavefunction(wf, field, ti+c1_gl2*dt, ui+z1)
         call wf%construct_complex_time_derivative(ddt_u1)
!
         if (converged) exit
         i = i + 1
!
!        Construct first z vector
!
!        z1_next = dt*a11_gl2*ddt_u1
!
         call zcopy(n, ddt_u1, 1, z1_next, 1)
         call zdscal(n, dt*a11_gl2, z1_next, 1)
!
!        Determine whether convergence is reached or not
!
         if ((norm2(real(z1_next-z1))  .le. solver%implicit_threshold) &
             .and. (norm2(aimag(z1_next-z1)) .le. solver%implicit_threshold)) then
!
            converged = .true.
!
         endif
! 
!        Update z vectors
!
         call zcopy(n, z1_next, 1, z1, 1)
!
      enddo
!
      call output%printf('n', 'GL2 iterations: (i6)', ints=[i], fs='(t3,a)')
!
      call mem%dealloc(z1, n)
      call mem%dealloc(z1_next, n)
!
!     Use the derivative of the single stage to estimate the solution uf at time t = ti + dt.
!
!     uf = ui + dt*b1_gl2*ddt_u1
!
      call zcopy(n, ui, 1, uf, 1)
      call zaxpy(n, cmplx(dt*b1_gl2, zero, dp), ddt_u1, 1, uf, 1)
!
!     Calculate guess of next z vectors
!
!     solver%z1_guess = ui - uf + dt*beta11_gl2*ddt_u1
!
      call zcopy(n, ui, 1, solver%z1_guess, 1)
      call zaxpy(n, -one_complex, uf, 1, solver%z1_guess, 1)
      call zaxpy(n, cmplx(dt*beta11_gl2, zero, dp), ddt_u1, 1, solver%z1_guess, 1)
!
      call mem%dealloc(ddt_u1, n)
!
   end subroutine gl2_step
!
!
end module gl2_cc_propagation_class