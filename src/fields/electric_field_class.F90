!
!
!  eT - a coupled cluster program
!  Copyright (C) 2016-2019 the authors of eT
!
!  eT is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
!
!  eT is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with this program. If not, see <https://www.gnu.org/licenses/>.
!
!
module electric_field_class
!
!!
!! Classical electric field class
!! Written by Andreas Skeidsvoll, May 2019
!!
!! Module containing the type electric_field, of which objects can be generated by calling
!! new_electric_field(). These objects are used for storing information about, and returning the
!! value of, a classical time-dependent electric field in the dipole approximation. The user can
!! specify an arbitrary number of pulses, with corresponding parameters, in the electric field
!! section of the input file. The returned value of the field at a given time will correspond
!! to the sum of the electric field contributions from each of the pulses at this time.
!!
!
   use parameters
!
   use memory_manager_class, only: mem
   use global_out, only: output
   use global_in, only: input
!
   implicit none
!
   type :: electric_field
!
      real(dp), dimension(3) :: vector
!
!     Variables for arbitrary pulses
!
      integer :: n_pulses
!
      integer, dimension(:), allocatable :: envelope, repetition
!
      real(dp), dimension(:), allocatable :: x_polarization, y_polarization, z_polarization, tc, &
                                             angfreqc, peak_strength, phase_shift, width,        &
                                             separation
!
   contains
!
      procedure :: cleanup                   => cleanup_electric_field
!
      procedure :: read_settings             => read_settings_electric_field
      procedure :: update                    => update_electric_field
!
      procedure, nopass :: sine_envelope     => sine_envelope_electric_field
      procedure, nopass :: gaussian_envelope => gaussian_envelope_electric_field
!
   end type electric_field
!
!
   interface electric_field
!
      procedure :: new_electric_field
!
   end interface electric_field
!
!
contains
!
!
   function new_electric_field() result(field)
!!
!!    New
!!    Written by Andreas Skeidsvoll, May 2019 
!!
!!    Generate a new electric field object.
!!
      implicit none
!
      type(electric_field) :: field
!
      field%n_pulses = 0
!
      call field%read_settings()
!
      field%vector = zero
!
   end function new_electric_field
!
!
   subroutine cleanup_electric_field(field)
!!
!!    Cleanup 
!!    Written by Andreas Skeidsvoll and Alice Balbi, May 2019
!!
!!    Clean up the electric field object
!!
      implicit none
!
      class(electric_field) :: field 
!
      if (field%n_pulses .ne. 0) then
!
         call mem%dealloc(field%envelope, field%n_pulses)
         call mem%dealloc(field%x_polarization, field%n_pulses)
         call mem%dealloc(field%y_polarization, field%n_pulses)
         call mem%dealloc(field%z_polarization, field%n_pulses)
         call mem%dealloc(field%tc, field%n_pulses)
         call mem%dealloc(field%width, field%n_pulses)
         call mem%dealloc(field%angfreqc, field%n_pulses)
         call mem%dealloc(field%peak_strength, field%n_pulses)
         call mem%dealloc(field%phase_shift, field%n_pulses)
         call mem%dealloc(field%repetition, field%n_pulses)
         call mem%dealloc(field%separation, field%n_pulses)
!
      endif
!
   end subroutine cleanup_electric_field
!
!
   subroutine read_settings_electric_field(field)
!!
!!    Read settings
!!    Written by Andreas Skeidsvoll and Alice Balbi, May 2019 
!!
!!    Read the settings in the section 'electric field'. The settings give the parameters
!!    necessary for specifying an arbitrary number of (possibly repeated) single electric field
!!    pulses. The subroutine checks, in the case of single pulses, that all parameters are given
!!    for each of the pulses. The settings are given as:
!!
!!    name of setting: {keyword for pulse 1, keyword for pulse 2, ...}
!!
!!    Settings:
!!
!!    envelope:        1 for Gaussian envelope, 2 for sine squared envelope
!!    x polarization:  x component of the polarization vector
!!    y polarization:  y component of the polarization vector
!!    z polarization:  z component of the polarization vector
!!    central time:    central time/maxima of both Gaussian and sine squared envelopes
!!    width:           Gaussian RMS width/standard deviation for Gaussian envelope,
!!                     half period (truncated outside this) for sine squared envelope
!!    central angfreq: central angular frequency/frequency of the carrier wave
!!    phase shift:     (Carrier-envelope) phase shift, given as the shift between the maxima
!!                     of the carrier and the central time of the envelope
!!    repetition:      number of repetitions of given pulse (default is 1)
!!    separation:      temporal separation between each of the repeated pulses (needed only when
!!                     the number of repetitions is greater than one)
!!
      implicit none
!
      class(electric_field) :: field
!
      logical :: separation_input
!
      integer :: n_envelopes, n_x_polarizations, n_y_polarizations, n_z_polarizations, &
                 n_central_times, n_widths, n_central_angfreqs, n_peak_strengths, n_phase_shifts, &
                 n_repetitions, n_separations, i
!
!     Read settings for an arbitrary number of pulses to arrays
!
      separation_input      = .false.
      n_envelopes           = 0 
      n_x_polarizations     = 0
      n_y_polarizations     = 0
      n_z_polarizations     = 0
      n_central_times       = 0
      n_widths              = 0
      n_central_angfreqs    = 0
      n_peak_strengths      = 0
      n_phase_shifts        = 0
      n_separations         = 0
      n_repetitions         = 0
!
      if (input%requested_keyword_in_section('envelope', 'electric field')) &
         n_envelopes = input%get_n_elements_for_keyword_in_section('envelope', 'electric field')
!
      if (input%requested_keyword_in_section('x polarization', 'electric field'))          &
         n_x_polarizations = input%get_n_elements_for_keyword_in_section('x polarization', &
                                                                         'electric field')
!
      if (input%requested_keyword_in_section('y polarization', 'electric field'))          &
         n_y_polarizations = input%get_n_elements_for_keyword_in_section('y polarization', &
                                                                         'electric field')
!
      if (input%requested_keyword_in_section('z polarization', 'electric field'))          &
         n_z_polarizations = input%get_n_elements_for_keyword_in_section('z polarization', &
                                                                         'electric field')
!
      if (input%requested_keyword_in_section('central time', 'electric field'))        &
         n_central_times = input%get_n_elements_for_keyword_in_section('central time', &
                                                                       'electric field')
!
      if (input%requested_keyword_in_section('width', 'electric field')) &
         n_widths = input%get_n_elements_for_keyword_in_section('width', 'electric field')
!
      if (input%requested_keyword_in_section('central angular frequency', 'electric field')) &
         n_central_angfreqs =                                                                &
            input%get_n_elements_for_keyword_in_section('central angular frequency',         &
                                                        'electric field')
!
      if (input%requested_keyword_in_section('peak strength', 'electric field'))         &
         n_peak_strengths = input%get_n_elements_for_keyword_in_section('peak strength', &
                                                                        'electric field')
!
      if (input%requested_keyword_in_section('phase shift', 'electric field'))       &
         n_phase_shifts = input%get_n_elements_for_keyword_in_section('phase shift', &
                                                                      'electric field')
!
      if (input%requested_keyword_in_section('repetition', 'electric field'))      &
         n_repetitions = input%get_n_elements_for_keyword_in_section('repetition', &
                                                                     'electric field')
!
      if (input%requested_keyword_in_section('separation', 'electric field'))      &
         n_separations = input%get_n_elements_for_keyword_in_section('separation', &
                                                                     'electric field')
!
!     Check if the arrays of pulse parameters have the same lengths, sets n_pulses to this length if
!     true
!
      if ((n_envelopes .eq. n_x_polarizations)        &
          .and. (n_envelopes .eq. n_y_polarizations)  &
          .and. (n_envelopes .eq. n_z_polarizations)  &
          .and. (n_envelopes .eq. n_central_times)    &
          .and. (n_envelopes .eq. n_widths)           &
          .and. (n_envelopes .eq. n_central_angfreqs) &
          .and. (n_envelopes .eq. n_peak_strengths)   &
          .and. (n_envelopes .eq. n_phase_shifts))    then
!
         field%n_pulses = n_envelopes
!
      else
!
         call output%error_msg('the arrays of pulse parameters need to have the same lengths.')
!
      endif
!
      if ((n_repetitions .ne. 0) .and. (n_repetitions .ne. field%n_pulses)) then
!
         call output%error_msg('the array of repetitions was specified, but the length did not ' &
                                // 'match the number of specified pulses.')
!
      endif
!
      if ((n_separations .ne. 0) .and. (n_separations .ne. field%n_pulses)) then
!
         call output%error_msg('the array of separations was specified, but the length did not ' &
                               // 'match the number of specified pulses.')
!
      endif
!
      if (field%n_pulses .ne. 0) then
!
         call mem%alloc(field%envelope, field%n_pulses)
         call mem%alloc(field%x_polarization, field%n_pulses)
         call mem%alloc(field%y_polarization, field%n_pulses)
         call mem%alloc(field%z_polarization, field%n_pulses)
         call mem%alloc(field%tc, field%n_pulses)
         call mem%alloc(field%width, field%n_pulses)
         call mem%alloc(field%angfreqc, field%n_pulses)
         call mem%alloc(field%peak_strength, field%n_pulses)
         call mem%alloc(field%phase_shift, field%n_pulses)
         call mem%alloc(field%repetition, field%n_pulses)
         call mem%alloc(field%separation, field%n_pulses)
!
         field%repetition = 1
!
         call input%get_array_for_keyword_in_section('envelope', 'electric field', &
                                                     field%n_pulses, field%envelope)
         call input%get_array_for_keyword_in_section('x polarization', 'electric field', &
                                                     field%n_pulses, field%x_polarization)
         call input%get_array_for_keyword_in_section('y polarization', 'electric field', &
                                                     field%n_pulses, field%y_polarization)
         call input%get_array_for_keyword_in_section('z polarization', 'electric field', &
                                                     field%n_pulses, field%z_polarization)
         call input%get_array_for_keyword_in_section('central time', 'electric field', &
                                                     field%n_pulses, field%tc)
         call input%get_array_for_keyword_in_section('width', 'electric field', field%n_pulses, &
                                                     field%width)
         call input%get_array_for_keyword_in_section('central angular frequency',      &
                                                     'electric field', field%n_pulses, &
                                                     field%angfreqc)
         call input%get_array_for_keyword_in_section('peak strength', 'electric field', &
                                                     field%n_pulses, field%peak_strength)
         call input%get_array_for_keyword_in_section('phase shift', 'electric field', &
                                                     field%n_pulses, field%phase_shift)
!
         if (input%requested_keyword_in_section('separation', 'electric field')) then
            call input%get_array_for_keyword_in_section('separation', 'electric field', &
                                                        field%n_pulses, field%separation)
            separation_input = .true.
         endif
!
         if (input%requested_keyword_in_section('repetition', 'electric field')) then
            call input%get_array_for_keyword_in_section('repetition', 'electric field', &
                                                        field%n_pulses, field%repetition)                                                                                 
         endif
!
         do i = 1, field%n_pulses
! 
            if (field%repetition(i) .lt. 0) then
               call output%error_msg('the number of repetitions have to be positive.')
            endif
!
            if ((field%repetition(i) .gt. 1) .and. (.not. separation_input)) then
               call output%error_msg('separations has to be specified for repeated pulses.')
            endif
!
         enddo
!
      endif
!
   end subroutine read_settings_electric_field
!
!
   subroutine update_electric_field(field, t)
!!
!!    Update field
!!    Written by Alice Balbi and Andreas Skeidsvoll, May 2019
!!
!!    Updates the value of the electric field (field%vector) to the value at the given time t
!!
      implicit none
!
      class(electric_field), intent(inout) :: field
!
      real(dp), intent(in) :: t
!
      integer :: i,j
!
      real(dp) :: envelope, tc, field_strength
!
      field%vector = zero
!
      do i = 1, field%n_pulses
!
         do j = 1, field%repetition(i)
!
            tc = field%tc(i) + (j-1)*field%separation(i)
!
            if (field%envelope(i) == 1) then
!
               call field%gaussian_envelope(t, tc, field%width(i), envelope)
!
            elseif (field%envelope(i) == 2) then
!
               call field%sine_envelope(t, tc, field%width(i), envelope)
!
            else
!
               call output%error_msg('one of the specified pulse shapes does not exist.')
!
            endif
!
!           Cosine carrier wave modulated by the envelope of the given pulse
!
            field_strength = field%peak_strength(i) &
                             *cos(field%angfreqc(i)*(t-tc)+field%phase_shift(i))*envelope
!
            field%vector(1) = field%vector(1) + field%x_polarization(i)*field_strength
            field%vector(2) = field%vector(2) + field%y_polarization(i)*field_strength
            field%vector(3) = field%vector(3) + field%z_polarization(i)*field_strength
!
         enddo
!
      enddo
!
   end subroutine update_electric_field
!
!
   subroutine sine_envelope_electric_field(t, tc, width, envelope)
!!
!!    Sine envelope
!!    Written by Andreas Skeidsvoll, Jan 2019
!!
!!    Returns the value of a sine squared envelope, truncated outside tc ± width/two
!!
      implicit none
!
      real(dp), intent(in) :: t, tc, width
      real(dp), intent(out) :: envelope
!
      if ((t .ge. tc-width/two) .and. (t .le. tc+width/two)) then
         envelope = sin(four*atan(one)*(t - (tc-width/two))/width)**2
      else
         envelope = zero
      endif
!
   end subroutine sine_envelope_electric_field
!
!
   subroutine gaussian_envelope_electric_field(t, tc, width, envelope)
!!
!!    Gaussian envelope
!!    Written by Andreas Skeidsvoll and Alice Balbi, Jan 2019
!!
!!    Returns the value of a Gaussian envelope, truncated outside tc ± truncation_factor*width

      implicit none
!
      real(dp), intent(in) :: t, tc, width
      real(dp), intent(out) :: envelope
!
      real(dp) :: truncation_factor
!
      truncation_factor = 8.0_dp
!
      if ((t .ge. tc-truncation_factor*width) .and. (t .le. tc+truncation_factor*width)) then
         envelope = exp(-((t - tc)**2)/(two*width**2))
      else
         envelope = zero
      endif
!
   end subroutine gaussian_envelope_electric_field
!
!
end module electric_field_class
