!
!
!  eT - a coupled cluster program
!  Copyright (C) 2016-2022 the authors of eT
!
!  eT is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
!
!  eT is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with this program. If not, see <https://www.gnu.org/licenses/>.
!
!
module td_engine_class
!
!!
!! Coupled cluster time dependent engine class module
!! Written by Alice Balbi and Andreas Skeidsvoll, Oct 2018
!!
!! Module containing the type td_engine, of which engine objects can be generated by calling
!! new_td_engine(). The engine objects are first used to generate ground state coupled cluster
!! wavefunction objects. If specified in the input file, the engine objects will then generate
!! extended cc_propagation solver objects, and use these to solve the time-dependent
!! coupled cluster equations through interaction with wavefunction and electric_field objects. If
!! specified in the input file, the engine objects will then generate complex_fft solver objects,
!! and use them to read and process time series files.
!!
!
   use global_in,       only: input
   use global_out,      only: output
   use gs_engine_class, only: gs_engine
   use ccs_class,       only: ccs
   use timings_class,   only: timings
   use task_list_class, only: task_list
   use kinds
   use memory_manager_class, only: mem
!
   type, extends(gs_engine) :: td_engine
!
      logical :: propagation, fft_dipole_moment, fft_electric_field
!
      character(len=200) :: integrator
!
   contains
!
      procedure :: run                   => run_td_engine
!
      procedure :: read_settings         => read_settings_td_engine
!
      procedure :: do_propagation        => do_propagation_td_engine
!
      procedure :: do_fft_dipole_moment  => do_fft_dipole_moment_td_engine
      procedure :: do_fft_electric_field => do_fft_electric_field_td_engine
!
      procedure :: do_td_visualization   => do_td_visualization_td_engine
!
      procedure :: set_printables        => set_printables_td_engine
!
   end type td_engine
!
!
   interface td_engine
!
      procedure :: new_td_engine
!
   end interface td_engine
!
!
contains
!
!
   function new_td_engine(wf) result(engine)
!!
!!    New td engine
!!    Written by Alice Balbi and Andreas Skeidsvoll, Oct 2018
!!
!!    Generates a new time dependent engine object. Sets the default settings for the engine, and
!!    replaces these with user defined settings if specified in the input file.
!!
      use citation_printer_class, only: eT_citations
!
      implicit none
!
!     Needed for defaults and sanity checks
      class(ccs), intent(in)       :: wf
!
      type(td_engine) :: engine
!
!     Set defaults
!
      if (wf%name_ .eq. 'ccsd(t)') then
!
         call output%error_msg("TD (a0) makes no sense", &
                               chars=[wf%name_])
!
      end if
!
      call engine%set_default_gs_algorithm(wf)
      call engine%set_default_multipliers_algorithm(wf)
!
      engine%integrator            = 'rk4'
!
      engine%propagation        = .false.
      engine%fft_dipole_moment  = .false.
      engine%fft_electric_field = .false.
      engine%ri                 = .false.
!
      call engine%read_settings()
!
      call engine%set_printables()
!
      engine%timer = timings(trim(engine%name_))
      call engine%timer%turn_on()
!
      call eT_citations%add("Time-dependent CC")
!
   end function new_td_engine
!
!
   subroutine read_settings_td_engine(engine)
!!
!!    Read settings
!!    Written by Andreas Skeidsvoll, May 2019
!!
!!    Reads settings used in the engine. Ground state settings are described in gs_engine_class.
!!
!!    Settings:
!!
!!    solver cc propagation section:
!!    integrator: first order differential equation solver to be used for the propagation. The
!!                options are euler (Euler method), rk4 (fourth order Runge-Kutta method), gl2
!!                (second order Gauss-Legendre mehtod), gl4 (fourth order Gauss-Legendre method),
!!                gl6 (sixth order Gauss-Legendre method).
!!
!!    cc td section:
!!    propagation:        whether the propagation is requested or not
!!    fft dipole moment:  whether the fast Fourier transform of the dipole moment is requested or
!!                        not
!!    fft electric field: whether the fast Fourier transform of the electric field is requested or
!!                        not
!!
      implicit none
!
      class(td_engine) :: engine
!
      call engine%gs_engine%read_settings()
!
      call input%get_keyword('integrator', 'solver cc propagation', engine%integrator)
!
      if (input%is_keyword_present('propagation','cc td')) engine%propagation = .true.
      if (input%is_keyword_present('fft dipole moment','cc td')) &
         engine%fft_dipole_moment = .true.
      if (input%is_keyword_present('fft electric field','cc td')) &
         engine%fft_electric_field = .true.
!
   end subroutine read_settings_td_engine
!
!
   subroutine run_td_engine(engine, wf)
!!
!!    Run
!!    Written by Alice Balbi and Andreas Skeidsvoll, Oct 2018
!!
!!    Prints the banner of the engine, computes the ground state coupled cluster wavefunction and
!!    determines the corresponding multipliers. Then, the wavefunction is made complex in order to
!!    allow time propagation. If specified in the input file, the propagation of the wavefunction
!!    is done. If specified in the input file, the fast Fourier transform of the dipole moment
!!    and/or the electric field is computed.
!!
      implicit none
!
      class(td_engine) :: engine
      class(ccs) :: wf
!
      call engine%print_banner(wf)
!
      call engine%tasks%print_('cholesky')
!
      call engine%do_integral_decomposition(wf)
!
      call engine%tasks%print_('mo preparations')
!
      call wf%mo_preparations()
!
!     Determine ground state
!
      call engine%do_ground_state(wf)
!
!     Determine multipliers
!
      call engine%do_multipliers(wf)
!
!     Make wavefunction complex
!
      call wf%make_complex()
!
!     Do propagation
!
      if (engine%propagation) call engine%do_propagation(wf)
!
!     Do complex FFT of the time dependent dipole moment
!
      if (engine%fft_dipole_moment) call engine%do_fft_dipole_moment()
!
!     Do complex FFT of the time dependent electric field
!
      if (engine%fft_electric_field) call engine%do_fft_electric_field()
!
!     Plot density matrices
!
      if (engine%plot_density) call engine%do_td_visualization(wf)
!
!     Deallocate complex arrays
!
      call wf%cleanup_complex()
!
   end subroutine run_td_engine
!
!
   subroutine do_propagation_td_engine(engine, wf)
!!
!!    Do propagation
!!    Written by Alice Balbi and Andreas Skeidsvoll, Oct 2018
!!
!!    Performs the propagation of a time dependent coupled cluster wavefunction interacting with
!!    an external electric field by letting extended cc_propagation objects act on wavefunction
!!    and electric_field objects. If specified in the input file, time series containing time
!!    dependent properties of the wavefunction are written to files.
!!
      use cc_propagation_class, only: cc_propagation
      use euler_cc_propagation_class, only: euler_cc_propagation
      use rk4_cc_propagation_class, only: rk4_cc_propagation
      use gl2_cc_propagation_class, only: gl2_cc_propagation
      use gl4_cc_propagation_class, only: gl4_cc_propagation
      use gl6_cc_propagation_class, only: gl6_cc_propagation
!
      use electric_field_class, only: electric_field
!
      implicit none
!
      class(td_engine), intent(in) :: engine
      class(ccs), intent(inout) :: wf
!
      type(electric_field) :: field
!
      class(cc_propagation), allocatable :: cc_propagation_solver
!
      call engine%tasks%print_('propagation')
!
!     Prepare electric field object
!
      field = electric_field()
!
!     Do propagation from CC ground state
!
      if (trim(engine%integrator) == 'euler') then
!
         cc_propagation_solver = euler_cc_propagation(wf)
!
      elseif (trim(engine%integrator) == 'rk4') then
!
         cc_propagation_solver = rk4_cc_propagation(wf)
!
      elseif (trim(engine%integrator) == 'gl2') then
!
         cc_propagation_solver = gl2_cc_propagation(wf)
!
      elseif (trim(engine%integrator) == 'gl4') then
!
         cc_propagation_solver = gl4_cc_propagation(wf)
!
      elseif (trim(engine%integrator) == 'gl6') then
!
         cc_propagation_solver = gl6_cc_propagation(wf)
!
      else
!
         call output%error_msg('asked for propagation, but the integrator was not specified.')
!
      endif
!
      call cc_propagation_solver%initializations()
      call cc_propagation_solver%run(wf, field)
      call cc_propagation_solver%cleanup(wf, field)
!
      call field%cleanup()
!
   end subroutine do_propagation_td_engine
!
!
   subroutine do_fft_dipole_moment_td_engine(engine)
!!
!!    Do FFT of dipole moment
!!    Written by Alice Balbi and Andreas Skeidsvoll, Oct 2018
!!
!!    Performs the complex fast Fourier transform of a dipole moment time series read from the file
!!    cc_propagation_dipole_moment. This file can be created by the propagation_solver object.
!!
      use complex_fft_class, only: complex_fft
!
      implicit none

      class(td_engine) :: engine
!
      class(complex_fft), allocatable :: fft_solver_dipole_moment
!
      call engine%tasks%print_('FFT dipole')
!
      fft_solver_dipole_moment = complex_fft('dipole moment', 'cc_propagation_dipole_moment')
      call fft_solver_dipole_moment%run()
      call fft_solver_dipole_moment%cleanup()
!
   end subroutine do_fft_dipole_moment_td_engine
!
!
   subroutine do_fft_electric_field_td_engine(engine)
!!
!!    Do FFT of electric field
!!    Written by Alice Balbi and Andreas Skeidsvoll, Oct 2018
!!
!!    Performs the complex fast Fourier transform of a electric field time series read from the
!!    file cc_propagation_electric_field. This file can be created by the propagation_solver
!!    object.
!!
      use complex_fft_class, only: complex_fft
!
      implicit none
!
      class(td_engine) :: engine
      class(complex_fft), allocatable :: fft_solver_electric_field

      call engine%tasks%print_('FFT electric field')
!
      fft_solver_electric_field = complex_fft('electric field', 'cc_propagation_electric_field')
      call fft_solver_electric_field%run()
      call fft_solver_electric_field%cleanup()
!
   end subroutine do_fft_electric_field_td_engine
!
!
   subroutine set_printables_td_engine(engine)
!!
!!    Set printables
!!    Written by Andreas Skeidsvoll, Sep 2019
!!
!!    Sets the information that is printed in the banner of the engine in the output file.
!!
!
      use string_utilities, only: convert_to_uppercase
!
      implicit none
!
      class(td_engine) :: engine
!
      engine%name_ = 'Time dependent coupled cluster engine'
!
      engine%description = 'Calculates the time dependent CC wavefunction'
      engine%tag = 'time dependent'
!
!
!     Prepare the list of tasks
!
      engine%tasks = task_list()
!
      if (engine%ri) then
!
         call engine%tasks%add(label='ri', &
                               description='RI approximation of the electron &
                                           &repulsion integrals')
!
      else
         call engine%tasks%add(label='cholesky', &
                               description='Cholesky decomposition of the electron &
                                           &repulsion integrals')
      endif
!
      call engine%tasks%add(label='mo preparations',                             &
                            description='Preparation of MO basis and integrals')
!
      call engine%tasks%add(label='gs solver',                                &
                            description='Calculation of the ground state ('// &
                           trim((engine%gs_algorithm))//' algorithm)')
!
      call engine%tasks%add(label='multipliers solver',                       &
                            description='Calculation of the multipliers ('    &
                            //trim((engine%multipliers_algorithm))&
                            //' algorithm)')
!
      if (engine%propagation) then
!
         call engine%tasks%add(label='propagation',                    &
                            description='Propagation from the ground state')
!
      endif
!
      if (engine%fft_dipole_moment) then
!
         call engine%tasks%add(label='FFT dipole',                      &
                            description='FFT of the time dependent dipole moment')
!
      endif
!
      if (engine%fft_electric_field) then
!
         call engine%tasks%add(label='FFT electric field',              &
                            description='FFT of the time dependent electric field')
!
      endif
!
      if (engine%plot_density) then
!
         call engine%tasks%add(label='plotting', description='Plot density')
!
      endif
!
   end subroutine set_printables_td_engine
!
!
   subroutine do_td_visualization_td_engine(engine, wf)
!!
!!    Do visualization
!!    Written by Andreas Skeidsvoll, Dec 2019
!!
!!    Reads the electron density matrices listed in cc_propagation_density_matrix_real and
!!    cc_propagation_density_matrix_imaginary, and writes the corresponding electron densities to
!!    file.
!!
!!    Based on do_visualization_gs_engine by Tor S. Haugland, Nov 2019
!!
      use visualization_class, only : visualization
      use array_utilities, only: symmetric_sandwich_right_transposition
      use sequential_file_class, only: sequential_file
!
      implicit none
!
      class(td_engine) :: engine
      class(ccs) :: wf
!
      type(visualization), allocatable :: plotter
!
      real(dp), dimension(:,:), allocatable :: mo_density, density
!
      type(sequential_file) :: density_matrix_real_file, density_matrix_imaginary_file
!
      integer :: file_count, iostat
!
      character(len=200) :: file_count_string
!
      call engine%tasks%print_('plotting')
!
!     Initialize the plotter
!
      plotter = visualization(wf%ao)
      call plotter%initialize(wf%ao)
!
      call mem%alloc(mo_density, wf%n_mo, wf%n_mo)
      call mem%alloc(density, wf%ao%n, wf%ao%n)
!
!     Plot real electron densities using density matrices on file
!
      density_matrix_real_file = sequential_file('cc_propagation_density_matrix_real', 'formatted')
      call density_matrix_real_file%open_('read','rewind')
!
      file_count = 0
!
      do
!
         call density_matrix_real_file%read_(mo_density, wf%n_mo*wf%n_mo, io_stat=iostat)
!
         if (iostat .ne. 0) exit
!
!        D_alpha,beta = sum_pq  D_pq C_alpha,p C_beta,q
!
         call symmetric_sandwich_right_transposition(density,                 &
                                                     mo_density,              &
                                                     wf%orbital_coefficients, &
                                                     wf%ao%n,                 &
                                                     wf%n_mo)
!
!        Plot density
!
         file_count = file_count + 1
         write(file_count_string, *) file_count
!
         call plotter%plot_density(wf%ao, density, 'cc_propagation_density_matrix_real_' &
                                                       // trim(adjustl(file_count_string)))
!
      enddo
!
      call density_matrix_real_file%close_
!
!     Plot imaginary electron densities using density matrices on file
!
      density_matrix_imaginary_file = sequential_file('cc_propagation_density_matrix_imaginary', &
                                                      'formatted')
      call density_matrix_imaginary_file%open_('read','rewind')
!
      file_count = 0
!
      do
!
         call density_matrix_imaginary_file%read_(mo_density, wf%n_mo*wf%n_mo, io_stat=iostat)
!
         if (iostat .ne. 0) exit
!
!        D_alpha,beta = sum_pq  D_pq C_alpha,p C_beta,q
!
         call symmetric_sandwich_right_transposition(density,                 &
                                                     mo_density,              &
                                                     wf%orbital_coefficients, &
                                                     wf%ao%n,                 &
                                                     wf%n_mo)
!
!        Plot density
!
         file_count = file_count + 1
         write(file_count_string, *) file_count
!
         call plotter%plot_density(wf%ao, density, 'cc_propagation_density_matrix_imaginary_' &
                                                       // trim(adjustl(file_count_string)))
!
      enddo
!
      call density_matrix_imaginary_file%close_
!
      call mem%dealloc(mo_density, wf%n_mo, wf%n_mo)
      call mem%dealloc(density, wf%ao%n, wf%ao%n)
!
      call plotter%cleanup()
!
   end subroutine do_td_visualization_td_engine
!
!
end module td_engine_class
