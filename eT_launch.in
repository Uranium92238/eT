#!/usr/bin/env python3
"""
 
   eT - a coupled cluster program
   Copyright (C) 2016-2019 the authors of eT
 
   eT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
 
   eT is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.
 
   You should have received a copy of the GNU General Public License
   along with this program. If not, see <https://www.gnu.org/licenses/>.
 
"""

import os
import tempfile
import shutil
import argparse
import sys
import glob
import subprocess
import fnmatch

if sys.version < '3.5':
    sys.exit('requires python version >= 3.5')

# Kill if given negative number of OMP threads
class OMPaction(argparse.Action):
    def __call__(self, parser, namespace, value, option_string=None):
        if value < 1:
            parser.error("{0} must be greater than 0".format(option_string))
        setattr(namespace, self.dest, value)

def list_restart_files(restart_dir):

    #Determine what files are present
    rfiles =  [rfile for rfile in fnmatch.filter(os.listdir(restart_dir), '*restart_file')]
    rfiles += [rfile for rfile in fnmatch.filter(os.listdir(restart_dir), 'orbital_*')]
    rfiles += [rfile for rfile in fnmatch.filter(os.listdir(restart_dir), 'excitation_energies')]
    rfiles += [rfile for rfile in fnmatch.filter(os.listdir(restart_dir), 't')]
    rfiles += [rfile for rfile in fnmatch.filter(os.listdir(restart_dir), 'tbar')]
    rfiles += [rfile for rfile in fnmatch.filter(os.listdir(restart_dir), 'r_*')]
    rfiles += [rfile for rfile in fnmatch.filter(os.listdir(restart_dir), 'l_*')]
    rfiles += [rfile for rfile in fnmatch.filter(os.listdir(restart_dir), 'G_De_ao')]

    return rfiles


parser = argparse.ArgumentParser()
parser.add_argument('input_file', help="eT input file(s)", nargs='*', default=glob.glob("*.inp"), metavar="input file")
parser.add_argument('-of', '--output-file', help="eT output file(s)", nargs='*', default=[None])
parser.add_argument('--scratch', help="Specify scratch directory", type=str)
parser.add_argument('-ks', '--keep-scratch', help="Do not delete scratch", action="store_true")
parser.add_argument("--omp", help="Number of OpenMP threads", action=OMPaction, type=int)
parser.add_argument('-nt', "--no-timing", help="Do not copy timing.out from scratch", action='store_true')
parser.add_argument('-v', "--verbose", help="Run some print statements", action='store_true')
parser.add_argument('-bd', "--binary-dir", help="Specify location of eT executable", type=str)
parser.add_argument('-basis', "--basis-path-dir", help="Specify location of the basis directory", type=str)
parser.add_argument('-pcm', "--pcm-input-file", help="Specify PCMSolver Input File", type=str)
parser.add_argument('-i-err', '--ignore-errors', help="Continue with default behaviour if errors detected", action='store_true')

parser.add_argument('-save', '--save-restart-dir',
                    help="Directory to save restart files", type=str, nargs='?', default='off')
parser.add_argument('-load', '--load-restart-dir',
                    help="Directory(ies) to get restart files", type=str, nargs='+', default=[None])

args = parser.parse_args()

something_wrong = False

#Check if any input files were found
if (not args.input_file):
    sys.exit('Could not find any input files')

#Check that output file makes sense or set default
if (args.output_file[0]):
    if (len(args.output_file) != len(args.input_file)):
        parser.error('Number of output files must be same as input files')
else:
    args.output_file = args.output_file*len(args.input_file)

if (len(args.load_restart_dir) < len(args.input_file)):
    n = len(args.input_file) - len(args.load_restart_dir)
    args.load_restart_dir = args.load_restart_dir + n*[None]
elif (len(args.load_restart_dir) > len(args.input_file)):
    parser.error('Number of restart load directories greater than number of input files')


cwd = os.getcwd() # Get current directory

#Set the binary directory
if (args.binary_dir):
    eT_dir = os.path.abspath(args.binary_dir)
else:
    eT_dir = '${CMAKE_BINARY_DIR}' # Default binary directory set by CMake
eT_dir = os.path.abspath(eT_dir) # Use absolute path

if (args.verbose):
    print("Will use executable from", eT_dir)

#Set the Libint basis directory
if (args.basis_path_dir):
    ldd_dir = os.path.abspath(args.basis_path_dir)
    os.environ['LIBINT_DATA_PATH'] = ldd_dir
elif not 'LIBINT_DATA_PATH' in os.environ:
    ldd_dir = os.path.join('${CMAKE_SOURCE_DIR}','ao_basis')
    os.environ['LIBINT_DATA_PATH'] = ldd_dir

if (args.verbose):
    print("LIBINT_DATA_PATH (basis set folder) set to", ldd_dir)

#Set the PCMSolver input location
#([file].pcm specified in input continuum section) 
if (args.pcm_input_file):
    pcm_input_file = os.path.abspath(args.pcm_input_file)
    PCMSolver_GOPCM = os.path.split('${PCMSolver_INCLUDE_DIR}')
    PCMSolver_GOPCM = os.path.join(PCMSolver_GOPCM[0], 'bin', 'go_pcm.py')

    if (args.verbose):
        print("PCM inputfile:", pcm_input_file)
        print("Go PCM", PCMSolver_GOPCM)

executable = os.path.join(eT_dir,'eT')

if (not os.path.isfile(executable)):
    print(executable, 'is not a file')
    raise FileNotFoundError

# Make a scratch dir. Either specified by user or wherever os dumps temporary file
if args.scratch:
    scratch = os.path.abspath(args.scratch)
    os.makedirs(scratch, exist_ok=True)
else:
    tmpscratch = os.getenv('eT_SCRATCH')
    scratch = tempfile.mkdtemp(dir=tmpscratch)

if (args.save_restart_dir != 'off'):
    if (args.save_restart_dir):
        save_dir = os.path.abspath(args.save_restart_dir)
    else:
        env_save = os.getenv('eT_SAVE')
        if (env_save):
            save_dir = env_save
        else:
            save_dir = cwd


# Set OMP_NUM_THREADS in environment
if args.omp:
    os.environ['OMP_NUM_THREADS'] = str(args.omp)
    os.environ['MKL_NUM_THREADS'] = str(args.omp)

omps = os.getenv('OMP_NUM_THREADS')
if (not omps):
    omps = 'dynamic number of'
mkls = os.getenv('MKL_NUM_THREADS')

for i, (inpf,outf) in enumerate(zip(args.input_file, args.output_file)):

    # Set up name for output files
    inp_name = os.path.splitext(inpf)[0]
    if outf:
        output_file = outf
        out_name = os.path.splitext(outf)[0]
        time_file = '{0}{1}{2}'.format(out_name,'.timing','.out')
    else:
        out_name = inp_name
        output_file = '{0}{1}'.format(out_name,'.out')
        time_file = '{0}{1}{2}'.format(out_name,'.timing','.out')

    if (args.verbose):
        print()
        print("Input file:", inpf, "Output file:", output_file)

    # Set up paths for copying files back and forth
    inp_src = os.path.abspath(inpf)
    out_dest = os.path.join(cwd,output_file)
    time_dest = os.path.join(cwd,time_file)
    inp_dest = os.path.join(scratch,'eT.inp')
    out_src = os.path.join(scratch,'eT.out')
    time_src = os.path.join(scratch,'timing.out')
    if (args.pcm_input_file):
       pcm_src = os.path.abspath(pcm_input_file)
       pcm_dest = os.path.join(scratch,'pcmsolver.inp')

    # Copy files
    shutil.copyfile(inp_src,inp_dest)
    if (args.pcm_input_file):
       shutil.copyfile(pcm_src,pcm_dest)

    if (args.load_restart_dir[i]):
        load_dir = os.path.abspath(args.load_restart_dir[i])
        loadfiles = list_restart_files(load_dir)

        if (args.verbose):
            print("Copying restart files to", load_dir)

        for loadfile in loadfiles:
            loadsrc  = os.path.join(load_dir, loadfile)
            loaddest = os.path.join(scratch, loadfile)
            shutil.copyfile(loadsrc, loaddest)


    os.chdir(scratch) #Now in scratch

    if (args.verbose):
        print("Ready to run eT in", scratch, "with", omps, "threads")

    # preprocess for PCMSolver external file
    # have to use subprocess to get the module loading right
    if (args.pcm_input_file):
        PCMSolver_libpy = '${PCMSolver_PYMOD}'
        os.environ["PYTHONPATH"] = PCMSolver_libpy+':$PYTHONPATH'
        
        pcmprocess = subprocess.run('python3 ' + PCMSolver_GOPCM + ' --inp pcmsolver.inp',
                                     shell=True,
                                     stderr=subprocess.PIPE,
                                     stdout=subprocess.PIPE)
        pcmerror = pcmprocess.stdout.decode('utf8') + pcmprocess.stderr.decode('utf8') 

        if (pcmerror != ''):
            if (not args.ignore_errors):
                something_wrong = True
            print()
            print("Error message for pcm input file", pcm_input_file, ":")
            print(pcmerror)

        if (something_wrong):
            print("Stopping now")
            break
        
    # Run eT
    p = subprocess.run(executable,
                       shell=True,
                       stderr=subprocess.PIPE)

    s = p.stderr.decode('utf8') 

    if (s != ''):
        if (not args.ignore_errors):
            something_wrong = True
        print()
        print("Error message for input file ", inpf, ":")
        print(s)

    if (args.verbose):
        print("Copying output to", out_dest)

    # Copy files back
    shutil.copyfile(out_src,out_dest)
    if not args.no_timing:
        shutil.copyfile(time_src,time_dest)

    # Check if there are mo_coefficient.out files
    coeff_files = [coeff_file for coeff_file in fnmatch.filter \
                      (os.listdir(scratch), '*mo_coefficients.out')]
    for coeff_file in coeff_files:
        mo_coeff_src = os.path.join(scratch, coeff_file)
        mo_coeff_name = out_name + '_' + coeff_file
        mo_coeff_dest = os.path.join(cwd, mo_coeff_name)
        shutil.copyfile(mo_coeff_src, mo_coeff_dest)
        
    #Check if there are any .plt files    
    pltfiles = [pltfile for pltfile in fnmatch.filter(os.listdir(scratch), '*.plt')]
    for pltfile in pltfiles:
        pltsrc = os.path.join(scratch, pltfile)
        pltname = pltfile.replace('eT', out_name)
        pltdest = os.path.join(cwd, pltname)
        shutil.copyfile(pltsrc, pltdest)

    #Save restart files somewhere if requested
    if(args.save_restart_dir != 'off'):
        current_save_dir = os.path.join(save_dir,inp_name + '_restart_files')
        os.makedirs(current_save_dir, exist_ok=True)

        if (args.verbose):
            print("Copying restart files to", current_save_dir)

        savefiles = list_restart_files(scratch)
        #Copy the files
        for savefile in savefiles:
            savesrc = os.path.join(scratch, savefile)
            savedest = os.path.join(current_save_dir, savefile)
            shutil.copyfile(savesrc, savedest)
        

    os.chdir(cwd) #Now in work

    if (something_wrong):
        print("Stopping now")
        break
        

# Delete scratch
if (not args.keep_scratch and not something_wrong):
    if (args.verbose):
        print()
        print("Deleting scratch")
    shutil.rmtree(scratch)

if (something_wrong):
    raise Exception('Error message from eT')
