#!/usr/bin/env python3
"""
 
   eT - a coupled cluster program
   Copyright (C) 2016-2019 the authors of eT
 
   eT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
 
   eT is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.
 
   You should have received a copy of the GNU General Public License
   along with this program. If not, see <https://www.gnu.org/licenses/>.
 
"""

import os
import tempfile
import shutil
import argparse
import sys
import glob
import subprocess

if sys.version < '3.5':
    print('requires python version >= 3.5')
    sys.exit(1)

# Kill if given negative number of OMP threads
class OMPaction(argparse.Action):
    def __call__(self, parser, namespace, value, option_string=None):
        if value < 1:
            parser.error("{0} must be greater than 0".format(option_string))
        setattr(namespace, self.dest, value)


parser = argparse.ArgumentParser()
parser.add_argument('input_file', help="eT input file(s)", nargs='*', default=glob.glob("*.inp"), metavar="input file")
parser.add_argument('-of', '--output-file', help="eT output file(s)", nargs='*', default=[None])
parser.add_argument('--scratch', help="Specify scratch directory", type=str)
parser.add_argument('-ks', '--keep-scratch', help="Do not delete scratch", action="store_true")
parser.add_argument("--omp", help="Number of OpenMP threads", action=OMPaction, type=int)
parser.add_argument('-nt', "--no-timing", help="Do not copy timing.out from scratch", action='store_true')
parser.add_argument('-v', "--verbose", help="Run some print statements", action='store_true')
parser.add_argument('-bd', "--binary-dir", help="Specify location of eT executable", type=str)
parser.add_argument('-ldd', "--libint-data-dir", help="Specify location of Libint basis directory", type=str)
parser.add_argument('--profile', help="Copy gmon.out from scratch", action='store_true')
parser.add_argument('-i_err', '--ignore_errors', help="Continue with default behaviour if errors detected", action='store_true')
args = parser.parse_args()

something_wrong = False

#Check that output file makes sense and set default
if (args.output_file[0]):
    if (len(args.output_file) != len(args.input_file)):
        parser.error('Number of output files must be same as input files')
else:
    args.output_file = args.output_file*len(args.input_file)
        

cwd = os.getcwd() # Get current directory

#Set the binary directory
if (args.binary_dir):
    eT_dir = os.path.abspath(args.binary_dir)
else:
    eT_dir = '${CMAKE_BINARY_DIR}' # Default binary directory set by CMake
eT_dir = os.path.abspath(eT_dir) # Use absolute path

#Set the Libint basis directory
if (args.libint_data_dir):
    ldd_dir = os.path.abspath(args.libint_data_dir)
    os.environ['LIBINT_DATA_PATH'] = ldd_dir
elif not 'LIBINT_DATA_PATH' in os.environ:
    ldd_dir = os.path.join('${CMAKE_SOURCE_DIR}/basis')
    os.environ['LIBINT_DATA_PATH'] = ldd_dir

executable = os.path.join(eT_dir,'eT')

if (not os.path.isfile(executable)):
    print(executable, 'is not a file')
    raise FileNotFoundError

if (args.verbose):
    print("Will use executable from", eT_dir)

# Make a scratch dir. Either specified by user or wherever os dumps temporary file
if args.scratch:
    scratch = os.path.abspath(args.scratch)
    os.makedirs(scratch, exist_ok=True)
else:
    tmpscratch = os.getenv('eT_SCRATCH')
    scratch = tempfile.mkdtemp(dir=tmpscratch)

# Set OMP_NUM_THREADS in environment
if args.omp:
    os.environ['OMP_NUM_THREADS'] = str(args.omp)
    os.environ['MKL_NUM_THREADS'] = str(args.omp)

omps = os.getenv('OMP_NUM_THREADS')
if (not omps):
    omps = 'dynamic number of'
mkls = os.getenv('MKL_NUM_THREADS')

for (inpf,outf) in zip (args.input_file,args.output_file):

    # Set up name for output files
    if outf:
        output_file = outf
        out_name = os.path.splitext(outf)[0]
        time_file = '{0}{1}{2}'.format(out_name,'.timing','.out')
        if(args.profile):
            profile_file = '{0}{1}{2}'.format(out_name,'.profile','.out')
    else:
        inp_name = os.path.splitext(inpf)[0]
        output_file = '{0}{1}'.format(inp_name,'.out')
        time_file = '{0}{1}{2}'.format(inp_name,'.timing','.out')
        if(args.profile):
            profile_file = '{0}{1}{2}'.format(inp_name,'.profile','.out')

    if (args.verbose):
        print()
        print("Input file:", inpf, "Output file:", output_file)

    # Set up paths for copying files back and forth
    inp_src = os.path.abspath(inpf)
    out_dest = os.path.join(cwd,output_file)
    time_dest = os.path.join(cwd,time_file)
    inp_dest = os.path.join(scratch,'eT.inp')
    out_src = os.path.join(scratch,'eT.out')
    time_src = os.path.join(scratch,'timing.out')
    if(args.profile):
        profile_src = os.path.join(scratch,'gmon.out')
        profile_dest = os.path.join(cwd,profile_file)

    # Copy files
    shutil.copyfile(inp_src,inp_dest)
    os.chdir(scratch)

    if (args.verbose):
        print("Ready to run eT in", scratch, "with", omps, "threads")

    # Run eT
    p = subprocess.run(executable,
                       shell=True,
                       stderr=subprocess.PIPE)

    s = p.stderr.decode('utf8') 

    if (s != ''):
        if (not args.ignore_errors):
            something_wrong = True
        print()
        print("Error message from eT:")
        print(s)

    if (args.verbose):
        print("Copying output to", out_dest)

    # Copy files back
    shutil.copyfile(out_src,out_dest)
    if not args.no_timing:
        shutil.copyfile(time_src,time_dest)
    if(args.profile):
        shutil.copyfile(profile_src,profile_dest)
    
    os.chdir(cwd)

    if (something_wrong):
        print("Stopping now")
        break
        

# Delete scratch
if (not args.keep_scratch and not something_wrong):
    if (args.verbose):
        print()
        print("Deleting scratch")
    shutil.rmtree(scratch)
