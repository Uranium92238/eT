#
#
#  eT - a coupled cluster program
#  Copyright (C) 2016-2021 the authors of eT
#
#  eT is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  eT is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program. If not, see <https://www.gnu.org/licenses/>.
#

"""
Simple script to autogenerate complex files and interfaces in eT

Usage: call
$ python3 autogenerate_interfaces.py
in the main eT directory (where this file is found).

Written by Alice Balbi and Andreas Skeidsvoll, Sep 2019
Restructured by Sander Roet, Feb 2020
Combined in autogenerate_files.py by Alexander C. Paul, Nov 2020
Cleaned and optimized by Rolf H. Myhre, Mar 2021
"""

from re import sub, subn, findall
from pathlib import Path

# Set of modules that can be complexified.
# Add any new modules here and the script should handle the rest.
complexifiable_modules = {"packed_array_utilities_r"}


def is_submodule(file_path):
    # Checks if first non comment line in file starts with "submodule"

    with file_path.open("r", encoding="utf-8") as f:
        lines = f.readlines()

    for line in lines:
        # Skip comment lines
        if line.startswith("!"):
            continue
        # First non-comment line start with submodule
        elif line.startswith("submodule"):
            return True
        # First non-comment line does not start with submodule
        else:
            return False


def write_license(f):
    f.write(
        "!\n"
        "!\n"
        "!  eT - a coupled cluster program\n"
        "!  Copyright (C) 2016-2021 the authors of eT\n"
        "!\n"
        "!  eT is free software: you can redistribute it and/or modify\n"
        "!  it under the terms of the GNU General Public "
        "License as published by\n"
        "!  the Free Software Foundation, either version 3 "
        "of the License, or\n"
        "!  (at your option) any later version.\n"
        "!\n"
        "!  eT is distributed in the hope that it will be "
        "useful,\n"
        "!  but WITHOUT ANY WARRANTY; without even the "
        "implied warranty of\n"
        "!  MERCHANTABILITY or FITNESS FOR A PARTICULAR "
        "PURPOSE. See the\n"
        "!  GNU General Public License for more details.\n"
        "!\n"
        "!  You should have received a copy of the GNU "
        "General Public License\n"
        "!  along with this program. If not, see "
        "<https://www.gnu.org/licenses/>.\n"
    )


def create_code_to_line_map(lines):
    """
    Iterates over lines and returns two strings,
    the first with concatenated lines in case of line continuation
    and the second with the concatenated lines
    without comments and continuation symbols ("&").
    """

    full_lines = []
    code_lines = []
    for line in lines:
        full_line = line.rstrip(" ")
        code_line = line.partition("!")[0].strip()

        while code_line.endswith("&"):
            add_line = next(lines).rstrip(" ")

            full_line = full_line + add_line
            code_line = (
                f"{code_line.split('&')[0].strip()} "
                f"{add_line.split('!')[0].strip()}"
            )

        full_lines.append(full_line)
        code_lines.append(code_line)

    return full_lines, code_lines


def find_arguments(line):
    """
    Returns a list of strings that are inside parenthesis "()" in string.
    """

    # Finds the strings inside parentheses in the given line using regex
    # and returns a list of such groups
    groups = findall(r"\((.*?)\)", line)

    argument_list = []
    for group in groups:
        arguments = group.split(",")

        for argument in arguments:
            argument_list.append(argument.strip())

    return argument_list


def write_function_interface(iterator, arguments, outfile):
    """
    Loop over iterator until reaching end of function or subroutine
    and print header line (starts with "!!"), "implicit none", and
    argument declarations for arguments in argument_list.
    Iterator is generated by a zip of a list of concatenated full lines
    (with newlines), and the corresponding code line without comments and &.
    """

    for line, code_line in iterator:

        # Write header lines
        if line.startswith("!!"):
            outfile.write(line)
            continue

        # Reached implicit none
        if code_line.startswith("implicit none"):
            outfile.write(line + "!\n")
            continue

        # Write out variable declarations if they are in the argument list
        if "::" in code_line:
            after_dots = code_line.split("::")[1]
            variable = after_dots.split(",")[0].strip()

            if variable in arguments:
                outfile.write(line)
                continue

        # Reached end of subroutine
        if code_line.startswith(("end subroutine", "end function")):
            outfile.write("!\n" + line)
            break


def autogenerate_interfaces(src_dir):
    """
    Autogenerate interfaces
    Written by Alice Balbi and Andreas Skeidsvoll, Sep 2019
    Restructured by Sander Roet , Feb 2020
    Converted to use pathlib.Path and f-strings by Sander Roet, Sep 2020
    This script reads relevant Fortran files, and makes interfaces.
    Cleaned up Rolf H. Myhre, Mar 2021
    """

    # Get all .F90 files under src_dir and check if submodule
    f90_files = set(src_dir.glob("**/*.F90"))
    all_submodules = {i for i in f90_files if is_submodule(i)}

    for submodule_path in all_submodules:

        # Make a generator
        with submodule_path.open("r", encoding="utf-8") as f:
            lines = (i for i in f.readlines())

        lines, code_lines = create_code_to_line_map(lines)
        iterator = zip(lines, code_lines)

        interface_path = Path(f"{submodule_path.with_suffix('')}_interface.F90")
        with interface_path.open("w", encoding="utf-8") as interface_file:

            write_license(interface_file)

            for line, code_line in iterator:
                if code_line.startswith(("module subroutine", "module function")):

                    interface_file.write("!\n!\n" + line)

                    argument_list = find_arguments(code_line)

                    # Loop until reaching end of subroutine or function
                    write_function_interface(iterator, argument_list, interface_file)


def get_code_line(lines):
    """
    Strip away comments and concatenate lines with
    line continuation (lines ending with "&")
    """

    line = next(lines)

    code_line = line.partition("!")[0].strip()
    while (len(code_line) > 0) and (code_line[-1] == "&"):
        add_line = next(lines)
        code_line = (
            f"{code_line.split('&')[0].strip()} " f"{add_line.split('!')[0].strip()}"
        )

    return code_line


def delete_generated(src_dir):
    """
    Delete all directories starting with "generated"
    and files ending with _interface.F90
    """

    # Remove all interface files
    interface_files = set(src_dir.glob("**/*_interface.F90"))
    for f in interface_files:
        f.unlink()

    # Remove generated directories
    auto_dirs = set(src_dir.glob("**/generated*"))
    for auto_dir in auto_dirs:

        auto_files = set(auto_dir.glob("*.F90"))
        for auto_file in auto_files:
            auto_file.unlink()

        auto_dir.rmdir()


def get_complex_mod_variables(file_path):
    """
    Find all complex variables in module ending in "_complex" before "contains"
    and return them as a list
    """

    variable_list = []

    # Loop over lines in class_file until "contains"
    # If line starts with "complex(dp) and contains "_complex"
    # add the word preceding "complex" to variable list.
    mod_file = file_path.open("r", encoding="utf-8")
    with mod_file as lines:
        while True:
            try:
                line = get_code_line(lines)
            except StopIteration:
                break

            if line.startswith("contains"):
                break
            elif len(line) > 0:
                if line.startswith("complex(dp)") and "_complex" in line:
                    variable_list.append(line.split("_complex")[0].split()[-1])

    mod_file.close()

    return variable_list


def get_complex_class_procedures(file_path):
    """
    Find all procedures ending in "_complex" in a module before "end type"
    and return a list of the procedures and the corresponding procedure pointers
    """

    pointer_list = []
    procedure_list = []

    # Loop over lines in class_file until "end type"
    # If the first string in line is "procedure" and the third ends with "_complex",
    # add pointer and procedure to the list
    class_file = file_path.open("r", encoding="utf-8")
    with class_file as lines:
        while True:
            try:
                line = get_code_line(lines)
            except StopIteration:
                break

            if line.startswith("end type"):
                break

            elif len(line) > 0:

                # Check whether line is procedure with a name that ends with "_complex"
                if line.lstrip().startswith("procedure") and line.endswith("_complex"):

                    split_match = line.split("::")
                    after_colon = split_match[1]

                    if "=>" in after_colon:
                        names = after_colon.split("=>")
                        pointer = names[0].strip().split("_complex")[0]
                        routine = names[1].strip().split("_complex")[0]
                    else:
                        pointer = after_colon.strip().split("_complex")[0]
                        routine = pointer

                    procedure_list.append(routine)
                    pointer_list.append(pointer)

    class_file.close()

    return pointer_list, procedure_list


def skip_to_procedure_end(lines):
    """
    Iterate through the iterator lines until we find a line
    starting with "end subroutine" or "end function"
    """
    while True:
        line = next(lines)
        code_line = line.partition("!")[0].strip()
        if code_line.startswith(("end subroutine", "end function")):
            break


def complexify_from_set(line, real_set):
    """
    Loop over set of strings, search for them in line
    and replace with (string)_complex if present
    """
    for item in real_set:
        if item in line:
            line = sub(r"\b" + item + r"\b", item + "_complex", line)
    return line


def complexify_line(line, parameter_list, continuation_mem_batch_setup):
    """
    Check line for strings that have to be replaced for
    complexification and replace them
    """

    # Explicit translations of routine names
    explicit_translation = [
        ("dgemm", "zgemm"),
        ("dsymm", "zsymm"),
        ("dsyrk", "zsyrk"),
        ("dcopy", "zcopy"),
        ("daxpy", "zaxpy"),
        ("dscal", "zscal"),
        ("dgemv", "zgemv"),
        ("dger", "zgeru"),
        ("ddot", "zdot"),
        ("zero_array", "zero_array_complex"),
        ("copy_and_scale", "copy_and_scale_complex"),
    ]

    # Complexify routines that have explcit complex versions
    for routines in explicit_translation:
        if routines[0] in line:
            line = sub(r"\b" + routines[0] + r"\b", routines[1], line)

    # Complexify parameters
    line = complexify_from_set(line, parameter_list)

    # Change variable declarations
    if "real" in line:
        line = sub(r"\b" + "real" + r"\b", "complex", line)

    # Change Real in comments
    if "Real" in line:
        line = sub(r"\b" + "Real" + r"\b", "Complex", line)

    # Change wf%eri to wf%eri_c
    if "wf%eri" in line:
        line = sub(r"\b" + "wf%eri" + r"\b", "wf%eri_complex", line)

    # Correct element size in batch_setup
    # in case of complex double precision

    if "mem%batch_setup" in line or continuation_mem_batch_setup:

        continuation_mem_batch_setup = True

        (line, n_substitutions) = subn(
            r"element_size\s*=\s*dp", ", element_size=2*dp)\n", line
        )

        if n_substitutions > 0:
            continuation_mem_batch_setup = False
            return line, continuation_mem_batch_setup

        (line, n_substitutions) = subn(r"\)\s*\n", ", element_size=2*dp)\n", line)

        if n_substitutions > 0:
            continuation_mem_batch_setup = False
            return line, continuation_mem_batch_setup

        return line, continuation_mem_batch_setup

    # Change complexifiable submodules to complex version
    for module in complexifiable_modules:
        if module in line:
            line = sub(r"\b" + module + r"\b", module.rpartition("_r")[0] + "_c", line)

    return line, continuation_mem_batch_setup


def get_parameter_list(source_directory):
    """
    Read the parameter file and extract the complex variables
    ending in '_complex' before contains
    """
    parameter_path = source_directory / "various" / "parameters.F90"
    parameter_list = get_complex_mod_variables(parameter_path)
    return parameter_list


def autogenerate_complex_files(source_directory, parameter_list):
    """
    Autogenerate complex files
    Written by Alice Balbi and Andreas Skeidsvoll, Sep 2019
    Converted to use pathlib.Path and f-strings by Sander Roet, Sep 2020
    Cleaned up and optimized by Rolf H. Myhre, Mar 2021
    This script reads relevant real Fortran files and writes complex versions.
    """

    wf_root = source_directory / "wavefunctions"
    auto_dir_name = Path("generated_complex_files")

    # List of wavefunctions
    wfs = ["ccs", "doubles", "ccsd"]

    wf_classes = {
        "ccs": ["ccs_class.F90"],
        "doubles": ["doubles_class.F90"],
        "ccsd": ["ccsd_class.F90"],
    }

    # Dictionary with wavefunction directory as key and the corresponding
    # complexified submodules as value
    complex_submodules = {
        "ccs": [
            "fock_ccs",
            "initialize_destruct_ccs",
            "jacobian_transpose_ccs",
            "multiplier_equation_ccs",
            "omega_ccs",
            "set_get_ccs",
            "mean_value_ccs",
            "t1_ccs",
        ],
        "doubles": [
            "initialize_destruct_doubles",
            "jacobian_transpose_doubles",
            "omega_doubles",
            "mean_value_doubles",
        ],
        "ccsd": [
            "initialize_destruct_ccsd",
            "jacobian_transpose_ccsd",
            "multiplier_equation_ccsd",
            "omega_ccsd",
            "set_get_ccsd",
            "mean_value_ccsd",
            "fock_ccsd",
        ],
    }

    # Initialize variable set with complex variables from wavefunction_class
    variable_set = {"energy", "dipole_moment"}
    procedure_set = set()

    pointer_set = set()
    wf_procedure_set = set()

    # set to true if mem%batch_setup continues on next line
    continuation_mem_batch_setup = False

    for wf in wfs:

        wf_dir = wf_root / wf

        auto_dir = wf_dir / auto_dir_name
        auto_dir.mkdir()

        # Expand _complex variable set with variables from wf
        variable_set |= set(get_complex_mod_variables(wf_dir / wf_classes[wf][0]))

        # Get _complex pointers and procedures in wf.
        # Pointer_set requires lower level pointers,
        # while we only require procedures from current wf
        pointers, procedures = get_complex_class_procedures(wf_dir / wf_classes[wf][0])
        pointer_set |= set(pointers)
        wf_procedure_set = set(procedures)
        procedure_set = pointer_set | set(procedures)

        for submodule_name in complex_submodules[wf]:

            with (wf_dir / f"{submodule_name}.F90").open(
                "r", encoding="utf-8"
            ) as r_file:
                line_list = r_file.readlines()

            # Make an iterator
            lines = (i for i in line_list)

            with (auto_dir / f"{submodule_name}_complex.F90").open(
                "w", encoding="utf-8"
            ) as c_file:
                while True:

                    try:
                        line = next(lines)
                    except StopIteration:
                        break

                    if len(line.strip()) > 1:

                        # Skip ddot definitions due to issues on mac
                        # Will fail in case of line continuation
                        if ("::" in line) and ("ddot" in line):
                            line = next(lines)

                        code_line = line.split("!")[0].strip()

                        # Skip non complex procedures
                        while True:
                            if (
                                code_line.startswith(
                                    ("module subroutine", "module function")
                                )
                            ) and (
                                code_line.split()[2].split("(")[0]
                                not in wf_procedure_set
                            ):

                                skip_to_procedure_end(lines)

                                line = next(lines)
                                while line.strip() == "!":
                                    line = next(lines)
                                code_line = line.split("!")[0].strip()
                            else:
                                break

                        # Change submodule names
                        if submodule_name in line:
                            line = sub(
                                r"\b" + submodule_name + r"\b",
                                submodule_name + "_complex",
                                line,
                            )

                        # Complexify variables, procedures and general complexification
                        line = complexify_from_set(line, variable_set)
                        line = complexify_from_set(line, procedure_set)
                        line, continuation_mem_batch_setup = complexify_line(
                            line, parameter_list, continuation_mem_batch_setup
                        )

                    c_file.write(line)


def complexify_modules(src_dir, parameter_list):
    """
    Create complex versions of modules listed in complexifiable_modules.
    """

    # Get files in src and subdirectories
    f_paths = set(src_dir.glob("**/*.F90"))

    # set to true if mem%batch_setup continues on next line
    continuation_mem_batch_setup = False

    # Loop over all files and check if complexifiable
    for f_path in f_paths:
        if f_path.stem in complexifiable_modules:

            # Get name of autodir and make it if it does not exist yet
            dir_name = f_path.parent.name
            auto_dir = f_path.parent / f"generated_{dir_name}"
            auto_dir.mkdir(exist_ok=True)

            # Generate _c name
            split_name = str(f_path.name).rpartition("_r")
            c_path = auto_dir / (split_name[0] + "_c" + split_name[2])

            with f_path.open("r", encoding="utf-8") as r_file:
                lines = r_file.readlines()

            # Loop over lines, complexify if longer than 1 and write
            with c_path.open("w", encoding="utf-8") as c_file:
                for line in lines:

                    if len(line.strip()) > 1:
                        line, continuation_mem_batch_setup = complexify_line(
                            line, parameter_list, continuation_mem_batch_setup
                        )
                    c_file.write(line)


def autogenerate(root_dir):

    source_directory = Path(root_dir / "src")

    # Delete all generated directories
    delete_generated(source_directory)

    # Get a list of parameters to complexify
    parameter_list = get_parameter_list(source_directory)

    # Generate complex modules
    complexify_modules(source_directory, parameter_list)

    # Generate complex wavefunction files
    autogenerate_complex_files(source_directory, parameter_list)

    # Finally, generate all the submodule interfaces
    autogenerate_interfaces(source_directory)


if __name__ == "__main__":
    default_path = Path(__file__).resolve().parent
    autogenerate(default_path)
